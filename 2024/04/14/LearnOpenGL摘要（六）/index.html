<!DOCTYPE html>


<html lang="zh-Hans">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>LearnOpenGL摘要（六） |  b4mang95</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/images/hexo.png" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-LearnOpenGL摘要（六）"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  LearnOpenGL摘要（六）
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/04/14/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%85%AD%EF%BC%89/" class="article-date">
  <time datetime="2024-04-13T19:27:11.000Z" itemprop="datePublished">2024-04-14</time>
</a>   
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">10.2k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">42 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="高级OpenGL（下）立方体贴图、高级数据、高级GLSL、几何着色器、实例化、抗锯齿"><a href="#高级OpenGL（下）立方体贴图、高级数据、高级GLSL、几何着色器、实例化、抗锯齿" class="headerlink" title="高级OpenGL（下）立方体贴图、高级数据、高级GLSL、几何着色器、实例化、抗锯齿"></a>高级OpenGL（下）立方体贴图、高级数据、高级GLSL、几何着色器、实例化、抗锯齿</h1><h2 id="一、立方体贴图"><a href="#一、立方体贴图" class="headerlink" title="一、立方体贴图"></a>一、立方体贴图</h2><h3 id="立方体贴图"><a href="#立方体贴图" class="headerlink" title="立方体贴图"></a>立方体贴图</h3><p>将多个纹理组合起来映射到一张纹理上的一种纹理类型：<code>立方体贴图(Cube Map)</code>。</p>
<ul>
<li>立方体贴图就是一个包含了6个2D纹理的纹理</li>
<li>一个非常有用的特性：可以通过一个<code>方向向量</code>来进行索引&#x2F;采样。<img src="/2024/04/14/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%85%AD%EF%BC%89/image-20240410135127885.png" alt="image-20240410135127885" style="zoom:50%;"></li>
<li>如何确定方向向量：<ul>
<li>从模型空间的原点出发，到顶点位置的方向向量</li>
<li>非顶点位置的方向向量可以根据周围的顶点插值求得</li>
</ul>
</li>
<li>纹理坐标：<ul>
<li>由方向向量，确定与立方体相交的面，以及在这个面上的UV坐标</li>
</ul>
</li>
</ul>
<p><strong>创建和使用立方体贴图</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建和绑定</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> textureID;</span><br><span class="line"><span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;textureID);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_CUBE_MAP, textureID);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分别给6个面生成纹理</span></span><br><span class="line"><span class="type">int</span> width, height, nrChannels;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *data;  </span><br><span class="line"><span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; textures_faces.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    data = <span class="built_in">stbi_load</span>(textures_faces[i].<span class="built_in">c_str</span>(), &amp;width, &amp;height, &amp;nrChannels, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glTexImage2D</span>(</span><br><span class="line">        GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, </span><br><span class="line">        <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 环绕和过滤方式</span></span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制图像之前要先激活纹理单元和绑定纹理</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>片段着色器：</p>
<ul>
<li><code>samplerCube</code> 立方体纹理采样器</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> textureDir; <span class="comment">// 代表3D纹理坐标的方向向量</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">samplerCube</span> cubemap; <span class="comment">// 立方体贴图的纹理采样器</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;             </span><br><span class="line">    FragColor = <span class="built_in">texture</span>(cubemap, textureDir);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="天空盒"><a href="#天空盒" class="headerlink" title="天空盒"></a>天空盒</h3><p>加载纹理</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">loadCubemap</span><span class="params">(vector&lt;std::string&gt; faces)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> textureID;</span><br><span class="line">    <span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;textureID);</span><br><span class="line">    <span class="built_in">glBindTexture</span>(GL_TEXTURE_CUBE_MAP, textureID);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> width, height, nrChannels;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; faces.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> *data = <span class="built_in">stbi_load</span>(faces[i].<span class="built_in">c_str</span>(), &amp;width, &amp;height, &amp;nrChannels, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (data)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">glTexImage2D</span>(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, </span><br><span class="line">                         <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data</span><br><span class="line">            );</span><br><span class="line">            <span class="built_in">stbi_image_free</span>(data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Cubemap texture failed to load at path: &quot;</span> &lt;&lt; faces[i] &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">stbi_image_free</span>(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> textureID;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;std::string&gt; faces</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;right.jpg&quot;</span>,</span><br><span class="line">    <span class="string">&quot;left.jpg&quot;</span>,</span><br><span class="line">    <span class="string">&quot;top.jpg&quot;</span>,</span><br><span class="line">    <span class="string">&quot;bottom.jpg&quot;</span>,</span><br><span class="line">    <span class="string">&quot;front.jpg&quot;</span>,</span><br><span class="line">    <span class="string">&quot;back.jpg&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> cubemapTexture = <span class="built_in">loadCubemap</span>(faces);</span><br></pre></td></tr></table></figure>



<p>顶点着色器</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> TexCoords;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> projection;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> view;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    TexCoords = aPos;</span><br><span class="line">    <span class="built_in">gl_Position</span> = projection * view * <span class="type">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>片段着色器</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> TexCoords;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">samplerCube</span> skybox;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;    </span><br><span class="line">    FragColor = <span class="built_in">texture</span>(skybox, TexCoords);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><img src="/2024/04/14/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%85%AD%EF%BC%89/image-20240410150233280.png" alt="image-20240410150233280"></p>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><ul>
<li>上面的做法是先在关闭深度测试的情况下渲染天空盒，然后开启深度测试并渲染其他东西</li>
<li>屏幕上的每一个像素都要运行一遍天空盒的片段着色器，即便只有一小部分的天空盒最终是可见的</li>
</ul>
<p>使用<code>提前深度测试</code>(Early Depth Testing)，提前丢弃掉天空盒的片段，节省宝贵的带宽。</p>
<ul>
<li><p>最后渲染天空盒，以获得轻微的性能提升</p>
</li>
<li><p>问题：天空盒距离相机的距离可能比场景物体更近，挡到其他物体</p>
</li>
<li><p>解决：</p>
<ul>
<li><p>让天空盒所有片段的深度值为1.0（最大值），若深度缓冲中对应位置已有的深度值更小，则不渲染天空盒片段。</p>
</li>
<li><p>如何让深度值为1.0：</p>
<ul>
<li><p>在顶点着色器中设置pos中的 z 分量为 w 分量的值（顶点着色器之后的透视除法会将 x y z 都除以 w 来转换到标准化设备坐标）</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    TexCoords = aPos;</span><br><span class="line">    <span class="type">vec4</span> pos = projection * view * <span class="type">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line">    <span class="built_in">gl_Position</span> = pos.xyww;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>将深度测试的比较方式改为<code>glDepthFunc(GL_LEQUAL);</code>使得深度值为1.0的天空盒片段能通过并写入深度缓冲。</p>
</li>
</ul>
</li>
</ul>
<p>渲染循环：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Draw Cube</span></span><br><span class="line">&#123;</span><br><span class="line">    boxShader.<span class="built_in">use</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算mvp变换矩阵</span></span><br><span class="line">    glm::mat4 view = g_camera.<span class="built_in">GetLookAt</span>();</span><br><span class="line">    glm::mat4 projection = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">    projection = glm::<span class="built_in">perspective</span>(glm::<span class="built_in">radians</span>(g_camera.<span class="built_in">GetFov</span>()), <span class="number">800.0f</span> / <span class="number">600.0f</span>, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br><span class="line">    glm::mat4 model = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">    boxShader.<span class="built_in">setMat4</span>(<span class="string">&quot;model&quot;</span>, model);</span><br><span class="line">    boxShader.<span class="built_in">setMat4</span>(<span class="string">&quot;view&quot;</span>, view);</span><br><span class="line">    boxShader.<span class="built_in">setMat4</span>(<span class="string">&quot;projection&quot;</span>, projection);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glActiveTexture</span>(GL_TEXTURE0);</span><br><span class="line">    <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, textureBox);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(cubeVAO);</span><br><span class="line">    <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Draw Skybox</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">glDepthFunc</span>(GL_LEQUAL);</span><br><span class="line"></span><br><span class="line">    skyShader.<span class="built_in">use</span>();</span><br><span class="line">    glm::mat4 view = glm::<span class="built_in">mat4</span>(glm::<span class="built_in">mat3</span>(g_camera.<span class="built_in">GetLookAt</span>()));</span><br><span class="line">    glm::mat4 projection = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">    projection = glm::<span class="built_in">perspective</span>(glm::<span class="built_in">radians</span>(g_camera.<span class="built_in">GetFov</span>()), <span class="number">800.0f</span> / <span class="number">600.0f</span>, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br><span class="line">    skyShader.<span class="built_in">setMat4</span>(<span class="string">&quot;view&quot;</span>, view);</span><br><span class="line">    skyShader.<span class="built_in">setMat4</span>(<span class="string">&quot;projection&quot;</span>, projection);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(skyVAO);</span><br><span class="line">    <span class="built_in">glBindTexture</span>(GL_TEXTURE_CUBE_MAP, textureSky);</span><br><span class="line">    <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glDepthFunc</span>(GL_LESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="环境映射"><a href="#环境映射" class="headerlink" title="环境映射"></a>环境映射</h3><p>环境映射</p>
<ul>
<li><p>将整个环境映射到了一个纹理对象上</p>
</li>
<li><p>通过使用环境的立方体贴图，我们可以给物体<code>反射</code>和<code>折射</code>的属性</p>
</li>
</ul>
<h4 id="反射-reflect"><a href="#反射-reflect" class="headerlink" title="反射 reflect"></a>反射 reflect</h4><ul>
<li><p>反射这个属性表现为物体（或物体的一部分）反射它周围环境</p>
</li>
<li><p>即根据观察者的视角，物体的颜色或多或少等于它周围的环境</p>
</li>
<li><p>镜子就是一个反射性物体：它会根据观察者的视角反射它周围的环境。</p>
</li>
<li><p>计算反射向量，使用这个向量来从立方体贴图中采样</p>
<ul>
<li>使用GLSL内建的reflect函数来计算这个反射向量</li>
</ul>
</li>
</ul>
<img src="/2024/04/14/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%85%AD%EF%BC%89/image-20240411140256300.png" alt="image-20240411140256300" style="zoom:67%;">



<p>修改箱子的片段着色器</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> Normal;</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> Position;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> cameraPos;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">samplerCube</span> skybox;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;             </span><br><span class="line">    <span class="type">vec3</span> I = <span class="built_in">normalize</span>(Position - cameraPos);</span><br><span class="line">    <span class="type">vec3</span> R = <span class="built_in">reflect</span>(I, <span class="built_in">normalize</span>(Normal));</span><br><span class="line">    FragColor = <span class="type">vec4</span>(<span class="built_in">texture</span>(skybox, R).rgb, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/2024/04/14/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%85%AD%EF%BC%89/image-20240411141455998.png" alt="image-20240411141455998"></p>
<p><img src="/2024/04/14/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%85%AD%EF%BC%89/image-20240411142026894.png" alt="image-20240411142026894"></p>
<blockquote>
<p>现实中大部分的模型都不具有完全反射性</p>
<p>可以引入反射贴图(Reflection Map)，来给模型更多的细节</p>
<ul>
<li>它决定了片段的反射性</li>
<li>模型的哪些部分该以什么强度显示反射</li>
</ul>
</blockquote>
<h4 id="折射-refract"><a href="#折射-refract" class="headerlink" title="折射 refract"></a>折射 refract</h4><ul>
<li>折射是光线由于传播介质的改变而产生的方向变化</li>
<li>将你的半只胳膊伸进水里，观察出来的就是这种效果</li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Snell's_law">斯涅尔定律</a>(Snell’s Law)</li>
</ul>
<img src="/2024/04/14/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%85%AD%EF%BC%89/image-20240411142249987.png" alt="image-20240411142249987" style="zoom:67%;">

<ul>
<li><p>折射计算：使用GLSL的内建refract函数</p>
<ul>
<li>一个法向量</li>
<li>一个观察方向</li>
<li>两个材质之间的折射率(Refractive Index)的比值。</li>
</ul>
</li>
<li><p>折射率</p>
<ul>
<li>决定了材质中光线弯曲的程度</li>
<li><img src="/2024/04/14/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%85%AD%EF%BC%89/image-20240411142500061.png" alt="image-20240411142500061"></li>
<li>比如光线&#x2F;视线从<strong>空气</strong>进入<strong>玻璃</strong>：比值为 1.00&#x2F;1.52 &#x3D; 0.658</li>
</ul>
</li>
</ul>
<p>修改片段着色器</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> Normal;</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> Position;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> cameraPos;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">samplerCube</span> skybox;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;             </span><br><span class="line">    <span class="type">float</span> ratio = <span class="number">1.00</span> / <span class="number">1.52</span>;</span><br><span class="line">    <span class="type">vec3</span> I = <span class="built_in">normalize</span>(Position - cameraPos);</span><br><span class="line">    <span class="type">vec3</span> R = <span class="built_in">refract</span>(I, <span class="built_in">normalize</span>(Normal), ratio);</span><br><span class="line">    FragColor = <span class="type">vec4</span>(<span class="built_in">texture</span>(skybox, R).rgb, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><img src="/2024/04/14/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%85%AD%EF%BC%89/image-20240411143620540.png" alt="image-20240411143620540"></p>
<p><img src="/2024/04/14/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%85%AD%EF%BC%89/image-20240411143649781.png" alt="image-20240411143649781"></p>
<h4 id="动态环境贴图"><a href="#动态环境贴图" class="headerlink" title="动态环境贴图"></a>动态环境贴图</h4><p>静态环境映射</p>
<ul>
<li>只映射天空盒。</li>
<li>如果我们有一个镜子一样的物体，周围还有多个物体，镜子中可见的只有天空盒，看起来就像它是场景中唯一一个物体一样。</li>
</ul>
<p>动态环境映射(Dynamic Environment Mapping)</p>
<ul>
<li><p>通过使用帧缓冲，我们能够为物体的6个不同角度创建出场景的纹理，并在每个渲染迭代中将它们储存到一个立方体贴图中。</p>
</li>
<li><p>之后我们就可以使用这个（动态生成的）立方体贴图来创建出更真实的，包含其它物体的，反射和折射表面了。</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li>我们需要为每个使用环境贴图的物体渲染场景6次，这是非常大的性能开销</li>
<li>现代的程序通常会尽可能使用天空盒，并在可能的时候使用预编译的立方体贴图，只要它们能产生一点动态环境贴图的效果。</li>
</ul>
<h2 id="二、高级数据"><a href="#二、高级数据" class="headerlink" title="二、高级数据"></a>二、高级数据</h2><ul>
<li>OpenGL中使用缓冲来储存数据</li>
<li>操作缓冲其实还有更有意思的方式</li>
<li>使用纹理将大量数据传入着色器也有更有趣的方法</li>
</ul>
<h3 id="缓冲操作"><a href="#缓冲操作" class="headerlink" title="缓冲操作"></a>缓冲操作</h3><h4 id="内存分配和数据填充"><a href="#内存分配和数据填充" class="headerlink" title="内存分配和数据填充"></a>内存分配和数据填充</h4><p>OpenGL中的缓冲只是一个管理特定内存块的对象</p>
<p>在我们将它绑定到一个缓冲目标(Buffer Target)时，我们才赋予了其意义</p>
<ul>
<li>绑定一个缓冲到GL_ARRAY_BUFFER时，它就是一个顶点数组缓冲</li>
<li>也可以绑定到GL_ELEMENT_ARRAY_BUFFER等</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;cubeVBO);    </span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, cubeVBO);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(data), data, GL_STATIC_DRAW);</span><br><span class="line"><span class="comment">// 分配一块内存，并将数据添加到这块内存中。</span></span><br><span class="line"><span class="comment">// 如果我们将它的data参数设置为NULL，那么这个函数将只会分配内存，但不进行填充。</span></span><br><span class="line"><span class="comment">// 可用于 预留(Reserve) 特定大小的内存</span></span><br></pre></td></tr></table></figure>

<p>填充数据到缓冲内存：</p>
<ul>
<li>方法一：<code>glBufferSubData</code>函数（需要先用<code>glBufferData</code>分配好内存）</li>
<li>方法二：<code>glMapBuffer</code>函数，获取指向缓冲内存的指针，直接设置内存数据</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glBufferSubData</span>(GL_ARRAY_BUFFER, <span class="number">24</span>, <span class="built_in">sizeof</span>(data), &amp;data); <span class="comment">// 填充范围： [24, 24 + sizeof(data)]</span></span><br><span class="line"><span class="comment">// 填充缓冲的特定区域</span></span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line">    </span><br><span class="line"><span class="type">float</span> data[] = &#123;</span><br><span class="line">  <span class="number">0.5f</span>, <span class="number">1.0f</span>, <span class="number">-0.35f</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, buffer);</span><br><span class="line"><span class="comment">// 获取指针</span></span><br><span class="line"><span class="type">void</span> *ptr = <span class="built_in">glMapBuffer</span>(GL_ARRAY_BUFFER, GL_WRITE_ONLY);</span><br><span class="line"><span class="comment">// 复制数据到内存</span></span><br><span class="line"><span class="built_in">memcpy</span>(ptr, data, <span class="built_in">sizeof</span>(data));</span><br><span class="line"><span class="comment">// 记得告诉OpenGL我们不再需要这个指针了</span></span><br><span class="line"><span class="built_in">glUnmapBuffer</span>(GL_ARRAY_BUFFER);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果要直接映射数据到缓冲，而不事先将其存储到临时内存中，glMapBuffer这个函数会很有用。</p>
<p>比如说，你可以从文件中读取数据，并直接将它们复制到缓冲内存中。</p>
</blockquote>
<h4 id="分批顶点属性"><a href="#分批顶点属性" class="headerlink" title="分批顶点属性"></a>分批顶点属性</h4><p>之前学的方法：</p>
<ul>
<li>通过使用glVertexAttribPointer，我们能够指定顶点数组缓冲内容的属性布局。在顶点数组缓冲中，我们对属性进行了交错(Interleave)处理，也就是说，我们将每一个顶点的位置、法线和&#x2F;或纹理坐标紧密放置在一起。</li>
</ul>
<p>新的方法：</p>
<ul>
<li>将每一种属性类型的向量数据打包(Batch)为一个大的区块，而不是对它们进行交错储存。</li>
<li>与交错布局123123123123不同，我们将采用分批(Batched)的方式111122223333。</li>
</ul>
<p>使用<code>glBufferSubData</code>函数实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> positions[] = &#123; ... &#125;;</span><br><span class="line"><span class="type">float</span> normals[] = &#123; ... &#125;;</span><br><span class="line"><span class="type">float</span> tex[] = &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充缓冲</span></span><br><span class="line"><span class="built_in">glBufferSubData</span>(GL_ARRAY_BUFFER, <span class="number">0</span>, <span class="built_in">sizeof</span>(positions), &amp;positions);</span><br><span class="line"><span class="built_in">glBufferSubData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(positions), <span class="built_in">sizeof</span>(normals), &amp;normals);</span><br><span class="line"><span class="built_in">glBufferSubData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(positions) + <span class="built_in">sizeof</span>(normals), <span class="built_in">sizeof</span>(tex), &amp;tex);</span><br></pre></td></tr></table></figure>

<p>以及更新顶点属性指针</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), <span class="number">0</span>);  </span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)(<span class="built_in">sizeof</span>(positions)));  </span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(</span><br><span class="line">  <span class="number">2</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">2</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)(<span class="built_in">sizeof</span>(positions) + <span class="built_in">sizeof</span>(normals)));</span><br></pre></td></tr></table></figure>



<h4 id="复制缓冲"><a href="#复制缓冲" class="headerlink" title="复制缓冲"></a>复制缓冲</h4><p>当你的缓冲已经填充好数据之后，你可能会想与其它的缓冲共享其中的数据，或者想要将缓冲的内容复制到另一个缓冲当中。</p>
<p><code>glCopyBufferSubData</code>函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">glCopyBufferSubData</span><span class="params">(GLenum readtarget, GLenum writetarget, GLintptr readoffset, GLintptr writeoffset, GLsizeiptr size)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>复制源和复制目标的缓冲目标：</p>
<ul>
<li>比如说，我们可以将VERTEX_ARRAY_BUFFER缓冲复制到VERTEX_ELEMENT_ARRAY_BUFFER缓冲，分别将这些缓冲目标设置为读和写的目标。</li>
<li>当前绑定到这些缓冲目标的缓冲将会被影响到。</li>
</ul>
</li>
<li><p>对于复制源和复制目标为同样类型的缓冲目标的情况：</p>
<ul>
<li>OpenGL提供给我们另外两个缓冲目标，叫做GL_COPY_READ_BUFFER和GL_COPY_WRITE_BUFFER</li>
<li>将需要的缓冲绑定到这两个缓冲目标上，并将这两个目标作为<code>readtarget</code>和<code>writetarget</code>参数。</li>
</ul>
</li>
<li><p>使用过程类似：</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> vertexData[] = &#123; ... &#125;;</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_COPY_READ_BUFFER, vbo1);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_COPY_WRITE_BUFFER, vbo2);</span><br><span class="line"><span class="built_in">glCopyBufferSubData</span>(GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">sizeof</span>(vertexData));</span><br></pre></td></tr></table></figure>

<ul>
<li>也可以只将<code>writetarget</code>缓冲绑定为新的缓冲目标类型之一：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> vertexData[] = &#123; ... &#125;;</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo1);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_COPY_WRITE_BUFFER, vbo2);</span><br><span class="line"><span class="built_in">glCopyBufferSubData</span>(GL_ARRAY_BUFFER, GL_COPY_WRITE_BUFFER, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">sizeof</span>(vertexData));</span><br></pre></td></tr></table></figure>





<h2 id="三、高级glsl"><a href="#三、高级glsl" class="headerlink" title="三、高级glsl"></a>三、高级glsl</h2><p>内容：</p>
<ul>
<li>在组合使用OpenGL和GLSL创建程序时的一些<strong>最好要知道的东西</strong>，一些<strong>会让你生活更加轻松的特性</strong></li>
<li>一些有趣的内建变量(Built-in Variable)</li>
<li>管理着色器输入和输出的新方式</li>
<li>一个叫做Uniform缓冲对象(Uniform Buffer Object)的有用工具。</li>
</ul>
<h3 id="GLSL内建变量"><a href="#GLSL内建变量" class="headerlink" title="GLSL内建变量"></a>GLSL内建变量</h3><p>GLSL定义了以<code>gl_</code>为前缀的变量，它们能提供给我们更多的方式来读取&#x2F;写入数据。</p>
<h4 id="顶点着色器变量"><a href="#顶点着色器变量" class="headerlink" title="顶点着色器变量"></a>顶点着色器变量</h4><p><code>gl_Position</code></p>
<ul>
<li>顶点着色器的裁剪空间输出位置向量</li>
</ul>
<p><code>gl_PointSize</code></p>
<ul>
<li><p>使用图元 GL_POINTS 绘制 每一个顶点都将是一个图元，都会被渲染为一个点</p>
</li>
<li><p>对每个顶点使用不同的点大小，会在<code>粒子生成</code>之类的技术中很有意思</p>
<ul>
<li>通过OpenGL的glPointSize函数来设置渲染出来的点的大小</li>
<li>或者在顶点着色器中使用 gl_PointSize 设置点的大小</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glEnable</span>(GL_PROGRAM_POINT_SIZE);</span><br></pre></td></tr></table></figure>

<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = projection * view * model * <span class="type">vec4</span>(aPos, <span class="number">1.0</span>);    </span><br><span class="line">    <span class="built_in">gl_PointSize</span> = <span class="built_in">gl_Position</span>.z;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>gl_VertexID</code></p>
<ul>
<li><p><strong>输入变量</strong> gl_VertexID。</p>
</li>
<li><p>gl_Position和gl_PointSize都是<strong>输出变量</strong>，因为它们的值是作为顶点着色器的输出被读取的。</p>
</li>
<li><p>整型变量gl_VertexID储存了正在绘制顶点的当前ID。</p>
<ul>
<li>当（使用glDrawElements）进行索引渲染的时候，这个变量会存储正在绘制顶点的当前索引。</li>
<li>当（使用glDrawArrays）不使用索引进行绘制的时候，这个变量会储存从渲染调用开始的已处理顶点数量。</li>
</ul>
</li>
</ul>
<h4 id="片段着色器变量"><a href="#片段着色器变量" class="headerlink" title="片段着色器变量"></a>片段着色器变量</h4><p><code>gl_FragCoord</code></p>
<ul>
<li>一个只读(Read-only)变量</li>
<li>gl_FragCoord的z分量等于对应片段的深度值</li>
<li>gl_FragCoord的x和y分量是片段的窗口空间(Window-space)坐标，其原点为窗口的左下角</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;             </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">gl_FragCoord</span>.x &lt; <span class="number">400</span>)</span><br><span class="line">        FragColor = <span class="type">vec4</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        FragColor = <span class="type">vec4</span>(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><code>gl_FrontFacing</code></p>
<ul>
<li>告诉我们当前片段是属于正向面的一部分还是背向面的一部分</li>
<li>正向面和背向面分别使用不同的而纹理</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec2</span> TexCoords;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> frontTexture;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> backTexture;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;             </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">gl_FrontFacing</span>)</span><br><span class="line">        FragColor = <span class="built_in">texture</span>(frontTexture, TexCoords);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        FragColor = <span class="built_in">texture</span>(backTexture, TexCoords);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>gl_FragDepth</code></p>
<ul>
<li>输出变量</li>
<li>在着色器内设置片段的深度值（0.0 ~ 1.0）</li>
<li>只要我们在片段着色器中对gl_FragDepth进行写入，OpenGL就会禁用所有的提前深度测试(Early Depth Testing)。<ul>
<li>OpenGL无法在片段着色器运行<strong>之前</strong>得知片段将拥有的深度值，因为片段着色器可能会完全修改这个深度值。</li>
<li>从OpenGL 4.2起，我们仍可以对两者进行一定的调和，在片段着色器的顶部使用深度条件(Depth Condition)重新声明gl_FragDepth变量：<ul>
<li><code>layout (depth_&lt;condition&gt;) out float gl_FragDepth;</code></li>
<li>限定写入的深度值的条件，使得提前深度测试能够进行。</li>
<li><img src="/2024/04/14/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%85%AD%EF%BC%89/image-20240413161257556.png" alt="image-20240413161257556"></li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 420 core // 注意GLSL的版本！</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">depth_greater</span>) <span class="keyword">out</span> <span class="type">float</span> <span class="built_in">gl_FragDepth</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;             </span><br><span class="line">    FragColor = <span class="type">vec4</span>(<span class="number">1.0</span>);</span><br><span class="line">    <span class="built_in">gl_FragDepth</span> = <span class="built_in">gl_FragCoord</span>.z + <span class="number">0.1</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>







<h3 id="接口块"><a href="#接口块" class="headerlink" title="接口块"></a>接口块</h3><p>之前的 in out 数据都是一个变量。考虑如何处理 in out 数组和结构体。</p>
<p>声明与结构体类似</p>
<ul>
<li>顶点着色器</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec2</span> aTexCoords;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> model;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> view;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> projection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> VS_OUT</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> TexCoords;</span><br><span class="line">&#125; vs_out;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = projection * view * model * <span class="type">vec4</span>(aPos, <span class="number">1.0</span>);    </span><br><span class="line">    vs_out.TexCoords = aTexCoords;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<ul>
<li>片段着色器</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> VS_OUT</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> TexCoords;</span><br><span class="line">&#125; fs_in;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> <span class="built_in">texture</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;             </span><br><span class="line">    FragColor = <span class="built_in">texture</span>(<span class="built_in">texture</span>, fs_in.TexCoords);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="Uniform-缓冲对象"><a href="#Uniform-缓冲对象" class="headerlink" title="Uniform 缓冲对象"></a>Uniform 缓冲对象</h3><p>当使用多于一个的着色器时，尽管大部分的uniform变量都是相同的，我们还是需要不断地设置它们，所以为什么要这么麻烦地重复设置它们呢？</p>
<p><strong>UBO</strong></p>
<p>OpenGL为我们提供了一个叫做Uniform缓冲对象(Uniform Buffer Object)的工具，它允许我们定义一系列在多个着色器中相同的<strong>全局</strong>Uniform变量。</p>
<ul>
<li>顶点着色器<ul>
<li><code>layout (std140)</code>：设置了Uniform块布局(Uniform Block Layout)</li>
<li>将 投影矩阵 和 观察矩阵 放到共享的 uniform接口块 里。</li>
</ul>
</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">std140</span>) <span class="keyword">uniform</span> Matrices</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">mat4</span> projection;</span><br><span class="line">    <span class="type">mat4</span> view;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> model;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = projection * view * model * <span class="type">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Uniform块布局"><a href="#Uniform块布局" class="headerlink" title="Uniform块布局"></a>Uniform块布局</h4><ul>
<li>Uniform块的内容是储存在一个缓冲对象中的，它实际上只是一块预留内存，不会保存它具体保存的是什么类型的数据。</li>
<li>块布局告诉OpenGL内存的哪一部分对应着着色器中的哪一个uniform变量。</li>
</ul>
<p>默认布局</p>
<ul>
<li>共享(Shared)布局</li>
<li>一旦硬件定义了偏移量，它们在多个程序中是<strong>共享</strong>并一致的</li>
<li>GLSL是可以为了优化而对uniform变量的位置进行变动的，只要变量的顺序保持不变</li>
<li>共享布局给了我们很多节省空间的优化，但是我们需要查询每个uniform变量的偏移量</li>
</ul>
<p>std140布局</p>
<ul>
<li>每个变量的偏移量都是由一系列规则所决定的，这<strong>显式地</strong>声明了每个变量类型的内存布局</li>
<li>可以手动计算出每个变量的偏移量</li>
<li>每个变量都有一个基准对齐量(Base Alignment)，它等于一个变量在Uniform块中所占据的空间（包括填充量(Padding)）</li>
<li>对每个变量，我们再计算它的对齐偏移量(Aligned Offset)，它是一个变量从块起始位置的字节偏移量。一个变量的对齐字节偏移量<strong>必须</strong>等于基准对齐量的倍数。</li>
</ul>
<p><img src="/2024/04/14/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%85%AD%EF%BC%89/image-20240413165008180.png" alt="image-20240413165008180"></p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">layout</span> (<span class="keyword">std140</span>) <span class="keyword">uniform</span> ExampleBlock</span><br><span class="line">&#123;</span><br><span class="line">                     <span class="comment">// 基准对齐量       // 对齐偏移量</span></span><br><span class="line">    <span class="type">float</span> value;     <span class="comment">// 4               // 0 </span></span><br><span class="line">    <span class="type">vec3</span> vector;     <span class="comment">// 16              // 16  (必须是16的倍数，所以 4-&gt;16)</span></span><br><span class="line">    <span class="type">mat4</span> matrix;     <span class="comment">// 16              // 32  (列 0)</span></span><br><span class="line">                     <span class="comment">// 16              // 48  (列 1)</span></span><br><span class="line">                     <span class="comment">// 16              // 64  (列 2)</span></span><br><span class="line">                     <span class="comment">// 16              // 80  (列 3)</span></span><br><span class="line">    <span class="type">float</span> values[<span class="number">3</span>]; <span class="comment">// 16              // 96  (values[0])</span></span><br><span class="line">                     <span class="comment">// 16              // 112 (values[1])</span></span><br><span class="line">                     <span class="comment">// 16              // 128 (values[2])</span></span><br><span class="line">    <span class="type">bool</span> boolean;    <span class="comment">// 4               // 144</span></span><br><span class="line">    <span class="type">int</span> integer;     <span class="comment">// 4               // 148</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>



<p>紧凑(Packed)布局</p>
<ul>
<li>不能保证这个布局在每个程序中保持不变的（即非共享）</li>
<li>允许编译器去将uniform变量从Uniform块中优化掉</li>
</ul>
<h4 id="使用Uniform缓冲"><a href="#使用Uniform缓冲" class="headerlink" title="使用Uniform缓冲"></a>使用Uniform缓冲</h4><ul>
<li><p>创建一个Uniform缓冲对象</p>
</li>
<li><p>绑定到GL_UNIFORM_BUFFER目标</p>
</li>
<li><p>分配足够的内存</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> uboExampleBlock;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;uboExampleBlock);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_UNIFORM_BUFFER, uboExampleBlock);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_UNIFORM_BUFFER, <span class="number">152</span>, <span class="literal">NULL</span>, GL_STATIC_DRAW); <span class="comment">// 分配152字节的内存</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_UNIFORM_BUFFER, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>对缓冲更新或者插入数据:</p>
<ul>
<li>绑定到UBO对象，并使用glBufferSubData来更新它的内存</li>
</ul>
</li>
<li><p>如何才能让OpenGL知道哪个Uniform缓冲对应的是哪个Uniform块呢？</p>
<ul>
<li>OpenGL上下文中定义了一些<code>绑定点(Binding Point)</code></li>
<li>可以将一个Uniform缓冲对象链接至一个绑定点，并将着色器中的Uniform块绑定到相同的绑定点<img src="/2024/04/14/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%85%AD%EF%BC%89/image-20240413171701192.png" alt="image-20240413171701192" style="zoom:80%;"></li>
</ul>
</li>
</ul>
<p>使用方法</p>
<ul>
<li><p>绑定 着色器的Uniform块 到绑定点</p>
<ul>
<li>第一个参数是一个程序对象</li>
<li>之后是一个 Uniform块索引 和 链接到的绑定点<ul>
<li>Uniform块索引(Uniform Block Index)是着色器中已定义Uniform块的位置值索引</li>
<li>通过调用glGetUniformBlockIndex来获取</li>
</ul>
</li>
<li>注意我们需要对<strong>每个</strong>着色器程序对象重复这一步骤。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> lights_index = <span class="built_in">glGetUniformBlockIndex</span>(shaderA.ID, <span class="string">&quot;Lights&quot;</span>);   </span><br><span class="line"></span><br><span class="line"><span class="built_in">glUniformBlockBinding</span>(shaderA.ID, lights_index, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>从OpenGL 4.2版本起，你也可以添加一个布局标识符，显式地将Uniform块的绑定点储存在着色器中，这样就不用再调用glGetUniformBlockIndex和glUniformBlockBinding了。</p>
<p>下面的代码显式地设置了Lights Uniform块的绑定点</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">layout</span>(<span class="keyword">std140</span>, <span class="keyword">binding</span> = <span class="number">2</span>) <span class="keyword">uniform</span> Lights &#123; ... &#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>绑定 Uniform缓冲对象 到绑定点</p>
<ul>
<li><code>glBindbufferBase</code>需要 一个目标，一个绑定点索引和一个Uniform缓冲对象 作为它的参数。</li>
<li><code>glBindBufferRange</code>需要 一个附加的偏移量和大小参数 ，这样子你可以绑定Uniform缓冲的特定一部分到绑定点中。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glBindBufferBase</span>(GL_UNIFORM_BUFFER, <span class="number">2</span>, uboExampleBlock); </span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="built_in">glBindBufferRange</span>(GL_UNIFORM_BUFFER, <span class="number">2</span>, uboExampleBlock, <span class="number">0</span>, <span class="number">152</span>);</span><br></pre></td></tr></table></figure>


</li>
<li><p>设置 Uniform缓冲对象的数据</p>
<ul>
<li>使用glBufferSubData函数</li>
<li>同样的步骤也能应用到Uniform块中其它的uniform变量上，但需要使用不同的范围参数</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glBindBuffer</span>(GL_UNIFORM_BUFFER, uboExampleBlock);</span><br><span class="line"><span class="type">int</span> b = <span class="literal">true</span>; <span class="comment">// GLSL中的bool是4字节的，所以我们将它存为一个integer</span></span><br><span class="line"><span class="built_in">glBufferSubData</span>(GL_UNIFORM_BUFFER, <span class="number">144</span>, <span class="number">4</span>, &amp;b); </span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_UNIFORM_BUFFER, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>



<h4 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h4><p>如果我们回头看看之前所有的代码例子，我们不断地在使用3个矩阵：投影、观察和模型矩阵。在所有的这些矩阵中，只有模型矩阵会频繁变动。如果我们有多个着色器使用了这同一组矩阵，那么使用Uniform缓冲对象可能会更好。</p>
<p>顶点着色器</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">std140</span>) <span class="keyword">uniform</span> Matrices</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">mat4</span> projection;</span><br><span class="line">    <span class="type">mat4</span> view;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> model;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = projection * view * model * <span class="type">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>初始化代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 箱子着色器</span></span><br><span class="line"><span class="function">Shader <span class="title">shaderRed</span><span class="params">(<span class="string">&quot;./MoreGLSLVShader.glsl&quot;</span>, <span class="string">&quot;./MoreGLSLFShaderRed.glsl&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">Shader <span class="title">shaderGreen</span><span class="params">(<span class="string">&quot;./MoreGLSLVShader.glsl&quot;</span>, <span class="string">&quot;./MoreGLSLFShaderGreen.glsl&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">Shader <span class="title">shaderBlue</span><span class="params">(<span class="string">&quot;./MoreGLSLVShader.glsl&quot;</span>, <span class="string">&quot;./MoreGLSLFShaderBlue.glsl&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">Shader <span class="title">shaderYellow</span><span class="params">(<span class="string">&quot;./MoreGLSLVShader.glsl&quot;</span>, <span class="string">&quot;./MoreGLSLFShaderYellow.glsl&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Shader <span class="title">skyShader</span><span class="params">(<span class="string">&quot;./SkyboxVShader.glsl&quot;</span>, <span class="string">&quot;./SkyboxFShader.glsl&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将着色器程序的 uniform块 绑定到 绑定点0</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> uniformBlockIndexRed = <span class="built_in">glGetUniformBlockIndex</span>(shaderRed.ID, <span class="string">&quot;Matrices&quot;</span>);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> uniformBlockIndexGreen = <span class="built_in">glGetUniformBlockIndex</span>(shaderGreen.ID, <span class="string">&quot;Matrices&quot;</span>);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> uniformBlockIndexBlue = <span class="built_in">glGetUniformBlockIndex</span>(shaderBlue.ID, <span class="string">&quot;Matrices&quot;</span>);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> uniformBlockIndexYellow = <span class="built_in">glGetUniformBlockIndex</span>(shaderYellow.ID, <span class="string">&quot;Matrices&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glUniformBlockBinding</span>(shaderRed.ID, uniformBlockIndexRed, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glUniformBlockBinding</span>(shaderGreen.ID, uniformBlockIndexGreen, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glUniformBlockBinding</span>(shaderBlue.ID, uniformBlockIndexBlue, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glUniformBlockBinding</span>(shaderYellow.ID, uniformBlockIndexYellow, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 UBO</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> uboMatrices;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;uboMatrices);</span><br><span class="line"><span class="comment">// 分配 UBO 的内存</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_UNIFORM_BUFFER, uboMatrices);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_UNIFORM_BUFFER, <span class="number">2</span> * <span class="built_in">sizeof</span>(glm::mat4), <span class="literal">NULL</span>, GL_STATIC_DRAW);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_UNIFORM_BUFFER, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 绑定 UBO 到 绑定点0</span></span><br><span class="line"><span class="built_in">glBindBufferRange</span>(GL_UNIFORM_BUFFER, <span class="number">0</span>, uboMatrices, <span class="number">0</span>, <span class="number">2</span> * <span class="built_in">sizeof</span>(glm::mat4));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>渲染循环内</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 计算变换矩阵</span></span><br><span class="line">glm::mat4 view = g_camera.<span class="built_in">GetLookAt</span>();</span><br><span class="line">glm::mat4 projection = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">projection = glm::<span class="built_in">perspective</span>(glm::<span class="built_in">radians</span>(g_camera.<span class="built_in">GetFov</span>()), <span class="number">800.0f</span> / <span class="number">600.0f</span>, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 投影变换 和 视图变换 的矩阵数据到 ubo</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_UNIFORM_BUFFER, uboMatrices);</span><br><span class="line"><span class="built_in">glBufferSubData</span>(GL_UNIFORM_BUFFER, <span class="number">0</span>, <span class="built_in">sizeof</span>(glm::mat4), glm::<span class="built_in">value_ptr</span>(projection));</span><br><span class="line"><span class="built_in">glBufferSubData</span>(GL_UNIFORM_BUFFER, <span class="built_in">sizeof</span>(glm::mat4), <span class="built_in">sizeof</span>(glm::mat4), glm::<span class="built_in">value_ptr</span>(view));</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_UNIFORM_BUFFER, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">glEnable</span>(GL_DEPTH_TEST);</span><br><span class="line">    <span class="built_in">glClearColor</span>(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">    <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Draw Cube</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glBindVertexArray</span>(cubeVAO);</span><br><span class="line"></span><br><span class="line">        glm::mat4 model;</span><br><span class="line"></span><br><span class="line">        shaderRed.<span class="built_in">use</span>();</span><br><span class="line">        model = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">        model = glm::<span class="built_in">translate</span>(model, glm::<span class="built_in">vec3</span>(<span class="number">-0.75f</span>, <span class="number">0.75f</span>, <span class="number">0.0f</span>));  </span><br><span class="line">        shaderRed.<span class="built_in">setMat4</span>(<span class="string">&quot;model&quot;</span>, model);</span><br><span class="line">        <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line"></span><br><span class="line">        shaderGreen.<span class="built_in">use</span>();</span><br><span class="line">        model = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">        model = glm::<span class="built_in">translate</span>(model, glm::<span class="built_in">vec3</span>(<span class="number">0.75f</span>, <span class="number">0.75f</span>, <span class="number">0.0f</span>));  </span><br><span class="line">        shaderGreen.<span class="built_in">setMat4</span>(<span class="string">&quot;model&quot;</span>, model);</span><br><span class="line">        <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line"></span><br><span class="line">        shaderBlue.<span class="built_in">use</span>();</span><br><span class="line">        model = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">        model = glm::<span class="built_in">translate</span>(model, glm::<span class="built_in">vec3</span>(<span class="number">0.75f</span>, <span class="number">-0.75f</span>, <span class="number">0.0f</span>));  </span><br><span class="line">        shaderBlue.<span class="built_in">setMat4</span>(<span class="string">&quot;model&quot;</span>, model);</span><br><span class="line">        <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line"></span><br><span class="line">        shaderYellow.<span class="built_in">use</span>();</span><br><span class="line">        model = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">        model = glm::<span class="built_in">translate</span>(model, glm::<span class="built_in">vec3</span>(<span class="number">-0.75f</span>, <span class="number">-0.75f</span>, <span class="number">0.0f</span>));  </span><br><span class="line">        shaderYellow.<span class="built_in">setMat4</span>(<span class="string">&quot;model&quot;</span>, model);</span><br><span class="line">        <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>





<p>结果</p>
<p><img src="/2024/04/14/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%85%AD%EF%BC%89/image-20240413221821026.png" alt="image-20240413221821026"></p>
<h2 id="四、几何着色器"><a href="#四、几何着色器" class="headerlink" title="四、几何着色器"></a>四、几何着色器</h2><p>在顶点和片段着色器之间有一个可选的<code>几何着色器(Geometry Shader)</code></p>
<ul>
<li><p>几何着色器的输入是<code>一个图元（如点或三角形）的一组顶点</code></p>
</li>
<li><p>在顶点发送到下一着色器阶段之前对它们随意变换</p>
</li>
<li><p>能够将（这一组）顶点变换为完全不同的图元</p>
</li>
<li><p>还能生成比原来更多的顶点</p>
</li>
</ul>
<h3 id="基本内容"><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h3><p>几何着色器案例：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">points</span>) <span class="keyword">in</span>;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">line_strip</span>, <span class="keyword">max_vertices</span> = <span class="number">2</span>) <span class="keyword">out</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;    </span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="built_in">gl_in</span>[<span class="number">0</span>].<span class="built_in">gl_Position</span> + <span class="type">vec4</span>(<span class="number">-0.1</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>); </span><br><span class="line">    <span class="built_in">EmitVertex</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="built_in">gl_in</span>[<span class="number">0</span>].<span class="built_in">gl_Position</span> + <span class="type">vec4</span>( <span class="number">0.1</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">    <span class="built_in">EmitVertex</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">EndPrimitive</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>声明从顶点着色器输入的图元类型：<code>layout (points) in;</code></p>
<ul>
<li><code>points</code>：绘制GL_POINTS图元时（1）</li>
<li><code>lines</code>：绘制GL_LINES或GL_LINE_STRIP时（2）</li>
<li><code>lines_adjacency</code>：GL_LINES_ADJACENCY或GL_LINE_STRIP_ADJACENCY（4）</li>
<li><code>triangles</code>：GL_TRIANGLES、GL_TRIANGLE_STRIP或GL_TRIANGLE_FAN（3）</li>
<li><code>triangles_adjacency</code>：GL_TRIANGLES_ADJACENCY或GL_TRIANGLE_STRIP_ADJACENCY（6）</li>
<li>括号内的数字表示的是一个图元所包含的最小顶点数</li>
</ul>
</li>
<li><p>指定几何着色器输出的图元类型，以及该几何着色器能够输出的最大的顶点数量：<code>layout (line_strip, max_vertices = 2) out;</code></p>
<ul>
<li><code>points</code></li>
<li><code>line_strip</code></li>
<li><code>triangle_strip</code></li>
</ul>
</li>
<li><p>用于传递顶点着色器输出的GLSL内建变量</p>
<ul>
<li>被声明为一个数组，因为大多数的渲染图元包含多于1个的顶点</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">in</span> <span class="built_in">gl_Vertex</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec4</span>  <span class="built_in">gl_Position</span>;</span><br><span class="line">    <span class="type">float</span> <span class="built_in">gl_PointSize</span>;</span><br><span class="line">    <span class="type">float</span> <span class="built_in">gl_ClipDistance</span>[];</span><br><span class="line">&#125; <span class="built_in">gl_in</span>[];</span><br></pre></td></tr></table></figure>
</li>
<li><p>2个几何着色器函数，<code>EmitVertex</code>和<code>EndPrimitive</code></p>
<ul>
<li>调用<code>EmitVertex</code>时，gl_Position中的向量会被添加到图元中</li>
<li>调用<code>EndPrimitive</code>时，所有发射出的(Emitted)顶点都会合成为指定的输出渲染图元</li>
<li>几何着色器希望你能够生成并输出至少一个定义为输出的图元。</li>
<li>在我们的例子中，我们需要至少生成一个线条图元。</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="built_in">gl_in</span>[<span class="number">0</span>].<span class="built_in">gl_Position</span> + <span class="type">vec4</span>(<span class="number">-0.1</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>); </span><br><span class="line">    <span class="built_in">EmitVertex</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="built_in">gl_in</span>[<span class="number">0</span>].<span class="built_in">gl_Position</span> + <span class="type">vec4</span>( <span class="number">0.1</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">    <span class="built_in">EmitVertex</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">EndPrimitive</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>效果</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glDrawArrays</span>(GL_POINTS, <span class="number">0</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<img src="/2024/04/14/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%85%AD%EF%BC%89/image-20240413234118641.png" alt="image-20240413234118641" style="zoom:80%;"></li>
</ul>
<h3 id="使用几何着色器"><a href="#使用几何着色器" class="headerlink" title="使用几何着色器"></a>使用几何着色器</h3><h4 id="传递-Pass-through-几何着色器"><a href="#传递-Pass-through-几何着色器" class="headerlink" title="传递(Pass-through)几何着色器"></a>传递(Pass-through)几何着色器</h4><ul>
<li><p>直接原封不动地将顶点着色器地数据，传递给片段着色器</p>
</li>
<li><p>定义</p>
</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">points</span>) <span class="keyword">in</span>;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">points</span>, <span class="keyword">max_vertices</span> = <span class="number">1</span>) <span class="keyword">out</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;    </span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="built_in">gl_in</span>[<span class="number">0</span>].<span class="built_in">gl_Position</span>; </span><br><span class="line">    <span class="built_in">EmitVertex</span>();</span><br><span class="line">    <span class="built_in">EndPrimitive</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>着色器代码编译<ul>
<li>使用GL_GEOMETRY_SHADER作为着色器类型</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">geometryShader = <span class="built_in">glCreateShader</span>(GL_GEOMETRY_SHADER);</span><br><span class="line"><span class="built_in">glShaderSource</span>(geometryShader, <span class="number">1</span>, &amp;gShaderCode, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">glCompileShader</span>(geometryShader);  </span><br><span class="line">...</span><br><span class="line"><span class="built_in">glAttachShader</span>(program, geometryShader);</span><br><span class="line"><span class="built_in">glLinkProgram</span>(program);</span><br></pre></td></tr></table></figure>



<h4 id="画三角形"><a href="#画三角形" class="headerlink" title="画三角形"></a>画三角形</h4><ul>
<li>将几何着色器的输出设置为 <code>triangle_strip</code><ul>
<li><code>triangle_strip</code>在第一个三角形绘制完之后，每个后续顶点将会在上一个三角形边上生成另一个三角形</li>
<li>需要按一定的顺序传入三角形顶点</li>
</ul>
</li>
<li>绘制三个三角形：其中两个组成一个正方形，另一个用作房顶。<img src="/2024/04/14/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%85%AD%EF%BC%89/image-20240414000146491.png" alt="image-20240414000146491" style="zoom:60%;"></li>
</ul>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">points</span>) <span class="keyword">in</span>;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">triangle_strip</span>, <span class="keyword">max_vertices</span> = <span class="number">5</span>) <span class="keyword">out</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> VS_OUT &#123;</span><br><span class="line">    <span class="type">vec3</span> color;</span><br><span class="line">&#125; gs_in[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> fColor;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> build_house(<span class="type">vec4</span> position)</span><br><span class="line">&#123;    </span><br><span class="line">    fColor = gs_in[<span class="number">0</span>].color; <span class="comment">// gs_in[0] 因为只有一个输入顶点</span></span><br><span class="line">    <span class="built_in">gl_Position</span> = position + <span class="type">vec4</span>(<span class="number">-0.2</span>, <span class="number">-0.2</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);    <span class="comment">// 1:左下  </span></span><br><span class="line">    <span class="built_in">EmitVertex</span>();   </span><br><span class="line">    <span class="built_in">gl_Position</span> = position + <span class="type">vec4</span>( <span class="number">0.2</span>, <span class="number">-0.2</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);    <span class="comment">// 2:右下</span></span><br><span class="line">    <span class="built_in">EmitVertex</span>();</span><br><span class="line">    <span class="built_in">gl_Position</span> = position + <span class="type">vec4</span>(<span class="number">-0.2</span>,  <span class="number">0.2</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);    <span class="comment">// 3:左上</span></span><br><span class="line">    <span class="built_in">EmitVertex</span>();</span><br><span class="line">    <span class="built_in">gl_Position</span> = position + <span class="type">vec4</span>( <span class="number">0.2</span>,  <span class="number">0.2</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);    <span class="comment">// 4:右上</span></span><br><span class="line">    <span class="built_in">EmitVertex</span>();</span><br><span class="line">    <span class="built_in">gl_Position</span> = position + <span class="type">vec4</span>( <span class="number">0.0</span>,  <span class="number">0.4</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);    <span class="comment">// 5:顶部</span></span><br><span class="line">    fColor = <span class="type">vec3</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    <span class="built_in">EmitVertex</span>();</span><br><span class="line">    <span class="built_in">EndPrimitive</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;    </span><br><span class="line">    build_house(<span class="built_in">gl_in</span>[<span class="number">0</span>].<span class="built_in">gl_Position</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>结果</p>
<p><img src="/2024/04/14/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%85%AD%EF%BC%89/image-20240414001840888.png" alt="image-20240414001840888"></p>
<h4 id="爆破物体"><a href="#爆破物体" class="headerlink" title="爆破物体"></a>爆破物体</h4><p>我们是要将每个三角形沿着法向量的方向移动一小段时间，使得整个物体看起来像是沿着每个三角形的法线向量<strong>爆炸</strong>一样。</p>
<p>几何着色器代码应该如此</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">triangles</span>) <span class="keyword">in</span>;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">triangle_strip</span>, <span class="keyword">max_vertices</span> = <span class="number">3</span>) <span class="keyword">out</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> VS_OUT &#123;</span><br><span class="line">    <span class="type">vec2</span> texCoords;</span><br><span class="line">&#125; gs_in[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec2</span> TexCoords; </span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> time;</span><br><span class="line"></span><br><span class="line"><span class="type">vec3</span> GetNormal()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">vec3</span> a = <span class="type">vec3</span>(<span class="built_in">gl_in</span>[<span class="number">0</span>].<span class="built_in">gl_Position</span>) - <span class="type">vec3</span>(<span class="built_in">gl_in</span>[<span class="number">1</span>].<span class="built_in">gl_Position</span>);</span><br><span class="line">   <span class="type">vec3</span> b = <span class="type">vec3</span>(<span class="built_in">gl_in</span>[<span class="number">2</span>].<span class="built_in">gl_Position</span>) - <span class="type">vec3</span>(<span class="built_in">gl_in</span>[<span class="number">1</span>].<span class="built_in">gl_Position</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">normalize</span>(<span class="built_in">cross</span>(a, b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">vec4</span> explode(<span class="type">vec4</span> position, <span class="type">vec3</span> normal)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> magnitude = <span class="number">2.0</span>;</span><br><span class="line">    <span class="type">vec3</span> direction = normal * ((<span class="built_in">sin</span>(time) + <span class="number">1.0</span>) / <span class="number">2.0</span>) * magnitude; </span><br><span class="line">    <span class="keyword">return</span> position + <span class="type">vec4</span>(direction, <span class="number">0.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;    </span><br><span class="line">    <span class="type">vec3</span> normal = GetNormal();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">gl_Position</span> = explode(<span class="built_in">gl_in</span>[<span class="number">0</span>].<span class="built_in">gl_Position</span>, normal);</span><br><span class="line">    TexCoords = gs_in[<span class="number">0</span>].texCoords;</span><br><span class="line">    <span class="built_in">EmitVertex</span>();</span><br><span class="line">    <span class="built_in">gl_Position</span> = explode(<span class="built_in">gl_in</span>[<span class="number">1</span>].<span class="built_in">gl_Position</span>, normal);</span><br><span class="line">    TexCoords = gs_in[<span class="number">1</span>].texCoords;</span><br><span class="line">    <span class="built_in">EmitVertex</span>();</span><br><span class="line">    <span class="built_in">gl_Position</span> = explode(<span class="built_in">gl_in</span>[<span class="number">2</span>].<span class="built_in">gl_Position</span>, normal);</span><br><span class="line">    TexCoords = gs_in[<span class="number">2</span>].texCoords;</span><br><span class="line">    <span class="built_in">EmitVertex</span>();</span><br><span class="line">    <span class="built_in">EndPrimitive</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>顶点着色器和片段着色器还是用的之前的，懒得改直接用了</p>
<p><img src="/2024/04/14/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%85%AD%EF%BC%89/image-20240414010913596.png" alt="image-20240414010913596"></p>
<p><img src="/2024/04/14/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%85%AD%EF%BC%89/image-20240414010947212.png" alt="image-20240414010947212"></p>
<h4 id="法向量可视化"><a href="#法向量可视化" class="headerlink" title="法向量可视化"></a>法向量可视化</h4><p>检测法向量是否正确的一个很好的方式就是对它们进行可视化，几何着色器正是实现这一目的非常有用的工具。</p>
<p>思路是这样的：</p>
<ul>
<li>我们首先不使用几何着色器正常绘制场景。</li>
<li>然后再次绘制场景，但这次只显示通过几何着色器生成法向量。</li>
<li>几何着色器接收一个三角形图元，并沿着法向量生成三条线——每个顶点一个法向量。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shader.<span class="built_in">use</span>();</span><br><span class="line"><span class="built_in">DrawScene</span>();</span><br><span class="line">normalDisplayShader.<span class="built_in">use</span>();</span><br><span class="line"><span class="built_in">DrawScene</span>();</span><br></pre></td></tr></table></figure>



<p>顶点着色器</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec3</span> aNormal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> VS_OUT &#123;</span><br><span class="line">    <span class="type">vec3</span> normal;</span><br><span class="line">&#125; vs_out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> view;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> model;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = view * model * <span class="type">vec4</span>(aPos, <span class="number">1.0</span>); </span><br><span class="line">    <span class="type">mat3</span> normalMatrix = <span class="type">mat3</span>(<span class="built_in">transpose</span>(<span class="built_in">inverse</span>(view * model)));</span><br><span class="line">    vs_out.normal = <span class="built_in">normalize</span>(<span class="type">vec3</span>(<span class="type">vec4</span>(normalMatrix * aNormal, <span class="number">0.0</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>几何着色器</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">triangles</span>) <span class="keyword">in</span>;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">line_strip</span>, <span class="keyword">max_vertices</span> = <span class="number">6</span>) <span class="keyword">out</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> VS_OUT &#123;</span><br><span class="line">    <span class="type">vec3</span> normal;</span><br><span class="line">&#125; gs_in[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="type">float</span> MAGNITUDE = <span class="number">0.4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> projection;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> GenerateLine(<span class="type">int</span> <span class="keyword">index</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = projection * <span class="built_in">gl_in</span>[<span class="keyword">index</span>].<span class="built_in">gl_Position</span>;</span><br><span class="line">    <span class="built_in">EmitVertex</span>();</span><br><span class="line">    <span class="built_in">gl_Position</span> = projection * (<span class="built_in">gl_in</span>[<span class="keyword">index</span>].<span class="built_in">gl_Position</span> + </span><br><span class="line">                                <span class="type">vec4</span>(gs_in[<span class="keyword">index</span>].normal, <span class="number">0.0</span>) * MAGNITUDE);</span><br><span class="line">    <span class="built_in">EmitVertex</span>();</span><br><span class="line">    <span class="built_in">EndPrimitive</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    GenerateLine(<span class="number">0</span>); <span class="comment">// 第一个顶点法线</span></span><br><span class="line">    GenerateLine(<span class="number">1</span>); <span class="comment">// 第二个顶点法线</span></span><br><span class="line">    GenerateLine(<span class="number">2</span>); <span class="comment">// 第三个顶点法线</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>片段着色器</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    FragColor = <span class="type">vec4</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<p>结果</p>
<p><img src="/2024/04/14/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%85%AD%EF%BC%89/image-20240414012439135.png" alt="image-20240414012439135"></p>
<blockquote>
<p>这样的几何着色器也经常用于给物体添加毛发(Fur)。</p>
</blockquote>
<h2 id="五、实例化"><a href="#五、实例化" class="headerlink" title="五、实例化"></a>五、实例化</h2><p>假设你有一个绘制了很多模型的场景，而大部分的模型包含的是同一组顶点数据，只不过进行的是不同的世界空间变换。</p>
<p>如果我们需要渲染大量物体时，代码看起来会像这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; amount_of_models_to_draw; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">DoSomePreparations</span>(); <span class="comment">// 绑定VAO，绑定纹理，设置uniform等</span></span><br><span class="line">    <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, amount_of_vertices);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果像这样绘制模型的大量实例(Instance)，你很快就会因为绘制调用过多而达到性能瓶颈。<ul>
<li>与绘制顶点本身相比，使用glDrawArrays或glDrawElements函数告诉GPU去绘制你的顶点数据会消耗更多的性能</li>
<li>因为OpenGL在绘制顶点数据之前需要做很多准备工作<ul>
<li>比如告诉GPU该从哪个缓冲读取数据，从哪寻找顶点属性，而且这些都是在相对缓慢的CPU到GPU总线(CPU to GPU Bus)上进行的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="实例化-Instancing"><a href="#实例化-Instancing" class="headerlink" title="实例化(Instancing)"></a><strong>实例化(Instancing)</strong></h3><ul>
<li>将数据一次性发送给GPU，然后使用一个绘制函数让OpenGL利用这些数据绘制多个物体</li>
<li>使用一个渲染调用来绘制多个物体，来节省每次绘制物体时CPU -&gt; GPU的通信</li>
<li>将<code>glDrawArrays</code>和<code>glDrawElements</code>的渲染调用分别改为<code>glDrawArraysInstanced</code>和<code>glDrawElementsInstanced</code></li>
</ul>
<p>在实例化渲染方式中如何分辨不同实例</p>
<ul>
<li>GLSL在顶点着色器中嵌入了另一个内建变量 <code>gl_InstanceID</code></li>
<li>在使用实例化渲染调用时，gl_InstanceID会从0开始，在每个实例被渲染时递增1。</li>
</ul>
<p>案例：</p>
<ul>
<li><p>顶点着色器</p>
<ul>
<li>关注 <code>uniform vec2 offsets[100];</code> 和 <code>gl_InstanceID</code></li>
</ul>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec2</span> aPos;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec3</span> aColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> fColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec2</span> offsets[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> <span class="keyword">offset</span> = offsets[<span class="built_in">gl_InstanceID</span>];</span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(aPos + <span class="keyword">offset</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    fColor = aColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>片段着色器</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> fColor;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    FragColor = <span class="type">vec4</span>(fColor, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>其他代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置每个实例对应的数据</span></span><br><span class="line">glm::vec2 translations[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="type">float</span> offset = <span class="number">0.1f</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> y = <span class="number">-10</span>; y &lt; <span class="number">10</span>; y += <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">-10</span>; x &lt; <span class="number">10</span>; x += <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        glm::vec2 translation;</span><br><span class="line">        translation.x = (<span class="type">float</span>)x / <span class="number">10.0f</span> + offset;</span><br><span class="line">        translation.y = (<span class="type">float</span>)y / <span class="number">10.0f</span> + offset;</span><br><span class="line">        translations[index++] = translation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 并传递给着色器</span></span><br><span class="line">shader.<span class="built_in">use</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    stringstream ss;</span><br><span class="line">    string index;</span><br><span class="line">    ss &lt;&lt; i; </span><br><span class="line">    index = ss.<span class="built_in">str</span>(); </span><br><span class="line">    shader.<span class="built_in">setVec2</span>((<span class="string">&quot;offsets[&quot;</span> + index + <span class="string">&quot;]&quot;</span>).<span class="built_in">c_str</span>(), translations[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制实例</span></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(quadVAO);</span><br><span class="line"><span class="built_in">glDrawArraysInstanced</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">6</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="/2024/04/14/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%85%AD%EF%BC%89/image-20240414020654224.png" alt="image-20240414020654224"></p>
<h3 id="实例化数组"><a href="#实例化数组" class="headerlink" title="实例化数组"></a>实例化数组</h3><p>要渲染远超过100个实例的时候，我们最终会超过最大能够发送至着色器的uniform数据大小<a target="_blank" rel="noopener" href="http://www.opengl.org/wiki/Uniform_(GLSL)#Implementation_limits">上限</a>；</p>
<p>采用实例化数组(Instanced Array)解决这个问题</p>
<ul>
<li>实例化数组被定义为一个顶点属性（能够让我们储存更多的数据），仅在顶点着色器渲染一个新的实例时才会更新。</li>
<li>顶点着色器的每次运行都会让GLSL获取新的一组适用于当前顶点的属性，而对于实例化数组这个属性，只有在渲染下一个实例（而不是下一个顶点）时才进行更新。</li>
</ul>
<p>设置顶点着色器</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec2</span> aPos;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec3</span> aColor;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">2</span>) <span class="keyword">in</span> <span class="type">vec2</span> aOffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> fColor;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(aPos + aOffset, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    fColor = aColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他代码</p>
<ul>
<li><code>glVertexAttribDivisor</code>函数告诉了OpenGL该<strong>什么时候</strong>更新顶点属性的内容至新一组数据<ul>
<li>第一个参数是需要的顶点属性，第二个参数是属性除数(Attribute Divisor)</li>
<li>默认情况下，属性除数是0，告诉OpenGL我们需要在顶点着色器的每次迭代时更新顶点属性。</li>
<li>将它设置为1时，我们告诉OpenGL我们希望在渲染一个新实例的时候更新顶点属性。</li>
<li>而设置为2时，我们希望每2个实例更新一次属性，以此类推。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">glm::vec2 translations[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="type">float</span> offset = <span class="number">0.1f</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">-10</span>; y &lt; <span class="number">10</span>; y += <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">-10</span>; x &lt; <span class="number">10</span>; x += <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        glm::vec2 translation;</span><br><span class="line">        translation.x = (<span class="type">float</span>)x / <span class="number">10.0f</span> + offset;</span><br><span class="line">        translation.y = (<span class="type">float</span>)y / <span class="number">10.0f</span> + offset;</span><br><span class="line">        translations[index++] = translation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将要传给实例化数组的数据映射到一个 instanceVBO</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> instanceVBO;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;instanceVBO);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, instanceVBO);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(glm::vec2) * <span class="number">100</span>, &amp;translations[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// VBO 和 VAO（先bind VAO，之后再bind VBO设置数据，以及设置顶点属性指针）</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> VBO;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> VAO;</span><br><span class="line"><span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;VAO);</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;VBO);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(quadVertices), quadVertices, GL_STATIC_DRAW);</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">5</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">5</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)(<span class="number">2</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>)));</span><br><span class="line"><span class="comment">// 设置instanceVBO的顶点属性指针，并启用顶点属性：</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, instanceVBO);</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">2</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">2</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glVertexAttribDivisor</span>(<span class="number">2</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>



<p><img src="/2024/04/14/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%85%AD%EF%BC%89/image-20240414023004222.png" alt="image-20240414023004222"></p>
<h3 id="小行星带"><a href="#小行星带" class="headerlink" title="小行星带"></a>小行星带</h3><p>懒得弄了…</p>
<p>主要是把每个小行星的 <code>uniform model矩阵</code> 抽离出来用实例化数组来存，即 <code>layout (location = 3) in mat4 instanceMatrix;</code></p>
<blockquote>
<p>实例化渲染通常会用于渲染草、植被、粒子，以及上面这样的场景，基本上只要场景中有很多重复的形状，都能够使用实例化渲染来提高性能。</p>
</blockquote>
<h2 id="六、抗锯齿"><a href="#六、抗锯齿" class="headerlink" title="六、抗锯齿"></a>六、抗锯齿</h2><p>锯齿边缘(Jagged Edges)的产生和光栅器将顶点数据转化为片段的方式有关。</p>
<img src="/2024/04/14/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%85%AD%EF%BC%89/image-20240414023907491.png" alt="image-20240414023907491" style="zoom:67%;">

<p>清楚看见形成边缘的像素，这种现象被称之为走样(Aliasing)。</p>
<p>抗锯齿（Anti-aliasing，也被称为反走样）的技术能够帮助我们缓解这种现象，从而产生更<strong>平滑</strong>的边缘。</p>
<ul>
<li>超采样抗锯齿(Super Sample Anti-aliasing, SSAA)<ul>
<li>使用比正常分辨率更高的分辨率（即超采样）来渲染场景</li>
<li>当图像输出在帧缓冲中更新时，分辨率会被下采样(Downsample)至正常的分辨率</li>
<li>由于比平时要绘制更多的片段，它会带来很大的性能开销。</li>
</ul>
</li>
<li>多重采样抗锯齿(Multisample Anti-aliasing, MSAA)<ul>
<li>借鉴了SSAA背后的理念，但却以更加高效的方式实现了抗锯齿</li>
</ul>
</li>
</ul>
<h3 id="多重采样"><a href="#多重采样" class="headerlink" title="多重采样"></a>多重采样</h3><p><strong>OpenGL光栅器的工作方式</strong></p>
<p>光栅器是位于最终处理过的顶点之后，到片段着色器之前，所经过的所有的算法与过程的总和。</p>
<ul>
<li>光栅器会将一个图元的所有顶点作为输入，并将它转换为一系列的片段</li>
<li>顶点坐标理论上可以取任意值，但片段不行，因为它们受限于你窗口的分辨率</li>
<li>顶点坐标与片段之间几乎永远也不会有一对一的映射，所以光栅器必须以某种方式来决定每个顶点最终所在的片段&#x2F;屏幕坐标</li>
</ul>
<p><img src="/2024/04/14/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%85%AD%EF%BC%89/image-20240414024456540.png" alt="image-20240414024456540"></p>
<p>这里我们可以看到一个屏幕像素的网格，每个像素的中心包含有一个<code>采样点(Sample Point)</code>，它会被用来决定这个三角形是否遮盖了某个像素。</p>
<ul>
<li>图中红色的采样点被三角形所遮盖，在每一个遮住的像素处都会生成一个片段.</li>
<li>虽然三角形边缘的一些部分也遮住了某些屏幕像素，但是这些像素的采样点并没有被三角形<strong>内部</strong>所遮盖，所以它们不会受到片段着色器的影响。</li>
</ul>
<p>完成渲染后：</p>
<ul>
<li>由于屏幕像素总量的限制，有些边缘的像素能够被渲染出来，而有些则不会。结果就是我们使用了不光滑的边缘来渲染图元，导致之前讨论到的锯齿边缘。</li>
</ul>
<p><img src="/2024/04/14/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%85%AD%EF%BC%89/image-20240414024602352.png" alt="image-20240414024602352"></p>
<p><strong>多重采样</strong></p>
<p>多重采样所做的正是将单一的采样点变为多个采样点（这也是它名称的由来）</p>
<ul>
<li>取而代之的是以特定图案排列的4个子采样点(Subsample)<ul>
<li>采样点的数量可以是任意的，更多的采样点能带来更精确的遮盖率</li>
</ul>
</li>
<li>这也意味着颜色缓冲的大小会随着子采样点的增加而增加</li>
</ul>
<p><img src="/2024/04/14/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%85%AD%EF%BC%89/image-20240414024753943.png" alt="image-20240414024753943"></p>
<ul>
<li>我们知道三角形只遮盖了2个子采样点，所以下一步是决定这个像素的颜色。<ul>
<li>MSAA真正的工作方式是：无论三角形遮盖了多少个子采样点（至少1个），（每个图元中）每个像素只运行<strong>一次</strong>片段着色器。</li>
<li>片段着色器所使用的顶点数据会插值到每个像素的<strong>中心</strong>，所得到的结果颜色会被储存在每个被遮盖住的子采样点中。</li>
<li>当颜色缓冲的子样本被图元的所有颜色填满时，所有的这些颜色将会在每个像素内部平均化。<ul>
<li>因为上图的4个采样点中只有2个被遮盖住了，这个像素的颜色将会是三角形颜色与其他两个采样点的颜色（在这里是无色）的平均值，最终形成一种淡蓝色。</li>
</ul>
</li>
<li>对于每个像素来说，越少的子采样点被三角形所覆盖，那么它受到三角形的影响就越小。</li>
</ul>
</li>
</ul>
<p><img src="/2024/04/14/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%85%AD%EF%BC%89/image-20240414025133098.png" alt="image-20240414025133098"></p>
<p><img src="/2024/04/14/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%85%AD%EF%BC%89/image-20240414025304477.png" alt="image-20240414025304477"></p>
<ul>
<li>三角形的不平滑边缘被稍浅的颜色所包围后，从远处观察时就会显得更加平滑了。</li>
</ul>
<p>不仅仅是颜色值会受到多重采样的影响，深度和模板测试也能够使用多个采样点。</p>
<ul>
<li>对深度测试来说，每个顶点的深度值会在运行深度测试之前被插值到各个子样本中。</li>
<li>对模板测试来说，我们对每个子样本，而不是每个像素，存储一个模板值。</li>
</ul>
<p>当然，这也意味着深度和模板缓冲的大小会乘以子采样点的个数。</p>
<h3 id="OpenGL中的MSAA"><a href="#OpenGL中的MSAA" class="headerlink" title="OpenGL中的MSAA"></a>OpenGL中的MSAA</h3><p>如果我们想要在OpenGL中使用MSAA，我们必须要使用一个能在每个像素中存储大于1个颜色值的颜色缓冲（因为多重采样需要我们为每个采样点都储存一个颜色）。</p>
<p><code>多重采样缓冲(Multisample Buffer)</code>，存储特定数量的多重采样样本</p>
<ul>
<li><p>大多数的窗口系统都应该提供了一个多重采样缓冲，用以代替默认的颜色缓冲</p>
</li>
<li><p>在创建窗口之前调用<code>glfwWindowHint</code><strong>提示</strong>(Hint) GLFW，我们希望使用一个包含N个样本的多重采样缓冲</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_SAMPLES, <span class="number">4</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>调用glEnable启用GL_MULTISAMPLE，来启用多重采样</p>
<ul>
<li><p>在大多数OpenGL的驱动上，多重采样都是默认启用的</p>
</li>
<li><p>只要默认的帧缓冲有了多重采样缓冲的附件，我们所要做的只是调用glEnable来启用多重采样。</p>
<ul>
<li>多重采样的算法都在OpenGL驱动的光栅器中实现了，我们不需要再多做什么。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glEnable</span>(GL_MULTISAMPLE);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="离屏MSAA"><a href="#离屏MSAA" class="headerlink" title="离屏MSAA"></a>离屏MSAA</h3><p>如果我们想要使用我们自己的帧缓冲来进行离屏渲染，那么我们就必须要自己动手生成多重采样缓冲了。</p>
<p>有两种方式可以创建多重采样缓冲，将其作为帧缓冲的附件：</p>
<ul>
<li>纹理附件</li>
<li>渲染缓冲对象</li>
</ul>
<h4 id="多重采样纹理附件"><a href="#多重采样纹理附件" class="headerlink" title="多重采样纹理附件"></a>多重采样纹理附件</h4><p>创建一个支持储存多个采样点的纹理</p>
<ul>
<li>它的第二个参数设置的是纹理所拥有的样本个数</li>
<li>最后一个参数为GL_TRUE，图像将会对每个纹素使用相同的样本位置以及相同数量的子采样点个数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D_MULTISAMPLE, tex);</span><br><span class="line"><span class="built_in">glTexImage2DMultisample</span>(GL_TEXTURE_2D_MULTISAMPLE, samples, GL_RGB, width, height, GL_TRUE);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D_MULTISAMPLE, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>使用glFramebufferTexture2D将多重采样纹理附加到帧缓冲上</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glFramebufferTexture2D</span>(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D_MULTISAMPLE, tex, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>



<h4 id="多重采样渲染缓冲对象"><a href="#多重采样渲染缓冲对象" class="headerlink" title="多重采样渲染缓冲对象"></a>多重采样渲染缓冲对象</h4><p>在指定（当前绑定的）渲染缓冲的内存存储时，将<code>glRenderbufferStorage</code>的调用改为<code>glRenderbufferStorageMultisample</code>就可以了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glRenderbufferStorageMultisample</span>(GL_RENDERBUFFER, <span class="number">4</span>, GL_DEPTH24_STENCIL8, width, height);</span><br></pre></td></tr></table></figure>



<h4 id="渲染到多重采样帧缓冲"><a href="#渲染到多重采样帧缓冲" class="headerlink" title="渲染到多重采样帧缓冲"></a>渲染到多重采样帧缓冲</h4><p>一个多重采样的图像包含比普通图像更多的信息，我们所要做的是缩小或者还原(Resolve)图像。</p>
<p>多重采样帧缓冲的还原通常是通过<code>glBlitFramebuffer</code>来完成：</p>
<ul>
<li>将一个帧缓冲中的某个区域复制到另一个帧缓冲中，并且将多重采样缓冲还原。</li>
<li>将一个用4个屏幕空间坐标所定义的源区域复制到一个同样用4个屏幕空间坐标所定义的目标区域中</li>
<li>根据当前绑定的<code>GL_READ_FRAMEBUFFER</code>与<code>GL_DRAW_FRAMEBUFFER</code>来确定 源 和 目标</li>
</ul>
<p>将图像位块传送(Blit)到默认的帧缓冲中，即把多重采样的帧缓冲传送到屏幕上。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源：多重采样帧缓冲 目标：屏幕帧缓冲</span></span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_READ_FRAMEBUFFER, multisampledFBO);</span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_DRAW_FRAMEBUFFER, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBlitFramebuffer</span>(<span class="number">0</span>, <span class="number">0</span>, width, height, <span class="number">0</span>, <span class="number">0</span>, width, height, GL_COLOR_BUFFER_BIT, GL_NEAREST);</span><br></pre></td></tr></table></figure>



<h4 id="使用多重采样帧缓冲做后期处理"><a href="#使用多重采样帧缓冲做后期处理" class="headerlink" title="使用多重采样帧缓冲做后期处理"></a>使用多重采样帧缓冲做后期处理</h4><p>使用多重采样帧缓冲的纹理输出来做像是后期处理这样的事情</p>
<ul>
<li>我们不能直接在片段着色器中使用多重采样的纹理</li>
<li>我们能做的是将多重采样缓冲位块传送到一个没有使用多重采样纹理附件的FBO中，然后用这个普通的颜色附件来做后期处理</li>
</ul>
<p>这也意味着我们需要生成一个新的FBO，作为中介帧缓冲对象，将多重采样缓冲还原为一个能在着色器中使用的普通2D纹理。这个过程的伪代码是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> msFBO = <span class="built_in">CreateFBOWithMultiSampledAttachments</span>();</span><br><span class="line"><span class="comment">// 使用普通的纹理颜色附件创建一个新的FBO</span></span><br><span class="line">...</span><br><span class="line"><span class="built_in">glFramebufferTexture2D</span>(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, screenTexture, <span class="number">0</span>);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glBindFramebuffer</span>(msFBO);</span><br><span class="line">    <span class="built_in">ClearFrameBuffer</span>();</span><br><span class="line">    <span class="built_in">DrawScene</span>();</span><br><span class="line">    <span class="comment">// 将多重采样缓冲还原到中介FBO上</span></span><br><span class="line">    <span class="built_in">glBindFramebuffer</span>(GL_READ_FRAMEBUFFER, msFBO);</span><br><span class="line">    <span class="built_in">glBindFramebuffer</span>(GL_DRAW_FRAMEBUFFER, intermediateFBO);</span><br><span class="line">    <span class="built_in">glBlitFramebuffer</span>(<span class="number">0</span>, <span class="number">0</span>, width, height, <span class="number">0</span>, <span class="number">0</span>, width, height, GL_COLOR_BUFFER_BIT, GL_NEAREST);</span><br><span class="line">    <span class="comment">// 现在场景是一个2D纹理缓冲，可以将这个图像用来后期处理</span></span><br><span class="line">    <span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">ClearFramebuffer</span>();</span><br><span class="line">    <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, screenTexture);</span><br><span class="line">    <span class="built_in">DrawPostProcessingQuad</span>();  </span><br><span class="line"></span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>因为屏幕纹理又变回了一个只有单一采样点的普通纹理，像是<strong>边缘检测</strong>这样的后期处理滤镜会重新导致锯齿。为了补偿这一问题，你可以之后对纹理进行模糊处理，或者想出你自己的抗锯齿算法。</p>
</blockquote>
<blockquote>
<p>如果将多重采样与离屏渲染结合起来，我们需要自己负责一些额外的细节。</p>
</blockquote>
<h3 id="自定义抗锯齿算法"><a href="#自定义抗锯齿算法" class="headerlink" title="自定义抗锯齿算法"></a>自定义抗锯齿算法</h3><p>将一个多重采样的纹理图像不进行还原直接传入着色器也是可行的</p>
<p>GLSL提供了这样的选项，让我们能够对纹理图像的每个子样本进行采样，所以我们可以创建我们自己的抗锯齿算法</p>
<ul>
<li>将纹理uniform采样器设置为<code>sampler2DMS</code>，而不是平常使用的sampler2D</li>
<li>使用<code>texelFetch</code>函数获取每个子样本的颜色值</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2DMS</span> screenTextureMS;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec4</span> colorSample = <span class="built_in">texelFetch</span>(screenTextureMS, TexCoords, <span class="number">3</span>);  <span class="comment">// 第4个子样本</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://mang959595.github.io/2024/04/14/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%85%AD%EF%BC%89/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
    </footer>
  </div>

   
  <nav class="article-nav">
    
    
      <a href="/2024/04/10/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%BA%94%EF%BC%89/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">LearnOpenGL摘要（入门五）</div>
      </a>
    
  </nav>

  
   
    
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022-2024
        <i class="ri-heart-fill heart_icon"></i> FRP
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/123.jpg" alt="b4mang95"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>