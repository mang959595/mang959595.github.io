<!DOCTYPE html>


<html lang="zh-Hans">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>LearnOpenGL摘要（入门二） |  b4mang95</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/images/hexo.png" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-LearnOpenGL摘要（2）"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  LearnOpenGL摘要（入门二）
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/" class="article-date">
  <time datetime="2024-04-02T04:08:11.000Z" itemprop="datePublished">2024-04-02</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/">图形学</a> / <a class="article-category-link" href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/OpenGL/">OpenGL</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">10.9k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">43 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="着色器，纹理，变换，坐标系、摄像机"><a href="#着色器，纹理，变换，坐标系、摄像机" class="headerlink" title="着色器，纹理，变换，坐标系、摄像机"></a>着色器，纹理，变换，坐标系、摄像机</h1><h2 id="一、着色器-Shader"><a href="#一、着色器-Shader" class="headerlink" title="一、着色器 Shader"></a>一、着色器 Shader</h2><ul>
<li><strong>概念</strong>：着色器(Shader)是运行在GPU上的小程序。这些小程序为图形渲染管线的某个特定部分而运行。</li>
<li><strong>抽象描述</strong>：着色器只是一种把输入转化为输出的程序。</li>
<li><strong>独立</strong>：着色器也是一种非常独立的程序，因为它们之间不能相互通信；它们之间唯一的沟通只有通过输入和输出。</li>
</ul>
<span id="more"></span>

<h2 id><a href="#" class="headerlink" title></a></h2><h3 id="OpengGL的着色器语言——GLSL"><a href="#OpengGL的着色器语言——GLSL" class="headerlink" title="OpengGL的着色器语言——GLSL"></a>OpengGL的着色器语言——GLSL</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul>
<li><p>C语言 like</p>
</li>
<li><p>为图形计算量身定制，包含一些针对向量和矩阵操作的有用特性</p>
</li>
</ul>
<h4 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h4><ul>
<li>声明版本</li>
<li>输入变量，输出变量</li>
<li>uniform</li>
<li>main函数</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version version_number</span></span><br><span class="line"><span class="keyword">in</span> type in_variable_name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> type out_variable_name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> type uniform_name;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 处理输入并进行一些图形操作</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 输出处理过的结果到输出变量</span></span><br><span class="line">  out_variable_name = weird_stuff_we_processed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>每个着色器的入口点都是main函数，在这个函数中我们处理所有的输入变量，并将结果输出到输出变量中。</p>
</blockquote>
<blockquote>
<p>特定于顶点着色器</p>
<ul>
<li><p>每个输入变量也叫顶点属性(Vertex Attribute)</p>
</li>
<li><p>由硬件来决定顶点属性的数量</p>
</li>
<li><p>OpenGL确保至少有16个包含4分量的顶点属性可用，但是有些硬件或许允许更多的顶点属性</p>
</li>
<li><p>&#96;&#96;&#96;c<br>&#x2F;&#x2F; 查询顶点属性数量<br>int nrAttributes;<br>glGetIntegerv(GL_MAX_VERTEX_ATTRIBS, &amp;nrAttributes);<br>std::cout &lt;&lt; “Maximum nr of vertex attributes supported: “ &lt;&lt; nrAttributes &lt;&lt; std::endl;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 数据类型</span><br><span class="line"></span><br><span class="line">- 默认基础数据类型：`int`,`float`,`double`,`uint`,`bool`</span><br><span class="line">- 容器类型：`Vector`和`Matrix`</span><br><span class="line"></span><br><span class="line">##### 向量Vector</span><br><span class="line"></span><br><span class="line">- 可以包含有2、3或者4个分量的容器，分量的类型可以是前面默认基础类型的任意一个</span><br><span class="line"></span><br><span class="line">![image-20240331001426533](LearnOpenGL摘要（2）/image-20240331001426533.png)</span><br><span class="line"></span><br><span class="line">- 可通过`.xyzw`，`.rgba`，`stpq`访问分量</span><br><span class="line"></span><br><span class="line">- 向量重组的语法：</span><br><span class="line"></span><br><span class="line"> ```glsl</span><br><span class="line"> vec2 someVec;</span><br><span class="line"> vec4 differentVec = someVec.xyxx;</span><br><span class="line"> vec3 anotherVec = differentVec.zyw;</span><br><span class="line"> vec4 otherVec = someVec.xxxx + anotherVec.yxzy;</span><br><span class="line"> </span><br><span class="line"> // 以及构造函数的参数</span><br><span class="line"> vec2 vect = vec2(0.5, 0.7);</span><br><span class="line"> vec4 result = vec4(vect, 0.0, 0.0);</span><br><span class="line"> vec4 otherResult = vec4(result.xyz, 1.0);</span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
<h4 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h4><ul>
<li>着色器之间是各自独立的程序</li>
<li>但是为了完成同一个整体目标，需要通过<code>输入输出</code>来彼此进行数据交流和传递</li>
<li>使用关键字 in out 设定输入和输出，只要一个输出变量与下一个着色器阶段的输入匹配，它就会传递下去。</li>
</ul>
<p><strong>在顶点和片段着色器中会有点不同</strong>：</p>
<ul>
<li>顶点着色器 ——— 接收的是一种特殊形式的输入<ul>
<li>从顶点数据中直接接收输入</li>
<li>使用<code>location</code>这一元数据指定输入变量的位置，对应我们在CPU上配置的顶点属性</li>
<li><code>layout (location = 0)</code>：为顶点着色器的输入提供一个额外的<code>layout</code>标识，把它链接到顶点数据</li>
</ul>
</li>
<li>片段着色器 ———— 需要一个<code>vec4</code>颜色输出变量<ul>
<li>需要生成一个最终输出的颜色（否则默认输出黑&#x2F;白）</li>
</ul>
</li>
</ul>
<p><strong>定义输入与输出</strong></p>
<ul>
<li><p>如果我们打算从一个着色器向另一个着色器发送数据，我们必须在发送方着色器中声明一个输出，在接收方着色器中声明一个类似的输入</p>
</li>
<li><p><strong>当类型和名字都一样</strong>的时候，OpenGL就会把两个变量链接到一起，它们之间就能发送数据了（这是在链接着色器程序对象时完成的）</p>
</li>
<li><p>新的顶点着色器</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos; <span class="comment">// 位置变量的属性位置值为0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> vertexColor; <span class="comment">// 为片段着色器指定一个颜色输出</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(aPos, <span class="number">1.0</span>); <span class="comment">// 注意我们如何把一个vec3作为vec4的构造器的参数</span></span><br><span class="line">    vertexColor = <span class="type">vec4</span>(<span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>); <span class="comment">// 把输出变量设置为暗红色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>新的片段着色器</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec4</span> vertexColor; <span class="comment">// 从顶点着色器传来的输入变量（名称相同、类型相同）</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    FragColor = vertexColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Uniform"><a href="#Uniform" class="headerlink" title="Uniform"></a>Uniform</h4><p>用于从CPU中的应用向GPU中的着色器发送数据的方式</p>
<p>但uniform和顶点属性有些不同</p>
<ul>
<li><p>uniform是全局的(Global)</p>
<ul>
<li>必须在每个·着色器程序对象·中都是独一无二的</li>
<li>可以被着色器程序的任意着色器在任意阶段访问</li>
<li>uniform会一直保存它们的数据，直到它们被重置或更新</li>
</ul>
</li>
<li><p>在着色器代码中声明</p>
<ul>
<li><code>uniform vec4 ourColor; // 在OpenGL程序代码中设定这个变量</code></li>
<li>声明之后，如果该uniform变量不被使用，编译器会默认移除这个变量。这可能会导致一些问题</li>
</ul>
</li>
<li><p>在应用代码中设置数据</p>
<ul>
<li><p>首先需要找到着色器程序中对应uniform属性的索引&#x2F;位置值：<code>glGetUniformLocation</code></p>
</li>
<li><p>设置数据：<code>glUniform4</code></p>
</li>
<li><p>案例：随时间改变颜色数值</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> timeValue = glfwGetTime();</span><br><span class="line"><span class="type">float</span> greenValue = (<span class="built_in">sin</span>(timeValue) / <span class="number">2.0</span>f) + <span class="number">0.5</span>f;</span><br><span class="line"><span class="type">int</span> vertexColorLocation = glGetUniformLocation(shaderProgram, &quot;ourColor&quot;);</span><br><span class="line">glUseProgram(shaderProgram);</span><br><span class="line">glUniform4f(vertexColorLocation, <span class="number">0.0</span>f, greenValue, <span class="number">0.0</span>f, <span class="number">1.0</span>f);</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询uniform地址不要求你之前使用过着色器程序，但是更新一个uniform之前你<strong>必须</strong>先使用程序（调用glUseProgram)，因为它是在当前激活的着色器程序中设置uniform的。</p>
</li>
</ul>
</li>
<li><pre><code class="c">// 变色示例中的渲染循环

while(!glfwWindowShouldClose(window))
&#123;
    // 输入
    processInput(window);

    // 渲染
    // 清除颜色缓冲
    glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT);

    // 记得激活着色器
    glUseProgram(shaderProgram);

    // 更新uniform颜色
    float timeValue = glfwGetTime();
    float greenValue = sin(timeValue) / 2.0f + 0.5f;
    int vertexColorLocation = glGetUniformLocation(shaderProgram, &quot;ourColor&quot;);
    glUniform4f(vertexColorLocation, 0.0f, greenValue, 0.0f, 1.0f);

    // 绘制三角形
    glBindVertexArray(VAO);
    glDrawArrays(GL_TRIANGLES, 0, 3);

    // 交换缓冲并查询IO事件
    glfwSwapBuffers(window);
    glfwPollEvents();
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;OpenGL不支持函数重载（C语言库），对应的有多种函数后缀</span><br><span class="line">&gt;</span><br><span class="line">&gt;- 每当你打算配置一个OpenGL的选项时就可以简单地根据这些规则选择适合你的数据类型的重载函数。</span><br><span class="line">&gt;</span><br><span class="line">&gt;![image-20240331014255103](LearnOpenGL摘要（2）/image-20240331014255103.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 为顶点设置更多属性</span><br><span class="line"></span><br><span class="line">之前的顶点属性只有位置</span><br><span class="line"></span><br><span class="line">在前面的教程中，我们了解了：</span><br><span class="line"></span><br><span class="line">- 如何填充VBO（设置顶点缓冲区对象，把内存中的顶点数据映射到GPU显存）</span><br><span class="line">- 配置顶点属性指针（指定顶点数据中的顶点属性信息）</span><br><span class="line">- 如何把它们都储存到一个VAO里（顶点属性指针和VBO的关联可以存放到VAO里，以便于重复利用）</span><br><span class="line"></span><br><span class="line">![image-20240331015257562](LearnOpenGL摘要（2）/image-20240331015257562.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 案例</span><br><span class="line"></span><br><span class="line">- 顶点数据：</span><br><span class="line"></span><br><span class="line">  ```c</span><br><span class="line">  float vertices[] = &#123;</span><br><span class="line">      // 位置              // 颜色</span><br><span class="line">       0.5f, -0.5f, 0.0f,  1.0f, 0.0f, 0.0f,   // 右下</span><br><span class="line">      -0.5f, -0.5f, 0.0f,  0.0f, 1.0f, 0.0f,   // 左下</span><br><span class="line">       0.0f,  0.5f, 0.0f,  0.0f, 0.0f, 1.0f    // 顶部</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>顶点着色器：新增一个 in 颜色属性，指定location 为 1</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;   <span class="comment">// 位置变量的属性位置值为 0 </span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec3</span> aColor; <span class="comment">// 颜色变量的属性位置值为 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> ourColor; <span class="comment">// 向片段着色器输出一个颜色</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line">    ourColor = aColor; <span class="comment">// 将ourColor设置为我们从顶点数据那里得到的输入颜色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>片段着色器：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;  </span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> ourColor;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    FragColor = <span class="type">vec4</span>(ourColor, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置顶点属性指针：</p>
<ul>
<li><p>目标<br><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240331015638950.png" alt="image-20240331015638950"></p>
</li>
<li><p>&#96;&#96;&#96;c<br>&#x2F;&#x2F; 位置属性<br>glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);<br>glEnableVertexAttribArray(0);</p>
<p>&#x2F;&#x2F; 颜色属性<br>glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(3* sizeof(float)));<br>glEnableVertexAttribArray(1);</p>
<p>glVertexAttribPointer:</p>
<ul>
<li>第一个参数指定我们要配置的顶点属性的位置值（对应顶点着色器中in属性的location）</li>
<li>第二个参数指定顶点属性的大小</li>
<li>第三个参数指定数据的类型</li>
<li>第四个参数定义我们是否希望数据被标准化(Normalize)</li>
<li>第五个参数叫做步长(Stride)，它告诉我们在连续的顶点属性组之间的间隔</li>
<li>最后一个参数的类型是<code>void*</code>，所以需要我们进行这个奇怪的强制类型转换。它表示位置数据在缓冲中起始位置的偏移量(Offset)。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 着色器管理</span><br><span class="line"></span><br><span class="line">编写、编译、管理着色器是件麻烦事。</span><br><span class="line"></span><br><span class="line">可以封装一个着色器类：</span><br><span class="line"></span><br><span class="line">- 从硬盘读取着色器，然后编译并链接成着色器程序，并对它们进行错误检测</span><br><span class="line">- 激活着色器程序操作</span><br><span class="line">- uniform变量设置操作</span><br><span class="line"></span><br><span class="line">详细代码见[着色器 - LearnOpenGL CN (learnopengl-cn.github.io)](https://learnopengl-cn.github.io/01 Getting started/05 Shaders/)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 二、纹理</span><br><span class="line"></span><br><span class="line">纹理是一个2D图片（甚至也有1D和3D的纹理），它可以用来添加物体的细节。</span><br><span class="line"></span><br><span class="line">除了图像以外，纹理也可以被用来储存大量的数据，这些数据可以发送到着色器上。</span><br><span class="line"></span><br><span class="line">### 相关概念</span><br><span class="line"></span><br><span class="line">#### 纹理映射(Map)</span><br><span class="line"></span><br><span class="line">- 三角形的每个顶点各自关联着一个纹理坐标(Texture Coordinate)，标明该从纹理图像的哪个部分采样</span><br><span class="line">- 非顶点的片段通过片段插值(Fragment Interpolation)，获取纹理坐标的插值结果，再从纹理上采样对应的数值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 纹理坐标</span><br><span class="line"></span><br><span class="line">- （2D纹理图像）纹理坐标在x和y轴上，范围为0到1之间。又称uv坐标</span><br><span class="line">- 使用纹理坐标获取纹理颜色叫做采样(Sampling)</span><br><span class="line">- 顶点的纹理坐标一般是先确定好的，需要从应用中传递给顶点着色器。顶点着色器再传递给片段着色器进行插值计算。</span><br><span class="line">  ![image-20240331024628030](LearnOpenGL摘要（2）/image-20240331024628030.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 纹理环绕方式</span><br><span class="line"></span><br><span class="line">纹理坐标值的范围为（0，0）到（1，1）</span><br><span class="line"></span><br><span class="line">讨论坐标值在这个范围之外的情况：</span><br><span class="line"></span><br><span class="line">- OpenGL默认的行为是重复这个纹理图像（忽略浮点数的整数部分）</span><br><span class="line"></span><br><span class="line">- 不同的重复方式：</span><br><span class="line">  ![image-20240331032852725](LearnOpenGL摘要（2）/image-20240331032852725.png)</span><br><span class="line"></span><br><span class="line">   ![image-20240331032805953](LearnOpenGL摘要（2）/image-20240331032805953.png)</span><br><span class="line"></span><br><span class="line">- 设置方法：`glTexParameter*`函数</span><br><span class="line"></span><br><span class="line">  ```c</span><br><span class="line">  // 分别对 S,T(,R) 方向（和xyz等价）设置GL_MIRRORED_REPEAT</span><br><span class="line">  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);</span><br><span class="line">  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);</span><br><span class="line">  </span><br><span class="line">  或者是</span><br><span class="line">      </span><br><span class="line">  // 设置 GL_CLAMP_TO_BORDER</span><br><span class="line">  float borderColor[] = &#123; 1.0f, 1.0f, 0.0f, 1.0f &#125;;</span><br><span class="line">  glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="纹理过滤"><a href="#纹理过滤" class="headerlink" title="纹理过滤"></a>纹理过滤</h3><p>纹理坐标的基于浮点值，精细度是无限的。</p>
<p>而纹理图片是由有限的像素组成的，是具有有限分辨率的。</p>
<p>考虑一个问题：</p>
<ul>
<li>OpenGL需要知道怎样将纹理像素(Texture Pixel，也叫Texel)映射到纹理坐标。</li>
<li>即纹理坐标(u,v)，其对应的纹理像素应该是哪个&#x2F;些，颜色值应该是多少</li>
</ul>
<p>OpenGL的两种纹理过滤方式</p>
<h4 id="GL-NEAREST-临近过滤"><a href="#GL-NEAREST-临近过滤" class="headerlink" title="GL_NEAREST 临近过滤"></a>GL_NEAREST 临近过滤</h4><ul>
<li>OpenGL默认的纹理过滤方式</li>
<li>选择中心点最接近纹理坐标的那个像素</li>
<li><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240331033826506.png" alt="image-20240331033826506"></li>
</ul>
<h4 id="GL-LINEAR-线性过滤"><a href="#GL-LINEAR-线性过滤" class="headerlink" title="GL_LINEAR 线性过滤"></a>GL_LINEAR 线性过滤</h4><ul>
<li>基于纹理坐标附近的纹理像素，计算出一个插值，近似出这些纹理像素之间的颜色</li>
<li>距离越近权值越大</li>
<li><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240331033858271.png" alt="image-20240331033858271"></li>
</ul>
<p><strong>设置</strong></p>
<ul>
<li><p>可以设置纹理在放大(Magnify)和缩小(Minify)情况下的纹理过滤选项</p>
</li>
<li><p>&#96;&#96;&#96;c<br>&#x2F;&#x2F; 在纹理被缩小的时候使用邻近过滤，被放大时使用线性过滤。</p>
<p>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);<br>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-  ![image-20240331034553017](LearnOpenGL摘要（2）/image-20240331034553017.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; 纹理分辨率相对太小的情况 (上面文章中的情况)</span><br><span class="line">&gt;</span><br><span class="line">&gt; - 对应纹理放大情况(Magnify)</span><br><span class="line">&gt; - 一个片段的纹理坐标，只能对应到一个纹理像素的内部。或者说一个纹理像素，可能对应着多个片段。</span><br><span class="line">&gt; - 解决：</span><br><span class="line">&gt;   - 临近</span><br><span class="line">&gt;   - 线性（双线性插值）</span><br><span class="line">&gt;   - bicubic</span><br><span class="line">&gt;</span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br><span class="line">&gt; 纹理分辨率相对太大的情况：（下面文章中的情况）</span><br><span class="line">&gt;</span><br><span class="line">&gt; - 对应纹理缩小情况(Minify)</span><br><span class="line">&gt; - 纹理像素和片段几乎一一对应，但是临近的两个片段对应的两个纹理像素中间的那些纹理是没有被任何片段对应到的。</span><br><span class="line">&gt; - 解决：</span><br><span class="line">&gt;   - 超采样</span><br><span class="line">&gt;   - 范围查询</span><br><span class="line">&gt;   - mipmap</span><br><span class="line">&gt;   - 三线性插值</span><br><span class="line">&gt;   - 各向异性过滤</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 多级渐远纹理 Mipmap</span><br><span class="line"></span><br><span class="line">有些物体会很远，但其纹理会拥有与近处物体同样高的分辨率。</span><br><span class="line"></span><br><span class="line">由于远处的物体可能只产生很少的片段，OpenGL从高分辨率纹理中为这些片段获取正确的颜色值就很困难，因为它需要对一个跨过纹理很大部分的片段只拾取一个纹理颜色。</span><br><span class="line"></span><br><span class="line">在小物体上这会产生不真实的感觉，更不用说对它们使用高分辨率纹理浪费内存的问题了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image-20240331035431064](LearnOpenGL摘要（2）/image-20240331035431064.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**理念**：距观察者的距离超过一定的阈值，OpenGL会使用不同的多级渐远纹理，即最适合物体的距离的那个。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 使用方法</span><br><span class="line"></span><br><span class="line">- glGenerateMipmaps，在创建完一个纹理后调用它OpenGL就会承担接下来的所有工作了。</span><br><span class="line"></span><br><span class="line">- 不同级别的渐远纹理之间的过渡</span><br><span class="line"></span><br><span class="line">  - 跨级的时候纹理会由生硬的边界</span><br><span class="line"></span><br><span class="line">  - 可以采样临近过滤或线性过滤来处理</span><br><span class="line"></span><br><span class="line">  -  ![image-20240331035927857](LearnOpenGL摘要（2）/image-20240331035927857.png)</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);</span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="实操：加载和创建纹理"><a href="#实操：加载和创建纹理" class="headerlink" title="实操：加载和创建纹理"></a>实操：加载和创建纹理</h3><h4 id="加载纹理"><a href="#加载纹理" class="headerlink" title="加载纹理"></a>加载纹理</h4><ul>
<li><p>纹理的格式：png，jpg，tga等</p>
</li>
<li><p>加载纹理的库：stb_image.h</p>
</li>
<li><p>加载木箱图片：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> width, height, nrChannels;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *data = stbi_load(<span class="string">&quot;container.jpg&quot;</span>, &amp;width, &amp;height, &amp;nrChannels, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 纹理图像的宽度、高度和颜色通道的个数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>释放内存：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stbi_image_free(data);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="生成纹理"><a href="#生成纹理" class="headerlink" title="生成纹理"></a>生成纹理</h4><ul>
<li><p>opengl中对纹理对象也是用一个id引用</p>
</li>
<li><p>生成和绑定纹理对象：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> texture;</span><br><span class="line"><span class="comment">// 生成纹理的数量 1</span></span><br><span class="line">glGenTextures(<span class="number">1</span>, &amp;texture);</span><br><span class="line"><span class="comment">// 绑定纹理对象</span></span><br><span class="line">glBindTexture(GL_TEXTURE_2D, texture);</span><br></pre></td></tr></table></figure>
</li>
<li><p>为纹理对象附加上纹理图像：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 附加纹理图像数据，指定多级渐远纹理为基本级别</span></span><br><span class="line">glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data);</span><br><span class="line"><span class="comment">// 生成所有需要的多级渐远纹理</span></span><br><span class="line">glGenerateMipmap(GL_TEXTURE_2D);</span><br></pre></td></tr></table></figure>

<ul>
<li>glTexImage2D函数<ul>
<li>第一个参数指定了纹理目标(Target)</li>
<li>第二个参数为纹理指定多级渐远纹理的级别，0为基本级别</li>
<li>第三个参数告诉OpenGL我们希望把纹理储存为何种格式</li>
<li>第四个和第五个参数设置最终的纹理的宽度和高度</li>
<li>第六个参数设为0就行</li>
<li>第七第八个参数定义了源图的格式和数据类型</li>
<li>第九个参数是是真正的图像数据</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="大致使用过程"><a href="#大致使用过程" class="headerlink" title="大致使用过程"></a>大致使用过程</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> texture;</span><br><span class="line">glGenTextures(<span class="number">1</span>, &amp;texture);</span><br><span class="line">glBindTexture(GL_TEXTURE_2D, texture);</span><br><span class="line"><span class="comment">// 为当前绑定的纹理对象设置环绕、过滤方式</span></span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);   </span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line"><span class="comment">// 加载并生成纹理</span></span><br><span class="line"><span class="type">int</span> width, height, nrChannels;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *data = stbi_load(<span class="string">&quot;container.jpg&quot;</span>, &amp;width, &amp;height, &amp;nrChannels, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (data)</span><br><span class="line">&#123;</span><br><span class="line">    glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data);</span><br><span class="line">    glGenerateMipmap(GL_TEXTURE_2D);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Failed to load texture&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">stbi_image_free(data);</span><br></pre></td></tr></table></figure>



<h3 id="实操：应用纹理"><a href="#实操：应用纹理" class="headerlink" title="实操：应用纹理"></a>实操：应用纹理</h3><p>更新顶点属性格式</p>
<ul>
<li><p><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240331150944358.png" alt="image-20240331150944358"></p>
</li>
<li><pre><code class="c">    // 位置属性
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);
    glEnableVertexAttribArray(0);

    // 颜色属性
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));
    glEnableVertexAttribArray(1);

    // 纹理属性
    glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));
    glEnableVertexAttribArray(2);
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 顶点着色器</span><br><span class="line"></span><br><span class="line">  ```glsl</span><br><span class="line">  #version 330 core</span><br><span class="line">  layout (location = 0) in vec3 aPos;</span><br><span class="line">  layout (location = 1) in vec3 aColor;</span><br><span class="line">  layout (location = 2) in vec2 aTexCoord;</span><br><span class="line">  </span><br><span class="line">  out vec3 ourColor;</span><br><span class="line">  out vec2 TexCoord;</span><br><span class="line">  </span><br><span class="line">  void main()</span><br><span class="line">  &#123;</span><br><span class="line">      gl_Position = vec4(aPos, 1.0);</span><br><span class="line">      ourColor = aColor;</span><br><span class="line">      TexCoord = aTexCoord;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>片段着色器</p>
<ul>
<li>片段着色器可以访问纹理对象，通过<code>uniform sampler2D</code> 变，此外还有sampler1D、sampler3D</li>
<li>GLSL有一个供纹理对象使用的内建数据类型，叫做采样器(Sampler)，以纹理类型作为后缀(1D,2D,3D)</li>
<li>GLSL内建的<code>texture函数</code>：采样纹理的颜色<ul>
<li>第一个参数是纹理采样器sampler</li>
<li>第二个参数是对应的纹理坐标</li>
</ul>
</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> ourColor;</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec2</span> TexCoord;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> ourTexture;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    FragColor = <span class="built_in">texture</span>(ourTexture, TexCoord);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>应用层代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 生成和绑定纹理对象</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> texture;</span><br><span class="line">   glGenTextures(<span class="number">1</span>, &amp;texture);</span><br><span class="line">   glBindTexture(GL_TEXTURE_2D, texture);</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 载入纹理数据</span></span><br><span class="line">   <span class="type">int</span> width, height, nrChannels;</span><br><span class="line">   <span class="type">unsigned</span> <span class="type">char</span>* data = stbi_load(<span class="string">&quot;resource/container.jpg&quot;</span>, &amp;width, &amp;height, &amp;nrChannels, <span class="number">0</span>);</span><br><span class="line">   <span class="keyword">if</span> (data)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">// 将纹理数据加载到纹理对象</span></span><br><span class="line">       glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data);</span><br><span class="line">       glGenerateMipmap(GL_TEXTURE_2D);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Failed to load texture&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   stbi_image_free(data);</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">while</span>(xxx) &#123;</span><br><span class="line">	...</span><br><span class="line">  </span><br><span class="line">       glBindTexture(GL_TEXTURE_2D, texture);</span><br><span class="line">       glBindVertexArray(VAO);</span><br><span class="line">       glDrawElements(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">   	...</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="纹理单元"><a href="#纹理单元" class="headerlink" title="纹理单元"></a>纹理单元</h3><ul>
<li>使用<code>glUniform1i</code>为纹理采样器sampler分配一个位置值</li>
<li>为多个sampler分配多个位置值，我们能够在一个片段着色器中设置多个纹理</li>
<li>一个纹理的位置值通常称为一个纹理单元(Texture Unit)</li>
</ul>
<p>使用：</p>
<ul>
<li><p>首先激活纹理单元</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glActiveTexture(GL_TEXTURE0); <span class="comment">// 在绑定纹理之前先激活纹理单元</span></span><br><span class="line"></span><br><span class="line">glBindTexture(GL_TEXTURE_2D, texture); <span class="comment">// glBindTexture函数调用会绑定这个纹理到当前激活的纹理单元</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>纹理单元GL_TEXTURE0默认总是被激活</p>
</li>
</ul>
<blockquote>
<ul>
<li><p>OpenGL至少保证有16个纹理单元供你使用，也就是说你可以激活从GL_TEXTURE0到GL_TEXTRUE15。</p>
</li>
<li><p>它们都是按顺序定义的，所以我们也可以通过GL_TEXTURE0 + 8的方式获得GL_TEXTURE8，这在当我们需要循环一些纹理单元的时候会很有用。</p>
</li>
</ul>
</blockquote>
<ul>
<li><p>增加片段着色器中的纹理采样器</p>
<ul>
<li>GLSL内建的mix函数：接受两个值作为参数，并对它们根据第三个参数进行线性插值</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> texture1;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> texture2;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    FragColor = <span class="built_in">mix</span>(<span class="built_in">texture</span>(texture1, TexCoord), <span class="built_in">texture</span>(texture2, TexCoord), <span class="number">0.2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>更新用户层代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 激活两个纹理单元</span></span><br><span class="line">glActiveTexture(GL_TEXTURE0);</span><br><span class="line">glActiveTexture(GL_TEXTURE1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定两个纹理到对应的纹理单元</span></span><br><span class="line">glBindTexture(GL_TEXTURE_2D, texture1);</span><br><span class="line">glBindTexture(GL_TEXTURE_2D, texture2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后定义哪个uniform采样器对应哪个纹理单元</span></span><br><span class="line">shader.use();</span><br><span class="line">shader.setInt(<span class="string">&quot;texture1&quot;</span>, <span class="number">0</span>);</span><br><span class="line">shader.setInt(<span class="string">&quot;texture2&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(...) &#123;</span><br><span class="line">    ...</span><br><span class="line">    glBindVertexArray(VAO);</span><br><span class="line">    glDrawElements(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>注意：</p>
<p>PNG的颜色通道为RGBA，JPG的颜色通道为RGB</p>
<ul>
<li>映射图片数据到纹理对象时注意</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">glBindTexture(GL_TEXTURE_2D, texture1);</span><br><span class="line">...</span><br><span class="line">glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data);</span><br><span class="line"></span><br><span class="line">glBindTexture(GL_TEXTURE_2D, texture2);</span><br><span class="line">...</span><br><span class="line"> glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGBA, width2, height2, <span class="number">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, data2);</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="三、变换"><a href="#三、变换" class="headerlink" title="三、变换"></a>三、变换</h2><p>改变顶点位置的两个思路：</p>
<ul>
<li>一（改变输入）：在应用层改变传给OpenGL的顶点数据，以及重新绑定顶点相关对象。<ul>
<li>效率低</li>
</ul>
</li>
<li>二（变换）：传入的顶点数据不变。在应用层计算变换矩阵，传给着色器。在着色器计算顶点的新位置。</li>
</ul>
<h3 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h3><p>概念：</p>
<ul>
<li><p>表示一个方向</p>
</li>
<li><p>包含：方向(Direction)和大小(Magnitude，也叫做强度或长度)</p>
</li>
<li><p>习惯上，在字母上面加一横表示向量</p>
</li>
<li><p>位置向量(Position Vector)：指定向量起点（一般是原点），则可以表示一个位置</p>
</li>
</ul>
<p>运算：</p>
<ul>
<li><p>与标量(Scalar)</p>
<ul>
<li><p><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240401151350661.png" alt="image-20240401151350661"></p>
</li>
<li><blockquote>
<p>数学上是没有向量与标量相加这个运算的</p>
</blockquote>
</li>
</ul>
</li>
<li><p>取反(Negate)</p>
</li>
<li><p>加减</p>
</li>
<li><p>长度</p>
</li>
<li><p>标准化（得到单位向量，单位向量头上有一个^）</p>
</li>
<li><p>相乘：</p>
<ul>
<li>点乘<ul>
<li><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240401151736967.png" alt="image-20240401151736967"></li>
<li><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240401152036509.png" alt="image-20240401152036509"></li>
<li>求夹角余弦值</li>
<li>判断正交、平行</li>
</ul>
</li>
<li>叉乘<ul>
<li>叉乘只在3D空间中有定义，它需要两个不平行向量作为输入，生成一个正交于两个输入向量的第三个向量。</li>
<li><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240401152147432.png" alt="image-20240401152147432"></li>
<li>已知两个轴，求3D坐标系中的第三个轴</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><ul>
<li><p>与标量的加减</p>
<ul>
<li><p><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240401152432621.png" alt="image-20240401152432621"></p>
</li>
<li><blockquote>
<p>数学上是没有矩阵与标量相加减的运算的，但是很多线性代数的库都对它有支持</p>
</blockquote>
</li>
</ul>
</li>
<li><p>矩阵加减</p>
<ul>
<li><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240401152516356.png" alt="image-20240401152516356"></li>
</ul>
</li>
<li><p>矩阵数乘</p>
<ul>
<li><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240401152544583.png" alt="image-20240401152544583"></li>
</ul>
</li>
<li><p>矩阵相乘</p>
<ul>
<li><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240401152648582.png" alt="image-20240401152648582"></li>
<li>只有当左侧矩阵的列数与右侧矩阵的行数相等，两个矩阵才能相乘。</li>
<li>矩阵相乘不遵守交换律(Commutative)</li>
</ul>
</li>
<li><p>单位矩阵</p>
<ul>
<li><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240401153125352.png" alt="image-20240401153125352"></li>
</ul>
</li>
</ul>
<blockquote>
<p>单位矩阵通常是生成其他变换矩阵的起点，如果我们深挖线性代数，这还是一个对证明定理、解线性方程非常有用的矩阵。</p>
</blockquote>
<h3 id="在变换中的应用"><a href="#在变换中的应用" class="headerlink" title="在变换中的应用"></a>在变换中的应用</h3><ul>
<li><p>向量可以拿来表示位置，方向，颜色，甚至是纹理坐标。</p>
</li>
<li><p>正巧，很多有趣的2D&#x2F;3D变换都可以放在一个矩阵中。</p>
</li>
<li><p>用这个矩阵乘以我们的向量将<strong>变换</strong>(Transform)这个向量。</p>
</li>
</ul>
<h4 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h4><p>分为</p>
<ul>
<li>不均匀(Non-uniform)缩放</li>
<li>均匀缩放(Uniform Scale)</li>
</ul>
<p><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240401153415065.png" alt="image-20240401153415065"></p>
<h4 id="位移"><a href="#位移" class="headerlink" title="位移"></a>位移</h4><p>位移(Translation)是在原始向量的基础上加上另一个向量从而获得一个在不同位置的新向量的过程。</p>
<p><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240401153501671.png" alt="image-20240401153501671"></p>
<blockquote>
<p><strong>齐次坐标(Homogeneous Coordinates)</strong></p>
<p>向量的w分量也叫齐次坐标。想要从齐次向量得到3D向量，我们可以把x、y和z坐标分别除以w坐标。我们通常不会注意这个问题，因为w分量通常是1.0。</p>
<p>使用齐次坐标有几点好处：它允许我们在3D向量上进行位移（如果没有w分量我们是不能位移向量的），而且下一章我们会用w值创建3D视觉效果。</p>
<p>如果一个向量的齐次坐标是0，这个坐标就是方向向量(Direction Vector)，因为w坐标是0，这个向量就不能位移（译注：这也就是我们说的不能位移一个方向）。</p>
<p>齐次坐标非0的是位置向量。</p>
</blockquote>
<h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><ul>
<li>度量：角度制（180）或弧度制（PI）</li>
<li>在3D空间中旋转需要定义一个角<strong>和</strong>一个旋转轴(Rotation Axis)<ul>
<li>沿坐标轴旋转<ul>
<li><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240401154232617.png" alt="image-20240401154232617"></li>
<li>可以组合几次沿坐标轴的旋转</li>
<li>但是会出现<code>万向节死锁</code></li>
</ul>
</li>
<li>沿任意轴旋转<ul>
<li>（Rx，Ry，Rz）表示旋转轴</li>
<li><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240401154423576.png" alt="image-20240401154423576"></li>
<li>仍存在万向节死锁</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>上面都是基于<code>欧拉角</code>的旋转，存在万向节死锁的问题。</p>
<p>还有一种方案是基于 <code>四元数</code> 。</p>
</blockquote>
<h4 id="矩阵组合"><a href="#矩阵组合" class="headerlink" title="矩阵组合"></a>矩阵组合</h4><ul>
<li>注意矩阵乘法是没有交换率的，即变换的结果跟变换的顺序是有关的。</li>
<li>建议：先进行缩放操作，然后是旋转，最后才是位移，否则它们会（消极地）互相影响</li>
</ul>
<p><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240401155222918.png" alt="image-20240401155222918"></p>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><h4 id="库"><a href="#库" class="headerlink" title="库"></a>库</h4><ul>
<li>数学库：GLM</li>
</ul>
<blockquote>
<p>GLM 0.9.9之后的版本中，矩阵的默认初始化为零矩阵，而非之前的单位矩阵。</p>
<p>使用<code>glm::mat4 mat = glm::mat4(1.0f)</code>可以初始化单位矩阵。</p>
</blockquote>
<ul>
<li>用到的头文件</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/gtc/matrix_transform.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/gtc/type_ptr.hpp&gt;</span></span></span><br></pre></td></tr></table></figure>



<h4 id="矩阵构造"><a href="#矩阵构造" class="headerlink" title="矩阵构造"></a>矩阵构造</h4><ul>
<li><p>案例一：构造一个位移矩阵，并应用到一个向量上</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">glm::vec4 <span class="title function_">vec</span><span class="params">(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>)</span>;</span><br><span class="line"><span class="comment">// 译注：下面就是矩阵初始化的一个例子，如果使用的是0.9.9及以上版本</span></span><br><span class="line"><span class="comment">// 下面这行代码就需要改为:</span></span><br><span class="line"><span class="comment">// glm::mat4 trans = glm::mat4(1.0f)</span></span><br><span class="line"><span class="comment">// 之后将不再进行提示</span></span><br><span class="line">glm::mat4 trans;</span><br><span class="line">trans = glm::translate(trans, glm::vec3(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">vec = trans * vec;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; vec.x &lt;&lt; vec.y &lt;&lt; vec.z &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>案例二：构造一个先缩放后旋转的变换矩阵</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 trans;</span><br><span class="line">trans = glm::rotate(trans, glm::radians(<span class="number">90.0f</span>), glm::vec3(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>));</span><br><span class="line">trans = glm::scale(trans, glm::vec3(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先，我们把箱子在每个轴都缩放到0.5倍，然后沿z轴旋转90度。GLM希望它的角度是弧度制的(Radian)，所以我们使用glm::radians将角度转化为弧度。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="将矩阵传递给着色器"><a href="#将矩阵传递给着色器" class="headerlink" title="将矩阵传递给着色器"></a>将矩阵传递给着色器</h4><p>顶点着色器</p>
<ul>
<li><p>glsl中的 mat4 类型</p>
</li>
<li><p>uniform 变量</p>
</li>
<li><pre><code class="glsl">#version 330 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec2 aTexCoord;

out vec2 TexCoord;

uniform mat4 transform;

void main()
&#123;
    gl_Position = transform * vec4(aPos, 1.0f);
    TexCoord = vec2(aTexCoord.x, 1.0 - aTexCoord.y);
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">传入着色器程序对象</span><br><span class="line"></span><br><span class="line">- ```c</span><br><span class="line">  unsigned int transformLoc = glGetUniformLocation(ourShader.ID, &quot;transform&quot;);</span><br><span class="line">  glUniformMatrix4fv(transformLoc, 1, GL_FALSE, glm::value_ptr(trans));</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>我们首先查询uniform变量的地址，然后用有<code>Matrix4fv</code>后缀的glUniform函数把矩阵数据发送给着色器。第一个参数你现在应该很熟悉了，它是uniform的位置值。第二个参数告诉OpenGL我们将要发送多少个矩阵，这里是1。第三个参数询问我们是否希望对我们的矩阵进行转置(Transpose)，也就是说交换我们矩阵的行和列。OpenGL开发者通常使用一种内部矩阵布局，叫做列主序(Column-major Ordering)布局。GLM的默认布局就是列主序，所以并不需要转置矩阵，我们填<code>GL_FALSE</code>。最后一个参数是真正的矩阵数据，但是GLM并不是把它们的矩阵储存为OpenGL所希望接受的那种，因此我们要先用GLM的自带的函数value_ptr来变换这些数据。</p>
</li>
</ul>
<h2 id="四、坐标系统"><a href="#四、坐标系统" class="headerlink" title="四、坐标系统"></a>四、坐标系统</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="坐标空间"><a href="#坐标空间" class="headerlink" title="坐标空间"></a>坐标空间</h4><p>OpenGL希望在每次顶点着色器运行后，我们可见的所有顶点都为<code>标准化设备坐标</code>(Normalized Device Coordinate, NDC)。</p>
<ul>
<li>即顶点着色器输出的<code>gl_position</code>是在<code>标准化设备坐标系</code>下的坐标</li>
<li>每个顶点的<strong>x</strong>，<strong>y</strong>，<strong>z</strong>坐标都应该在**-1.0<strong>到</strong>1.0**之间，超出这个坐标范围的顶点都将不可见</li>
</ul>
<p>我们通常会自己设定一个坐标的范围，之后再在顶点着色器中将这些坐标变换为标准化设备坐标。</p>
<p>然后将这些标准化设备坐标传入光栅器(Rasterizer)，将它们变换为屏幕上的二维坐标或像素。</p>
<ul>
<li>在顶点从初始坐标系转化到最终的屏幕坐标的过程中，会有经过多种坐标系的过渡转换。</li>
<li>原因是：在特定的坐标系统中，一些操作或运算更加方便和容易<ul>
<li>例如，当需要对物体进行修改的时候，在局部空间中来操作会更说得通；如果要对一个物体做出一个相对于其它物体位置的操作时，在世界坐标系中来做这个才更说得通，等等。</li>
</ul>
</li>
<li>比较重要的5个不同的坐标系：<ul>
<li><strong>局部空间</strong>(Local Space，或者称为物体空间(Object Space))</li>
<li><strong>世界空间</strong>(World Space)</li>
<li><strong>观察空间</strong>(View Space，或者称为视觉空间(Eye Space))</li>
<li><strong>裁剪空间</strong>(Clip Space)</li>
<li><strong>屏幕空间</strong>(Screen Space)</li>
</ul>
</li>
</ul>
<h4 id="坐标空间变换"><a href="#坐标空间变换" class="headerlink" title="坐标空间变换"></a>坐标空间变换</h4><p>将坐标从一个坐标系变换到另一个坐标系</p>
<ul>
<li>重要的变换矩阵：模型(Model)、观察(View)、投影(Projection)三个矩阵</li>
<li>顶点坐标起始于局部空间(Local Space)，在这里它称为局部坐标(Local Coordinate)，之后会变为世界坐标(World Coordinate)，观察坐标(View Coordinate)，裁剪坐标(Clip Coordinate)，并最后以屏幕坐标(Screen Coordinate)的形式结束。</li>
</ul>
<p><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240401165205323.png" alt="image-20240401165205323"></p>
<h3 id="局部空间"><a href="#局部空间" class="headerlink" title="局部空间"></a>局部空间</h3><p>指物体所在的坐标空间，物体有自己的一个原点位置。</p>
<p>物体&#x2F;模型的所有顶点的位置是相对于模型自身的局部空间的原点来说的。</p>
<h3 id="世界空间"><a href="#世界空间" class="headerlink" title="世界空间"></a>世界空间</h3><p>容纳多个物体的世界，采用一个共同的原点和一套坐标轴。</p>
<p>物体在世界空间中的坐标即物体相对于世界原点的坐标。</p>
<blockquote>
<p>物体的顶点的坐标从局部空间到世界空间的转换 —— 模型转换</p>
<ul>
<li>用到的变换矩阵称为 模型矩阵</li>
<li>包含 缩放、旋转、位移 操作</li>
</ul>
<p>通过物体的局部坐标系和世界坐标系的相对关系来求。</p>
</blockquote>
<h3 id="观察空间"><a href="#观察空间" class="headerlink" title="观察空间"></a>观察空间</h3><p>基于眼睛或摄像机的空间，即以摄像机的位置为原点，基于摄像机的朝向建立坐标轴的空间。</p>
<blockquote>
<p>物体的顶点的坐标从世界空间到相机空间的转换 —— 观察转换</p>
<ul>
<li>用到的变换矩阵称为 观察矩阵</li>
<li>包含 旋转、位移 操作</li>
</ul>
<p>摄像机在世界空间中会有一个位置，根据世界坐标系和相机坐标系的相对关系来建立变换矩阵 —— 观察矩阵</p>
</blockquote>
<h3 id="裁剪空间"><a href="#裁剪空间" class="headerlink" title="裁剪空间"></a>裁剪空间</h3><p>在一个顶点着色器运行的最后，OpenGL期望所有的坐标都能落在一个特定的范围内，且任何在这个范围之外的点都应该被裁剪掉(Clipped)。</p>
<ul>
<li><p>从观察空间（特定范围内）变换到裁剪空间，称为 投影变换；</p>
</li>
<li><p>用到的变换矩阵称为 投影矩阵；</p>
</li>
<li><p>从观察空间的某个坐标范围内，变换到（-1，1）的范围，范围外的坐标会被裁剪掉。</p>
</li>
<li><p>变换到裁剪空间之后，顶点着色器最后会自动进行 <code>透视除法</code></p>
<ul>
<li>在这个过程中我们将位置向量的x，y，z分量分别除以向量的齐次w分量</li>
<li>将4D裁剪空间坐标变换为3D标准化设备坐标</li>
</ul>
</li>
</ul>
<blockquote>
<p>如果只是图元(Primitive)(例如三角形)的一部分超出了裁剪体积(Clipping Volume)，则OpenGL会重新构建这个三角形为一个或多个三角形让其能够适合这个裁剪范围。</p>
</blockquote>
<p>投影变换是如何进行的？</p>
<ul>
<li>需要先定义观察范围，即摄像机的观察范围，又称为<code>观察箱</code>或<code>平戳头体 Frustum</code></li>
<li>两种平戳头体：<ul>
<li>正交</li>
<li>透视</li>
</ul>
</li>
<li>对应的，有两种投影矩阵需要计算</li>
</ul>
<h4 id="正射-x2F-正交投影"><a href="#正射-x2F-正交投影" class="headerlink" title="正射&#x2F;正交投影"></a>正射&#x2F;正交投影</h4><ul>
<li>正射投影矩阵定义了一个类似立方体的平截头箱，它定义了一个裁剪空间，在这空间之外的顶点都会被裁剪掉。</li>
<li>需要指定可见平截头体的<code>宽、高和近(Near)平面和远(Far)平面</code></li>
</ul>
<p><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240401174839859.png" alt="image-20240401174839859"></p>
<ul>
<li>任何出现在近平面之前或远平面之后的坐标都会被裁剪掉</li>
<li>正射平截头体直接将平截头体内部的所有坐标映射为标准化设备坐标，因为每个向量的w分量都没有进行改变</li>
<li>如果w分量等于1.0，透视除法则不会改变这个坐标。</li>
</ul>
<p>使用glm库创建正射投影矩阵</p>
<ul>
<li>这个投影矩阵会将处于这些x，y，z值范围内的坐标变换为标准化设备坐标。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glm::ortho(<span class="number">0.0f</span>, <span class="number">800.0f</span>, <span class="number">0.0f</span>, <span class="number">600.0f</span>, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br><span class="line"><span class="comment">// 前两个参数指定了平截头体的左右坐标，第三和第四参数指定了平截头体的底部和顶部。</span></span><br><span class="line"><span class="comment">// 第五和第六个参数则定义了近平面和远平面的距离。</span></span><br></pre></td></tr></table></figure>



<h4 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h4><p>近大远小</p>
<ul>
<li><p>透视投影矩阵除了将给定的平截头体范围映射到裁剪空间，还修改了每个顶点坐标的w值，从而使得离观察者越远的顶点坐标w分量越大。</p>
</li>
<li><p>被变换到裁剪空间的坐标都会在-w到w的范围之间（任何大于这个范围的坐标都会被裁剪掉）。</p>
</li>
</ul>
<p>在变换到裁剪空间后，需要进行透视除法，以便能够得到最后的归一化设备坐标</p>
<p><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240401175607210.png" alt="image-20240401175607210"></p>
<p>顶点坐标的每个分量都会除以它的w分量，距离观察者越远顶点坐标就会越小。</p>
<p>这是也是w分量非常重要的另一个原因，它能够帮助我们进行透视投影。</p>
<p>在GLM中创建透视投影矩阵：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 proj = glm::perspective(glm::radians(<span class="number">45.0f</span>), (<span class="type">float</span>)width/(<span class="type">float</span>)height, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br></pre></td></tr></table></figure>

<p>透视平戳头体的定义：</p>
<ul>
<li>视角 FOV</li>
<li>宽高比</li>
<li>远&#x2F;近平面与摄像机的距离</li>
</ul>
<p><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240401175851375.png" alt="image-20240401175851375"></p>
<blockquote>
<p>正射投影主要用于二维渲染以及一些建筑或工程的程序，在这些场景中我们更希望顶点不会被透视所干扰。</p>
<p>某些如 <em>Blender</em> 等进行三维建模的软件有时在建模时也会使用正射投影，因为它在各个维度下都更准确地描绘了每个物体。</p>
<p><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240401180518844.png" alt="image-20240401180518844"></p>
</blockquote>
<h3 id="屏幕空间"><a href="#屏幕空间" class="headerlink" title="屏幕空间"></a>屏幕空间</h3><p>前面的空间变换，组合起来就是：</p>
<p><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240401181028777.png" alt="image-20240401181028777"></p>
<p>此时得到的是裁剪空间下的坐标（即在顶点着色器中传给gl_position的坐标）</p>
<ul>
<li>OpenGL会自己进行透视除法和裁剪</li>
<li>最后就得到了标准化设备坐标。</li>
</ul>
<h4 id="视口变换"><a href="#视口变换" class="headerlink" title="视口变换"></a>视口变换</h4><ul>
<li>标准化设备坐标 到 屏幕坐标</li>
</ul>
<p>有了屏幕大小信息，就可以将标准化设备坐标映射到屏幕坐标，与屏幕的一个像素一一对应。</p>
<h3 id="实操一"><a href="#实操一" class="headerlink" title="实操一"></a>实操一</h3><p>目标效果</p>
<p><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240401194035654.png" alt="image-20240401194035654"></p>
<ul>
<li><p>首先，顶点的模型坐标就是最初的顶点位置信息</p>
</li>
<li><p>然后，定义模型在世界中的坐标&#x2F;旋转&#x2F;缩放</p>
<ul>
<li><p>构建 模型矩阵 （需要自己计算）</p>
<ul>
<li><p>假设：该模型是在世界空间中原点的位置，并绕x轴旋转一定度数</p>
</li>
<li><p>&#96;&#96;&#96;c<br>glm::mat4 model;<br>model &#x3D; glm::rotate(model, glm::radians(-55.0f), glm::vec3(1.0f, 0.0f, 0.0f));</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 然后，定义摄像机的位置和朝向</span><br><span class="line"></span><br><span class="line">  - 构建观察矩阵 （同样需要自己计算）</span><br><span class="line"></span><br><span class="line">    - 摄像机一开始在世界空间的原点处</span><br><span class="line"></span><br><span class="line">      - 那么将摄像机移动到世界空间中的指定位置，相当于反过来将其他物体的按相反的方式移动。</span><br><span class="line">      - 透视矩阵做的就是，按这个相反的操作移动整个场景</span><br><span class="line"></span><br><span class="line">    - 假设：摄像机在z轴正向上的某个位置</span><br><span class="line"></span><br><span class="line">    - ```c</span><br><span class="line">      glm::mat4 view;</span><br><span class="line">      // 注意，我们将矩阵向我们要进行移动场景的反方向移动。</span><br><span class="line">      view = glm::translate(view, glm::vec3(0.0f, 0.0f, -3.0f));</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>然后，确定投影类型</p>
<ul>
<li><p>计算投影矩阵（正交和透视两种，确定平戳头体的参数即可）</p>
</li>
<li><p>以透视投影为例：</p>
<ul>
<li>&#96;&#96;&#96;c<br>glm::mat4 projection;<br>projection &#x3D; glm::perspective(glm::radians(45.0f), screenWidth &#x2F; screenHeight, 0.1f, 100.0f);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 将所有变换矩阵传给顶点着色器</span><br><span class="line"></span><br><span class="line">  - ```glsl</span><br><span class="line">    #version 330 core</span><br><span class="line">    layout (location = 0) in vec3 aPos;</span><br><span class="line">    ...</span><br><span class="line">    uniform mat4 model;</span><br><span class="line">    uniform mat4 view;</span><br><span class="line">    uniform mat4 projection;</span><br><span class="line">    </span><br><span class="line">    void main()</span><br><span class="line">    &#123;</span><br><span class="line">        // 注意乘法要从右向左读</span><br><span class="line">        gl_Position = projection * view * model * vec4(aPos, 1.0);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>传入变换矩阵（这通常在每次的渲染迭代中进行，因为变换矩阵会经常变动）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> modelLoc = glGetUniformLocation(ourShader.ID, <span class="string">&quot;model&quot;</span>));</span><br><span class="line">glUniformMatrix4fv(modelLoc, <span class="number">1</span>, GL_FALSE, glm::value_ptr(model));</span><br><span class="line">... <span class="comment">// 观察矩阵和投影矩阵与之类似</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>右手坐标系(Right-handed System)</strong></p>
<p><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240401184027481.png" alt="image-20240401184027481"></p>
<ul>
<li>OpenGL使用的是右手系</li>
<li>DirectX使用的是左手系</li>
</ul>
</blockquote>
<h3 id="实操二"><a href="#实操二" class="headerlink" title="实操二"></a>实操二</h3><p>渲染一个立方体</p>
<ul>
<li><p>顶点属性</p>
<ul>
<li>不使用EBO&#x2F;IBO了，直接使用VBO，即<code>glDrawArrays</code></li>
<li>移除了颜色属性，即仅剩位置属性和纹理坐标属性（需要更新<code>顶点属性指针</code></li>
<li>代码就不贴上来了</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>效果（未做深度测试）<br><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240401195047440.png" alt="image-20240401195047440"></p>
</li>
</ul>
<h3 id="实操三"><a href="#实操三" class="headerlink" title="实操三"></a>实操三</h3><ul>
<li><p>在二的基础上，加上深度测试，以显示正确的遮挡关系</p>
</li>
<li><p>OpenGL会维护 Z-buffer 即深度缓冲，结合片段的深度值，在渲染时可以判断哪些片段应该被显示在前面。</p>
</li>
<li><p>深度值存储在每个片段里面（作为片段的<strong>z</strong>值），当片段想要输出它的颜色时，OpenGL会将它的深度值和z缓冲进行比较，如果当前的片段在其它片段之后，它将会被丢弃，否则将会覆盖。这个过程称为深度测试(Depth Testing)，它是由OpenGL自动完成的。</p>
</li>
<li><p>启用深度测试：</p>
<ul>
<li>&#96;&#96;&#96;c<br>glEnable(GL_DEPTH_TEST);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 在每一帧开始时，清楚深度缓冲</span><br><span class="line"></span><br><span class="line">  - ```c</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>效果<br><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240401200809266.png" alt="image-20240401200809266"></p>
</li>
</ul>
<h3 id="实操四"><a href="#实操四" class="headerlink" title="实操四"></a>实操四</h3><ul>
<li>绘制更多立方体</li>
<li>区别在于它们在世界的位置及旋转角度不同。</li>
<li>当渲染更多物体的时候我们不需要改变我们的缓冲数组和属性数组，我们唯一需要做的只是改变每个对象的模型矩阵来将立方体变换到世界坐标系中。</li>
</ul>
<p>代码：</p>
<ul>
<li><p>各个物体的位置信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 cubePositions[] = &#123;</span><br><span class="line">  glm::vec3( <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>), </span><br><span class="line">  glm::vec3( <span class="number">2.0f</span>,  <span class="number">5.0f</span>, <span class="number">-15.0f</span>), </span><br><span class="line">  glm::vec3(<span class="number">-1.5f</span>, <span class="number">-2.2f</span>, <span class="number">-2.5f</span>),  </span><br><span class="line">  glm::vec3(<span class="number">-3.8f</span>, <span class="number">-2.0f</span>, <span class="number">-12.3f</span>),  </span><br><span class="line">  glm::vec3( <span class="number">2.4f</span>, <span class="number">-0.4f</span>, <span class="number">-3.5f</span>),  </span><br><span class="line">  glm::vec3(<span class="number">-1.7f</span>,  <span class="number">3.0f</span>, <span class="number">-7.5f</span>),  </span><br><span class="line">  glm::vec3( <span class="number">1.3f</span>, <span class="number">-2.0f</span>, <span class="number">-2.5f</span>),  </span><br><span class="line">  glm::vec3( <span class="number">1.5f</span>,  <span class="number">2.0f</span>, <span class="number">-2.5f</span>), </span><br><span class="line">  glm::vec3( <span class="number">1.5f</span>,  <span class="number">0.2f</span>, <span class="number">-1.5f</span>), </span><br><span class="line">  glm::vec3(<span class="number">-1.3f</span>,  <span class="number">1.0f</span>, <span class="number">-1.5f</span>)  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在渲染循环中，通过改变变换矩阵来渲染同一个模型，以达到渲染多个物体的效果</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">glBindVertexArray(VAO);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">  glm::mat4 model;</span><br><span class="line">  model = glm::translate(model, cubePositions[i]);</span><br><span class="line">  <span class="type">float</span> angle = <span class="number">20.0f</span> * i; </span><br><span class="line">  model = glm::rotate(model, glm::radians(angle), glm::vec3(<span class="number">1.0f</span>, <span class="number">0.3f</span>, <span class="number">0.5f</span>));</span><br><span class="line">  ourShader.setMat4(<span class="string">&quot;model&quot;</span>, model);</span><br><span class="line"></span><br><span class="line">  glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>效果<br><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240401201917505.png" alt="image-20240401201917505"></p>
</li>
</ul>
<h2 id="五、摄像机"><a href="#五、摄像机" class="headerlink" title="五、摄像机"></a>五、摄像机</h2><p>OpenGL本身没有<strong>摄像机</strong>(Camera)的概念，但我们可以通过把场景中的所有物体往相反方向移动的方式来模拟出摄像机，产生一种<strong>我们</strong>在移动的感觉，而不是场景在移动。</p>
<h3 id="相机-x2F-观察空间"><a href="#相机-x2F-观察空间" class="headerlink" title="相机&#x2F;观察空间"></a>相机&#x2F;观察空间</h3><p>以摄像机的视角作为场景原点时，场景中所有的顶点坐标：观察矩阵把所有的世界坐标变换为相对于摄像机位置与方向的观察坐标。</p>
<ul>
<li><p>定义一个相机：（在世界空间中）</p>
<ul>
<li><p>位置坐标</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 cameraPos = glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">3.0f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右手系中，z轴正方向 是从屏幕指向你的。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><p>观察方向（相机z轴）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 cameraTarget = glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">glm::vec3 cameraDirection = glm::normalize(cameraPos - cameraTarget);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过两个位置向量相减得到，这里是看向原点。</span></span><br><span class="line"><span class="comment">// 然而，用来表示相机观察方向的 &quot;方向向量&quot; 一般与相机实际观察方向相反。所以这里是用相机位置减去相机看向的目标。</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>右侧方向（相机x轴）</p>
<ul>
<li>需要先定义一个 up 向量，表示世界空间中y轴的方向</li>
<li>将 up向量 和 相机方向向量 进行叉乘，可得相机的右轴（叉乘顺序不能反了——右手螺旋）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 up = glm::vec3(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>); </span><br><span class="line">glm::vec3 cameraRight = glm::normalize(glm::cross(up, cameraDirection));</span><br></pre></td></tr></table></figure>


</li>
<li><p>上方方向（相机y轴）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 cameraUp = glm::cross(cameraDirection, cameraRight);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>基于相机上述信息，可以形成一个新的坐标系</p>
</li>
</ul>
<p><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240401203015989.png" alt="image-20240401203015989"></p>
<h3 id="Look-At-矩阵"><a href="#Look-At-矩阵" class="headerlink" title="Look At 矩阵"></a>Look At 矩阵</h3><ul>
<li><p>如果你使用3个相互垂直（或非线性）的轴定义了一个坐标空间，你可以用这3个轴外加一个平移向量（根据新坐标空间原点相对原坐标空间的位置）来创建一个矩阵</p>
</li>
<li><p>这个矩阵乘以任何向量，可以将其变换到新的坐标空间</p>
</li>
</ul>
<p><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240401204810640.png" alt="image-20240401204810640"></p>
<ul>
<li>其中R是右向量，U是上向量，D是方向向量，P是摄像机位置向量。</li>
</ul>
<p>把这个 LookAt矩阵 作为 观察矩阵 可以很高效地把所有世界坐标变换到刚刚定义的观察空间。</p>
<p>也即，对于某摄像机，观察变换使用的观察矩阵 就是该摄像机的 Look At 矩阵</p>
<p>在GLM中，可以直接定义LookAt矩阵:</p>
<ul>
<li>glm::LookAt函数需要一个相机位置、观察目标和上向量。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 view;</span><br><span class="line">view = glm::lookAt(glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">3.0f</span>), </span><br><span class="line">           glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>), </span><br><span class="line">           glm::vec3(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br></pre></td></tr></table></figure>



<h3 id="实操一-1"><a href="#实操一-1" class="headerlink" title="实操一"></a>实操一</h3><p>假设：观察目标保持为世界原点，而摄像机绕着原点在场景中旋转。</p>
<ul>
<li>用sin,cos函数设置相机的x,z坐标即可，并使用LookAt矩阵作为观察矩阵</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> radius = <span class="number">10.0f</span>;</span><br><span class="line"><span class="type">float</span> camX = <span class="built_in">sin</span>(glfwGetTime()) * radius;</span><br><span class="line"><span class="type">float</span> camZ = <span class="built_in">cos</span>(glfwGetTime()) * radius;</span><br><span class="line">glm::mat4 view;</span><br><span class="line">view = glm::lookAt(glm::vec3(camX, <span class="number">0.0</span>, camZ), glm::vec3(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>), glm::vec3(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>)); </span><br></pre></td></tr></table></figure>



<p><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240401205923860.png" alt="image-20240401205923860"></p>
<h3 id="实操二-1"><a href="#实操二-1" class="headerlink" title="实操二"></a>实操二</h3><p>实现一个相机系统，由用户自主控制摄像机的位置、朝向、缩放</p>
<ul>
<li><p>定义好相机的三个信息：</p>
<ul>
<li>位置</li>
<li>方向向量</li>
<li>up向量</li>
</ul>
</li>
<li><p>&#96;&#96;&#96;c<br>glm::vec3 cameraPos   &#x3D; glm::vec3(0.0f, 0.0f,  3.0f);<br>glm::vec3 cameraFront &#x3D; glm::vec3(0.0f, 0.0f, -1.0f);<br>glm::vec3 cameraUp    &#x3D; glm::vec3(0.0f, 1.0f,  0.0f);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 则LookAt函数的参数为</span><br><span class="line"></span><br><span class="line">  ```c</span><br><span class="line">  view = glm::lookAt(cameraPos, cameraPos + cameraFront, cameraUp);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h4><ul>
<li><p>根据键盘输入，修改<code>cameraPos</code></p>
</li>
<li><p>由GLFW获取输入</p>
</li>
<li><p>&#96;&#96;&#96;c<br>void processInput(GLFWwindow *window)<br>{<br>…<br>float cameraSpeed &#x3D; 0.05f; &#x2F;&#x2F; adjust accordingly<br>if (glfwGetKey(window, GLFW_KEY_W) &#x3D;&#x3D; GLFW_PRESS)<br>    cameraPos +&#x3D; cameraSpeed * cameraFront;<br>if (glfwGetKey(window, GLFW_KEY_S) &#x3D;&#x3D; GLFW_PRESS)<br>    cameraPos -&#x3D; cameraSpeed * cameraFront;<br>if (glfwGetKey(window, GLFW_KEY_A) &#x3D;&#x3D; GLFW_PRESS)<br>    cameraPos -&#x3D; glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed;<br>if (glfwGetKey(window, GLFW_KEY_D) &#x3D;&#x3D; GLFW_PRESS)<br>    cameraPos +&#x3D; glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed;<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 在封装类的时候，如果相机类的成员变量是glm库中的类型，需要注意拷贝数据的方式可能导致的问题。</span><br><span class="line"></span><br><span class="line">- 平均速度</span><br><span class="line"></span><br><span class="line">  - 渲染帧时间差 Deltatime，储存了渲染上一帧所用的时间</span><br><span class="line">  - 固定速度 * Deltatime 的结果：可以使得在相同的时间内，不同机器上渲染帧数不同的情况下，保持相同的速率</span><br><span class="line"></span><br><span class="line">#### 朝向</span><br><span class="line"></span><br><span class="line">- 用鼠标控制朝向</span><br><span class="line">  - 水平的移动影响偏航角，竖直的移动影响俯仰角。</span><br><span class="line">  - 储存上一帧鼠标的位置，在当前帧中我们当前计算鼠标位置与上一帧的位置相差多少。</span><br><span class="line">-  欧拉角</span><br><span class="line">  - 俯仰角(Pitch)、偏航角(Yaw)和滚转角(Roll)</span><br><span class="line">  -  ![image-20240402000146667](LearnOpenGL摘要（2）/image-20240402000146667.png)</span><br><span class="line"></span><br><span class="line">- 一般对于摄像机来说，只关心俯仰角和偏航角即可，滚筒角用不到</span><br><span class="line"></span><br><span class="line">  - 对于给定的俯仰角和偏航角，我们需要计算出一个方向向量</span><br><span class="line"></span><br><span class="line">  - 引用别人的图：</span><br><span class="line"></span><br><span class="line">    - h为方向向量（长度为1），我们的目标是求这个方向向量的x,y,z分量</span><br><span class="line"></span><br><span class="line">    - 如图可得：</span><br><span class="line"></span><br><span class="line">      - y = sin(pitch)</span><br><span class="line">      - x = cos(pitch) * cos(yaw)</span><br><span class="line">      - z = cos(pitch) * sin(yaw)</span><br><span class="line"></span><br><span class="line">      &lt;img src=&quot;LearnOpenGL摘要（2）/image-20240402010939180.png&quot; alt=&quot;image-20240402010939180&quot; style=&quot;zoom:80%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    - pitch，yaw 都初始化为0的话，则初始朝向 x轴 方向。</span><br><span class="line"></span><br><span class="line">- 编程</span><br><span class="line"></span><br><span class="line">  - FPS风格的鼠标输入和摄像机控制：</span><br><span class="line">    1. 计算鼠标距上一帧的偏移量。</span><br><span class="line">    2. 把偏移量添加到摄像机的俯仰角和偏航角中。</span><br><span class="line">    3. 对偏航角和俯仰角进行最大和最小值的限制。</span><br><span class="line">    4. 计算方向向量。</span><br><span class="line"></span><br><span class="line">  - GLFW鼠标设置：隐藏光标，并捕捉(Capture)鼠标</span><br><span class="line"></span><br><span class="line">    ```c</span><br><span class="line">    glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>监听鼠标移动事件，鼠标移动时，调用回调函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听</span></span><br><span class="line">glfwSetCursorPosCallback(window, mouse_callback);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mouse_callback</span><span class="params">(GLFWwindow* window, <span class="type">double</span> xpos, <span class="type">double</span> ypos)</span> &#123;</span><br><span class="line"> 	<span class="keyword">if</span>(firstMouse)</span><br><span class="line">    &#123;</span><br><span class="line">        lastX = xpos;</span><br><span class="line">        lastY = ypos;</span><br><span class="line">        firstMouse = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> xoffset = xpos - lastX;</span><br><span class="line">    <span class="type">float</span> yoffset = lastY - ypos; </span><br><span class="line">    lastX = xpos;</span><br><span class="line">    lastY = ypos;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> sensitivity = <span class="number">0.05</span>;</span><br><span class="line">    xoffset *= sensitivity;</span><br><span class="line">    yoffset *= sensitivity;</span><br><span class="line"></span><br><span class="line">    yaw   += xoffset;</span><br><span class="line">    pitch += yoffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pitch &gt; <span class="number">89.0f</span>)</span><br><span class="line">        pitch = <span class="number">89.0f</span>;</span><br><span class="line">    <span class="keyword">if</span>(pitch &lt; <span class="number">-89.0f</span>)</span><br><span class="line">        pitch = <span class="number">-89.0f</span>;</span><br><span class="line"></span><br><span class="line">    glm::vec3 front;</span><br><span class="line">    front.x = <span class="built_in">cos</span>(glm::radians(yaw)) * <span class="built_in">cos</span>(glm::radians(pitch));</span><br><span class="line">    front.y = <span class="built_in">sin</span>(glm::radians(pitch));</span><br><span class="line">    front.z = <span class="built_in">sin</span>(glm::radians(yaw)) * <span class="built_in">cos</span>(glm::radians(pitch));</span><br><span class="line">    cameraFront = glm::normalize(front);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="缩放-1"><a href="#缩放-1" class="headerlink" title="缩放"></a>缩放</h4><ul>
<li><p>主要是通过改变透视投影矩阵，即改变透视平戳头体</p>
<ul>
<li>改变FOV的视角：<ul>
<li>缩小视角则投影出的空间变少，可以产生放大的效果</li>
<li>反之则是缩小的效果</li>
</ul>
</li>
<li>限定FOV范围为 1.0f ~ 45.0f</li>
</ul>
</li>
<li><p>鼠标滚轮控制</p>
<ul>
<li><p>回调函数</p>
<ul>
<li>当滚动鼠标滚轮的时候，yoffset值代表我们竖直滚动的大小</li>
<li></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">scroll_callback</span><span class="params">(GLFWwindow* window, <span class="type">double</span> xoffset, <span class="type">double</span> yoffset)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(fov &gt;= <span class="number">1.0f</span> &amp;&amp; fov &lt;= <span class="number">45.0f</span>)</span><br><span class="line">    fov -= yoffset;</span><br><span class="line">  <span class="keyword">if</span>(fov &lt;= <span class="number">1.0f</span>)</span><br><span class="line">    fov = <span class="number">1.0f</span>;</span><br><span class="line">  <span class="keyword">if</span>(fov &gt;= <span class="number">45.0f</span>)</span><br><span class="line">    fov = <span class="number">45.0f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://mang959595.github.io/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OpenGL/" rel="tag">OpenGL</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
    
      <a href="/2024/03/30/LearnOpenGL%E6%91%98%E8%A6%81/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">LearnOpenGL摘要（入门一）</div>
      </a>
    
  </nav>

  
   
    
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022-2024
        <i class="ri-heart-fill heart_icon"></i> FRP
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/123.jpg" alt="b4mang95"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>