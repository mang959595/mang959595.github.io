<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>git简单入门</title>
    <url>/2023/02/12/git%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="Git简单入门"><a href="#Git简单入门" class="headerlink" title="Git简单入门"></a>Git简单入门</h1><p>基本命令</p>
<p>git </p>
<p><img src="/2023/02/12/git%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/image-20230212074446947.png" alt="image-20230212074446947"></p>
<p>更多命令</p>
<p><img src="/2023/02/12/git%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/image-20230212074320214.png" alt="image-20230212074320214"></p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>珍惜时间</title>
    <url>/2023/02/12/%E5%90%B8%E5%8F%96%E6%95%99%E8%AE%AD/</url>
    <content><![CDATA[<p><a href="https://www.bilibili.com/video/BV1YR4y187Dw/?spm_id_from=333.1007.tianma.2-1-4.click&vd_source=c36c31c15822f9e983f85418bfdcddd9">如何欺骗大脑爱上做困难的事 远离超量多巴胺让你沉迷学习</a></p>
<p>现在是2023年2月12日，凌晨1：33…</p>
<p>临近大三下学期开学，目前三线作战，一条线是考试复习，一条线是SRP项目，一条线是实习秋招。感觉时间非常紧张，精神压力也非常大。甚至考试上已经放弃了某一难啃的科目。</p>
<p>那么时间为什么又会如此紧迫？</p>
<br>

<br>

<br>

<p>这里需要展开一场自我反思</p>
<br>

<br>

<br>

<br>

<h2 id="拷打FW"><a href="#拷打FW" class="headerlink" title="拷打FW"></a>拷打FW</h2><h3 id="一事无成"><a href="#一事无成" class="headerlink" title="一事无成"></a>一事无成</h3><p>其实我是很早就了解到大学应该做什么的（可惜不知道具体该如何去做）。在<strong>大一上学期，差不多2020年10月份的时候</strong>，已经有学长指明了三条路：1.竞赛（CTF，ACM…） 2.工作（尽早去实习） 3.绩点科研（搞成绩以及进实验室）</p>
<br>

<p><strong>竞赛：</strong></p>
<p>那时候又刚好听了CTF的讲座，于是心中默认自己以后要走安全路线。可惜我太高估自己了，选择了pwn路线来入门CTF。因为很多前置知识都没学过，也不知道要去学，去哪学，也就没有一个循序渐进的学习过程，所以就学不下去了。</p>
<p>连一点语言基础、操作系统方面的知识都没有，所以看那些什么虚拟地址空间、段、函数引用表等词汇完全没有概念，即使是到网上查资料看视频，也很难消化进去。比起艰难地去理解一些新概念，打游戏实在爽快多了，所以我也就没有学下去了。（现在想想，当时也不太会检索信息）</p>
<br>

<p>到了大二自己还是有一点这方面的想法，也稍微付出了多一点的时间，浅浅地捡了一点东西，去应付招新的事。结果，花的时间和学的东西还是太少了，只能用特殊方式入队。</p>
<p>入队后，又没有驱动力去学了，就一直搁置着，后面也没有参加过一次比赛。</p>
<br>

<p>现在回想，也许我应该选一个简单一点的方向，或者是，学的时候直接从解题入手，边做题边学新概念。在学习过程中，以解出题目作为激励，或许我就能学的下去，从而形成一个良性循环。</p>
<p>不过还是得怪自己太懒了。</p>
<p><br><br></p>
<p><strong>工作：</strong></p>
<p>当时，我默认自己不读研，本科毕业就工作。所以我应该是尽早往工作路线靠拢，但是，那会儿实在是不知道要学什么方向。</p>
<p><strong>开始的开始</strong></p>
<p>真正开始学习计算机之前，也就是中学时期，我因为喜欢玩各种单机游戏，就曾有过日后做一名游戏开发者的想法。在高考完的暑假，我也买了一本C语言的教材。可惜当时并不知道怎么学习这些东西，还按照高中的学习方式，学一点就记一点（比如C语言的关键字还要列出来然后去背…），导致效率很低。于是没学多少就没一点兴趣了（好像也没那么少，可惜没有进度没有推到内存管理和网络编程相的部分）。unity也不知道因为什么始终没有开始学。</p>
<blockquote>
<p>翻看了那时候的笔记，感觉那是高考结束到目前为止，自己最认真学习的一段时间了，泪目啊</p>
<p>好恨啊，如果当时的学习方式对了，后面这几年应该会顺利很多</p>
</blockquote>
<p>又因为中学过得太憋屈了，加上自控力差，高考完的那个暑假就疯狂的玩。当时我对未来十分憧憬、充满动力，然而这些还是没能变成我的自制力。</p>
<br>

<p><strong>路线</strong></p>
<p>到后来，每一年，每一学期，都会更新自己的方向。一会儿是游戏开发，一会儿是Linux C++，一会儿是信息安全，一会儿是区块链。看到网上的一些信息，就会影响自己的心态，忧虑这个那个。再加上我的学习方式不正确，就导致什么都没有学好。</p>
<br>

<p><strong>数据结构与算法</strong></p>
<p>大一寒假（两年前），有学长告诉我们得趁早刷题，可惜我当时不了解这方面的重要性，以及该如何去学，答案稍微看不懂，就不想学了。也不知道原来平时C++上机的内容，就是一些数据结构和算法题。每次只能看着大神们30分钟解决战斗，潇洒离开机房，而自己只有羡慕的份。</p>
<p>在数据结构和算法题这方面，后面又是因为学习方式不对，搁置了很长一段时间（还有自己懒惰）。</p>
<p>直到最近换了方式，先分类，然后边做题边看别人的总结，才顺利起来。</p>
<br>

<p><strong>编程语言</strong></p>
<p>这个应该是我大三之前就要掌握好的。</p>
<p>大一的时候决定要学C++，可惜，学了基本语法和一点点面向对象、泛型编程之后就停了，也就是学完课本上的一点东西就停了。还记得两年前的寒假，我在艰难地翻看C++课本，因为太关注那些语法规则，那些细枝末节，导致因小失大，学得很难受而学不下去。</p>
<p>又因为课本上没有STL的内容，STL的东西也没学到。</p>
<p>也不知道有系统编程，网络编程这些东西，虽然那会儿还没学操作系统和计算机网络。我要是能够意识到这两点，就应该早点自学操作系统和计算机网络，不用等到大二下学期才去学。</p>
<p>还有应该面向项目来学习编程语言，在学语言的同时，又能掌握工程技能。可惜自己太懒，浅学即止。</p>
<p>到现在因为要找实习找工作，需要项目经验，才从网上找视频一步一步跟着构建。对了，在项目选择这方面，我又浪费了不少时间。</p>
<p>除了做项目，C++其实还有好多需要学的，哎…</p>
<br>

<br>

<p><strong>本科学习</strong></p>
<p>这是我在选择摆烂的同时，又不愿放弃的东西。</p>
<p>大一上学期玩得很嗨，把学分最高的两门数学可都丢了。</p>
<p>大一下学期，稍微知耻而后勇了一点，但是还是把学分最高的数学丢了。并且该学好的专业课，也没好好学。</p>
<p>大二上学期（大一虽然浪飞了，但是分流后的排名也不是说毫无保研希望），于是就想在这方面努力一点，最后这学期的成绩总体也还不错，但还是够高，某些科目拖了后腿。分析原因，主要还是因为自己贪玩，没有花足够的时间学习。</p>
<p>大二下学期，明显后劲不足了，但是三门专业课都还行，就计算机网络稍微拖了一点后腿（这时候还没意识到计网的重要性），政治课成绩掉大分。</p>
<p>大三上学期，现在正在复习的。其实一开始还是打算好好学，然而还是第n次虎头蛇尾。有一个原因是因为自己选的课太多，但也只是我的借口罢了。</p>
<br>

<p>为什么说不愿放弃：因为对于主要科目，我在学习的时候都会做好很多笔记，包括大一被我丢掉的数学分析、线性代数。</p>
<p>为什么又说是摆烂：虽然做了笔记，但是，就仅限于笔记。该刷题的科目，我几乎都没有刷题；该深入实践的科目，我都是应付任务。</p>
<p>最后成绩不上不下，不下是因为我确实学了，不上是因为我没有花更多时间去加强我学的东西。</p>
<p>其实想要分数更高，只要再多刷一点题就行了，笔记甚至也可以不做。而我在笔记上面花费了大量时间，最后也没有好好利用笔记去提高分数（但保住了下限），只能说怪谁呢？怪自己SB，认命了。</p>
<br>

<br>

<br>

<br>

<h3 id="时间都去哪了"><a href="#时间都去哪了" class="headerlink" title="时间都去哪了"></a>时间都去哪了</h3><p>上了大学后，我生活的各项内容占比，大概是：</p>
<p>（计算方式： 实际时间*权值）</p>
<ol>
<li>打游戏</li>
<li>踢球</li>
<li>刷视频，刷知乎</li>
<li>学习</li>
</ol>
<br>

<p>这个权值，可以认为是实际做事时的优先级</p>
<p>权值排行：</p>
<p>top1 踢球</p>
<p>top2 打游戏</p>
<p>top3 刷视频，刷知乎</p>
<p>top4 学习</p>
<p>而我认为的，正确的优先级排行应该是：</p>
<p>top1 学习</p>
<p>top2 踢球</p>
<p>top3 打游戏</p>
<p>top4 刷视频，刷知乎</p>
<br>

<p>实际时间排行:</p>
<ol>
<li>学习（上课）</li>
<li>打游戏</li>
<li>踢球</li>
<li>学习（课后）or 刷视频，刷知乎</li>
</ol>
<br>

<br>

<p><strong>关于游戏：</strong></p>
<p>有很多个晚上，我在宿舍里快乐开黑打 LOL ，可以从六七点打到九点十点，或者是从九点十点，打倒十二点断网。如果是白天，可以打一整个下午。只要是开始了游戏，就会持续很久，没有说打一把两把就关了的。除了LOL，又有很多时间贡献给了 Planeside2，骑马与砍杀，饥荒……</p>
<p>我知道自己深陷其中，也尝试过很多次物理戒断，但是一直不能解决这个问题。把这个游戏卸载了，过段时间就会去玩没有卸载地游戏。把所有游戏都卸载了，过段时间又会忍不住重新下回来一个。每次破戒，都会破得很彻底。</p>
<p>也许根本原因在于自制力不足，我习惯了中学时期的种种约束，现在给予了我足够的自由，我却不能够合理地去发展。</p>
<br>

<p><strong>关于踢球：</strong></p>
<p>虽然说运动强身健体，但是踢球确实占据了我不少时间和精力。每次踢球，一般是从四五点，踢到六七点，然后吃饭、洗澡、歇息，一晃就八点多九点多，也快半天时间。而且踢完球了，一般也提不起学习的念头，就又是游戏，短视频…</p>
<p>一周多则踢个3次4次，少则1次2次，时间也就这么消失了。</p>
<br>

<p><strong>关于刷视频：</strong></p>
<p>这个没什么好说的，手机打开，只要一点进去，时间就消失了。尤其是微信视频号，毫无营养的视频非常多，但却能让我在半夜刷上一两个小时。因为太容易点到这个玩意儿了，现在我已经把视频号给撤了。</p>
<p>另外就是B站，知乎…很多没意义没营养的内容，都消耗了我不少时间。并且，知乎的很多负能量在不经意间击碎了我对未来的憧憬，陡增焦虑。</p>
<br>

<p><strong>剖析每一天的时间：</strong></p>
<p>每学期都有一段时间课比较多，一段时间没什么课</p>
<ul>
<li>有课：获得逃课技能之前，上完课之后的时间，几乎都不想学习。习得逃课技能之后，该逃不该逃的课也都逃过了，逃了之后有去自学的，也有去游戏人生的，还有去踢球的…</li>
<li>没课：没课一般是中午起床，吃个饭之后就一点多了。这个时候要么会犯困（奇了怪了），要么没忍住点开了游戏，通常来说一下午就又没了。如果衔接踢球的话，这一天就没了。衔接学习的话，多半是在完成作业什么的，完成任务罢了。到了比较晚的时候，就轮到短视频、新媒体什么的来抢占我的时间了。</li>
</ul>
<br>

<p><strong>再仔细回想，发现我用来学习的时间几乎都在深夜。好像只有在这个时候我才能保持专注，才能进入状态。</strong></p>
<p>浪费了一天的时间后，夜里常常感到愧疚。这个时候我就有动力学习了，而一旦进入状态，我就舍不得去睡觉。或许这就是我深夜学习的原因。</p>
<br>

<p><strong>放长假：</strong></p>
<p>每个假期都会带几本书回家，然而一点也没看。</p>
<p>在家里就是阴间作息+游戏人生。完全没有考虑学习什么的，有的话也是浅尝即止，觉得香不过游戏。</p>
<p>直到这个寒假的前2&#x2F;3部分，也还是如此。虽然刚回家的那几天都有刷题。</p>
<p>到现在因为面临春招实习的压力（很可能寄了，来不及），这段时间才开始猛学，才开始追悔莫及。</p>
<br>

<br>

<p>就像我在一天中的深夜里学习一样，在某些时间段的尾段，我也是冲刺地学习。这并不是一个好的现象和方式，因为情况通常都是时间不够充裕，大脑不能稳定和冷静地运行。冲刺式的学习不能够深入知识和技术，通常只是以应付任务作为目的，达到应付任务的效果。</p>
<br>

<p>这样子的一天一天连在一起，就成了我不堪回首的大学时光。（虽然也就过了5&#x2F;8，还有一点抢救的机会）</p>
<br>

<br>

<br>

<h3 id="为什么会这样"><a href="#为什么会这样" class="headerlink" title="为什么会这样"></a>为什么会这样</h3><p>不妨回忆一下高中生涯，跟现在很相似。高一高二处于半摆烂状态，高三开始冲刺，就像我半摆烂到现在开始冲刺。高三冲刺到最后填平了前面摆烂挖的坑，结果也还不错。而现在，我实在不敢去奢求未来有多好的结果，只要不是烂果就行了。但是冲刺不能停，这点必须时刻提醒自己。</p>
<br>

<p>这种 半摆烂+冲刺 现象的成因如何解释。</p>
<ul>
<li><p>先说为什么会出现冲刺：时间临近终点，即将取得某种结果。此时，我会明确的希望自己能达到什么层次，确定自己的风格路线，并去了解应该如何去实现目标。</p>
<ul>
<li><p>概括下来就是：</p>
<p>​	一定的野心 + 明确的目标 + 合适的方法</p>
<p>分析高三冲刺：</p>
<p>​	希望中学生涯有个好的结尾  + 92计算机专业 + 学习方法比较正确</p>
<p>分析现在的冲刺：</p>
<p>​	希望毕业有个匹配的工作 + C++服务器开发 + 我不好说</p>
</li>
</ul>
</li>
<li><p>再说为什么会半摆烂：无非就是，没有明确的目标，学习方式不对，迷茫，没有动力，自制力不足，玩心太重…</p>
</li>
</ul>
<br>

<p>补救措施：</p>
<ul>
<li>目标，现在有了</li>
<li>路线，有了</li>
<li>学习方式，这个感觉得参考别人了</li>
<li>动力，压力都变成动力了</li>
<li>自制力，只能改，从好习惯开始</li>
<li>玩心重，不敢玩了</li>
</ul>
<p>还有一个，自我监督。</p>
<br>

<br>

<h3 id="以后怎么办"><a href="#以后怎么办" class="headerlink" title="以后怎么办"></a>以后怎么办</h3><p>高三和现在又有些许不同：高三靠约束，现在靠自律；高三有贵人相伴，现在孤身奋战。约束养不成我的自控力，但代替了我的自控力；而贵人在我低落的时候给了我不少鼓励，在我松懈的时候给了我十足的动力。而目前形势严峻。</p>
<p>我不好说未来会是什么结果，只能再次提醒自己，冲刺不能停。</p>
<p>还有就是，吸取教训。不要过了这个坎，就觉得万事大吉，等到下一个坎到来，又像现在这样猴急。</p>
<p>先从养成习惯开始吧，两个目标：<strong>规律作息，按时三餐</strong>。</p>
<img src="/2023/02/12/%E5%90%B8%E5%8F%96%E6%95%99%E8%AE%AD/image-20230212062855952.png" alt="image-20230212062855952">

<br>

<p>今晚无论有什么事情没做，也要在12点前熄灯睡觉</p>
<br>

<br>

<br>

<br>

<br>

<p>而现在是2023年2月12日，早上6点27。本来是想反思一下自己的拖延症和网瘾，一不小心反思了一个晚上。</p>
]]></content>
      <categories>
        <category>反思录</category>
      </categories>
      <tags>
        <tag>时间</tag>
        <tag>拷打</tag>
      </tags>
  </entry>
  <entry>
    <title>用不同电脑写hexo博客</title>
    <url>/2022/07/11/%E4%B8%8D%E5%90%8C%E7%94%B5%E8%84%91%E5%86%99hexo%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="基于GitHub双分支方法"><a href="#基于GitHub双分支方法" class="headerlink" title="基于GitHub双分支方法"></a>基于GitHub双分支方法</h1><h2 id="1-在每次编辑之前"><a href="#1-在每次编辑之前" class="headerlink" title="1. 在每次编辑之前"></a>1. 在每次编辑之前</h2><hr>
<p>需要先 <code>git pull</code> 拉取hexo分支的内容到本地，即同步更新，然后再进行上述操作。</p>
<hr>
<p><br><br><br><br><br><br></p>
<h2 id="2-修改本地文件和编辑博客内容"><a href="#2-修改本地文件和编辑博客内容" class="headerlink" title="2. 修改本地文件和编辑博客内容"></a>2. 修改本地文件和编辑博客内容</h2><hr>
<p>Windows下用 git bash 打开本地文件夹</p>
<p>然后就是 <code>hexo new [layout] &lt;title&gt;</code> 创建新文件</p>
<img src="/2022/07/11/%E4%B8%8D%E5%90%8C%E7%94%B5%E8%84%91%E5%86%99hexo%E5%8D%9A%E5%AE%A2/07/11/%E4%B8%8D%E5%90%8C%E7%94%B5%E8%84%91%E5%86%99hexo%E5%8D%9A%E5%AE%A2/1.png" class>

<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/156915260">相关hexo操作</a></p>
</blockquote>
<blockquote>
<p><a href="https://markdown.com.cn/basic-syntax/">markdown语法</a></p>
</blockquote>
<blockquote>
<p>图片插入格式 <code>&#123;% asset_img example.jpg This is an example image %&#125;</code></p>
</blockquote>
<hr>
<p><br><br><br><br><br><br></p>
<h2 id="3-编辑和修改完成之后"><a href="#3-编辑和修改完成之后" class="headerlink" title="3. 编辑和修改完成之后"></a>3. 编辑和修改完成之后</h2><hr>
<p>先归并到hexo分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;xxx&quot;&#x27;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<p>再用</p>
<p> <code>hexo d -g</code></p>
<p> 部署到master分支中的网页上。</p>
<hr>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux多线程</title>
    <url>/2023/02/10/%E7%AC%AC%E4%B8%89%E7%AB%A0Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="第三章-Linux多线程开发"><a href="#第三章-Linux多线程开发" class="headerlink" title="第三章 Linux多线程开发"></a>第三章 Linux多线程开发</h1><hr>
<br>

<h2 id="3-1-线程"><a href="#3-1-线程" class="headerlink" title="3.1 线程"></a>3.1 线程</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li>与进程类似，线程是允许应用程序并发执行多个任务的一种机制。<ul>
<li>一个进程可以包含多个线程。</li>
<li>同一个程序中的所有线程均会独立执行相同程序，且共享同一份全局内存区域，其中包括初始化数据段、未初始化数据段，以及堆内存段。（传统意义上的 UNIX 进程只是多线程程序的一个特例，该进程只包含一个线程）</li>
</ul>
</li>
<li>进程是 CPU 分配资源的最小单位，线程是操作系统调度执行的最小单位</li>
<li>线程是轻量级的进程( LWP ,Light Weight Process )，在 Linux 环境下线程的本质仍是进程</li>
<li>查看指定进程的 LWP 号：<code>ps -Lf pid</code></li>
</ul>
<br>

<br>

<p><strong>线程与进程的区别</strong></p>
<p>进程：</p>
<ul>
<li>进程间的信息难以共享。由于除去只读代码段外，父子进程并未共享内存，因此必须采用一些进程间通信方式，在进程间进行信息交换</li>
<li>调用 fork() 来创建进程的代价相对较高，即便利用了 写时复制 技术，仍需要复制诸如内存页表和文件描述符表之类的多种进程属性</li>
</ul>
<br>

<p>线程：</p>
<ul>
<li>线程之间能够方便、快速的共享信息。只需要将数据复制到共享(全局或堆)变量中即可</li>
<li>创建线程比创建进程通常要快得多。线程间是共享虚拟地址空间的，无需采用写时复制来复制内存，也无需复制页表</li>
</ul>
<p><img src="/2023/02/10/%E7%AC%AC%E4%B8%89%E7%AB%A0Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20230208234052055.png" alt="image-20230208234052055"></p>
<p><strong>线程资源</strong></p>
<p>共享资源：</p>
<ul>
<li>进程id，父进程id</li>
<li>进程组id，会话id</li>
<li>用户id，用户组id</li>
<li>文件描述符表</li>
<li>信号处置（注册的、默认的）</li>
<li>文件系统的相关信息：umask、当前工作目录</li>
<li>虚拟地址空间（除了栈、.text段)</li>
</ul>
<br>

<p>非共享资源：</p>
<ul>
<li>线程id</li>
<li>信号掩码</li>
<li>线程特有数据</li>
<li>error 变量（线程特有）</li>
<li>实时调度策略 和 优先级</li>
<li>栈、本地变量和函数的调用链接信息</li>
</ul>
<br>

<p><strong>NPTL</strong></p>
<p>查看当前 pthread 库版本：<code>getconf GNU_LIBPTHREAD_VERSION</code></p>
<p><img src="/2023/02/10/%E7%AC%AC%E4%B8%89%E7%AB%A0Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20230208234720549.png" alt="image-20230208234720549"></p>
<br>

<br>

<br>

<h3 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h3><p>一般情况下，main函数所在的线程作为主线程（main线程），其余创建的称为子线程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	创建一个子线程</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- thread：传出参数，线程创建成功后，子线程的线程id被写入该变量</span></span><br><span class="line"><span class="comment">		- attr：设置线程的属性，一般使用默认值 NULL</span></span><br><span class="line"><span class="comment">		- start_routine：函数指针，子线程需要处理的逻辑代码</span></span><br><span class="line"><span class="comment">		- arg：作为start_routine的参数</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		成功 返回0</span></span><br><span class="line"><span class="comment">		失败 返回错误号。与之前的erron不太一样</span></span><br><span class="line"><span class="comment">		获取错误号信息：char *strerror(int errnum);</span></span><br><span class="line"><span class="comment">*/</span>	</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<blockquote>
<p>编译的时候要加 -pthread</p>
</blockquote>
<br>

<p><strong>案例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">callback</span><span class="params">(<span class="type">void</span>*arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child thread and arg: %d\n&quot;</span>,*(<span class="type">int</span> *)arg);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, callback, (<span class="type">void</span>*)&amp;num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span> *errstr = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;err:%s\n&quot;</span>,errstr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<br>

<br>

<h3 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于提前 return</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	终止一个线程，在哪个线程中调用就终止哪个线程</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- retval：需要传递一个指针，作为一个返回值，可以在 pthread_join() 中获取到</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前线程的线程id</span></span><br><span class="line"><span class="type">pthread_t</span> <span class="title function_">pthread_self</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较两个线程 ID 是否相等</span></span><br><span class="line"><span class="comment">// 不同的操作系统，pthread_t类型的实现不同，有的是无符号长整形，有的是结构体。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_equal</span><span class="params">(<span class="type">pthread_t</span> t1, <span class="type">pthread_t</span> t2)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<br>

<h3 id="连接已终止的线程"><a href="#连接已终止的线程" class="headerlink" title="连接已终止的线程"></a>连接已终止的线程</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	和一个已经终止的线程进行连接（阻塞的）</span></span><br><span class="line"><span class="comment">	回收子线程的资源（一次回收一个）</span></span><br><span class="line"><span class="comment">	一般在主线程中使用</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- thread：需要回收的子线程的id</span></span><br><span class="line"><span class="comment">		- retval：二级指针，接收子线程退出时的返回值</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		成功 0</span></span><br><span class="line"><span class="comment">		失败 非0 返回错误号</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<p><strong>接收返回值的join案例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> value =<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">callback</span><span class="params">(<span class="type">void</span>*arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child thread and arg: %d\n&quot;</span>,*(<span class="type">int</span> *)arg);</span><br><span class="line">    pthread_exit((<span class="type">void</span> *)&amp;value);	<span class="comment">// return (void *)&amp;value;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, callback, (<span class="type">void</span>*)&amp;num);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span> *errstr = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;err:%s\n&quot;</span>,errstr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 主线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 回收</span></span><br><span class="line">    <span class="type">int</span> *rtvalue;	<span class="comment">// 作接收的变量</span></span><br><span class="line">    ret = pthread_join(tid,(<span class="type">void</span> **)&amp;rtvalue);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span> *errstr = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;err:%s\n&quot;</span>,errstr);</span><br><span class="line">    &#125;	</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;get return value:%d\n&quot;</span>,*rtvalue);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<br>

<br>

<h3 id="线程分离"><a href="#线程分离" class="headerlink" title="线程分离"></a>线程分离</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	分离一个线程</span></span><br><span class="line"><span class="comment">	将指定线程标记为分离，当该线程终止时系统会自动回收资源，而不再需要别的线程来join回收</span></span><br><span class="line"><span class="comment">	不能 detach / join 一个已经分离的线程</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- thread：需要分离的线程的id</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		成功 0</span></span><br><span class="line"><span class="comment">		失败 非0 返回错误号</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<br>

<h3 id="线程取消"><a href="#线程取消" class="headerlink" title="线程取消"></a>线程取消</h3><ul>
<li>调用 pthread_cancel 之后，线程不会立即退出，而是等运行到某一 取消点 的时候才会真正取消</li>
<li>取消点：系统规定好的一些系统调用，一般在用户态切换到内核态的场景出现</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	取消线程，当子线程执行到一个取消点时，线程才会终止</span></span><br><span class="line"><span class="comment">	线程能否取消取决于线程的一些属性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<br>

<h3 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h3><p>pthread_create()的第二个参数传入线程属性</p>
<p><strong>相关函数</strong></p>
<p><img src="/2023/02/10/%E7%AC%AC%E4%B8%89%E7%AB%A0Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20230209190308454.png" alt="image-20230209190308454"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">线程属性类型 <span class="type">pthread_attr_t</span></span><br><span class="line"></span><br><span class="line">    变量初始化与回收</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_init</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	初始化线程属性变量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_destroy</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	释放线程属性变量的资源</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	属性设置和获取</span><br><span class="line">        </span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getdetachstate</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> </span></span><br><span class="line"><span class="params">*detachstate)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	获取线程分离的状态属性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setdetachstate</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> </span></span><br><span class="line"><span class="params">detachstate)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	设置线程分离的状态属性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<br>

<br>

<br>

<h2 id="3-2-同步互斥"><a href="#3-2-同步互斥" class="headerlink" title="3.2 同步互斥"></a>3.2 同步互斥</h2><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><ul>
<li>线程的主要优势在于能够通过全局变量来共享信息。但是要确保多个线程不会同时修改同一变量，或者某一线程不会读取正在由其他线程修改的变量。</li>
</ul>
<br>

<p><strong>临界区</strong></p>
<p>指访问某一共享资源的代码片段，并且这段代码的执行应该为 原子操作 ，也就是同时访问同一共享资源的其他线程不应该中断该片段的执行。</p>
<br>

<p><strong>同步与互斥</strong></p>
<p><strong>线程同步</strong> 就是协同步调，按预定的先后次序进行运行。如：你说完，我再说。线程同步是指多线程通过特定的设置（如互斥量，事件对象，临界区）来控制线程之间的执行顺序（即所谓的同步）也可以说是在线程之间通过同步建立起执行顺序的关系，如果没有同步，那线程之间是各自运行各自的，也即异步。</p>
<p><strong>线程互斥</strong> 是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步。</p>
<br>

<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><ul>
<li>为了线程更新共享变量时出现问题，可以使用互斥量 mutex( mutual exclusion ) 来确保同时仅有一个线程可以访问某项共享资源。可以使用互斥量来保证对任意共享资源的原子访问。</li>
<li>互斥量有两种状态：锁定locked 和 未锁定unlocked 。任何时刻，至多只有一个线程可以锁定该互斥量。试图对已经锁定的某一互斥量再次加锁，将可能阻塞线程或者报错失败，具体取决于加锁使用的方法。</li>
<li>一旦线程锁定互斥量，随即成为该互斥量的所有者，只有所有者才能给互斥量解锁。一般情况下，对每一共享资源（可能有多个相关变量组成）会使用不同的互斥量，每一线程在访问同一资源时将采用如下协议：<ul>
<li>锁定相应的互斥量</li>
<li>访问共享资源</li>
<li>对互斥量解锁</li>
</ul>
</li>
</ul>
<br>

<p><img src="/2023/02/10/%E7%AC%AC%E4%B8%89%E7%AB%A0Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20230210020752443.png" alt="image-20230210020752443"></p>
<br>

<br>

<p><strong>互斥量相关函数</strong></p>
<p>互斥量类型 <code>pthread_mutex_t</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	初始化互斥量</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- mutex：需要初始化的互斥变量</span></span><br><span class="line"><span class="comment">		- attr：互斥量相关的属性，一般NULL</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	restrict ：C语言的修饰符，被修饰的指针指向的内容不能由别的指针进行操作</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	释放互斥量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	给互斥量加锁</span></span><br><span class="line"><span class="comment">	阻塞的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	给互斥量尝试加锁</span></span><br><span class="line"><span class="comment">	非阻塞</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	解锁</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<br>

<br>

<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul>
<li>有时，一个线程需要同时访问两个或更多不同的共享资源，而每个资源又都有不同的互斥量管理。当超过一个线程加锁同一组互斥量时，就可能发送死锁</li>
</ul>
<p><img src="/2023/02/10/%E7%AC%AC%E4%B8%89%E7%AB%A0Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20230210022902860.png" alt="image-20230210022902860"></p>
<br>

<blockquote>
<p><strong>死锁</strong>：两个或两个以上的进程在执行过程中，因为夺取资源而造成的一种相互等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统发生了死锁。</p>
<p><strong>场景</strong>：</p>
<ul>
<li>忘记释放锁</li>
<li>重复加锁</li>
<li>多线程多锁，抢占资源</li>
</ul>
</blockquote>
<br>

<br>

<p>更多相关内容详见操作系统课程…</p>
<br>

<br>

<br>

<br>

<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><ul>
<li>当一个线程已经持有互斥锁时，互斥锁将所有试图进入临界区的线程都阻塞住。<br>但考虑一种情况：当前持有互斥锁的线程只是读共享资源，而同时有其他几个线程也想读取这个共享资源，但由于互斥锁的排他性，所有线程都无法获取锁，即无法读访问共享资源，但是实际上多个线程同时读访问共享资源并不会导致问题</li>
<li>在对数据的读写操作中，更多的是读操作，写操作较少。为了满足允许多个读出，而只允许单个写入的情况，线程提供了读写锁来实现。</li>
</ul>
<br>

<p><strong>读写锁特点</strong>：</p>
<ul>
<li>如果有其他线程 <strong>读数据</strong> ，则允许其他线程执行读操作，但不允许写操作</li>
<li>如果有其他线程 <strong>写数据</strong> ，则其他线程都不允许读、写操作</li>
<li>写是独占的，写的优先级更高</li>
</ul>
<br>

<br>

<p><strong>相关函数</strong></p>
<p>读写锁类型 <code>pthread_rwlock_t</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化读写锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_init</span><span class="params">(<span class="type">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock, <span class="type">const</span> <span class="type">pthread_rwlock_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回收读写锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_destroy</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加读锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_rdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试加读锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_tryrdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加写锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_wrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试加写锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_trywrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_unlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<br>

<br>

<p><strong>生产者与消费者模型</strong></p>
<p><img src="/2023/02/10/%E7%AC%AC%E4%B8%89%E7%AB%A0Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20230210040352527.png" alt="image-20230210040352527"></p>
<br>

<p>更多相关内容详见操作系统课程…</p>
<br>

<br>

<br>

<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>不是锁，能够配合互斥量使用实现线程的同步关系</p>
<p>类型 <code>pthread_cond_t</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="type">const</span> <span class="type">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回收</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待条件实现（阻塞）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待条件实现（阻塞指定的一段时间）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_timewait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="type">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> abstime)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒等待的一个或多个等待的线程</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒所有等待的线程</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<br>

<blockquote>
<p>注意当 wait 阻塞的时候，会将 互斥锁 解锁；</p>
<p>等到 wait 被唤醒之后，又会在原处重新 对 互斥锁 加锁</p>
</blockquote>
<br>

<br>

<br>

<br>

<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>类型 <code>sem_t</code></p>
<p>与条件变量类似，与互斥锁搭配使用，实现线程同步关系</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	信号量初始化</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		sem：信号量变量的地址</span></span><br><span class="line"><span class="comment">		pshared：0 表示用于线程间， 非0 表示用于进程间</span></span><br><span class="line"><span class="comment">		value：信号量中的值，可表示资源数量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放资源</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_destroy</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若信号量值为 0 就阻塞，信号量值大于 0 就 -1，</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_trywait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_timewait</span><span class="params">(<span class="type">sem_t</span> *sem,<span class="type">const</span> <span class="keyword">struct</span> timespec *abs_timeout)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号量值 +1 ，并且如果有的话就唤醒一个 wait 中的线程</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_getvalue</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> sval)</span>;</span><br></pre></td></tr></table></figure>

<br>

<blockquote>
<p>wait – post 对应 P – V 操作</p>
</blockquote>
<br>

<p>模拟生产者消费者</p>
<p>以资源容量为 8 为例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> resource = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> psem;</span><br><span class="line"><span class="type">sem_t</span> csem;</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">producer</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sem_wait(&amp;psem);</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        ++resource;</span><br><span class="line">        usleep(<span class="number">100</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;tid:%ld, produce : %d\n&quot;</span>,pthread_self(),resource);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        sem_post(&amp;csem);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">consumer</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sem_wait(&amp;csem);</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        --resource;</span><br><span class="line">        usleep(<span class="number">100</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;tid:%ld, consume : %d\n&quot;</span>,pthread_self(),resource);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        sem_post(&amp;psem);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    sem_init(&amp;psem, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">    sem_init(&amp;csem, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> ptids[<span class="number">5</span>],ctids[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">        pthread_create(&amp;ptids[i],<span class="literal">NULL</span>,producer,<span class="literal">NULL</span>);</span><br><span class="line">        pthread_create(&amp;ctids[i],<span class="literal">NULL</span>,consumer,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">        pthread_join(ptids[i],<span class="literal">NULL</span>);</span><br><span class="line">        pthread_join(ctids[i],<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    sem_destroy(&amp;psem);</span><br><span class="line">    sem_destroy(&amp;csem);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<p><img src="/2023/02/10/%E7%AC%AC%E4%B8%89%E7%AB%A0Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20230210071555920.png" alt="image-20230210071555920"></p>
<p><br><br><br></p>
<p>第三章完结！</p>
<br>

<br>







]]></content>
      <categories>
        <category>C++开发</category>
        <category>高性能服务器项目</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>第五章项目实战</title>
    <url>/2023/03/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h1 id="5-项目相关知识点"><a href="#5-项目相关知识点" class="headerlink" title="5.项目相关知识点"></a>5.项目相关知识点</h1><br>

<br>

<br>

<h2 id="5-1-阻塞-x2F-非阻塞，同步-x2F-异步"><a href="#5-1-阻塞-x2F-非阻塞，同步-x2F-异步" class="headerlink" title="5.1 阻塞&#x2F;非阻塞，同步&#x2F;异步"></a>5.1 阻塞&#x2F;非阻塞，同步&#x2F;异步</h2><p>此处是对于 <strong>网络IO</strong></p>
<p>IO的两个阶段：1.<strong>数据就绪</strong> 2.<strong>数据读写</strong></p>
<br>

<p><strong>数据就绪</strong>	操作系统、内核缓冲区中</p>
<ul>
<li>阻塞   ：调用IO方法的线程进入阻塞状态</li>
<li>非阻塞  ：不改变线程的状态，通过返回值判断</li>
</ul>
<br>

<p><strong>数据读写</strong>	缓冲区的数据&lt;–&gt;内存</p>
<ul>
<li>同步   : 应用程序自行读写</li>
<li>异步   : 操作系统辅助读写   （异步IO接口、通知方式）</li>
</ul>
<br>

<blockquote>
<img src="/2023/03/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20230303232426115.png" alt="image-20230303232426115" style="zoom:80%;">

<p>陈硕：在处理IO的时候，阻塞和非阻塞都是同步IO，只有使用了特殊的API才是异步IO</p>
</blockquote>
<br>

<p>对于网络IO</p>
<ul>
<li>一个典型的<strong>网络IO接口调用</strong>，分为两个阶段，分别是“<strong>数据就绪</strong>” 和 “<strong>数据读写</strong>”<ul>
<li><strong>数据就绪</strong>阶段分为<strong>阻塞和非阻塞</strong>，表现得结果就是，<strong>阻塞当前线程</strong>或是<strong>直接返回</strong>。</li>
</ul>
</li>
</ul>
<br>

<ul>
<li><p><strong>同步</strong>表示A向B请求调用一个网络IO接口时（或者调用某个业务逻辑API接口时），<strong>数据的读写</strong>都是由<strong>请求方A自己来完成的</strong>（不管是阻塞还是非阻塞）</p>
</li>
<li><p><strong>异步</strong>表示A向B请求调用一个网络IO接口时（或者调用某个业务逻辑API接口时），向B传入<strong>请求的事件</strong>以及<strong>事件发生时通知的方式</strong>，<strong>A就可以处理其它逻辑了</strong>，当B监听到事件处理完成后，会用事先约定好的通知方式，通知A处理结果。</p>
<ul>
<li><p>同步阻塞</p>
</li>
<li><p>同步非阻塞</p>
</li>
<li><p>异步阻塞</p>
</li>
<li><p>异步非阻塞</p>
</li>
</ul>
</li>
</ul>
<br>

<br>

<br>

<br>

<h2 id="5-2-Linux的五种IO模型"><a href="#5-2-Linux的五种IO模型" class="headerlink" title="5.2 Linux的五种IO模型"></a>5.2 Linux的五种IO模型</h2><img src="/2023/03/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20230303232426115.png" alt="image-20230303232426115" style="zoom:80%;">

<h3 id="阻塞-blocking"><a href="#阻塞-blocking" class="headerlink" title="阻塞 blocking"></a>阻塞 blocking</h3><p>调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的去检查这个函数有没有返回，必须等待这个函数返回才能进行下一步操作。</p>
<p>以read为例：</p>
<img src="/2023/03/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20230304000806869.png" alt="image-20230304000806869" style="zoom:80%;">

<br>

<h3 id="非阻塞-non-blocking（NIO）"><a href="#非阻塞-non-blocking（NIO）" class="headerlink" title="非阻塞 non-blocking（NIO）"></a>非阻塞 non-blocking（NIO）</h3><p>非阻塞等待，每隔一段时间就去检测IO事件是否就绪，若没有就绪就可以做其他事。</p>
<p>非阻塞I&#x2F;O执行系统调用总是立即返回，不管事件是否已经发生。若事件没有发生，则返回-1，此时可以根据errno区分情况。</p>
<p>对于<strong>accept，recv和send</strong>，事件未发生时，errno通常被设置为<strong>EAGAIN</strong>。</p>
<img src="/2023/03/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20230304001316512.png" alt="image-20230304001316512" style="zoom:80%;">

<br>

<h3 id="IO复用（multiplexing）"><a href="#IO复用（multiplexing）" class="headerlink" title="IO复用（multiplexing）"></a>IO复用（multiplexing）</h3><p>Linux用select&#x2F;poll&#x2F;epoll函数实现IO复用模型，这些函数也会使进程阻塞，但是和阻塞IO所不同的是这些函数<strong>可以同时阻塞多个IO操作</strong>。而且可以<strong>同时对多个读操作、写操作的IO函数进行检测</strong>。直到有数据可读或可写时，才真正调用IO操作函数。</p>
<p>用于在一个服务端线程中响应多个客户端，但是不是处理高并发的（多线程多进程）。</p>
<img src="/2023/03/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20230304002733110.png" alt="image-20230304002733110" style="zoom:80%;">

<br>

<h3 id="信号驱动（signal-driven）"><a href="#信号驱动（signal-driven）" class="headerlink" title="信号驱动（signal-driven）"></a>信号驱动（signal-driven）</h3><p>Linux用套接口进行信号驱动IO，安装一个<strong>信号处理函数</strong>，进程继续运行并不阻塞。当IO事件就绪，进程收到SIGIO信号，然后处理IO事件。</p>
<ul>
<li>内核在数据准备阶段是异步的，在数据读写结段是同步的</li>
<li>与非阻塞IO的区别在于它提供了消息通知机制，不需要用户进程不断轮询检查，减少了系统API的调用次数，提高了效率</li>
</ul>
<img src="/2023/03/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20230304003340232.png" alt="image-20230304003340232" style="zoom:80%;">

<br>

<h3 id="异步IO（asynchronous）"><a href="#异步IO（asynchronous）" class="headerlink" title="异步IO（asynchronous）"></a>异步IO（asynchronous）</h3><p>Linux中，可以调用 aio_read 函数告诉内核<strong>描述符缓冲区指针</strong>和<strong>缓冲区的大小</strong>、<strong>文件偏移</strong>及<strong>通知的方式</strong>等，然后立即返回，当内核将数据拷贝到缓冲区后，在通知应用程序。</p>
<img src="/2023/03/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20230304004046738.png" alt="image-20230304004046738" style="zoom:80%;">

<br>

<img src="/2023/03/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20230304004303084.png" alt="image-20230304004303084" style="zoom:80%;">

<br>

<br>

<br>

<br>

<h2 id="5-3-Web服务器简介及http协议"><a href="#5-3-Web服务器简介及http协议" class="headerlink" title="5.3 Web服务器简介及http协议"></a>5.3 Web服务器简介及http协议</h2><h3 id="Web-Server"><a href="#Web-Server" class="headerlink" title="Web Server"></a>Web Server</h3><p>网页服务器</p>
<p>一个 Web Server 就是一个<strong>服务器软件</strong>（程序），或者是<strong>运行这个服务器软件的硬件</strong>（计算机）。</p>
<p>其主要功能就是通过 <strong>HTTP</strong> 协议与<strong>客户端</strong>（通常是浏览器Browser）进行<strong>通信</strong>，来<strong>接收、存储、处理</strong>来自客户端的 <strong>HTTP请求</strong> ，并对其请求做出 <strong>HTTP响应</strong> ，返回给客户端其请求的内容（<strong>文件、网页等</strong>）或返回一个 <strong>Error 信息</strong>。</p>
<br>

<p><img src="/2023/03/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20230304004705396.png" alt="image-20230304004705396"></p>
<br>

<p>通常用户使用 Web浏览器 与相应服务器进行通信。在浏览器中键入<strong>”域名“或”IP:Port“</strong>，浏览器先将你的<strong>域名解析成相应的IP地址</strong>或者直接根据你的IP地址向对应的Web服务器发送一个 <strong>HTTP请求</strong> 。这一过程首先要通过<strong>TCP协议的三次握手</strong>建立与目标Web服务器的连接，然后HTTP协议生成针对目标Web服务器的<strong>HTTP请求报文</strong>，通过<strong>TCP、IP等协议</strong>发送到目标服务器上。</p>
<br>

<br>

<br>

<h3 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h3><p><strong>简介</strong></p>
<p><strong>超文本传输协议</strong>（Hypertext Transfer Protocol，HTTP）是一个简单的 <strong>请求-响应</strong> 协议，它通常运行在 TCP 之上。</p>
<ul>
<li>它指定了客户端可能发送给服务器<strong>什么样的消息</strong>以及得到<strong>什么样的响应</strong>。</li>
<li>请求和响应消息的<strong>头</strong>以 ASCII 形式给出；而<strong>消息内容</strong>则具有一个类似 MIME 的格式。</li>
<li>HTTP是万维网的数据通信的基础。</li>
</ul>
<p><strong>概述</strong></p>
<p>HTTP 是一个客户端终端（用户）和服务器端（网站）请求和应答的标准（TCP）。</p>
<ul>
<li>通过使用网页浏览器、网络爬虫或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口（默认端口为80）。我们称这个<strong>客户端</strong>为<strong>用户代理程序</strong>（user agent）。</li>
<li>应答的服务器上存储着一些资源，比如 HTML 文件和图像。我们称这个<strong>应答服务器</strong>为<strong>源服务器</strong>（origin server）。在用户代理和源服务器中间可能存在多个“<strong>中间层</strong>”，比如<strong>代理服务器</strong>、<strong>网关</strong>或者<strong>隧道</strong>（tunnel）。</li>
<li>尽管 TCP&#x2F;IP 协议是互联网上最流行的应用，HTTP 协议中，并没有规定必须使用它或它支持的层。事实上，HTTP可以在任何互联网协议上，或其他网络上实现。<strong>HTTP 假定其下层协议提供可靠的传输</strong>。因此，任何能够提供这种保证的协议都可以被其使用。因此也就是其在  TCP&#x2F;IP 协议族使用 TCP 作为其传输层。</li>
</ul>
<p>通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的 TCP 连接。HTTP服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如”HTTP&#x2F;1.1 200 OK”，以及返回的内容，如请求的文件、错误消息、或者其它信息。</p>
<br>

<p><strong>工作原理</strong></p>
<p>HTTP 协议定义 Web 客户端如何从 Web 服务器请求 Web 页面，以及服务器如何把 Web 页面传送给客户端。HTTP 协议采用了<strong>请求&#x2F;响应模型</strong>。</p>
<ul>
<li>客户端向服务器发送一个<strong>请求报文</strong>，请求报文包含<strong>请求的方法</strong>、<strong>URL</strong>、<strong>协议版本</strong>、<strong>请求头部</strong>和<strong>请求数据</strong>。</li>
<li>服务器以一个<strong>状态行</strong>作为响应，响应的内容包括<strong>协议的版本</strong>、<strong>成功或者错误代码</strong>、<strong>服务器信息</strong>、<strong>响应头部</strong>和<strong>响应数据</strong>。</li>
</ul>
<p><strong>HTTP请求&#x2F;响应的步骤：</strong></p>
<ol>
<li>客户端连接到 Web服务器<ul>
<li>客户端比如浏览器，与Web服务器的HTTP端口(默认为<strong>80</strong>)建立一个TCP套接字连接</li>
</ul>
</li>
<li>客户端发送HTTP请求<ul>
<li>通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由 <strong>请求行</strong>、<strong>请求头部</strong>、<strong>空行</strong>和<strong>请求数据</strong> 4部分组成</li>
</ul>
</li>
<li>服务器接受请求并返回HTTP响应<ul>
<li>Web服务器<strong>解析请求</strong>，<strong>定位请求资源</strong>。</li>
<li>服务器<strong>将资源副本写到TCP套接字</strong>，由客户端读取。</li>
<li>一个响应由 <strong>状态行</strong>、<strong>响应头部</strong>、<strong>空行</strong>和<strong>响应数据</strong> 4部分组成</li>
</ul>
</li>
<li>释放连接 TCP 连接<ul>
<li>若 connection 模式为 <strong>close</strong> ，则服务器主动关闭 TCP 连接，客户端被动关闭连接，释放TCP连接；</li>
<li>若 connection 模式为 <strong>keepalive</strong> ，则该连接会保持一段时间，在该时间内可以继续接收请求；</li>
</ul>
</li>
<li>客户端浏览器解析 HTML 内容<ul>
<li>客户端浏览器<strong>首先解析状态行</strong>，查看表明请求是否成功的状态代码。<strong>然后解析每一个响应头</strong>，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口显示。</li>
</ul>
</li>
</ol>
<br>

<p>例如：在浏览器地址栏输入URL，按下回车之后</p>
<ol>
<li>浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的IP地址</li>
<li>解析出IP地址后，根据该IP地址和默认端口80，和服务器建立TCP连接</li>
<li>浏览器发出读取文件（URL中域名后面部分对应的文件）的HTTP请求，该请求报文作为TCP三次握手的第三个报文的数据发送给服务器</li>
<li>服务器对浏览器请求做出响应，并把对应的HTML文本发送给浏览器</li>
<li>释放TCP连接</li>
<li>浏览器将解析该HTML文本并显示内容</li>
</ol>
<br>

<img src="/2023/03/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20230304011652447.png" alt="image-20230304011652447" style="zoom:80%;">

<blockquote>
<p>HTTP协议规定，请求从客户端发出，最后服务端响应请求并返回。也即，是先从客户端开始建立通信的，<strong>服务端在没有接收到请求之前不会发送响应</strong>。</p>
</blockquote>
<br>

<br>

<br>

<h3 id="http报文格式"><a href="#http报文格式" class="headerlink" title="http报文格式"></a>http报文格式</h3><p><img src="/2023/03/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20230304015519816.png" alt="请求报文格式"></p>
<p><img src="/2023/03/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20230304015552413.png" alt="响应报文格式"></p>
<br>

<p>Web服务器要<strong>解析请求，并生成响应信息</strong></p>
<br>

<p>我们要了解各种<strong>请求头响应头</strong>的含义，以及<strong>状态码</strong>的含义</p>
<img src="/2023/03/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20230304020932915.png" alt="image-20230304020932915" style="zoom:80%;">

<br>

<p>HTTP请求的各种<strong>请求方法</strong>，这里主要用 GET 和 POST<br><img src="/2023/03/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20230304021118740.png" alt="image-20230304021118740" style="zoom:80%;"></p>
<br>

<br>

<br>

<h2 id="5-4-服务器编程基本框架"><a href="#5-4-服务器编程基本框架" class="headerlink" title="5.4 服务器编程基本框架"></a>5.4 服务器编程基本框架</h2><p>以及两种高效的<strong>事件处理模式</strong></p>
<br>

<h3 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h3><p>Web 服务器程序种类繁多，但基本框架都一样，不同之处在于逻辑处理。</p>
<img src="/2023/03/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20230304022023757.png" alt="image-20230304022023757" style="zoom:80%;">

<table>
<thead>
<tr>
<th>模块</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>I&#x2F;O 处理单元</td>
<td>处理客户连接，读写网络数据</td>
</tr>
<tr>
<td>逻辑单元</td>
<td>业务进程或线程</td>
</tr>
<tr>
<td>网络存储单元</td>
<td>数据库、文件或缓存</td>
</tr>
<tr>
<td>请求队列</td>
<td>各单元之间的通信方式</td>
</tr>
</tbody></table>
<ul>
<li><p><strong>I&#x2F;O处理单元</strong>是服务器管理客户连接的模块。它通常要完成一下工作：</p>
<ul>
<li>等待并接受新的客户链接</li>
<li>接收客户数据</li>
<li>将服务器响应数据返回给客户端</li>
</ul>
<p>但是数据的收发不一定在I&#x2F;O处理单元中执行，也可能在逻辑单元中执行，具体取决于事件处理模式</p>
</li>
<li><p>一个<strong>逻辑单元</strong>通常是一个进程或线程。它分析并处理客户数据，然后将结果<strong>传递给I&#x2F;O处理单元</strong>或者<strong>直接发送给客户端</strong>（取决于事件处理模式）。服务器通常拥有多个逻辑单元，以实现对多个客户任务的并发处理</p>
</li>
<li><p><strong>网络存储单元</strong>可以是数据库、缓存和文件，但不是必须的</p>
</li>
<li><p><strong>请求队列</strong>是个单元之间的通信方式的抽象。</p>
<ul>
<li>I&#x2F;O处理单元接收到客户请求时，需要以某种方式通知一个逻辑单元来处理该请求。</li>
<li>同样，多个逻辑单元同时访问一个存储单元时，也需要采用某种机制来协调处理竞态条件。</li>
<li>请求队列通常被实现为<strong>池(进程池、线程池)的一部分</strong>。</li>
</ul>
</li>
</ul>
<br>

<br>

<h3 id="两种高效的事件处理模式"><a href="#两种高效的事件处理模式" class="headerlink" title="两种高效的事件处理模式"></a>两种高效的事件处理模式</h3><p>服务器程序通常需要处理三类事件：</p>
<ul>
<li>I&#x2F;O事件</li>
<li>信号</li>
<li>定时事件</li>
</ul>
<br>

<p>两种高效的事件处理模式：</p>
<ul>
<li><strong>Reactor</strong>   (一般用同步I&#x2F;O模型实现)</li>
<li><strong>Proactor</strong>  (一般用异步I&#x2F;O模型实现，或者用同步I&#x2F;O模型模拟)</li>
</ul>
<br>

<h4 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h4><ul>
<li><p>要求<strong>主线程</strong>(<strong>I&#x2F;O处理单元</strong>)只负责<u>监听文件描述符上是否有事件发生</u>，有的话就立即将该事件通知<strong>工作线程</strong>（<strong>逻辑单元</strong>），将socket可读可写事件放入<strong>请求队列</strong>，交给工作线程处理。除此之外，主线程不做任何其他实质性的工作。</p>
</li>
<li><p><u>读写数据，接受新的连接，以及处理客户请求</u>均在<strong>工作线程</strong>中完成。</p>
</li>
</ul>
<br>

<p>使用同步I&#x2F;O(epoll_wait为例)实现的Reactor模式的工作流程：</p>
<ol>
<li>主线程往epoll内核事件表中注册socket上的读就绪事件</li>
<li>主线程调用epoll_wait等待socket上有数据可读</li>
<li>当socket上有数据可读时，epoll_wait通知主线程。主线程则将socket可读事件放入请求队列</li>
<li>睡眠在请求队列上的某个工作线程被唤醒，它从socket读取数据，并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件</li>
<li>主线程调用epoll_wait等待socket可写</li>
<li>当socket可写时，epoll_wait通知主线程。主线程将socket可写事件放入请求队列</li>
<li>睡眠在请求队列上的某个工作线程被唤醒，他往socket上写入服务器处理客户请求的结果</li>
</ol>
<br>

<img src="/2023/03/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20230304030515214.png" alt="image-20230304030515214" style="zoom:90%;">

<br>

<br>

<h4 id="Proactor"><a href="#Proactor" class="headerlink" title="Proactor"></a>Proactor</h4><ul>
<li>将所有的<strong>I&#x2F;O操作</strong>都交给<strong>主线程和内核</strong>来处理(进行读、写)，<strong>工作线程仅仅负责业务逻辑</strong>。</li>
</ul>
<br>

<p>使用异步I&#x2F;O模型实现的Proactor模式的工作流程：（以 aio_read 和 aio_wirte 为例)</p>
<ol>
<li><strong>主线程</strong>调用 aio_read 函数向内核注册socket上的<strong>读完成事件</strong>，并告诉内核用户<strong>读缓冲区的位置</strong>，以及读操作完成时<strong>如何通知应用程序</strong>(这里以信号为例)</li>
<li>主线程继续处理其他逻辑</li>
<li>当socket上的数据被读入缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据已经可用</li>
<li><strong>应用程序</strong>预先定义好的<strong>信号处理函数</strong>选择一个工作线程来处理客户请求。<br><strong>工作线程</strong>处理完客户请求后，调用 aio_write 函数向内核注册socket上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序。</li>
<li>主线程继续处理其他逻辑</li>
<li>当用户数据被写入socket之后，内核将向应用程序发送以一个信号，以通知应用程序数据已经发送完毕</li>
<li>应用程序预先定义好的信号处理函数选择一个工作线程来做善后工作，比如决定是否关闭socket</li>
</ol>
<br>

<img src="/2023/03/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20230304032743438.png" alt="image-20230304032743438" style="zoom:90%;">



<br>

<br>

<h4 id="模拟Proactor模式"><a href="#模拟Proactor模式" class="headerlink" title="模拟Proactor模式"></a>模拟Proactor模式</h4><p>使用<strong>同步I&#x2F;O</strong>方式模拟Procator模式。</p>
<p><strong>原理</strong>：主线程执行数据读写操作，读写完成之后，主线程向工作线程通知这一”完成事件”。从工作线程的角度看，它们就直接获得了数据读写的结果，接下来要做的只是对读写的结果进行逻辑处理。</p>
<br>

<p>使用同步I&#x2F;O模型(epoll_wait为例)模拟Proactor模式的工作流程：</p>
<ol>
<li>主线程往epoll内核事件表中注册socket上的读就绪事件</li>
<li>主线程调用epoll_wait等待socket上有数据可读</li>
<li>当socket上有数据可读时，epoll_wait通知主线程。主线程从socket循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列</li>
<li>睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往epoll内核事件表中注册socket上的写就绪事件</li>
<li>主线程调用epoll_wait等待socket可写</li>
<li>当socket可写时，epoll_wait通知主线程。主线程往socket上写入服务器处理客户请求的结果</li>
</ol>
<br>

<img src="/2023/03/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20230304033941878.png" alt="image-20230304033941878" style="zoom:90%;">

<br>

<br>

<br>

<br>

<h2 id="5-5-线程同步机制类封装及线程池实现"><a href="#5-5-线程同步机制类封装及线程池实现" class="headerlink" title="5.5 线程同步机制类封装及线程池实现"></a>5.5 线程同步机制类封装及线程池实现</h2><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>线程池是由服务器预先创建的一组子线程，线程池中的线程数量应该和 CPU 数量差不多。</p>
<ul>
<li>线程池中的所有子线程都运行着相同的代码。</li>
<li>当有新的任务到来时，主线程将通过某种方式选择线程池中的某一个子线程来为之服务。</li>
<li>相于与动态的创建子线程，选择一个已经存在的子线程的代价显然要小得多。</li>
<li>至于主线程选择哪个子线程来为新任务服务，则有多种方式：<ul>
<li>主线程使用<strong>某种算法</strong>来主动选择子线程。最简单、最常用的算法是随机算法和 Round Robin（轮流选取）算法，但更优秀、更智能的算法将使任务在各个工作线程中更均匀地分配，从而减轻服务器的整体压力。</li>
<li>主线程和所有子线程通过一个<strong>共享的工作队列</strong>来同步，子线程都睡眠在该工作队列上。当有新的任务到来时，主线程将任务添加到工作队列中。这将唤醒正在等待任务的子线程，不过只有一个子线程将获得新任务的”接管权“，它可以从工作队列中取出任务并执行之，而其他子线程将继续睡眠在工作队列上。</li>
</ul>
</li>
</ul>
<br>

<p><img src="/2023/03/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20230304143320886.png" alt="线程池模型"></p>
<br>

<p><strong>线程数量</strong></p>
<p>线程池中的<strong>线程数量最直接的限制因素</strong>是中央处理器(CPU)的处理器(processors&#x2F;cores)的数量N ：如果你的CPU是4-cores的，对于<strong>CPU密集型</strong>的任务(如视频剪辑等消耗CPU计算资源的任务)来说，那线程池中的线程数量最好也设置为4（或者+1防止其他因素造成的线程阻塞）；对于<strong>IO密集型</strong>的任务，一般要多于CPU的核数，因为线程间竞争的不是CPU的计算资源而是IO，IO的处理一般较慢，多于cores数的线程将为CPU争取更多的任务，不至在线程处理IO的过程造成CPU空闲导致资源浪费。</p>
<p>还可以动态控制线程池中的线程数量。</p>
<br>

<p><strong>线程池的特点</strong></p>
<ul>
<li><strong>空间换时间</strong>，浪费服务器的硬件资源，换取运行效率。</li>
<li>池是一组资源的集合，这组资源在服务器启动之初就被完全创建好并初始化，这称为<strong>静态资源</strong>。</li>
<li>当服务器进入正式运行阶段，开始处理客户请求的时候，如果它需要相关的资源，可以直接从池中获取，<strong>无需动态分配</strong>。</li>
<li>当服务器处理完一个客户连接后，可以把相关的资源放回池中，<strong>无需执行系统调用释放资源</strong>。</li>
</ul>
<br>

<br>

<br>

<br>

<br>

<br>

<br>

<h2 id="5-6-其他内容"><a href="#5-6-其他内容" class="headerlink" title="5.6 其他内容"></a>5.6 其他内容</h2><p><strong>EPOLLONESHOT事件</strong></p>
<ul>
<li>即使可以使用 ET 模式，一个socket 上的某个事件还是可能被触发多次。这在并发程序中就会引起一个问题。比如一个线程在读取完某个 socket 上的数据后开始处理这些数据，而在数据的处理过程中该socket 上又有新数据可读（EPOLLIN 再次被触发），此时另外一个线程被唤醒来读取这些新的数据。于是就出现了两个线程同时操作一个 socket 的局面。一个socket连接在任一时刻都只被一个线程处理，可以使用 epoll 的 EPOLLONESHOT 事件实现。</li>
<li>对于注册了 EPOLLONESHOT 事件的文件描述符，操作系统最多触发其上注册的一个可读、可写或者异常事件，且只触发一次，除非我们使用 epoll_ctl 函数重置该文件描述符上注册的 EPOLLONESHOT 事件。这样，当一个线程在处理某个 socket 时，其他线程是不可能有机会操作该 socket 的。但反过来思考，注册了 EPOLLONESHOT 事件的 socket 一旦被某个线程处理完毕， 该线程就应该立即重置这个socket 上的 EPOLLONESHOT 事件，以确保这个 socket 下一次可读时，其 EPOLLIN 事件能被触发，进而让其他工作线程有机会继续处理这个 socket。</li>
</ul>
<br>

<br>

<br>

<p><strong>有限状态机</strong></p>
<ol>
<li>有限状态机：逻辑单元内部的一种高效编程方法：有限状态机（finite state machine）。有的应用层协议头部包含数据包类型字段，每种类型可以映射为逻辑单元的一种执行状态，服务器可以根据它来编写相应的处理逻辑。如下是一种状态独立的有限状态机：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">STATE_MACHINE</span>( Package _pack )</span><br><span class="line">&#123;</span><br><span class="line">	PackageType _type = _pack.<span class="built_in">GetType</span>();</span><br><span class="line">	<span class="keyword">switch</span>( _type )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> type_A:</span><br><span class="line">			<span class="built_in">process_package_A</span>( _pack );</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> type_B:</span><br><span class="line">			<span class="built_in">process_package_B</span>( _pack );</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;<span class="comment">// 上面是一个简单的有限状态机，只不过该状态机的每个状态都是相互独立的，即状态之间没有相互转移。</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>状态之间的转移是需要状态机内部驱动，如下代码：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">STATE_MACHINE</span>()</span><br><span class="line">&#123;</span><br><span class="line">	State cur_State = type_A;</span><br><span class="line">	<span class="keyword">while</span>( cur_State != type_C )</span><br><span class="line">	&#123;</span><br><span class="line">		Package _pack = <span class="built_in">getNewPackage</span>();</span><br><span class="line">		<span class="keyword">switch</span>( cur_State )</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> type_A:</span><br><span class="line">                <span class="built_in">process_package_state_A</span>( _pack );</span><br><span class="line">                cur_State = type_B;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> type_B:</span><br><span class="line">                <span class="built_in">process_package_state_B</span>( _pack );</span><br><span class="line">                cur_State = type_C;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该状态机包含三种状态：type_A、type_B 和 type_C，其中 type_A 是状态机的开始状态，type_C 是状态机的结束状态。状态机的当前状态记录在 cur_State 变量中。在一趟循环过程中，状态机先通getNewPackage 方法获得一个新的数据包，然后根据 cur_State 变量的值判断如何处理该数据包。数据包处理完之后，状态机通过给 cur_State 变量传递目标状态值来实现状态转移。那么当状态机进入下一趟循环时，它将执行新的状态对应的逻辑。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++开发</category>
        <category>高性能服务器</category>
      </categories>
      <tags>
        <tag>web服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>框架汇总</title>
    <url>/2022/07/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="算法学习"><a href="#算法学习" class="headerlink" title="算法学习"></a>算法学习</h1><br>

<h2 id="day1——核心框架汇总"><a href="#day1——核心框架汇总" class="headerlink" title="day1——核心框架汇总"></a>day1——核心框架汇总</h2><h3 id="1-框架思维"><a href="#1-框架思维" class="headerlink" title="1-框架思维"></a>1-框架思维</h3><h4 id="基本数据结构及其操作"><a href="#基本数据结构及其操作" class="headerlink" title="基本数据结构及其操作"></a>基本数据结构及其操作</h4><p>数据结构的存储方式只有两种：<strong>数组（顺序存储）和链表（链式存储）</strong></p>
<p>在此之上可以构成：<strong>散列表、栈、队列、堆、树、图等等各种数据结构</strong></p>
<p>基本操作：无非就是<strong>遍历 + 访问</strong>，再具体一点就是：<strong>增删查改</strong>。</p>
<p>数据结构种类很多，但它们存在的目的都是在不同的应用场景，尽可能高效地增删查改。</p>
<hr>
<h4 id="算法的框架思维"><a href="#算法的框架思维" class="headerlink" title="算法的框架思维"></a>算法的框架思维</h4><p>数组遍历框架</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">voidtraverse</span>(<span class="type">int</span>[]arr)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i &lt;arr.length; i++)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 迭代访问 arr[i]</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<p>链表遍历框架，兼具迭代和递归结构：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 基本的单链表节点 */</span></span><br><span class="line"></span><br><span class="line">classListNode&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">voidtraverse</span>(ListNodehead)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(ListNode p = head; p != null; p =p.next)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 迭代访问 p.val</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">voidtraverse</span>(ListNodehead)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归访问 head.val</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">traverse</span>(head.next);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<p>二叉树遍历框架，典型的非线性递归遍历结构：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 基本的二叉树节点 */</span></span><br><span class="line"></span><br><span class="line">classTreeNode&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">    TreeNode left, right;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">voidtraverse</span>(TreeNoderoot)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">traverse</span>(root.left);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">traverse</span>(root.right);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<p>N 叉树的遍历框架：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 基本的 N 叉树节点 */</span></span><br><span class="line"></span><br><span class="line">classTreeNode&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">    TreeNode[] children;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">voidtraverse</span>(TreeNoderoot)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(TreeNode child :root.children)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">traverse</span>(child);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>1、先学习像数组、链表这种基本数据结构的常用算法</strong></p>
<p><strong>2、学会基础算法之后，不要急着上来就刷回溯算法、动态规划这类笔试常考题，而应该先刷二叉树</strong></p>
<hr>
<br>

<h3 id="2-刷题心得"><a href="#2-刷题心得" class="headerlink" title="2-刷题心得"></a>2-刷题心得</h3><h4 id="数组-x2F-单链表系列算法"><a href="#数组-x2F-单链表系列算法" class="headerlink" title="数组&#x2F;单链表系列算法"></a>数组&#x2F;单链表系列算法</h4><blockquote>
<p>-<strong>单链表常考的技巧就是双指针</strong></p>
</blockquote>
<blockquote>
<p>-<strong>数组常用的技巧有很大一部分还是双指针相关的技巧，说白了是教你如何聪明地进行穷举</strong></p>
</blockquote>
<blockquote>
<p>-<strong>滑动窗口算法技巧，典型的快慢双指针，快慢指针中间就是滑动的「窗口」，主要用于解决子串问题。</strong></p>
</blockquote>
<blockquote>
<p>-**最后说说 <a href="https://labuladong.github.io/algo/2/20/24/">前缀和技巧</a> 和 <a href="https://labuladong.github.io/algo/2/20/25/">差分数组技巧</a>**。</p>
</blockquote>
<blockquote>
<blockquote>
<p>如果频繁地让你计算子数组的和，每次用 for 循环去遍历肯定没问题，但前缀和技巧预计算一个 <code>preSum</code> 数组，就可以避免循环。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>类似的，如果频繁地让你对子数组进行增减操作，也可以每次用 for 循环去操作，但差分数组技巧维护一个 <code>diff</code> 数组，也可以避免循环。</p>
</blockquote>
</blockquote>
<br>

<h4 id="二叉树系列算法"><a href="#二叉树系列算法" class="headerlink" title="二叉树系列算法"></a>二叉树系列算法</h4><p>二叉树题目的递归解法可以分两类思路，第一类是遍历一遍二叉树得出答案，第二类是通过分解问题计算出答案，这两类思路分别对应着 <a href="https://labuladong.github.io/algo/4/31/105/">回溯算法核心框架</a> 和 <a href="https://labuladong.github.io/algo/3/25/69/">动态规划核心框架</a>。</p>
<p>更进一步，图论相关的算法也是二叉树算法的延续。</p>
<p>比如 <a href="https://labuladong.github.io/algo/2/22/50/">图论基础</a>， <a href="https://labuladong.github.io/algo/2/22/51/">环判断和拓扑排序</a> 和 <a href="https://labuladong.github.io/algo/2/22/52/">二分图判定算法</a> 就用到了 DFS 算法；再比如 <a href="https://labuladong.github.io/algo/2/22/56/">Dijkstra 算法模板</a>，就是改造版 BFS 算法加上一个类似 dp table 的数组。</p>
<p>这些算法的本质都是穷举二（多）叉树，有机会的话通过剪枝或者备忘录的方式减少冗余计算，提高效率，就这么点事儿。</p>
<hr>
<br>

<h3 id="3-双指针（七道链表题）"><a href="#3-双指针（七道链表题）" class="headerlink" title="3-双指针（七道链表题）"></a>3-双指针（七道链表题）</h3><br>

<h4 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h4><p>用到了3个指针：指向原链表的p1、p2，连接链表的p</p>
<p>注意要新建一个空的链表头</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">ListNodemergeTwoLists</span>(ListNodel1,ListNodel2)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 虚拟头结点</span></span><br><span class="line"></span><br><span class="line">    ListNode dummy =<span class="built_in">newListNode</span>(<span class="number">-1</span>), p = dummy;</span><br><span class="line"></span><br><span class="line">    ListNode p1 = l1, p2 = l2;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p1 != null &amp;&amp; p2 != null)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较 p1 和 p2 两个指针</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将值较小的的节点接到 p 指针</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(p1.val&gt;p2.val)&#123;</span><br><span class="line"></span><br><span class="line">            p.next= p2;</span><br><span class="line"></span><br><span class="line">            p2 =p2.next;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">            p.next= p1;</span><br><span class="line"></span><br><span class="line">            p1 =p1.next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// p 指针不断前进</span></span><br><span class="line"></span><br><span class="line">        p =p.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p1 != null)&#123;</span><br><span class="line"></span><br><span class="line">        p.next= p1;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p2 != null)&#123;</span><br><span class="line"></span><br><span class="line">        p.next= p2;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    returndummy.next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<h4 id="链表的分解"><a href="#链表的分解" class="headerlink" title="链表的分解"></a>链表的分解</h4><p><img src="https://labuladong.github.io/algo/images/%e9%93%be%e8%a1%a8%e6%8a%80%e5%b7%a7/title4.jpg" alt="img"></p>
<br>

<h4 id="合并k个有序链表"><a href="#合并k个有序链表" class="headerlink" title="合并k个有序链表"></a>合并k个有序链表</h4><p>利用优先级队列（堆）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">ListNodemergeKLists</span>(ListNode[]lists)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(lists.length==<span class="number">0</span>)<span class="keyword">return</span> null;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 虚拟头结点</span></span><br><span class="line"></span><br><span class="line">    ListNode dummy =<span class="built_in">newListNode</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    ListNode p = dummy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优先级队列，最小堆</span></span><br><span class="line"></span><br><span class="line">    PriorityQueue&lt;ListNode&gt; pq =newPriorityQueue&lt;&gt;(</span><br><span class="line"></span><br><span class="line">        lists.length,(a, b)-&gt;(a.val-b.val));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 k 个链表的头结点加入最小堆</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(ListNode head : lists)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(head != null)</span><br><span class="line"></span><br><span class="line">            pq.<span class="built_in">add</span>(head);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!pq.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取最小节点，接到结果链表中</span></span><br><span class="line"></span><br><span class="line">        ListNode node =pq.<span class="built_in">poll</span>();</span><br><span class="line"></span><br><span class="line">        p.next= node;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node.next!= null)&#123;</span><br><span class="line"></span><br><span class="line">            pq.<span class="built_in">add</span>(node.next);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// p 指针不断前进</span></span><br><span class="line"></span><br><span class="line">        p =p.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    returndummy.next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>优先队列 <code>pq</code> 中的元素个数最多是 <code>k</code>，所以一次 <code>poll</code> 或者 <code>add</code> 方法的时间复杂度是 <code>O(logk)</code>；所有的链表节点都会被加入和弹出 <code>pq</code>，<strong>所以算法整体的时间复杂度是 <code>O(Nlogk)</code>，其中 <code>k</code> 是链表的条数，<code>N</code> 是这些链表的节点总数</strong>。</p>
<br>

<h4 id="寻找单链表的倒数第k个节点"><a href="#寻找单链表的倒数第k个节点" class="headerlink" title="寻找单链表的倒数第k个节点"></a>寻找单链表的倒数第k个节点</h4><p>不告诉链表长度；</p>
<p>只遍历一次链表的解法：用p1走k步后，p2再出发</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 返回链表的倒数第 k 个节点</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">ListNodefindFromEnd</span>(ListNodehead,intk)&#123;</span><br><span class="line"></span><br><span class="line">    ListNode p1 = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// p1 先走 k 步</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line"></span><br><span class="line">        p1 =p1.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode p2 = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// p1 和 p2 同时走 n - k 步</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p1 != null)&#123;</span><br><span class="line"></span><br><span class="line">        p2 =p2.next;</span><br><span class="line"></span><br><span class="line">        p1 =p1.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// p2 现在指向第 n - k + 1 个节点，即倒数第 k 个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p2;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<h4 id="寻找单链表的中点"><a href="#寻找单链表的中点" class="headerlink" title="寻找单链表的中点"></a>寻找单链表的中点</h4><p>利用快慢指针：快指针走两步，慢指针走一步</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">ListNodemiddleNode</span>(ListNodehead)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快慢指针初始化指向 head</span></span><br><span class="line"></span><br><span class="line">    ListNode slow = head, fast = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快指针走到末尾时停止</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(fast != null &amp;&amp;fast.next!= null)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 慢指针走一步，快指针走两步</span></span><br><span class="line"></span><br><span class="line">        slow =slow.next;</span><br><span class="line"></span><br><span class="line">        fast =fast.next.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 慢指针指向中点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>需要注意的是，如果链表长度为偶数，也就是说中点有两个的时候，我们这个解法返回的节点是靠后的那个节点。</p>
<br>

<h4 id="判断单链表是否包含环并找出环起点"><a href="#判断单链表是否包含环并找出环起点" class="headerlink" title="判断单链表是否包含环并找出环起点"></a>判断单链表是否包含环并找出环起点</h4><p>判断是否含环：快慢指针，如果最终快指针赶上慢指针说明有环。否则快指针遍历直到空指针。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">booleanhasCycle</span>(ListNodehead)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快慢指针初始化指向 head</span></span><br><span class="line"></span><br><span class="line">    ListNode slow = head, fast = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快指针走到末尾时停止</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(fast != null &amp;&amp;fast.next!= null)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 慢指针走一步，快指针走两步</span></span><br><span class="line"></span><br><span class="line">        slow =slow.next;</span><br><span class="line"></span><br><span class="line">        fast =fast.next.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 快慢指针相遇，说明含有环</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(slow == fast)&#123;</span><br><span class="line"></span><br><span class="line">            returntrue;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不包含环</span></span><br><span class="line"></span><br><span class="line">    returnfalse;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>若有环，如何判断环的起点</p>
<blockquote>
<p>当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">ListNodedetectCycle</span>(ListNodehead)&#123;</span><br><span class="line"></span><br><span class="line">    ListNode fast, slow;</span><br><span class="line"></span><br><span class="line">    fast = slow = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(fast != null &amp;&amp;fast.next!= null)&#123;</span><br><span class="line"></span><br><span class="line">        fast =fast.next.next;</span><br><span class="line"></span><br><span class="line">        slow =slow.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(fast == slow)<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上面的代码类似 hasCycle 函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fast == null ||fast.next== null)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// fast 遇到空指针说明没有环</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> null;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新指向头结点</span></span><br><span class="line"></span><br><span class="line">    slow = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快慢指针同步前进，相交点就是环起点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line"></span><br><span class="line">        fast =fast.next;</span><br><span class="line"></span><br><span class="line">        slow =slow.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<h4 id="判断两个单链表是否相交并找出交点"><a href="#判断两个单链表是否相交并找出交点" class="headerlink" title="判断两个单链表是否相交并找出交点"></a>判断两个单链表是否相交并找出交点</h4><p>不使用Hashmap的实现，即仅使用两个指针</p>
<blockquote>
<p>我们可以让 <code>p1</code> 遍历完链表 <code>A</code> 之后开始遍历链表 <code>B</code>，让 <code>p2</code> 遍历完链表 <code>B</code> 之后开始遍历链表 <code>A</code>，这样相当于「逻辑上」两条链表接在了一起。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">ListNodegetIntersectionNode</span>(ListNodeheadA,ListNodeheadB)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// p1 指向 A 链表头结点，p2 指向 B 链表头结点</span></span><br><span class="line"></span><br><span class="line">    ListNode p1 = headA, p2 = headB;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p1 != p2)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// p1 走一步，如果走到 A 链表末尾，转到 B 链表</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(p1 == null) p1 = headB;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>            p1 =p1.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// p2 走一步，如果走到 B 链表末尾，转到 A 链表</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(p2 == null) p2 = headA;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>            p2 =p2.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>或者通过预先求出两个链表的长度，来使p1、p2同时到达相交节点</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> lenA =<span class="number">0</span>, lenB =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算两条链表的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(ListNode p1 = headA; p1 != null; p1 =p1.next)&#123;</span><br><span class="line"></span><br><span class="line">        lenA++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(ListNode p2 = headB; p2 != null; p2 =p2.next)&#123;</span><br><span class="line"></span><br><span class="line">        lenB++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让 p1 和 p2 到达尾部的距离相同</span></span><br><span class="line"></span><br><span class="line">    ListNode p1 = headA, p2 = headB;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(lenA &gt; lenB)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i &lt; lenA - lenB; i++)&#123;</span><br><span class="line"></span><br><span class="line">            p1 =p1.next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i &lt; lenB - lenA; i++)&#123;</span><br><span class="line"></span><br><span class="line">            p2 =p2.next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 看两个指针是否会相同，p1 == p2 时有两种情况：</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、要么是两条链表不相交，他俩同时走到尾部空指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、要么是两条链表相交，他俩走到两条链表的相交点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p1 != p2)&#123;</span><br><span class="line"></span><br><span class="line">        p1 =p1.next;</span><br><span class="line"></span><br><span class="line">        p2 =p2.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<br>

<h3 id="4-双指针（七道数组题）"><a href="#4-双指针（七道数组题）" class="headerlink" title="4-双指针（七道数组题）"></a>4-双指针（七道数组题）</h3><blockquote>
<p>链表和数组题中的双指针有两种</p>
</blockquote>
<blockquote>
<p>-<strong>左右指针</strong>，就是两个指针相向而行或者相背而行；</p>
</blockquote>
<blockquote>
<p>-<strong>快慢指针</strong>，就是两个指针同向而行，一快一慢。</p>
</blockquote>
<br>

<h4 id="快慢指针技巧"><a href="#快慢指针技巧" class="headerlink" title="快慢指针技巧"></a>快慢指针技巧</h4><blockquote>
<p>原地修改数组</p>
</blockquote>
<h5 id="删除有序数组中的重复项"><a href="#删除有序数组中的重复项" class="headerlink" title="删除有序数组中的重复项"></a>删除有序数组中的重复项</h5><p>在不新开数组的情况下的解法</p>
<p><img src="https://labuladong.github.io/algo/images/%e6%95%b0%e7%bb%84%e5%8e%bb%e9%87%8d/1.gif" alt="img"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">intremoveDuplicates</span>(<span class="type">int</span>[]nums)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(nums.length==<span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">        return0;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> slow =<span class="number">0</span>, fast =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(fast &lt;nums.length)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums[fast]!=nums[slow])&#123;</span><br><span class="line"></span><br><span class="line">            slow++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 维护 nums[0..slow] 无重复</span></span><br><span class="line"></span><br><span class="line">            nums[slow]=nums[fast];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fast++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组长度为索引 + 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slow +<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于删除有序链表中的重复项呢？</p>
<p><img src="https://labuladong.github.io/algo/images/%e6%95%b0%e7%bb%84%e5%8e%bb%e9%87%8d/2.gif" alt="img"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">ListNodedeleteDuplicates</span>(ListNodehead)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(head == null)<span class="keyword">return</span> null;</span><br><span class="line"></span><br><span class="line">    ListNode slow = head, fast = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(fast != null)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(fast.val!=slow.val)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// nums[slow] = nums[fast];</span></span><br><span class="line"></span><br><span class="line">            slow.next= fast;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// slow++;</span></span><br><span class="line"></span><br><span class="line">            slow =slow.next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// fast++</span></span><br><span class="line"></span><br><span class="line">        fast =fast.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 断开与后面重复元素的连接</span></span><br><span class="line"></span><br><span class="line">    slow.next= null;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<h5 id="删除无序数组中的某个元素"><a href="#删除无序数组中的某个元素" class="headerlink" title="删除无序数组中的某个元素"></a>删除无序数组中的某个元素</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">intremoveElement</span>(<span class="type">int</span>[]nums,intval)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fast =<span class="number">0</span>, slow =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(fast &lt;nums.length)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums[fast]!= val)&#123;</span><br><span class="line"></span><br><span class="line">            nums[slow]=nums[fast];</span><br><span class="line"></span><br><span class="line">            slow++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fast++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里是先给 <code>nums[slow]</code> 赋值然后再给 slow++</p>
<br>

<h5 id="移动0"><a href="#移动0" class="headerlink" title="移动0"></a>移动0</h5><blockquote>
<p>比如说给你输入 <code>nums = [0,1,4,0,2]</code>，你的算法没有返回值，但是会把 <code>nums</code> 数组原地修改成 <code>[1,4,2,0,0]</code>。</p>
</blockquote>
<blockquote>
<p>其实就相当于移除 <code>nums</code> 中的所有 0，然后再把后面的元素都赋值为 0 即可。</p>
</blockquote>
<p>可以复用上一题的 <code>removeElement</code> 函数</p>
<br>

<h4 id="滑动窗口类型（快慢指针）"><a href="#滑动窗口类型（快慢指针）" class="headerlink" title="滑动窗口类型（快慢指针）"></a>滑动窗口类型（快慢指针）</h4><p>代码框架</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 滑动窗口算法框架 */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">voidslidingWindow</span>(strings,stringt)&#123;</span><br><span class="line"></span><br><span class="line">    unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; need, window;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c : t)need[c]++;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left =<span class="number">0</span>, right =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> valid =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(right &lt;s.<span class="built_in">size</span>())&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> c =s[right];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右移（增大）窗口</span></span><br><span class="line"></span><br><span class="line">        right++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(window needs shrink)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">char</span> d =s[left];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 左移（缩小）窗口</span></span><br><span class="line"></span><br><span class="line">            left++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>left</code> 指针在后，<code>right</code> 指针在前，两个指针中间的部分就是「窗口」，算法通过扩大和缩小「窗口」来解决某些问题。</p>
<hr>
<br>

<h4 id="左右指针技巧"><a href="#左右指针技巧" class="headerlink" title="左右指针技巧"></a>左右指针技巧</h4><h5 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h5><p>简单框架</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">intbinarySearch</span>(<span class="type">int</span>[]nums,inttarget)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一左一右两个指针相向而行</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left =<span class="number">0</span>, right =nums.length<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> mid =(right + left)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums[mid]== target)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">elseif</span>(nums[mid]&lt; target)</span><br><span class="line"></span><br><span class="line">            left = mid +<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">elseif</span>(nums[mid]&gt; target)</span><br><span class="line"></span><br><span class="line">            right = mid <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span><span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<h5 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h5><p>返回的下标是从1算起的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span>[] <span class="built_in">twoSum</span>(<span class="type">int</span>[] nums,<span class="type">int</span> target)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一左一右两个指针相向而行</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left =<span class="number">0</span>, right =nums.length<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> sum =nums[left]+nums[right];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 题目要求的索引是从 1 开始的</span></span><br><span class="line"></span><br><span class="line">            returnnewint[]&#123;left +<span class="number">1</span>, right +<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="built_in">elseif</span>(sum &lt; target)&#123;</span><br><span class="line"></span><br><span class="line">            left++; <span class="comment">// 让 sum 大一点 *</span></span><br><span class="line"></span><br><span class="line">        &#125;<span class="built_in">elseif</span>(sum &gt; target)&#123;</span><br><span class="line"></span><br><span class="line">            right--; <span class="comment">// 让 sum 小一点 *</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    returnnewint[]&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<h5 id="反转数组"><a href="#反转数组" class="headerlink" title="反转数组"></a>反转数组</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">voidreverseString</span>(<span class="type">char</span>[]s)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一左一右两个指针相向而行</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left =<span class="number">0</span>, right =s.length<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 交换 s[left] 和 s[right]</span></span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> temp =s[left];</span><br><span class="line"></span><br><span class="line">        s[left]=s[right];</span><br><span class="line"></span><br><span class="line">        s[right]= temp;</span><br><span class="line"></span><br><span class="line">        left++;</span><br><span class="line"></span><br><span class="line">        right--;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<h5 id="回文串匹配"><a href="#回文串匹配" class="headerlink" title="回文串匹配"></a>回文串匹配</h5><p>简单匹配</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">booleanisPalindrome</span>(Strings)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一左一右两个指针相向而行</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left =<span class="number">0</span>, right =s.<span class="built_in">length</span>()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">charAt</span>(left)!=s.<span class="built_in">charAt</span>(right))&#123;</span><br><span class="line"></span><br><span class="line">            returnfalse;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        left++;</span><br><span class="line"></span><br><span class="line">        right--;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    returntrue;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<p><strong>最长回文子串</strong></p>
<blockquote>
<p>左右指针从中间往两边延申</p>
</blockquote>
<blockquote>
<p>如果回文串的长度为奇数，参数 r &#x3D; l</p>
</blockquote>
<blockquote>
<p>如果回文串的长度为偶数，参数 r &#x3D; l+1</p>
</blockquote>
<blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 s 中寻找以 s[l] 和 s[r] 为中心的最长回文串</span></span><br><span class="line"><span class="built_in">Stringpalindrome</span>(Strings,intl,intr)&#123;</span><br><span class="line"><span class="comment">// 防止索引越界</span></span><br><span class="line"><span class="keyword">while</span>(l &gt;=<span class="number">0</span>&amp;&amp; r &lt;s.<span class="built_in">length</span>()</span><br><span class="line">&amp;&amp;s.<span class="built_in">charAt</span>(l)==s.<span class="built_in">charAt</span>(r))&#123;</span><br><span class="line"><span class="comment">// 双指针，向两边展开</span></span><br><span class="line">l--; r++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回以 s[l] 和 s[r] 为中心的最长回文串</span></span><br><span class="line">returns.<span class="built_in">substring</span>(l +<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">StringlongestPalindrome</span>(Strings)&#123;</span><br><span class="line"></span><br><span class="line">    String res =<span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i &lt;s.<span class="built_in">length</span>(); i++)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以 s[i] 为中心的最长回文子串</span></span><br><span class="line"></span><br><span class="line">        String s1 =<span class="built_in">palindrome</span>(s, i, i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以 s[i] 和 s[i+1] 为中心的最长回文子串</span></span><br><span class="line"></span><br><span class="line">        String s2 =<span class="built_in">palindrome</span>(s, i, i +<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// res = longest(res, s1, s2)</span></span><br><span class="line"></span><br><span class="line">        res =res.<span class="built_in">length</span>()&gt;s1.<span class="built_in">length</span>()? res : s1;</span><br><span class="line"></span><br><span class="line">        res =res.<span class="built_in">length</span>()&gt;s2.<span class="built_in">length</span>()? res : s2;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux网络编程</title>
    <url>/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<br>

<h1 id="第四章-Linux网络编程"><a href="#第四章-Linux网络编程" class="headerlink" title="第四章 Linux网络编程"></a>第四章 Linux网络编程</h1><hr>
<br>

<h2 id="4-1-计算机网络相关知识"><a href="#4-1-计算机网络相关知识" class="headerlink" title="4.1 计算机网络相关知识"></a>4.1 计算机网络相关知识</h2><br>

<h3 id="4-1-1-网络结构模式"><a href="#4-1-1-网络结构模式" class="headerlink" title="4.1.1 网络结构模式"></a>4.1.1 网络结构模式</h3><h4 id="C-x2F-S结构"><a href="#C-x2F-S结构" class="headerlink" title="C&#x2F;S结构"></a>C&#x2F;S结构</h4><p><strong>简介</strong></p>
<ul>
<li>服务器 - 客户机，即 Client - Server（C&#x2F;S）结构。<strong>C&#x2F;S 结构通常采取两层结构。服务器负责数据的管理，客户机负责完成与用户的交互任务。</strong>客户机是因特网上访问别人信息的机器，服务器则是提供信息供人访问的计算机。</li>
<li><strong>客户机通过局域网与服务器相连，接受用户的请求，并通过网络向服务器提出请求，对数据库进行操作。服务器接受客户机的请求，将数据提交给客户机，客户机将数据进行计算并将结果呈现给用户。</strong>服务器还要提供完善安全保护及对数据完整性的处理等操作，并允许多个客户机同时访问服务器，这就对服务器的硬件处理数据能力提出了很高的要求。</li>
<li>在C&#x2F;S结构中，<strong>应用程序分为两部分：服务器部分和客户机部分。</strong>服务器部分是多个用户共享的信息与功能，执行后台服务，如控制共享数据库的操作等；客户机部分为用户所专有，负责执行前台功能，在出错提示、在线帮助等方面都有强大的功能，并且可以在子程序间自由切换。</li>
</ul>
<br>

<p><strong>优点</strong></p>
<ol>
<li>能充分发挥客户端 PC 的处理能力，<strong>很多工作可以在客户端处理后再提交给服务器，</strong>所以 C&#x2F;S 结构<strong>客户端响应速度快</strong>；</li>
<li>操作界面漂亮、形式多样，可以充分满足客户自身的<strong>个性化</strong>要求；</li>
<li>C&#x2F;S 结构的<strong>管理信息系统具有较强的事务处理能力</strong>，能实现复杂的业务流程；</li>
<li><strong>安全性较高</strong>，C&#x2F;S 一般面向相对固定的用户群，<strong>程序更加注重流程</strong>，它可以<strong>对权限进行多层次校验</strong>，提供了更安全的存取模式，对信息安全的控制能力很强，一般<strong>高度机密</strong>的信息系统采用 C&#x2F;S 结构适宜。</li>
</ol>
<br>

<p><strong>缺点</strong></p>
<ol>
<li><strong>客户端需要安装专用的客户端软件</strong>。首先涉及到安装的工作量，其次任何一台电脑出问题，如病毒、硬件损坏，都需要进行安装或维护。系统软件升级时，每一台客户机需要重新安装，其维护和升级成本非常高；</li>
<li><strong>对客户端的操作系统一般也会有限制，不能够跨平台</strong></li>
</ol>
<br>

<br>

<h4 id="B-x2F-S-结构"><a href="#B-x2F-S-结构" class="headerlink" title="B&#x2F;S 结构"></a>B&#x2F;S 结构</h4><p><strong>简介</strong></p>
<ul>
<li>B&#x2F;S 结构（Browser&#x2F;Server，浏览器&#x2F;服务器模式），<strong>是WEB兴起后的一种网络结构模式，WEB浏览器是客户端最主要的应用软件。</strong>这种模式<strong>统一了客户端</strong>，将系统功能实现的<strong>核心部分集中到服务器上</strong>，简化了系统的开发、维护和使用。客户机上只要安装一个浏览器，如 Firefox 或 InternetExplorer，服务器安装 SQL Server、Oracle、MySQL 等数据库。浏览器通过 Web Server 同数据库进行数据交互</li>
</ul>
<br>

<p><strong>优点</strong></p>
<ul>
<li>B&#x2F;S 架构最大的优点是总体拥有<strong>成本低、维护方便、 分布性强、开发简单</strong>，可以不用安装任何专门的软件就能实现在任何地方进行操作，客户端零维护，系统的扩展非常容易，只要有一台能上网的电脑就能使用。</li>
</ul>
<br>

<p><strong>缺点</strong></p>
<ol>
<li><strong>通信开销大、系统和数据的安全性较难保障;</strong></li>
<li>个性特点明显降低，无法实现具有个性化的功能要求；</li>
<li>协议一般是<strong>固定</strong>的：<strong>http&#x2F;https</strong>（无法输出大数据）</li>
<li>客户端服务器端的交互是<strong>请求-响应模式</strong>，通常<strong>动态刷新</strong>页面，<strong>响应速度明显降低</strong>。</li>
</ol>
<br>

<br>

<br>

<h3 id="4-1-2-MAC、IP、端口"><a href="#4-1-2-MAC、IP、端口" class="headerlink" title="4.1.2 MAC、IP、端口"></a>4.1.2 MAC、IP、端口</h3><h4 id="网卡"><a href="#网卡" class="headerlink" title="网卡"></a>网卡</h4><p>（网卡分为 以太网卡 和 无线网卡 ）</p>
<ul>
<li>网卡是一块被设计用来允许计算机在计算机网络上进行通讯的计算机硬件，又称为 <strong>网络适配器</strong> 或 <strong>网络接口卡NIC</strong> 。</li>
<li>其<strong>拥有 MAC 地址</strong>，属于 OSI 模型的<strong>第 2 层</strong>，它使得用户可以通过电缆或无线相互连接。</li>
<li>每一个网卡都有一个被称为 MAC 地址的独一无二的 <strong>48 位</strong>串行号。</li>
<li>网卡的主要功能：<ul>
<li>数据的封装与解封装</li>
<li>链路管理</li>
<li>数据编码与译码</li>
</ul>
</li>
</ul>
<br>

<h4 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h4><ul>
<li>Media Access Control Address</li>
<li>直译为 <strong>媒体存取控制位址</strong> ，也称为 <strong>局域网地址</strong>、<strong>以太网地址</strong>、<strong>物理地址</strong> 或 <strong>硬件地址</strong> ，它是一个用来确认网络设备位置的位址，由网络设备制造商生产时烧录在网卡中</li>
<li>在 OSI 模型中，<strong>第三层网络层负责IP地址，第二层数据链路层则负责MAC位址</strong> </li>
<li>MAC 地址用于在网络中<strong>唯一标识一个网卡</strong>。一台设备若有一或多个网卡，则每个网卡都需要并会有一个唯一的 MAC 地址。</li>
<li>MAC 地址的长度为 <strong>48 位（6个字节）</strong>，通常表示为 12 个 16 进制数，如：00-16-EA-AE-3C-40 就是一个MAC 地址。<ul>
<li>其中前 3 个字节，16 进制数 00-16-EA 代表网络硬件制造商的编号，它由IEEE（电气与电子工程师协会）分配</li>
<li>而后 3 个字节，16进制数 AE-3C-40 代表该制造商所制造的某个网络产品（如网卡）的系列号。</li>
<li>只要不更改自己的 MAC 地址，MAC 地址在世界是唯一的。形象地说，MAC 地址就如同身份证上的身份证号码，具有唯性。</li>
</ul>
</li>
</ul>
<br>

<h4 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h4><p><strong>简介</strong></p>
<p>​	IP（Internet Protocol）协议是为计算机网络相互连接进行通信而设计的协议。在 <strong>因特网</strong> 中，它是能使连接到网上的所有计算机网络实现相互通信的一套规则，规定了计算机在因特网上进行通信时应当遵守的规则。任何厂家生产的计算机系统，只要遵守IP协议就可以与因特网互连互通。</p>
<p>​	各个厂家生产的网络系统和设备，如以太网、分组交换网等，它们相互之间不能互通，不能互通的主要原因是因为它们所传送数据的基本单元（技术上称之为“帧”）的格式不同。IP 协议实际上是一套由软件程序组成的协议软件，它把各种不同“<strong>帧</strong>”统一转换成“<strong>IP 数据报</strong>”格式，这种转换是因特网的一个最重要的特点，使所有各种计算机都能在因特网上实现互通，即具有“开放性”的特点。正是因为有了 IP 协议，因特网才得以迅速发展成为世界上最大的、开放的计算机通信网络。因此，IP 协议也可以叫做“<strong>因特网协议</strong>”。</p>
<br>

<ul>
<li><p><strong>IP地址</strong>（Internet Protocol Address）是指<strong>互联网协议地址</strong>，又译为<strong>网际协议地址</strong>。IP 地址是IP协议提供的一种统一的地址格式，<strong>它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异</strong></p>
</li>
<li><p>IP 地址是一个 <strong>32 位的二进制数</strong>，通常被分割为 <strong>4 个“ 8 位二进制数”</strong>（也就是 4 个字节）。</p>
</li>
</ul>
<br>

<p><strong>IP地址类型</strong></p>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230210225815319.png" alt="image-20230210225815319"></p>
<p>补充：</p>
<ul>
<li>D类IP地址：D 类 IP 地址在历史上被叫做多播地址（multicast address），即组播地址。在以太网中，多播地址命名了一组应该在这个网络中应用接收到一个分组的站点。多播地址的最高位必须是 “1110”，范围从224.0.0.0 - 239.255.255.255。</li>
<li><strong>特殊的网址</strong>（E类）：<ul>
<li>每一个字节都为 0 的地址（ “0.0.0.0” ）对应于当前主机；</li>
<li>IP 地址中的每一个字节都为 1 的 IP 地址（ “255.255.255.255” ）是当前子网的广播地址；</li>
<li>IP 地址中凡是以 “11110” 开头的 E 类 IP 地址都保留用于将来和实验使用。</li>
<li>IP地址中不能以十进制 “127” 作为开头，该类地址中数字 127.0.0.1 到 127.255.255.255 用于回路测试，如：127.0.0.1可以代表本机IP地址</li>
</ul>
</li>
</ul>
<br>

<p><strong>子网掩码</strong></p>
<ul>
<li>子网掩码（subnet mask）又叫网络掩码、地址掩码、子网络遮罩，它是一种用来指明一个 IP 地址的哪些位标识的是主机所在的子网，以及哪些位标识的是主机的位掩码。子网掩码不能单独存在，它必须结合 IP 地址一起用。子网掩码只有一个作用，就是<strong>将某个 IP 地址划分成 网络地址 和 主机地址 两部分</strong>。</li>
<li>子网掩码是一个 32 位地址，用于屏蔽 IP 地址的一部分以区别网络标识和主机标识，并说明该 IP地址是在局域网上，还是在广域网上。</li>
<li>子网掩码是在 IPv4 地址资源紧缺的背景下为了解决 IP 地址分配而产生的虚拟 IP 技术，通过子网掩码将A、B、C 三类地址划分为若干子网，从而显著提高了 IP 地址的分配效率，有效解决了 IP 地址资源紧张的局面。另一方面，在企业内网中为了更好地管理网络，网管人员也利用子网掩码的作用，人为地将一个较大的企业内部网络划分为更多个小规模的子网，再利用三层交换机的路由功能实现子网互联，从而有效解决了网络广播风暴和网络病毒等诸多网络管理方面的问题。</li>
</ul>
<br>

<br>

<h4 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h4><blockquote>
<p>端口 就是一块缓冲区，有 读缓冲 和 写缓冲 </p>
</blockquote>
<p><strong>简介</strong></p>
<ul>
<li>端口 是英文 port 的意译，可以认为是设备与外界通讯交流的出口。端口可分为 <strong>虚拟端口</strong> 和 <strong>物理端口</strong> ，<ul>
<li><strong>虚拟端口</strong> 指<strong>计算机内部或交换机路由器内的端口</strong>，<strong>不可见</strong>，是特指<strong>TCP&#x2F;IP协议中的端口</strong>，是<strong>逻辑意义上</strong>的端口。例如计算机中的 80 端口、21 端口、23 端口等。</li>
<li><strong>物理端口</strong> 又称为<strong>接口</strong>，<strong>是可见端口</strong>，计算机背板的 RJ45 网口，交换机路由器集线器等 RJ45 端口。电话使用 RJ11 插口也属于物理端口的范畴。</li>
</ul>
</li>
<li>如果把 IP 地址比作一间房子，端口就是出入这间房子的门。真正的房子只有几个门，但是一个 IP地址的端口可以有 <strong>65536</strong>（即：2^16）个之多！端口是通过端口号来标记的，端口号只有整数，范围是从 <strong>0 到 65535</strong>（2^16-1）。</li>
</ul>
<br>

<p><strong>端口类型</strong></p>
<ul>
<li><p><strong>周知端口</strong> Well Known Ports ：</p>
<ul>
<li>也叫知名端口、公认端口或者常用端口，范围从 <strong>0 到 1023</strong>，它们紧密绑定于一些特定的服务。</li>
<li>例如 <strong>80 端口分配给 WWW 服务，21 端口分配给 FTP 服务，23 端口分配给Telnet服务</strong>等等。</li>
<li>网络服务是可以使用其他端口号的，比如使用“8080” 作为 WWW服务的端口；但是有些系统协议使用固定的端口号，比如 139 端口专门用于 NetBIOS 与 TCP&#x2F;IP 之间的通信</li>
</ul>
</li>
<li><p><strong>注册端口</strong> Registered Ports ：</p>
<ul>
<li>端口号从 <strong>1024 到 49151</strong>，它们松散地绑定于一些服务，<strong>分配给用户进程或应用程序</strong>。</li>
<li>这些端口在没有被服务器资源占用的时候，可以给用户端动态选用为源端口。</li>
</ul>
</li>
<li><p><strong>动态端口</strong> &#x2F; <strong>私有端口</strong> Dynamic Ports&#x2F;Private Ports ：</p>
<ul>
<li>动态端口的范围是从 <strong>49152 到 65535</strong>。之所以称为动态端口，是因为它一般不固定分配某种服务，而是<strong>动态分配</strong>。</li>
</ul>
</li>
</ul>
<br>

<br>

<br>

<br>

<h3 id="4-1-3-网络模型"><a href="#4-1-3-网络模型" class="headerlink" title="4.1.3 网络模型"></a>4.1.3 网络模型</h3><h4 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h4><p>Open System Interconnection</p>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230210233638076.png" alt="image-20230210233638076"></p>
<p><strong>物理层</strong>：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输，到达目的地后再转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做比特。</p>
<br>

<p><strong>数据链路层</strong>：建立逻辑连接、进行硬件地址寻址、差错校验等功能。定义了如何让格式化数据以帧为单位进行传输，以及如何让控制对物理介质的访问。将比特组合成字节进而组合成帧，用MAC地址访问介质。</p>
<br>

<p><strong>网络层</strong>：进行逻辑地址寻址，在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。</p>
<br>

<p><strong>传输层</strong>：定义了一些传输数据的协议和端口号（ WWW 端口 80 等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与TCP 特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如 QQ 聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做段。</p>
<br>

<p><strong>会话层</strong>：通过传输层（端口号：传输端口与接收端口）建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求。</p>
<br>

<p><strong>表示层</strong>：<strong>数据的表示、安全、压缩。</strong>主要是进行对接收的数据进行解释、加密与解密、压缩与解压缩等（也就是把计算机能够识别的东西转换成人能够能识别的东西（如图片、声音等）。</p>
<br>

<p><strong>应用层</strong>：网络服务与最终用户的一个接口。这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务</p>
<br>

<br>

<h4 id="TCP-x2F-IP-四层模型"><a href="#TCP-x2F-IP-四层模型" class="headerlink" title="TCP&#x2F;IP 四层模型"></a>TCP&#x2F;IP 四层模型</h4><p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230210233916419.png" alt="image-20230210233916419"></p>
<p>现在 Internet（因特网）使用的<strong>主流协议族是 TCP&#x2F;IP 协议族</strong>，它是一个分层、多协议的通信体系。TCP&#x2F;IP协议族是一个四层协议系统，<strong>自底而上分别是数据链路层、网络层、传输层和应用层</strong>。</p>
<br>

<p><strong>简化OSI七层模型</strong></p>
<ol>
<li><strong>应用层、表示层、会话层</strong> 三个层次提供的服务相差不是很大，所以在 TCP&#x2F;IP 协议中，它们被合并为 <strong>应用层</strong> 一个层次。</li>
<li>由于 <strong>传输层、网络层</strong> 在网络协议中的地位十分重要，所以在 TCP&#x2F;IP 协议中它们被作为<strong>独立</strong>的两个层次。</li>
<li>因为 <strong>数据链路层、物理层</strong> 的内容相差不多，所以在 TCP&#x2F;IP 协议中它们被归并在 <strong>网络接口层</strong> 一个层次里。</li>
</ol>
<br>

<p><strong>四层介绍</strong></p>
<ul>
<li><strong>应用层</strong>：应用层是 TCP&#x2F;IP 协议的第一层，是直接为应用进程提供服务的。<ul>
<li>对不同种类的应用程序它们会根据自己的需要来使用应用层的不同协议，邮件传输应用使用了 SMTP 协议、万维网应用使用了 HTTP 协议、远程登录服务应用使用了有 TELNET 协议。</li>
<li>应用层还能<strong>加密、解密、格式化数据</strong>。</li>
<li>应用层可以<strong>建立或解除与其他节点的联系</strong>，这样可以充分节省网络资源。</li>
</ul>
</li>
<li><strong>传输层</strong>：作为 TCP&#x2F;IP 协议的第二层，运输层在整个 TCP&#x2F;IP 协议中起到了中流砥柱的作用。且在运输层中， <strong>TCP 和 UDP</strong> 也同样起到了中流砥柱的作用。</li>
<li><strong>网络层</strong>：网络层在 TCP&#x2F;IP 协议中的位于第三层。在 TCP&#x2F;IP 协议中网络层可以进行<strong>网络连接的建立和终止</strong>以及 <strong>IP 地址的寻找</strong>等功能。</li>
<li><strong>网络接口层</strong>：在 TCP&#x2F;IP 协议中，网络接口层位于第四层。由于网络接口层兼并了物理层和数据链路层所以，网络接口层既是<strong>传输数据的物理媒介</strong>，也可以为网络层<strong>提供一条准确无误的线路</strong>。</li>
</ul>
<br>

<br>

<p><strong>比较</strong></p>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230210235626139.png" alt="image-20230210235626139"></p>
<br>

<br>

<br>

<br>

<h3 id="4-1-4-协议"><a href="#4-1-4-协议" class="headerlink" title="4.1.4 协议"></a>4.1.4 协议</h3><p><strong>简介</strong></p>
<p>​	<strong>协议</strong>，网络协议的简称，网络协议是通信计算机双方必须共同遵从的一组约定。</p>
<ul>
<li>如怎么样建立连接、怎么样互相识别等。只有遵守这个约定，计算机之间才能相互通信交流。</li>
<li>它的三要素是：<strong>语法、语义、时序</strong>。</li>
<li>为了使数据在网络上从源到达目的，网络通信的参与方必须遵循相同的规则，这套规则称为协议（protocol），它最终体现为在网络上传输的<strong>数据包的格式</strong>。协议往往分成几个层次进行定义，<strong>分层定义</strong>是为了<u>使某一层协议的改变不影响其他层次的协议</u>。</li>
</ul>
<br>

<p><strong>常见协议</strong></p>
<ul>
<li><p>应用层：</p>
<ul>
<li>FTP协议（File Transfer Protocol 文件传输协议）</li>
<li>HTTP协议（Hyper Text Transfer Protocol 超文本传输协议）</li>
<li>NFS（Network File System 网络文件系统）。（SSH协议端口号是22）</li>
</ul>
</li>
<li><p>传输层：</p>
<ul>
<li>TCP协议（Transmission Control Protocol 传输控制协议）</li>
<li>UDP协议（User Datagram Protocol 用户数据报协议）。</li>
</ul>
</li>
<li><p>网络层：</p>
<ul>
<li>IP 协议（Internet Protocol 因特网互联协议）</li>
<li>ICMP 协议（Internet Control Message Protocol 因特网控制报文协议）</li>
<li>IGMP 协议（Internet Group Management Protocol 因特网组管理协议）。</li>
</ul>
</li>
<li><p>网络接口层：</p>
<ul>
<li>ARP协议（Address Resolution Protocol 地址解析协议）</li>
<li>RARP协议<br>（Reverse Address Resolution Protocol 反向地址解析协议）</li>
</ul>
</li>
</ul>
<br>

<br>

<h4 id="UDP报"><a href="#UDP报" class="headerlink" title="UDP报"></a>UDP报</h4><p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230211001006533.png" alt="image-20230211001006533"></p>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230211003426471.png" alt="image-20230211003426471"></p>
<br>

<h4 id="TCP报"><a href="#TCP报" class="headerlink" title="TCP报"></a>TCP报</h4><p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230211001202108.png" alt="image-20230211001202108"></p>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230211003839373.png" alt="image-20230211003839373"></p>
<p>flag：<br><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230211004511396.png" alt="image-20230211004511396"></p>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230211004527855.png" alt="image-20230211004527855"></p>
<br>

<h4 id="IP报"><a href="#IP报" class="headerlink" title="IP报"></a>IP报</h4><p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230211003610812.png" alt="image-20230211003610812"></p>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230211005238765.png" alt="image-20230211005238765"></p>
<br>

<h4 id="以太网帧"><a href="#以太网帧" class="headerlink" title="以太网帧"></a>以太网帧</h4><p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230211003524443.png" alt="image-20230211003524443"></p>
<p>类型：0x800 IP，0x806 ARP，0x835 RARP</p>
<br>

<h4 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h4><p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230211003731026.png" alt="image-20230211003731026"></p>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230211003742083.png" alt="image-20230211003742083"></p>
<br>

<br>

<h4 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程"></a>通信过程</h4><p><strong>封装</strong></p>
<p>​	应用程序数据在发送到物理网络上之前，将沿着协议栈从上往下依次传递。每层协议都将在上层数据的基础上加上自己的头部信息（有时还包括尾部信息），以实现该层的功能，这个过程就称为封装。</p>
<blockquote>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230211010042659.png" alt="封装"></p>
</blockquote>
<br>

<p><strong>分用</strong></p>
<p>​	当帧到达目的主机时，将沿着协议栈自底向上依次传递。各层协议依次处理帧中本层负责的头部数据，以获取所需的信息，并最终将处理后的帧交给目标应用程序。这个过程称为分用（demultiplexing）。分用是依靠头部信息中的类型字段实现的。</p>
<blockquote>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230211010337835.png" alt="分用"></p>
</blockquote>
<br>

<p><strong>封装与解封装案例</strong></p>
<p>（数据链路层还有 帧尾 的校验码）</p>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230211010845923.png" alt="封装与解封装"></p>
<br>

<br>

<h4 id="ARP协议的分析"><a href="#ARP协议的分析" class="headerlink" title="ARP协议的分析"></a>ARP协议的分析</h4><p>封装过程中，从网络层到数据链路层，需要添加的以太网帧头含有 <strong>目的mac地址</strong> 字段</p>
<p><strong>问题</strong>：目前知道 目的IP地址 ，要从何获取目的mac地址？ —— 利用ARP协议（通过 IP 获取 mac）</p>
<p>先查找本地 地址解析表 ，如果没有就如下：</p>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230211011936900.png" alt="arp"></p>
<ul>
<li>广播发送</li>
<li>单播应答</li>
</ul>
<br>

<p><strong>帧结构</strong></p>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230211020206256.png" alt="ARP报文"></p>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230211020650494.png" alt="加上帧头（请求包）"></p>
<blockquote>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230211003731026.png" alt="image-20230211003731026"></p>
</blockquote>
<br>

<br>

<h3 id="4-1-5-Socket套接字"><a href="#4-1-5-Socket套接字" class="headerlink" title="4.1.5 Socket套接字"></a>4.1.5 Socket套接字</h3><p><strong>socket</strong>（套接字），就是对 <strong>网络中不同主机上的应用进程之间</strong> 进行<strong>双向通信</strong>的<strong>端点</strong>的抽象。一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制。从所处的地位来讲，套接字上联应用进程，下联网络协议栈，是应用程序通过网络协议进行通信和交互的接口。</p>
<br>

<p>socket 可以看成是两个网络<strong>应用程序</strong>进行通信时，各自<strong>通信连接中的端点</strong>，这是一个<strong>逻辑上的概念</strong>。它是网络环境中进程间通信的 API，也是可以 <strong>被命名</strong> 和 <strong>寻址</strong> 的通信端点，使用中的每一个套接字都有其类型和一个与之相连进程。通信时其中一个网络应用程序将要传输的一段信息写入它所在主机的 socket 中，该 socket 通过与网络接口卡（NIC）相连的传输介质将这段信息送到另外一台主机的 socket 中，使对方能够接收到这段信息。socket 是由 <strong>IP</strong> 和 <strong>端口</strong> 结合的，提供<strong>向应用层进程传送数据包</strong>的机制。</p>
<br>

<p>socket 本身有“<strong>插座</strong>”的意思，在 Linux 环境下，用于表示进程间网络通信的特殊文件类型。本质为内核借助 <strong>缓冲区</strong> 形成的 <strong>伪文件</strong> 。既然是文件，那么理所当然的，我们可以使用 <strong>文件描述符</strong> 引用套接字。与管道类似的，<u>Linux 系统将其封装成文件的目的是为了统一接口</u>，使得读写套接字和读写文件的操作一致。<u>区别是管道主要应用于本地进程间通信，而套接字多应用于网络进程间数据的传递。</u></p>
<br>

<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230211023108406.png" alt="image-20230211023108406"></p>
<br>

<p>套接字通信分两部分：</p>
<ul>
<li><strong>服务器端</strong>：被动接受连接，一般不会主动发起连接</li>
<li><strong>客户端</strong>：主动向服务器发起连接</li>
</ul>
<blockquote>
<p>socket是一套通信的接口，Linux 和 Windows 都有，但是有一些细微的差别</p>
</blockquote>
<br>

<br>

<h3 id="4-1-6-字节序"><a href="#4-1-6-字节序" class="headerlink" title="4.1.6 字节序"></a>4.1.6 字节序</h3><blockquote>
<p>现代 CPU 的累加器一次都能装载（至少）4 字节（这里考虑 32 位机），即一个整数。</p>
<p>这 4 字节在内存中排列的顺序将影响它被累加器装载成的整数的值，这就是字节序问题。</p>
<p>通信双方交流的信息单元（比特、字节、字、双字等等）应该以什么样的顺序进行传送。</p>
</blockquote>
<br>

<p>字节序分为大端字节序（Big-Endian） 和小端字节序（Little-Endian）。</p>
<ul>
<li><p><strong>大端</strong> 字节序是指 一个整数 的 <strong>最高位字节</strong>（0x后面最左边的数字）存储在 <strong>内存</strong> 的 <strong>低地址</strong> 处 ，低位字节（0 ~ 7 bit）存储在内存的高地址处；<br><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230212223224461.png" alt="image-20230212223224461"></p>
</li>
<li><p><strong>小端</strong> 字节序则是指整数的高位字节存储在内存的高地址处，而低位字节则存储在内存的低地址处。</p>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230212223233439.png" alt="image-20230212223233439"></p>
</li>
</ul>
<br>

<p><strong>大部分计算机采用小端序</strong></p>
<br>

<h4 id="检测主机字节序"><a href="#检测主机字节序" class="headerlink" title="检测主机字节序"></a>检测主机字节序</h4><p>利用 union</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过代码检测当前主机的字节序</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 定义联合体</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">short</span> value;    <span class="comment">// 2字节</span></span><br><span class="line">        <span class="type">char</span> bytes[<span class="keyword">sizeof</span>(<span class="type">short</span>)];  <span class="comment">// char[2]</span></span><br><span class="line">    &#125; test;</span><br><span class="line"></span><br><span class="line">    test.value = <span class="number">0x0102</span>;</span><br><span class="line">    <span class="keyword">if</span>((test.bytes[<span class="number">0</span>] == <span class="number">1</span>) &amp;&amp; (test.bytes[<span class="number">1</span>] == <span class="number">2</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;大端字节序\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>((test.bytes[<span class="number">0</span>] == <span class="number">2</span>) &amp;&amp; (test.bytes[<span class="number">1</span>] == <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;小端字节序\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;未知\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<h4 id="字节序转换"><a href="#字节序转换" class="headerlink" title="字节序转换"></a>字节序转换</h4><p>当格式化的数据在两台使用不同字节序的主机之间直接传递时：</p>
<p><strong>发送端总是把要发送的数据转换成大端字节序数据后再发送，</strong>而接收端知道对方传送过来的数据总是采用大端字节序，所以接收端可以根据自身采用的字节序决定是否对接收到的数据进行转换。</p>
<br>

<p><strong>网络字节顺序</strong>：</p>
<p> TCP&#x2F;IP 中规定好的一种数据表示格式，它与具体的 CPU 类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释，<strong>网络字节顺序采用大端排序方式</strong>。</p>
<br>

<p>BSD Socket提供了封装好的转换接口，方便程序员使用。包括</p>
<ul>
<li><p>从主机字节序 到 网络字节序 的转换函数htons、htonl；</p>
</li>
<li><p>从网络字节序到主机字节序的转换函数：ntohs、ntohl。</p>
</li>
</ul>
<br>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	h - host 主机，主机字节序</span></span><br><span class="line"><span class="comment">	to - 转换成什么</span></span><br><span class="line"><span class="comment">	n - network 网络字节序</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	s - short unsigned short	，端口 </span></span><br><span class="line"><span class="comment">	l - long unsigned int	，IP</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 端口	short unsigned short</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">htons</span><span class="params">(<span class="type">uint16_t</span> hostshort)</span>; <span class="comment">// 主机字节序 - 网络字节序</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ntohs</span><span class="params">(<span class="type">uint16_t</span> netshort)</span>; <span class="comment">// 网络字节序 - 主机字节序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IP long unsigned int</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">htonl</span><span class="params">(<span class="type">uint32_t</span> hostlong)</span>; <span class="comment">// 主机字节序 - 网络字节序</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ntohl</span><span class="params">(<span class="type">uint32_t</span> netlong)</span>; <span class="comment">// 网络字节序 - 主机字节序</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><br><br></p>
<br>

<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// htons 转换端口</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> a = <span class="number">0x0102</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a : %x\n&quot;</span>, a);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> b = htons(a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b : %x\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;=======================\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// htonl  转换IP</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">4</span>] = &#123;<span class="number">192</span>, <span class="number">168</span>, <span class="number">1</span>, <span class="number">100</span>&#125;;</span><br><span class="line">    <span class="type">int</span> num = *(<span class="type">int</span> *)buf;  <span class="comment">// 先取数组地址，在对其进行int类型转换，再解引用</span></span><br><span class="line">    <span class="type">int</span> sum = htonl(num);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *p = (<span class="type">char</span> *)&amp;sum;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>, *p, *(p+<span class="number">1</span>), *(p+<span class="number">2</span>), *(p+<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;=======================\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ntohl</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buf1[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">168</span>, <span class="number">192</span>&#125;;</span><br><span class="line">    <span class="type">int</span> num1 = *(<span class="type">int</span> *)buf1;</span><br><span class="line">    <span class="type">int</span> sum1 = ntohl(num1);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *p1 = (<span class="type">unsigned</span> <span class="type">char</span> *)&amp;sum1;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>, *p1, *(p1+<span class="number">1</span>), *(p1+<span class="number">2</span>), *(p1+<span class="number">3</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ntohs</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> c = <span class="number">0x0201</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a : %x\n&quot;</span>, c);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> d = ntohs(c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b : %x\n&quot;</span>, d);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><br><br></p>
<br>

<h3 id="4-1-7-socket-地址"><a href="#4-1-7-socket-地址" class="headerlink" title="4.1.7 socket 地址"></a>4.1.7 socket 地址</h3><p>socket地址其实是一个结构体，封装端口号和IP等信息</p>
<h4 id="通用socket地址"><a href="#通用socket地址" class="headerlink" title="通用socket地址"></a>通用socket地址</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">	<span class="type">sa_family_t</span> sa_family;</span><br><span class="line">	<span class="type">char</span> sa_data[<span class="number">14</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="type">sa_family_t</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<br>

<p><strong>sa_family</strong> 成员是 地址族类型（sa_family_t）的变量。地址族类型通常与协议族类型对应。常见的协议族（protocol family，也称 domain）和对应的地址族入下所示：</p>
<table>
<thead>
<tr>
<th>协议族</th>
<th>地址族</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>PF_UNIX</td>
<td>AF_UNIX</td>
<td>UNIX本地域协议族</td>
</tr>
<tr>
<td>PF_INET</td>
<td>AF_INET</td>
<td>TCP&#x2F;IPv4协议族</td>
</tr>
<tr>
<td>PF_INET6</td>
<td>AF_INET6</td>
<td>TCP&#x2F;IPv6协议族</td>
</tr>
</tbody></table>
<blockquote>
<p>（宏 PF_* 和 AF_* 都定义在 bits&#x2F;socket.h 头文件中，且后者与前者有完全相同的值，所以二者通常混用）</p>
</blockquote>
<br>

<p><strong>sa_data</strong> 成员用于存放 <strong>socket 地址值</strong>。但是，不同的协议族的地址值具有不同的含义和长度，如下所示：</p>
<table>
<thead>
<tr>
<th align="left">协议族</th>
<th>地址值含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">PF_UNIX</td>
<td>文件的路径名，长度可达108字节</td>
</tr>
<tr>
<td align="left">PF_INET</td>
<td>16 bit 端口号 和 32 bit IPv4地址</td>
</tr>
<tr>
<td align="left">PF_INET6</td>
<td>16 bit 端口号，32 bit 流标识，128 bit IPv6 地址，32 bit 范围 ID  （共26字节）</td>
</tr>
</tbody></table>
<br>

<p>由上表可知，14 字节的 sa_data 根本无法容纳多数协议族的地址值。因此，Linux 定义了下面这个<strong>新的通用的 socket 地址结构体，这个结构体不仅提供了足够大的空间用于存放地址值，而且是内存对齐的</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">sa_family_t</span> sa_family;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> __ss_align;</span><br><span class="line">    <span class="comment">//	用来对其内存</span></span><br><span class="line">	<span class="type">char</span> __ss_padding[ <span class="number">128</span> - <span class="keyword">sizeof</span>(__ss_align) ];	<span class="comment">//	具体地址数据</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="type">sa_family_t</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<h4 id="专用socket地址"><a href="#专用socket地址" class="headerlink" title="专用socket地址"></a>专用socket地址</h4><p>很多网络编程函数诞生早于 IPv4 协议，那时候都使用的是 struct sockaddr 结构体，为了向前兼容，现sockaddr 退化成了（void *）的作用，传递一个地址给函数，至于是 sockaddr_in 还是sockaddr_in6，由地址族确定，然后函数内部再强制类型转化为所需的地址类型。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TCP/IP 协议族有 sockaddr_in 和 sockaddr_in6 两个专用的 socket 地址结构体，它们分别用于 IPv4 和 IPv6：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">sa_family_t</span> sin_family;	<span class="comment">// 地址族</span></span><br><span class="line">	<span class="type">in_port_t</span> sin_port; 	<span class="comment">// 端口</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">// IP</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">/* 对其内存用 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> sin_zero[<span class="keyword">sizeof</span> (<span class="keyword">struct</span> sockaddr) - __SOCKADDR_COMMON_SIZE - <span class="keyword">sizeof</span> (<span class="type">in_port_t</span>) - <span class="keyword">sizeof</span> (<span class="keyword">struct</span> in_addr)];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">in_addr_t</span> s_addr;	<span class="comment">//typedef uint32_t in_addr_t;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//	IPv6</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">sa_family_t</span> sin6_family;</span><br><span class="line">	<span class="type">in_port_t</span> sin6_port; <span class="comment">/* Transport layer port # */</span></span><br><span class="line">	<span class="type">uint32_t</span> sin6_flowinfo; <span class="comment">/* IPv6 flow information */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span> <span class="comment">/* IPv6 address */</span></span><br><span class="line">	<span class="type">uint32_t</span> sin6_scope_id; <span class="comment">/* IPv6 scope-id */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">uint16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">uint32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint16_t</span> <span class="type">in_port_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">in_addr_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SOCKADDR_COMMON_SIZE (sizeof (unsigned short int))</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230213070943568.png" alt="image-20230213070943568"></p>
<p><strong>所有专用 socket 地址（以及 sockaddr_storage）类型的变量在实际使用时都需要转化为通用 socket 地址类型 sockaddr（强制转化即可）</strong>，因为所有 socket 编程接口使用的地址参数类型都是 sockaddr</p>
<br>

<br>

<br>

<h3 id="4-1-8-IP地址转换"><a href="#4-1-8-IP地址转换" class="headerlink" title="4.1.8 IP地址转换"></a>4.1.8 IP地址转换</h3><p><strong>点分十进制字符串</strong> 表示的 <strong>IPv4</strong> 地址和用 <strong>网络字节序整数</strong> 表示的 <strong>IPv4</strong> 地址之间的转换：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 地址字符串 转 网络字节序整数</span></span><br><span class="line"><span class="type">in_addr_t</span> <span class="title function_">inet_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 地址字符串 转 网络字节序整数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_aton</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cp, <span class="keyword">struct</span> in_addr *inp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 网络字节序整数 转 地址字符串</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr in)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<p><strong>新版的函数接口</strong>：IPv4，IPv6</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// p:点分十进制的IP字符串，n:表示network，网络字节序的整数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 地址字符串 转 网络字节序整数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span>;</span><br><span class="line">af:地址族： AF_INET AF_INET6</span><br><span class="line">src:需要转换的点分十进制的IP字符串</span><br><span class="line">dst:转换后的结果保存在这个里面</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 网络字节序整数 转 地址字符串</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">char</span> *dst, <span class="type">socklen_t</span> size)</span>;</span><br><span class="line">af:地址族： AF_INET AF_INET6</span><br><span class="line">src: 要转换的ip的整数的地址</span><br><span class="line">dst: 转换成IP地址字符串保存的地方</span><br><span class="line">size：第三个参数的大小（数组的大小）</span><br><span class="line">返回值：返回转换后的数据的地址（字符串），和 dst 是一样的</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<p><strong>案例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个ip字符串,点分十进制的IP地址字符串</span></span><br><span class="line">    <span class="type">char</span> buf[] = <span class="string">&quot;192.168.1.4&quot;</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将点分十进制的IP字符串转换成网络字节序的整数</span></span><br><span class="line">    inet_pton(AF_INET, buf, &amp;num);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> * p = (<span class="type">unsigned</span> <span class="type">char</span> *)&amp;num;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>, *p, *(p+<span class="number">1</span>), *(p+<span class="number">2</span>), *(p+<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将网络字节序的IP整数转换成点分十进制的IP字符串</span></span><br><span class="line">    <span class="type">char</span> ip[<span class="number">16</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> * str =  inet_ntop(AF_INET, &amp;num, ip, <span class="number">16</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str : %s\n&quot;</span>, str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ip : %s\n&quot;</span>, ip);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ip == str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<p><br><br></p>
<br>

<h2 id="4-2-TCP通信"><a href="#4-2-TCP通信" class="headerlink" title="4.2 TCP通信"></a>4.2 TCP通信</h2><blockquote>
<p>UDP于TCP对比</p>
<hr>
<p><strong>UDP</strong>:<br>    <strong>用户数据报</strong> 协议，面向<strong>无连接</strong>，可以<strong>单播，多播，广播</strong>， 面向数据报，不可靠</p>
<p><strong>TCP</strong>:<br>    <strong>传输控制</strong> 协议，面向<strong>连接</strong>的，可靠的，基于<strong>字节流</strong>，仅支持<strong>单播</strong>传输</p>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th align="center">UDP</th>
<th align="center">TCP</th>
</tr>
</thead>
<tbody><tr>
<td>是否创建连接</td>
<td align="center">无连接</td>
<td align="center">面向连接</td>
</tr>
<tr>
<td>是否可靠</td>
<td align="center">不可靠</td>
<td align="center">可靠的</td>
</tr>
<tr>
<td>连接对象个数</td>
<td align="center">一对一、一对多、多对一、多对多</td>
<td align="center">一对一</td>
</tr>
<tr>
<td>传输的方式</td>
<td align="center">面向数据报</td>
<td align="center">面向字节流</td>
</tr>
<tr>
<td>首部开销</td>
<td align="center">8个字节</td>
<td align="center">最少20个字节</td>
</tr>
<tr>
<td>适用场景</td>
<td align="center">实时应用（视频会议，直播）</td>
<td align="center">可靠性高的应用（文件传输）</td>
</tr>
</tbody></table>
<br>

<br>

<h3 id="4-2-1-TCP通信流程"><a href="#4-2-1-TCP通信流程" class="headerlink" title="4.2.1 TCP通信流程"></a>4.2.1 TCP通信流程</h3><p><strong>服务器端</strong> （被动接受连接的角色）</p>
<ol>
<li>创建一个 <strong>用于监听</strong> 的套接字<ul>
<li>监听：监听有客户端的连接</li>
<li>套接字：这个套接字其实就是一个文件描述符</li>
</ul>
</li>
<li>将这个监听文件描述符和本地的IP和端口绑定（IP和端口就是服务器的地址信息）<ul>
<li>客户端连接服务器的时候使用的就是这个IP和端口</li>
</ul>
</li>
<li>设置监听，监听的fd开始工作</li>
<li>阻塞等待，当有客户端发起连接，解除阻塞，接受客户端的连接，会得到一个和客户端通信的套接字（fd）</li>
<li>通信<ul>
<li>接收数据</li>
<li>发送数据</li>
</ul>
</li>
<li>通信结束，断开连接</li>
</ol>
<br>

<p><strong>客户端</strong></p>
<ol>
<li>创建一个用于通信的套接字（fd）</li>
<li>连接服务器，需要指定连接的服务器的 IP 和 端口</li>
<li>连接成功了，客户端可以直接和服务器通信<ul>
<li>接收数据</li>
<li>发送数据</li>
</ul>
</li>
<li>通信结束，断开连接</li>
</ol>
<br>

<blockquote>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230213082358002.png" alt="image-20230213082358002"></p>
</blockquote>
<br>

<br>

<h3 id="4-2-2-Socket函数"><a href="#4-2-2-Socket函数" class="headerlink" title="4.2.2 Socket函数"></a>4.2.2 Socket函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span> <span class="comment">// 包含了这个头文件，上面两个就可以省略</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建套接字</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br><span class="line">	- 功能：创建一个套接字</span><br><span class="line">	- 参数：</span><br><span class="line">		- domain: 协议族</span><br><span class="line">			AF_INET : ipv4</span><br><span class="line">			AF_INET6 : ipv6</span><br><span class="line">			AF_UNIX, AF_LOCAL : 本地套接字通信（进程间通信）</span><br><span class="line">		- type: 通信过程中使用的协议类型</span><br><span class="line">			SOCK_STREAM : 流式协议 TCP</span><br><span class="line">			SOCK_DGRAM : 报式协议  UDP</span><br><span class="line">		- protocol : 具体的一个协议。一般写 <span class="number">0</span></span><br><span class="line">			- SOCK_STREAM : 流式协议默认使用 TCP</span><br><span class="line">			- SOCK_DGRAM : 报式协议默认使用 UDP</span><br><span class="line">	- 返回值：</span><br><span class="line">		- 成功：返回文件描述符，操作的就是内核缓冲区。</span><br><span class="line">		- 失败：<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将IP、端口绑定到套接字</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>; <span class="comment">// socket命名</span></span><br><span class="line">	- 功能：绑定，将 fd 和本地的IP + 端口进行绑定</span><br><span class="line">	- 参数：</span><br><span class="line">		- sockfd : 通过socket函数得到的文件描述符</span><br><span class="line">		- addr : 需要绑定的socket地址，这个地址封装了ip和端口号的信息</span><br><span class="line">		- addrlen : 第二个参数结构体占的内存大小</span><br><span class="line">            </span><br><span class="line"><span class="comment">// 套接字启动监听</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>; <span class="comment">// /proc/sys/net/core/somaxconn</span></span><br><span class="line">	- 功能：监听这个socket上的连接</span><br><span class="line">	- 参数：</span><br><span class="line">		- sockfd : 通过socket()函数得到的文件描述符</span><br><span class="line">		- backlog : 最大连接数， <span class="number">5</span>即可</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line"><span class="comment">// 接收连接，默认是阻塞的</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br><span class="line">	- 功能：接收客户端连接，默认是一个阻塞的函数，阻塞等待客户端连接</span><br><span class="line">	- 参数：</span><br><span class="line">		- sockfd : 用于监听的文件描述符</span><br><span class="line">		- addr : 传出参数，记录了连接成功后客户端的地址信息（ip，port）</span><br><span class="line">		- addrlen : 指定第二个参数的对应的内存大小</span><br><span class="line">	- 返回值：</span><br><span class="line">		- 成功 ：用于通信的文件描述符</span><br><span class="line">		- <span class="number">-1</span> ： 失败</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line"><span class="comment">// 客户端发起连接（参数有点像 bind ）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line">	- 功能： 客户端连接服务器</span><br><span class="line">	- 参数：</span><br><span class="line">		- sockfd : 用于通信的文件描述符</span><br><span class="line">		- addr : 客户端要连接的服务器的地址信息</span><br><span class="line">		- addrlen : 第二个参数的内存大小</span><br><span class="line">	- 返回值：成功 <span class="number">0</span>， 失败 <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>; <span class="comment">// 写数据</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>; <span class="comment">// 读数据</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<br>

<br>

<br>

<h3 id="4-2-3-三次握手"><a href="#4-2-3-三次握手" class="headerlink" title="4.2.3 三次握手"></a>4.2.3 三次握手</h3><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230214004936804.png" alt="image-20230214004936804" style="zoom:80%;">

<br>

<ul>
<li><p>TCP 是一种<strong>面向连接的单播协议</strong>，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的<strong>“连接”</strong>，其实是<strong>客户端和服务器的内存里保存的一份关于对方的信息</strong>，如 IP 地址、端口号等。</p>
</li>
<li><p>TCP 可以看成是一种<strong>字节流</strong>，它会处理 <strong>IP 层或以下的层</strong> 的 <strong>丢包、重复以及错误</strong> 问题。</p>
</li>
<li><p>在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在 TCP 头部。</p>
</li>
<li><p>TCP 提供了一种可靠、面向连接、字节流、传输层的服务，采用 三次握手建立一个连接 。采用 四次挥手来关闭一个连接 。 三次握手的目的是 <strong>保证双方互相之间建立了连接</strong> 。</p>
</li>
<li><p>三次握手发生在客户端连接的时候，当 <strong>调用connect()</strong> ，底层会通过TCP协议进行三次握手。</p>
</li>
</ul>
<br>

<p><strong>TCP 头</strong></p>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230214002211867.png" alt="image-20230214002211867"></p>
<br>

<ul>
<li><strong>16 位端口号</strong>（port number）：告知主机报文段是来自哪里（<strong>源端口</strong>）以及传给哪个上层协议或应用程序（<strong>目的端口</strong>）的。进行 TCP 通信时，客户端通常使用系统自动选择的临时端口号。</li>
<li><strong>32 位序号</strong>（sequence number）：一次 TCP 通信（从 TCP 连接建立到断开）过程中某一个传输方向上的字节流的每个字节的编号。假设主机 A 和主机 B 进行 TCP 通信，A 发送给 B 的第一个TCP 报文段中，序号值被系统初始化为某个随机值 ISN（Initial Sequence Number，初始序号值）。那么在该传输方向上（从 A 到 B），后续的 TCP 报文段中序号值将被系统设置成 ISN 加上该报文段所携带数据的第一个字节在整个字节流中的偏移。例如，某个 TCP 报文段传送的数据是字节流中的第 1025 ~ 2048 字节，那么该报文段的序号值就是 ISN + 1025。另外一个传输方向（从B 到 A）的 TCP 报文段的序号值也具有相同的含义。</li>
<li><strong>32 位确认号</strong>（acknowledgement number）：用作对另一方发送来的 TCP 报文段的响应。其值是收到的 TCP 报文段的序号值 + 标志位长度（SYN，FIN） + 数据长度 。假设主机 A 和主机 B 进行TCP 通信，那么 A 发送出的 TCP 报文段不仅携带自己的序号，而且包含对 B 发送来的 TCP 报文段的确认号。反之，B 发送出的 TCP 报文段也同样携带自己的序号和对 A 发送来的报文段的确认序</li>
<li><strong>4 位头部长度</strong>（head length）：标识该 TCP 头部有多少个 32 bit(4 字节)。因为 4 位最大能表示15，所以 TCP 头部最长是60 字节。</li>
<li><strong>6 位标志位</strong>包含如下几项：<ul>
<li>URG 标志，表示紧急指针（urgent pointer）是否有效。</li>
<li>ACK 标志，表示确认号是否有效。我们称携带 ACK 标志的 TCP 报文段为确认报文段。</li>
<li>PSH 标志，提示接收端应用程序应该立即从 TCP 接收缓冲区中读走数据，为接收后续数据腾出空间（如果应用程序不将接收到的数据读走，它们就会一直停留在 TCP 接收缓冲区中）。</li>
<li>RST 标志，表示要求对方重新建立连接。我们称携带 RST 标志的 TCP 报文段为 <strong>复位</strong> 报文段。</li>
<li>SYN 标志，表示请求建立一个连接。我们称携带 SYN 标志的 TCP 报文段为 <strong>同步</strong> 报文段。</li>
<li>FIN 标志，表示通知对方本端要关闭连接了。我们称携带 FIN 标志的 TCP 报文段为 <strong>结束</strong> 报文段。</li>
</ul>
</li>
<li><strong>16 位窗口大小</strong>（window size）：是 TCP 流量控制的一个手段。这里说的窗口，指的是 <strong>接收通告窗口</strong> （Receiver Window，RWND）。它告诉对方本端的 TCP 接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。</li>
<li><strong>16 位校验和</strong>（TCP checksum）：由发送端填充，接收端对 TCP 报文段执行 CRC 算法以校验TCP 报文段在传输过程中是否损坏。注意，这个校验不仅包括 TCP 头部，也包括数据部分。这也是 TCP 可靠传输的一个重要保障。</li>
<li><strong>16 位紧急指针</strong>（urgent pointer）：是一个正的偏移量。它和序号字段的值相加表示最后一个紧急数据的下一个字节的序号。因此，确切地说，这个字段是紧急指针相对当前序号的偏移，不妨称之为紧急偏移。TCP 的紧急指针是发送端向接收端发送紧急数据的方法。</li>
</ul>
<br>

<p><strong>三次握手</strong></p>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230214004856526.png" alt="image-20230214004856526"></p>
<p><strong>传输数据</strong></p>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230214004912780.png" alt="image-20230214004912780"></p>
<br>

<p><strong>小结</strong></p>
<p>第一次握手：<br>    1.客户端将SYN标志位置为1<br>    2.生成一个随机的32位的序号seq&#x3D;J ， 这个序号后边是可以携带数据（数据的大小）<br>第二次握手：<br>    1.服务器端接收客户端的连接： ACK&#x3D;1<br>    2.服务器会回发一个确认序号： ack &#x3D; 客户端的序号 + 数据长度 + SYN&#x2F;FIN(按一个字节算)<br>    3.服务器端会向客户端发起连接请求： SYN&#x3D;1<br>    4.服务器会生成一个随机序号：seq &#x3D; K<br>第三次握手：<br>    1.客户单应答服务器的连接请求：ACK&#x3D;1<br>    2.客户端回复收到了服务器端的数据：ack&#x3D;服务端的序号 + 数据长度 + SYN&#x2F;FIN(按一个字节算)</p>
<p><br><br></p>
<h3 id="4-2-4-滑动窗口"><a href="#4-2-4-滑动窗口" class="headerlink" title="4.2.4 滑动窗口"></a>4.2.4 滑动窗口</h3><p><strong>滑动窗口</strong>（Sliding window）是一种 <strong>流量控制</strong> 技术。</p>
<blockquote>
<p>早期的网络通信中，通信双方不会考虑网络的拥挤情况直接发送数据。由于大家不知道网络拥塞状况，同时发送数据，导致中间节点阻塞掉包，谁也发不了数据，所以就有了滑动窗口机制来解决此问题。</p>
</blockquote>
<p>滑动窗口协议是用来 <strong>改善吞吐量</strong> 的一种技术，即<strong>容许发送方在接收任何应答之前传送附加的包</strong> 。<strong>接收方告诉发送方在某一时刻能送多少包</strong>（称 <strong>窗口尺寸</strong>）。</p>
<p>TCP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。<strong>发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据</strong>。当滑动窗口为 0 时，发送方一般不能再发送数据报。</p>
<blockquote>
<p>滑动窗口是 TCP 中实现诸如 <strong>ACK 确认</strong>、<strong>流量控制</strong>、<strong>拥塞控制</strong> 的承载结构。</p>
</blockquote>
<br>

<ul>
<li>滑动窗口的大小会随着发送数据和接收数据而变化。</li>
<li>通信的双方都有发送缓冲区和接收数据的缓冲区</li>
</ul>
<br>

<p><strong>图例</strong></p>
<img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230214235843054.png" alt="image-20230214235843054" style="zoom:80%;">

<img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230214235856918.png" alt="image-20230214235856918" style="zoom:80%;">

<br>

<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230215000000336.png" alt="image-20230215000000336"></p>
<blockquote>
<p>mss: Maximum Segment Size(一条数据的最大的数据量)</p>
<p>win: 滑动窗口</p>
</blockquote>
<br>

<br>

<br>

<h3 id="4-2-5-四次挥手"><a href="#4-2-5-四次挥手" class="headerlink" title="4.2.5 四次挥手"></a>4.2.5 四次挥手</h3><ul>
<li>四次挥手发生在断开连接的时候，在程序中当调用了 close() 会使用TCP协议进行四次挥手。 </li>
<li>客户端和服务器端都可以主动发起断开连接，<strong>谁先调用 close() 谁就是发起</strong>。 </li>
<li>因为在TCP连接的时候，采用三次握手建立的的<strong>连接是双向</strong>的，在断开的时候需要<strong>双向断开</strong>。</li>
</ul>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230215010511553.png" alt="image-20230215010511553"></p>
<br>

<img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230215010632884.png" alt="image-20230215010632884" style="zoom:80%;">



<blockquote>
<p>ack &#x3D; 客户端的序号 + 数据长度 + SYN&#x2F;FIN(按一个字节算)</p>
</blockquote>
<br>

<br>

<br>

<br>

<h3 id="4-2-6-TCP状态转换"><a href="#4-2-6-TCP状态转换" class="headerlink" title="4.2.6 TCP状态转换"></a>4.2.6 TCP状态转换</h3><p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230215160143516.png" alt="image-20230215160143516"></p>
<br>

<br>

<p><strong>三次握手</strong></p>
<ul>
<li>客户端 SYN_SENT （发送 SYN ）</li>
<li>服务端 LISTEN -&gt; SYN_RCVD (接收并发送 SYN 和 ACK 回应)</li>
<li>客户端 ESTABLISHED （接收并发送 ACK ）</li>
<li>服务端 ESTABLISHED （接收）</li>
</ul>
<p><strong>数据传输</strong></p>
<ul>
<li>读写</li>
</ul>
<p><strong>四次握手</strong></p>
<ul>
<li>A: FIN_WAIT_1 （发送 FIN ）</li>
<li>B: CLOSE_WAIT （接收并发送 ACK ）</li>
<li>A: FIN_WAIT_2 （接收）</li>
<li>B: LAST_ACK   （发送 FIN ）</li>
<li>A: TIME_WAIT  （接收并发送ACK）</li>
<li>B: （接收）</li>
</ul>
<br>

<br>

<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230215161044162.png" alt="image-20230215161044162"></p>
<ul>
<li>红色当作客户端</li>
<li>绿色虚线当作服务端</li>
<li>黑色是异常</li>
</ul>
<blockquote>
<ul>
<li>四次握手中，前两次握手完成后，中间还可以继续通信一段时间，再去完成第三第四次握手。</li>
<li>TIME_WAIT：最后一次握手（主动方发送ACK）之后，无法立即确定对方是否收到ACK，所以要等待一段时间（<strong>两倍报文段寿命</strong>）来确定（如果对方收到了ACK就不会重发FIN）</li>
<li>2MSL 两倍报文段寿命：主动断开连接的一方, 最后进入一个 TIME_WAIT 状态, 这个状态会持续: 2msl。官方建议: 2分钟, 实际是30s</li>
</ul>
</blockquote>
<br>

<br>

<br>

<br>

<h2 id="4-3-并发服务器"><a href="#4-3-并发服务器" class="headerlink" title="4.3 并发服务器"></a>4.3 并发服务器</h2><h3 id="多进程实现"><a href="#多进程实现" class="headerlink" title="多进程实现"></a>多进程实现</h3><blockquote>
<p>要实现TCP通信服务器处理并发的任务，使用多线程或者多进程来解决。 </p>
<p>思路： </p>
<ol>
<li>一个父进程，多个子进程 </li>
<li>父进程负责等待并接受客户端的连接 </li>
<li>子进程：完成通信，接受一个客户端连接，就创建一个子进程用于通信。</li>
</ol>
</blockquote>
<br>

<h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><p>注意看注释</p>
<p><strong>子进程处理数据收发</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">// 不断循环等待客户端连接</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">        <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">        <span class="comment">// 接受连接</span></span><br><span class="line">        <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;len);</span><br><span class="line">        <span class="keyword">if</span>(cfd == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">==================================================================</span><br><span class="line">        <span class="comment">// 每一个连接进来，创建一个子进程跟客户端通信</span></span><br><span class="line">        <span class="type">pid_t</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 子进程</span></span><br><span class="line">            <span class="comment">// 获取客户端的信息</span></span><br><span class="line">            <span class="type">char</span> cliIp[<span class="number">16</span>];</span><br><span class="line">            inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, cliIp, <span class="keyword">sizeof</span>(cliIp));</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">short</span> cliPort = ntohs(cliaddr.sin_port);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client ip is : %s, prot is %d\n&quot;</span>, cliIp, cliPort);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 接收客户端发来的数据</span></span><br><span class="line">            <span class="type">char</span> recvBuf[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">int</span> len = read(cfd, &amp;recvBuf, <span class="keyword">sizeof</span>(recvBuf));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;recv client : %s\n&quot;</span>, recvBuf);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client closed....\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 回声服务器</span></span><br><span class="line">                write(cfd, recvBuf, <span class="built_in">strlen</span>(recvBuf) + <span class="number">1</span>);  <span class="comment">// 加1的目的是加上结束符</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            close(cfd);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);    <span class="comment">// 退出当前子进程</span></span><br><span class="line">        &#125;</span><br><span class="line">===================================================================</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<p><strong>利用信号来回收子进程资源</strong></p>
<p>注册信号 ( SIGCHLD )</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">   act.sa_flags = <span class="number">0</span>;</span><br><span class="line">   sigemptyset(&amp;act.sa_mask);</span><br><span class="line">   act.sa_handler = recyleChild;</span><br><span class="line">   <span class="comment">// 注册信号捕捉</span></span><br><span class="line">   sigaction(SIGCHLD, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<p>回调函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">recyleChild</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> ret = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="comment">// 所有的子进程都回收了</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 还有子进程活着</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 被回收了</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;子进程 %d 被回收了\n&quot;</span>, ret);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<br>

<br>

<p><strong>完整</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">recyleChild</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> ret = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="comment">// 所有的子进程都回收了</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 还有子进程活着</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 被回收了</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;子进程 %d 被回收了\n&quot;</span>, ret);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    act.sa_handler = recyleChild;</span><br><span class="line">    <span class="comment">// 注册信号捕捉</span></span><br><span class="line">    sigaction(SIGCHLD, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    <span class="type">int</span> ret = bind(lfd,(<span class="keyword">struct</span> sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不断循环等待客户端连接</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">        <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">        <span class="comment">// 接受连接</span></span><br><span class="line">        <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;len);</span><br><span class="line">        <span class="keyword">if</span>(cfd == <span class="number">-1</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;           <span class="comment">// 子进程的信号引发了软中断后，父进程中的accept会失败并设置错误号 EINTR，这时候不能让父进程（监听连接）退出</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每一个连接进来，创建一个子进程跟客户端通信</span></span><br><span class="line">        <span class="type">pid_t</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 子进程</span></span><br><span class="line">            <span class="comment">// 获取客户端的信息</span></span><br><span class="line">            <span class="type">char</span> cliIp[<span class="number">16</span>];</span><br><span class="line">            inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, cliIp, <span class="keyword">sizeof</span>(cliIp));</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">short</span> cliPort = ntohs(cliaddr.sin_port);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client ip is : %s, prot is %d\n&quot;</span>, cliIp, cliPort);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 接收客户端发来的数据</span></span><br><span class="line">            <span class="type">char</span> recvBuf[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">int</span> len = read(cfd, &amp;recvBuf, <span class="keyword">sizeof</span>(recvBuf));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;recv client : %s\n&quot;</span>, recvBuf);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client closed....\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                write(cfd, recvBuf, <span class="built_in">strlen</span>(recvBuf) + <span class="number">1</span>);  <span class="comment">// 加1的目的是加上结束符</span></span><br><span class="line">            &#125;</span><br><span class="line">            close(cfd);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);    <span class="comment">// 退出当前子进程</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<br>

<p><br><br></p>
<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TCP通信的客户端</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建套接字</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.连接服务器端</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span>;</span></span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;192.168.193.128&quot;</span>, &amp;serveraddr.sin_addr.s_addr);</span><br><span class="line">    serveraddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    <span class="type">int</span> ret = connect(fd, (<span class="keyword">struct</span> sockaddr *)&amp;serveraddr, <span class="keyword">sizeof</span>(serveraddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 通信</span></span><br><span class="line">    <span class="type">char</span> recvBuf[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">sprintf</span>(recvBuf, <span class="string">&quot;data : %d\n&quot;</span>, i++);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 给服务器端发送数据</span></span><br><span class="line">        write(fd, recvBuf, <span class="built_in">strlen</span>(recvBuf)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> len = read(fd, recvBuf, <span class="keyword">sizeof</span>(recvBuf));</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv server : %s\n&quot;</span>, recvBuf);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 表示服务器端断开连接</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;server closed...&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭连接</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<p><strong>注意</strong>：</p>
<p>如果客户端或者服务端进程提前终止，没有调用close(fd)，那么后续的数据传输会引发错误</p>
<p>比如</p>
<br>

<br>

<br>

<br>

<h3 id="多线程实现"><a href="#多线程实现" class="headerlink" title="多线程实现"></a>多线程实现</h3><p><strong>服务端</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockInfo</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> fd; <span class="comment">// 通信的文件描述符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;  <span class="comment">// 线程号</span></span><br><span class="line">    <span class="type">int</span> pos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockInfo</span> <span class="title">sockinfos</span>[128];</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">working</span><span class="params">(<span class="type">void</span> * arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 子线程和客户端通信   cfd 客户端的信息 线程号</span></span><br><span class="line">    <span class="comment">// 获取客户端的信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockInfo</span> * <span class="title">pinfo</span> =</span> (<span class="keyword">struct</span> sockInfo *)arg;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> cliIp[<span class="number">16</span>];</span><br><span class="line">    inet_ntop(AF_INET, &amp;pinfo-&gt;addr.sin_addr.s_addr, cliIp, <span class="keyword">sizeof</span>(cliIp));</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> cliPort = ntohs(pinfo-&gt;addr.sin_port);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client ip is : %s, prot is %d\n&quot;</span>, cliIp, cliPort);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收客户端发来的数据</span></span><br><span class="line">    <span class="type">char</span> recvBuf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> len = read(pinfo-&gt;fd, &amp;recvBuf, <span class="keyword">sizeof</span>(recvBuf));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv client : %s\n&quot;</span>, recvBuf);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client closed....\n&quot;</span>);</span><br><span class="line">            sockinfos[pinfo-&gt;pos].fd = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        write(pinfo-&gt;fd, recvBuf, <span class="built_in">strlen</span>(recvBuf) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(pinfo-&gt;fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    <span class="type">int</span> ret = bind(lfd,(<span class="keyword">struct</span> sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化数据</span></span><br><span class="line">    <span class="type">int</span> max = <span class="keyword">sizeof</span>(sockinfos) / <span class="keyword">sizeof</span>(sockinfos[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">        bzero(&amp;sockinfos[i], <span class="keyword">sizeof</span>(sockinfos[i]));</span><br><span class="line">        sockinfos[i].fd = <span class="number">-1</span>;</span><br><span class="line">        sockinfos[i].tid = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环等待客户端连接，一旦一个客户端连接进来，就创建一个子线程进行通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">        <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">        <span class="comment">// 接受连接</span></span><br><span class="line">        <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;len);</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockInfo</span> * <span class="title">pinfo</span>;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">            <span class="comment">// 从这个数组中找到一个可以用的sockInfo元素</span></span><br><span class="line">            <span class="keyword">if</span>(sockinfos[i].fd == <span class="number">-1</span>) &#123;</span><br><span class="line">                pinfo = &amp;sockinfos[i];</span><br><span class="line">                pinfo-&gt;pos = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i == max - <span class="number">1</span>) &#123;</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">                i = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pinfo-&gt;fd = cfd;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;pinfo-&gt;addr, &amp;cliaddr, len);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建子线程</span></span><br><span class="line">        pthread_create(&amp;pinfo-&gt;tid, <span class="literal">NULL</span>, working, pinfo);</span><br><span class="line"></span><br><span class="line">        pthread_detach(pinfo-&gt;tid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<br>

<p><br><br></p>
<br>

<br>

<p><br><br></p>
<br>

<br>

<h2 id="4-4-复用"><a href="#4-4-复用" class="headerlink" title="4.4 复用"></a>4.4 复用</h2><h3 id="4-4-1-半关闭、端口复用、IO多路复用"><a href="#4-4-1-半关闭、端口复用、IO多路复用" class="headerlink" title="4.4.1 半关闭、端口复用、IO多路复用"></a>4.4.1 半关闭、端口复用、IO多路复用</h3><h4 id="半关闭"><a href="#半关闭" class="headerlink" title="半关闭"></a>半关闭</h4><ul>
<li><strong>主动关闭方</strong> 从发送 FIN 并收到 ACK 后，到收到对方的 FIN 之前，处于 <strong>半关闭</strong> 状态。</li>
<li>此时还可以接收对方发送的数据，但不能够再向对方发送数据。</li>
</ul>
<br>

<p>半关闭不使用 close 实现，而是使用 shutdown ：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shutdown</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> how)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//	sockfd: 需要关闭的socket的描述符</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//	how: 允许为shutdown操作选择以下几种方式:</span></span><br><span class="line"><span class="comment">//		- SHUT_RD(0): 关闭sockfd上的 读 功能，此选项将不允许sockfd进行读操作。该套接字不再接收数据，任何当前在套接字接受缓冲区的数据将被无声的丢弃掉。</span></span><br><span class="line"><span class="comment">//		- SHUT_WR(1): 关闭sockfd的 写 功能，此选项将不允许sockfd进行写操作。进程不能对此套接字发出写操作。</span></span><br><span class="line"><span class="comment">//		- SHUT_RDWR(2): 关闭sockfd的读写功能。相当于调用shutdown两次：首先是以SHUT_RD,然后以SHUT_WR。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>close 中止一个连接，但它只是<strong>减少描述符的引用计数</strong>，并不直接关闭连接，只有<strong>当描述符的引用计数为 0 时才关闭连接</strong>。</li>
<li>shutdown 不考虑描述符的引用计数，<strong>直接关闭描述符</strong>。也<strong>可选择中止一个方向的连接</strong>，只中止读或只中止写。</li>
</ul>
<blockquote>
<p><strong>注意:</strong></p>
<ul>
<li>如果有多个进程共享一个套接字，close 每被调用一次，计数减 1 ，直到计数为 0 时，也就是所用进程都调用了 close，套接字将被释放。</li>
<li>在多进程中如果一个进程调用了 shutdown(sfd, SHUT_RDWR) 后，其它的进程将无法进行通信。<u>但如果一个进程 close(sfd) 将不会影响到其它进程。</u></li>
</ul>
</blockquote>
<br>

<br>

<h4 id="端口复用"><a href="#端口复用" class="headerlink" title="端口复用"></a>端口复用</h4><p>最常用的用途:</p>
<ul>
<li>防止服务器重启时之前绑定的端口还未释放</li>
<li>程序突然退出而系统没有释放端口</li>
</ul>
<blockquote>
<p>常看网络相关信息的命令:<code>netstat</code><br>参数：<br>    -a 所有的socket<br>    -p 显示正在使用socket的程序的名称<br>    -n 直接使用IP地址，而不通过域名服务器</p>
<p>​	…</p>
</blockquote>
<br>

<p><strong>setsockopt函数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置套接字的属性（不仅仅能设置端口复用）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">const</span> <span class="type">void</span> *optval, <span class="type">socklen_t</span> optlen)</span>;</span><br><span class="line">	参数（在UNP（Unix网络编程）书籍中使用）：</span><br><span class="line">		- sockfd : 要操作的文件描述符</span><br><span class="line">		- level : 级别 SOL_SOCKET (使用端口复用的级别)</span><br><span class="line">		- optname : 选项的名称</span><br><span class="line">			- SO_REUSEADDR	IP重用</span><br><span class="line">			- SO_REUSEPORT	端口复用</span><br><span class="line">		- optval : 端口复用的值（整型）</span><br><span class="line">			- <span class="number">1</span> : 可以复用</span><br><span class="line">			- <span class="number">0</span> : 不可以复用</span><br><span class="line">		- optlen : optval参数的大小</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line"><span class="comment">// 端口复用，设置的时机是在服务器绑定端口之前</span></span><br><span class="line">	setsockopt();</span><br><span class="line"></span><br><span class="line">	bind();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<br>

<h4 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h4><p>又称 <strong>IO多路转接</strong></p>
<ul>
<li>不是传统意义上的文件IO，而是对套接字读写缓冲区的IO管理</li>
<li>I&#x2F;O 多路复用使得程序能 <strong>同时监听多个文件描述符</strong> ，能够提高程序的性能，Linux 下实现 I&#x2F;O 多路复用的系统调用主要有 <strong>select、poll 和 epoll</strong>。</li>
</ul>
<br>

<p><strong>等待模型</strong></p>
<ol>
<li><strong>阻塞等待</strong>（阻塞IO模型即 <strong>BIO模型</strong> ）</li>
</ol>
<p>优点：不占用CPU宝贵的时间片</p>
<p>缺点：<br>    同一时刻只能处理一个操作，效率低（单进程&#x2F;单线程）<br>    线程或进程的创建消耗系统资源，调度消耗CPU资源（多线程&#x2F;多进程）</p>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230215175146862.png" alt="image-20230215175146862"></p>
<br>

<ol start="2">
<li><strong>非阻塞</strong>，<strong>忙轮询</strong>（非阻塞模型即 <strong>NIO模型</strong> ）</li>
</ol>
<p>优点：提高了程序的执行效率</p>
<p>缺点：占有更多的CPU和系统资源</p>
<p>使用 <strong>IO多路复用</strong>（select，poll，epoll） 来解决这里的缺点,</p>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230215175852729.png" alt="image-20230215175852729"></p>
<br>

<br>

<ul>
<li>第一种IO多路复用技术（select&#x2F;poll）<br><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230215180146018.png" alt="image-20230215180146018"></li>
<li>第二种IO多路复用技术（epoll）<br><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230215180630626.png" alt="image-20230215180630626"></li>
</ul>
<br>

<br>

<br>

<h3 id="4-4-2-Select"><a href="#4-4-2-Select" class="headerlink" title="4.4.2 Select"></a>4.4.2 Select</h3><p><strong>主要思路：</strong></p>
<ol>
<li>首先要构造一个<strong>关于文件描述符的列表</strong>，将要监听的文件描述符添加到该列表中。</li>
<li>调用一个系统函数（即select），<strong>监听该列表中的文件描述符</strong>，<u>直到这些描述符中的一个或者多个进行I&#x2F;O操作时，该函数才返回</u>。<ul>
<li>这个函数是<strong>阻塞的</strong></li>
<li>函数对文件描述符的检测的操作是由<strong>内核完成的</strong></li>
</ul>
</li>
<li>在返回时，它会告诉进程<strong>有多少（哪些）描述符</strong>要进行I&#x2F;O操作。</li>
</ol>
<br>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">fd_set 就是文件描述符的 位集，用 位 来表示各个描述符的状态</span><br><span class="line"><span class="comment">// sizeof(fd_set) = 128个字节 1024位</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 委托内核监听列表中的文件描述符</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span>;</span><br><span class="line">	- 参数：</span><br><span class="line">		- nfds : 委托内核检测的最大文件描述符的值 + <span class="number">1</span></span><br><span class="line">		- readfds : 要检测的文件描述符的读的集合，委托内核检测哪些文件描述符的读的属性</span><br><span class="line">			- 一般检测读操作</span><br><span class="line">			- 对应的是对方发送过来的数据，因为读是被动的接收数据，检测的就是读缓冲区</span><br><span class="line">            - 是一个 传入传出参数</span><br><span class="line">		- writefds : 要检测的文件描述符的写的集合，委托内核检测哪些文件描述符的写的属性</span><br><span class="line">			- 委托内核检测写缓冲区是不是还可以写数据（不满的就可以写）</span><br><span class="line">		- exceptfds : 检测发生异常的文件描述符的集合</span><br><span class="line">		- timeout : 设置的超时时间</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">				<span class="type">long</span> tv_sec; <span class="comment">/* seconds */</span></span><br><span class="line">				<span class="type">long</span> tv_usec; <span class="comment">/* microseconds */</span></span><br><span class="line">			&#125;;</span><br><span class="line">			- <span class="literal">NULL</span> : 永久阻塞，直到检测到了文件描述符有变化</span><br><span class="line">			- tv_sec = <span class="number">0</span> tv_usec = <span class="number">0</span>， 不阻塞</span><br><span class="line">			- tv_sec &gt; <span class="number">0</span> tv_usec &gt; <span class="number">0</span>， 阻塞对应的时间</span><br><span class="line">	- 返回值 :</span><br><span class="line">		- <span class="number">-1</span> : 失败</span><br><span class="line">		- &gt;<span class="number">0</span>(n) : 检测的集合中有n个文件描述符发生了变化</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">对位集合的操作         </span><br><span class="line"><span class="comment">// 将参数文件描述符fd对应的标志位设置为0（clear）</span></span><br><span class="line"><span class="type">void</span> FD_CLR(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将参数文件描述符fd 对应的标志位，设置为1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fd_set一共有1024 bit, 全部初始化为0</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断fd对应的标志位是0还是1， 返回值 ： fd对应的标志位的值，如果是0返回0， 是1返回1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<br>

<br>

<p><strong>Select 工作流程</strong></p>
<img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230215204459693.png" alt="image-20230215204459693" style="zoom: 67%;">



<img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230215204514747.png" alt="image-20230215204514747" style="zoom: 67%;">

<img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230215220639318.png" alt="image-20230215220639318" style="zoom:80%;">

<br>

<p><strong>服务端</strong></p>
<ul>
<li>accept之前先设置好fdset并调用select</li>
<li>如果select检测出数据变动：<ul>
<li>如果是服务端的socketfd有变动，则表示有客户端连接可进行accept</li>
<li>然后再for循环文件描述符列表进行读写处理（如果需要的话）</li>
</ul>
</li>
<li>fdset用到两个，一个用来给select调用，一个用来维护文件描述符列表</li>
<li>注意需要维护一个最大文件描述符</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    bind(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    listen(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个fd_set的集合，存放的是需要检测的文件描述符</span></span><br><span class="line">    fd_set rdset, tmp;	<span class="comment">// tmp用来给内核检测，rdset用来维护存在的文件描述符</span></span><br><span class="line">    FD_ZERO(&amp;rdset);</span><br><span class="line">    FD_SET(lfd, &amp;rdset);  <span class="comment">// select调用前rdset的某位fd为1表示我们希望内核帮我们检测该fd对应的接收缓存。select调用后rdset对应的fd为1表示该接收缓存接收到数据了，为0表示没接收到数据</span></span><br><span class="line">    <span class="type">int</span> maxfd = lfd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        tmp = rdset;  <span class="comment">// 这里要记得</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用select系统函数，让内核帮检测哪些文件描述符有数据</span></span><br><span class="line">        <span class="type">int</span> ret = select(maxfd + <span class="number">1</span>, &amp;tmp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;select&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 说明检测到了有文件描述符的对应的缓冲区的数据发生了改变</span></span><br><span class="line">            <span class="keyword">if</span>(FD_ISSET(lfd, &amp;tmp)) &#123;</span><br><span class="line">                <span class="comment">// 表示有新的客户端连接进来了</span></span><br><span class="line">                <span class="keyword">struct</span> sockaddr_in cliaddr;</span><br><span class="line">                <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">                <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;cliaddr, &amp;len);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将新的文件描述符加入到集合中</span></span><br><span class="line">                FD_SET(cfd, &amp;rdset);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 更新最大的文件描述符</span></span><br><span class="line">                maxfd = maxfd &gt; cfd ? maxfd : cfd;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = lfd + <span class="number">1</span>; i &lt;= maxfd; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(FD_ISSET(i, &amp;tmp)) &#123;</span><br><span class="line">                    <span class="comment">// 说明这个文件描述符对应的客户端发来了数据</span></span><br><span class="line">                    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                    <span class="type">int</span> len = read(i, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                    <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">                        perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;client closed...\n&quot;</span>);</span><br><span class="line">                        close(i);</span><br><span class="line">                        FD_CLR(i, &amp;rdset);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, buf);</span><br><span class="line">                        write(i, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<p><strong>客户端</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> fd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">seraddr</span>;</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;seraddr.sin_addr.s_addr);</span><br><span class="line">    seraddr.sin_family = AF_INET;</span><br><span class="line">    seraddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接服务器</span></span><br><span class="line">    <span class="type">int</span> ret = connect(fd, (<span class="keyword">struct</span> sockaddr *)&amp;seraddr, <span class="keyword">sizeof</span>(seraddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">char</span> sendBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">sprintf</span>(sendBuf, <span class="string">&quot;send data %d&quot;</span>, num++);</span><br><span class="line">        write(fd, sendBuf, <span class="built_in">strlen</span>(sendBuf) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收</span></span><br><span class="line">        <span class="type">int</span> len = read(fd, sendBuf, <span class="keyword">sizeof</span>(sendBuf));</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, sendBuf);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;服务器已经断开连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// sleep(1);</span></span><br><span class="line">        usleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<br>

<br>

<p><strong>Select 的缺点</strong></p>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230215221709493.png" alt="image-20230215221709493"></p>
<br>

<br>

<br>

<h3 id="4-4-3-poll"><a href="#4-4-3-poll" class="headerlink" title="4.4.3 poll"></a>4.4.3 poll</h3><p>select的改进版</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> fd; <span class="comment">/* 委托内核检测的文件描述符 */</span></span><br><span class="line">	<span class="type">short</span> events; <span class="comment">/* 委托内核检测文件描述符的什么事件 */</span></span><br><span class="line">	<span class="type">short</span> revents; <span class="comment">/* 文件描述符实际发生的事件 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">myfd</span>;</span></span><br><span class="line">	myfd.fd = <span class="number">5</span>;</span><br><span class="line">    myfd.events = POLLIN | POLLOUT;  同时委托内核进行读写操作</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span>;</span><br><span class="line">	- 参数：</span><br><span class="line">		- fds : 是一个<span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> 结构体数组，这是一个需要检测的文件描述符的集合</span></span><br><span class="line"><span class="class">		- <span class="title">nfds</span> :</span> 这个是第一个参数数组中最后一个有效元素的下标 + <span class="number">1</span></span><br><span class="line">		- timeout : 阻塞时长</span><br><span class="line">			<span class="number">0</span> : 不阻塞</span><br><span class="line">			<span class="number">-1</span> : 阻塞，当检测到需要检测的文件描述符有变化，解除阻塞</span><br><span class="line">			&gt;<span class="number">0</span> : 阻塞的时长</span><br><span class="line">	- 返回值：</span><br><span class="line">		<span class="number">-1</span> : 失败</span><br><span class="line">		&gt;<span class="number">0</span>（n） : 成功，n表示检测到集合中有n个文件描述符发生变化</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<p>short类型，表示发生事件</p>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230215224613996.png" alt="image-20230215224613996"></p>
<br>

<p><strong>服务端</strong></p>
<ul>
<li><p>在到客户端连接时，在accept之后要在pollfd数组中找一个靠前的位置来记录；</p>
</li>
<li><p>其他的跟select类似。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    bind(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    listen(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化检测的文件描述符数组</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>[1024];</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++) &#123;</span><br><span class="line">        fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">        fds[i].events = POLLIN;</span><br><span class="line">    &#125;</span><br><span class="line">    fds[<span class="number">0</span>].fd = lfd;</span><br><span class="line">    <span class="type">int</span> nfds = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用poll系统函数，让内核帮检测哪些文件描述符有数据</span></span><br><span class="line">        <span class="type">int</span> ret = poll(fds, nfds + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;poll&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 说明检测到了有文件描述符的对应的缓冲区的数据发生了改变</span></span><br><span class="line">            <span class="keyword">if</span>(fds[<span class="number">0</span>].revents &amp; POLLIN) &#123;</span><br><span class="line">                <span class="comment">// 表示有新的客户端连接进来了</span></span><br><span class="line">                <span class="keyword">struct</span> sockaddr_in cliaddr;</span><br><span class="line">                <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">                <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;cliaddr, &amp;len);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将新的文件描述符加入到集合中</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1024</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(fds[i].fd == <span class="number">-1</span>) &#123;</span><br><span class="line">                        fds[i].fd = cfd;</span><br><span class="line">                        fds[i].events = POLLIN;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 更新最大的文件描述符的索引</span></span><br><span class="line">                nfds = nfds &gt; cfd ? nfds : cfd;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">			<span class="comment">// 最大的文件描述符 一定 大于等于它在数组中的下标。</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= nfds; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(fds[i].revents &amp; POLLIN) &#123;</span><br><span class="line">                    <span class="comment">// 说明这个文件描述符对应的客户端发来了数据</span></span><br><span class="line">                    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                    <span class="type">int</span> len = read(fds[i].fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                    <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">                        perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;client closed...\n&quot;</span>);</span><br><span class="line">                        close(fds[i].fd);</span><br><span class="line">                        fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, buf);</span><br><span class="line">                        write(fds[i].fd, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>





<br>

<br>

<br>

<h3 id="4-4-4-epoll"><a href="#4-4-4-epoll" class="headerlink" title="4.4.4 epoll"></a>4.4.4 epoll</h3><p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230215225908336.png" alt="image-20230215225908336"></p>
<ol>
<li>不用从用户态拷贝数据到内核，直接在内核中进行实例化和数据处理</li>
<li>采用了更高效的数据结构<ul>
<li>红黑树：存储所有fd，用来遍历检测哪些发生数据改变</li>
<li>双向链表：存放发生数据改变的fd的就绪列表</li>
</ul>
</li>
</ol>
<br>

<br>

<br>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新的epoll实例。在内核中创建了一个数据，这个数据中有两个比较重要的数据，一个是需要检测的文件描述符的信息（红黑树），还有一个是就绪列表，存放检测到数据发送改变的文件描述符信息（双向链表）。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br><span class="line">	- 参数：</span><br><span class="line">		size : 目前没有意义了。随便写一个数，必须大于<span class="number">0</span></span><br><span class="line">	- 返回值：</span><br><span class="line">		<span class="number">-1</span> : 失败</span><br><span class="line">		&gt; <span class="number">0</span> : 文件描述符，操作epoll实例的fd</span><br><span class="line">         </span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">	<span class="type">uint32_t</span> events; <span class="comment">/* Epoll events */</span></span><br><span class="line">	<span class="type">epoll_data_t</span> data; <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br><span class="line">常见的Epoll检测事件：</span><br><span class="line">	- EPOLLIN</span><br><span class="line">	- EPOLLOUT</span><br><span class="line">	- EPOLLERR</span><br><span class="line">	- EPOLLET  <span class="comment">// 边沿触发</span></span><br><span class="line">  	- ...</span><br><span class="line">    	</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span>	<span class="comment">// 是一个union</span></span><br><span class="line">	<span class="type">void</span> *ptr;</span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	<span class="type">uint32_t</span> u32;</span><br><span class="line">	<span class="type">uint64_t</span> u64;</span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 对epoll实例进行管理：添加文件描述符信息，删除信息，修改信息</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>;</span><br><span class="line">	- 参数：</span><br><span class="line">		- epfd : epoll实例对应的文件描述符</span><br><span class="line">		- op : 要进行什么操作</span><br><span class="line">			EPOLL_CTL_ADD: 添加</span><br><span class="line">			EPOLL_CTL_MOD: 修改</span><br><span class="line">			EPOLL_CTL_DEL: 删除</span><br><span class="line">		- fd : 要检测的文件描述符</span><br><span class="line">		- event : 检测文件描述符什么事情</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line"><span class="comment">// 检测函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br><span class="line">	- 参数：</span><br><span class="line">		- epfd : epoll实例对应的文件描述符</span><br><span class="line">		- events : 传出参数，一个epoll_event数组，保存了发生了变化的文件描述符</span><br><span class="line">		- maxevents : 第二个参数结构体数组的大小</span><br><span class="line">		- timeout : 阻塞时间</span><br><span class="line">			- <span class="number">0</span> : 不阻塞</span><br><span class="line">			- <span class="number">-1</span> : 阻塞，直到检测到fd数据发生变化，解除阻塞</span><br><span class="line">			- &gt; <span class="number">0</span> : 阻塞的时长（毫秒）</span><br><span class="line">	- 返回值：</span><br><span class="line">		- 成功，返回发送变化的文件描述符的个数 &gt; <span class="number">0</span></span><br><span class="line">		- 失败 <span class="number">-1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<br>

<p><strong>服务端</strong></p>
<p>根据监听读还是写事件来编写对应的处理</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    bind(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    listen(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用epoll_create()创建一个epoll实例</span></span><br><span class="line">    <span class="type">int</span> epfd = epoll_create(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将监听的文件描述符相关的检测信息添加到epoll实例中</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epev</span>;</span></span><br><span class="line">    epev.events = EPOLLIN;</span><br><span class="line">    epev.data.fd = lfd;</span><br><span class="line">    epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;epev);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epevs</span>[1024];</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ret = epoll_wait(epfd, epevs, <span class="number">1024</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>, ret);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; ret; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> curfd = epevs[i].data.fd;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(curfd == lfd) &#123;</span><br><span class="line">                <span class="comment">// 监听的文件描述符有数据达到，有客户端连接</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">                <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">                <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;cliaddr, &amp;len);</span><br><span class="line">				</span><br><span class="line">                <span class="comment">// 将客户端文件描述符相关的检测信息添加到epoll实例中</span></span><br><span class="line">                epev.events = EPOLLIN;</span><br><span class="line">                epev.data.fd = cfd;</span><br><span class="line">                epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;epev);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(epevs[i].events &amp; EPOLLOUT) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;   </span><br><span class="line">                <span class="comment">// 有数据到达，需要通信</span></span><br><span class="line">                <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="type">int</span> len = read(curfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client closed...\n&quot;</span>);</span><br><span class="line">                    epoll_ctl(epfd, EPOLL_CTL_DEL, curfd, <span class="literal">NULL</span>);</span><br><span class="line">                    close(curfd);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, buf);</span><br><span class="line">                    write(curfd, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(lfd);</span><br><span class="line">    close(epfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<br>

<h4 id="epoll-两种工作模式"><a href="#epoll-两种工作模式" class="headerlink" title="epoll 两种工作模式"></a>epoll 两种工作模式</h4><br>

<ul>
<li><strong>LT</strong> 模式（<strong>水平触发</strong>）<ul>
<li>假设委托内核检测读事件 -&gt; 检测fd的读缓冲区</li>
<li>读缓冲区有数据 -&gt; epoll检测到了会给用户通知<ul>
<li>用户不读数据，数据会一直在缓冲区，epoll会一直通知</li>
<li>用户只读了一部分数据，epoll会通知</li>
<li>用户读完数据，epoll不通知</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>能否一次读完得看缓冲区大小和每次读取的数量</p>
<blockquote>
<p>LT（level - triggered）是缺省（即默认）的工作方式，并且同时支持 <strong>block 和 no-block socket</strong>。在这种做法中，<strong>内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的 fd 进行 IO 操作</strong>。如果你不作任何操作，<strong>内核还是会继续通知你的</strong>。</p>
</blockquote>
<br>

<ul>
<li><strong>ET</strong> 模式（<strong>边缘触发</strong>）<ul>
<li>假设委托内核检测读事件 -&gt; 检测fd的读缓冲区</li>
<li>读缓冲区有数据 -&gt; epoll 检测到了会给用户通知<ul>
<li>用户不读数据，数据一致在缓冲区中，epoll下次检测时不通知</li>
<li>用户只读了一部分数据，epoll不通知</li>
<li>用户读完数据，epoll不通知</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li><p>ET（edge - triggered）是高速工作方式，<strong>只支持 no-block socket</strong>。</p>
</li>
<li><p>在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，<strong>直到你做了某些操作导致那个文件描述符不再为就绪状态了</strong>。但是请注意，如果一直不对这个 fd 作 IO 操作（从而导致它再次变成未就绪），内核不会发送更多的通知（only once）。</p>
</li>
<li><p>ET 模式在很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。</p>
</li>
<li><p>epoll工作在 ET 模式的时候，必须使用<strong>非阻塞</strong>套接口，<strong>以避免由于一个文件句柄的阻塞读&#x2F;阻塞写操作把处理多个文件描述符的任务饿死。</strong></p>
</li>
</ul>
</blockquote>
<br>

<br>

<p><strong>客户端</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> fd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">seraddr</span>;</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;seraddr.sin_addr.s_addr);</span><br><span class="line">    seraddr.sin_family = AF_INET;</span><br><span class="line">    seraddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接服务器</span></span><br><span class="line">    <span class="type">int</span> ret = connect(fd, (<span class="keyword">struct</span> sockaddr *)&amp;seraddr, <span class="keyword">sizeof</span>(seraddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">char</span> sendBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">// sprintf(sendBuf, &quot;send data %d&quot;, num++);</span></span><br><span class="line">        fgets(sendBuf, <span class="keyword">sizeof</span>(sendBuf), <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">        write(fd, sendBuf, <span class="built_in">strlen</span>(sendBuf) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收</span></span><br><span class="line">        <span class="type">int</span> len = read(fd, sendBuf, <span class="keyword">sizeof</span>(sendBuf));</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, sendBuf);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;服务器已经断开连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<br>

<p><strong>LT 服务端</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    bind(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    listen(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用epoll_create()创建一个epoll实例</span></span><br><span class="line">    <span class="type">int</span> epfd = epoll_create(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将监听的文件描述符相关的检测信息添加到epoll实例中</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epev</span>;</span></span><br><span class="line">    epev.events = EPOLLIN;</span><br><span class="line">    epev.data.fd = lfd;</span><br><span class="line">    epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;epev);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epevs</span>[1024];</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ret = epoll_wait(epfd, epevs, <span class="number">1024</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>, ret);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; ret; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> curfd = epevs[i].data.fd;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(curfd == lfd) &#123;</span><br><span class="line">                <span class="comment">// 监听的文件描述符有数据达到，有客户端连接</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">                <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">                <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;cliaddr, &amp;len);</span><br><span class="line"></span><br><span class="line">                epev.events = EPOLLIN;</span><br><span class="line">                epev.data.fd = cfd;</span><br><span class="line">                epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;epev);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(epevs[i].events &amp; EPOLLOUT) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;   </span><br><span class="line">                <span class="comment">// 有数据到达，需要通信</span></span><br><span class="line">                <span class="type">char</span> buf[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="type">int</span> len = read(curfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client closed...\n&quot;</span>);</span><br><span class="line">                    epoll_ctl(epfd, EPOLL_CTL_DEL, curfd, <span class="literal">NULL</span>);</span><br><span class="line">                    close(curfd);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, buf);</span><br><span class="line">                    write(curfd, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(lfd);</span><br><span class="line">    close(epfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<br>

<br>

<br>

<p><strong>ET 服务端</strong></p>
<ul>
<li>用fctnl设置连接客户端的文件描述符为非阻塞</li>
<li>设置客户端fd的epoll_event为边缘触发模式</li>
<li>读数据的时候用循环来读完</li>
<li>数据读完之后，在非阻塞的条件下，再去read对应的fd会引发<strong>EAGAIN</strong>，需要用条件判断避开</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    bind(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    listen(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用epoll_create()创建一个epoll实例</span></span><br><span class="line">    <span class="type">int</span> epfd = epoll_create(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将监听的文件描述符相关的检测信息添加到epoll实例中</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epev</span>;</span></span><br><span class="line">    epev.events = EPOLLIN;</span><br><span class="line">    epev.data.fd = lfd;</span><br><span class="line">    epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;epev);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epevs</span>[1024];</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ret = epoll_wait(epfd, epevs, <span class="number">1024</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>, ret);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; ret; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> curfd = epevs[i].data.fd;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(curfd == lfd) &#123;</span><br><span class="line">                <span class="comment">// 监听的文件描述符有数据达到，有客户端连接</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">                <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">                <span class="type">int</span> cfd = accept(lf d, (<span class="keyword">struct</span> sockaddr *)&amp;cliaddr, &amp;len);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 设置cfd属性非阻塞</span></span><br><span class="line">                <span class="type">int</span> flag = fcntl(cfd, F_GETFL);</span><br><span class="line">                flag |= O_NONBLOCK;</span><br><span class="line">                fcntl(cfd, F_SETFL, flag);</span><br><span class="line"></span><br><span class="line">                epev.events = EPOLLIN | EPOLLET;    <span class="comment">// 设置边沿触发</span></span><br><span class="line">                epev.data.fd = cfd;</span><br><span class="line">                epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;epev);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(epevs[i].events &amp; EPOLLOUT) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;  </span><br><span class="line"></span><br><span class="line">                <span class="comment">// 循环读取出所有数据</span></span><br><span class="line">                <span class="type">char</span> buf[<span class="number">5</span>];</span><br><span class="line">                <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>( (len = read(curfd, buf, <span class="keyword">sizeof</span>(buf))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 打印数据</span></span><br><span class="line">                    <span class="comment">// printf(&quot;recv data : %s\n&quot;, buf);</span></span><br><span class="line">                    write(STDOUT_FILENO, buf, len);</span><br><span class="line">                    write(curfd, buf, len);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client closed....&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(errno == EAGAIN) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;data over.....&quot;</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(lfd);</span><br><span class="line">    close(epfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<br>

<br>

<br>

<h2 id="4-5-UDP通信"><a href="#4-5-UDP通信" class="headerlink" title="4.5 UDP通信"></a>4.5 UDP通信</h2><h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230216011718092.png" alt="image-20230216011718092"></p>
<p><strong>服务端</strong></p>
<ul>
<li>创建socket</li>
<li>绑定ip端口</li>
<li>通信</li>
<li>关闭socket</li>
</ul>
<p><strong>客户端</strong></p>
<ul>
<li>创建socket</li>
<li>通信</li>
<li>关闭socket</li>
</ul>
<br>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line">or</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *dest_addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line">	- 参数：</span><br><span class="line">		- sockfd : 通信的fd</span><br><span class="line">		- buf : 要发送的数据</span><br><span class="line">		- len : 发送数据的长度</span><br><span class="line">		- flags : <span class="number">0</span></span><br><span class="line">		- dest_addr : 传出参数，指定通信的另外一端的地址信息</span><br><span class="line">		- addrlen : 地址的内存大小</span><br><span class="line">           </span><br><span class="line">            </span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags, <span class="keyword">struct</span> sockaddr *src_addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br><span class="line">	- 参数：</span><br><span class="line">		- sockfd : 通信的fd</span><br><span class="line">		- buf : 接收数据的数组</span><br><span class="line">		- len : 数组的大小</span><br><span class="line">    	- flags : <span class="number">0</span></span><br><span class="line">		- src_addr : 传入参数，用来保存另外一端的地址信息，不需要可以指定为<span class="literal">NULL</span></span><br><span class="line">		- addrlen : 地址的内存大小</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<br>

<p><strong>服务端</strong></p>
<p>bind 绑定后不需要监听 listen</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建一个通信的socket</span></span><br><span class="line">    <span class="type">int</span> fd = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.绑定</span></span><br><span class="line">    <span class="type">int</span> ret = bind(fd, (<span class="keyword">struct</span> sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">char</span> recvbuf[<span class="number">128</span>];</span><br><span class="line">        <span class="type">char</span> ipbuf[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">        <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="type">int</span> num = recvfrom(fd, recvbuf, <span class="keyword">sizeof</span>(recvbuf), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;cliaddr, &amp;len);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client IP : %s, Port : %d\n&quot;</span>, </span><br><span class="line">            inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, ipbuf, <span class="keyword">sizeof</span>(ipbuf)),</span><br><span class="line">            ntohs(cliaddr.sin_port));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client say : %s\n&quot;</span>, recvbuf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        sendto(fd, recvbuf, <span class="built_in">strlen</span>(recvbuf) + <span class="number">1</span>, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;cliaddr, <span class="keyword">sizeof</span>(cliaddr));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<br>

<p><strong>客户端</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建一个通信的socket</span></span><br><span class="line">    <span class="type">int</span> fd = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务器的地址信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;saddr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 3.通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        <span class="type">char</span> sendBuf[<span class="number">128</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(sendBuf, <span class="string">&quot;hello , i am client %d \n&quot;</span>, num++);</span><br><span class="line">        sendto(fd, sendBuf, <span class="built_in">strlen</span>(sendBuf) + <span class="number">1</span>, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="type">int</span> num = recvfrom(fd, sendBuf, <span class="keyword">sizeof</span>(sendBuf), <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server say : %s\n&quot;</span>, sendBuf);</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<br>

<br>

<br>

<h3 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h3><p>向 <strong>子网</strong> 中多台计算机发送消息，并且子网中所有的计算机都可以接收到发送方发送的消息，每个广播消息都包含一个特殊的IP地址（<strong>广播地址</strong>），除了子网ip外的主机部分的二进制位都为1。</p>
<ul>
<li>只能在<strong>局域网</strong>中使用。</li>
<li><strong>客户端</strong>需要绑定<strong>服务器广播使用的端口</strong>，才可以接收到广播消息。</li>
</ul>
<br>

<p><strong>服务端</strong></p>
<ul>
<li>用setsockopt设置sockfd的广播属性</li>
<li>然后使用广播地址作为sendto的地址</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.设置广播属性</span></span><br><span class="line"><span class="type">int</span> op = <span class="number">1</span>;</span><br><span class="line">setsockopt(fd, SOL_SOCKET, SO_BROADCAST, &amp;op, <span class="keyword">sizeof</span>(op));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.创建一个广播的地址</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">cliaddr.sin_family = AF_INET;</span><br><span class="line">cliaddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">inet_pton(AF_INET, <span class="string">&quot;192.168.193.255&quot;</span>, &amp;cliaddr.sin_addr.s_addr);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<p><strong>客户端</strong></p>
<ul>
<li>sockfd 需要用 bind 绑定 本地IP和广播的端口</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.客户端绑定本地的IP和端口</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">addr.sin_family = AF_INET;</span><br><span class="line">addr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ret = bind(fd, (<span class="keyword">struct</span> sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<br>

<br>

<br>

<br>

<h3 id="组播-多播"><a href="#组播-多播" class="headerlink" title="组播(多播)"></a>组播(多播)</h3><ul>
<li>单播地址标识单个 IP 接口，广播地址标识某个子网的所有 IP 接口，多播地址标识一组 IP 接口。</li>
<li>单播和广播是寻址方案的两个极端（要么单个要么全部），多播则意在两者之间提供一种折中方案。</li>
<li>多播数据报只应该由对它感兴趣的接口接收，也就是说由<strong>运行相应多播会话应用系统的主机上的接口</strong>接收。</li>
<li>另外，<strong>广播一般局限于局域网内</strong>使用，而多播则既可以用于局域网，也可以跨广域网使用。<ul>
<li><strong>组播</strong>既可以用于<strong>局域网</strong>，也可以用于<strong>广域网</strong></li>
<li><strong>客户端</strong>需要加入<strong>多播组</strong>，才能接收到多播的数据</li>
</ul>
</li>
</ul>
<br>

<br>

<p><strong>组播地址</strong></p>
<p>IP 多播通信必须依赖于 IP 多播地址，在 IPv4 中它的范围从 <strong>224.0.0.0 到 239.255.255.255</strong> ，并被划分为 <strong>局部链接多播地址</strong>、 <strong>预留多播地址</strong> 和 <strong>管理权限多播地址</strong> 三类:</p>
<table>
<thead>
<tr>
<th align="center">IP地址</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">224.0.0.0~224.0.0.255</td>
<td align="center">局部链接多播地址：为路由协议和其他用途保留的地址，路由器并不转发属于此范围的IP包</td>
</tr>
<tr>
<td align="center">224.0.1.0~224.0.1.255</td>
<td align="center">预留多播地址：公用组播地址，可用于Internet；使用前需要申请</td>
</tr>
<tr>
<td align="center">224.0.2.0~238.255.255.255</td>
<td align="center">预留多播地址：用户可用组播地址（临时），全网范围有效</td>
</tr>
<tr>
<td align="center">239.0.0.0~239.255.255.255</td>
<td align="center">本地管理组播地址，可供组织内部使用，类似于私有IP地址，不能用于Internet，可限制多播范围</td>
</tr>
</tbody></table>
<br>

<br>

<p><strong>设置</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname,<span class="type">const</span> <span class="type">void</span> *optval, <span class="type">socklen_t</span> optlen)</span>;</span><br><span class="line">	<span class="comment">// 服务器设置多播的信息，外出接口</span></span><br><span class="line">	- level : IPPROTO_IP</span><br><span class="line">	- optname : IP_MULTICAST_IF</span><br><span class="line">	- optval : <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">	// 客户端加入到多播组：</span></span><br><span class="line"><span class="class">	- <span class="title">level</span> :</span> IPPROTO_IP</span><br><span class="line">	- optname : IP_ADD_MEMBERSHIP</span><br><span class="line">	- optval : <span class="class"><span class="keyword">struct</span> <span class="title">ip_mreq</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">        </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_mreq</span> &#123;</span></span><br><span class="line">	<span class="comment">/* IP multicast address of group. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">imr_multiaddr</span>;</span> <span class="comment">// 组播的IP地址</span></span><br><span class="line">	<span class="comment">/* Local IP address of interface. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">imr_interface</span>;</span> <span class="comment">// 本地的IP地址</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">	<span class="type">in_addr_t</span> s_addr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">in_addr_t</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<p><strong>服务端</strong></p>
<ul>
<li>setsockopt 设置 IPPROTO_IP 级别的 IP_MULTICAST_IF，传入组播的外出接口</li>
<li>将外出接口作为客户端地址信息，作为 sendto 指定的地址</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 2.设置多播的属性，设置外出接口</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">imr_multiaddr</span>;</span></span><br><span class="line"><span class="comment">// 初始化多播地址</span></span><br><span class="line">inet_pton(AF_INET, <span class="string">&quot;239.0.0.10&quot;</span>, &amp;imr_multiaddr.s_addr);</span><br><span class="line">setsockopt(fd, IPPROTO_IP, IP_MULTICAST_IF, &amp;imr_multiaddr, <span class="keyword">sizeof</span>(imr_multiaddr));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.初始化客户端的地址信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">cliaddr.sin_family = AF_INET;</span><br><span class="line">cliaddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">inet_pton(AF_INET, <span class="string">&quot;239.0.0.10&quot;</span>, &amp;cliaddr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通信</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<br>

<p><strong>客户端</strong></p>
<ul>
<li>bind 绑定端口</li>
<li>指定ip_mreq结构体中的本地地址和组播地址</li>
<li>setsockopt设置 IPPROTO_IP 级别的 IP_ADD_MEMBERSHIP ，传入上面（指定地址）的结构体</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">// 2.客户端绑定本地的IP和端口</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">   addr.sin_family = AF_INET;</span><br><span class="line">   addr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">   addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> ret = bind(fd, (<span class="keyword">struct</span> sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">   <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">       perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">       <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加入到多播组</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">ip_mreq</span> <span class="title">op</span>;</span></span><br><span class="line">   inet_pton(AF_INET, <span class="string">&quot;239.0.0.10&quot;</span>, &amp;op.imr_multiaddr.s_addr);</span><br><span class="line">   op.imr_interface.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">   setsockopt(fd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;op, <span class="keyword">sizeof</span>(op));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 3.通信</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<br>

<br>

<p><br><br></p>
<h2 id="4-6-本地套接字通信"><a href="#4-6-本地套接字通信" class="headerlink" title="4.6 本地套接字通信"></a>4.6 本地套接字通信</h2><p>本地套接字的作用：<strong>本地的进程间通信</strong></p>
<p>（本地套接字实现流程和网络套接字类似，一般采用 <strong>TCP 的通信流程</strong>）</p>
<ul>
<li><strong>有关系</strong>的进程间的通信</li>
<li><strong>没有关系</strong>的进程间的通信</li>
</ul>
<br>

<br>

<p><strong>struct sockaddr_un</strong></p>
<img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230216033138989.png" alt="image-20230216033138989" style="zoom:67%;">

<h3 id="通信流程"><a href="#通信流程" class="headerlink" title="通信流程"></a>通信流程</h3><p>本地套接字通信的流程 - tcp</p>
<img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230216033448663.png" alt="image-20230216033448663" style="zoom:80%;">

<p><strong>服务器端</strong></p>
<ol>
<li>创建监听的套接字</li>
</ol>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> lfd = socket(AF_UNIX/AF_LOCAL, SOCK_STREAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>监听的套接字 绑定 <strong>本地的套接字文件</strong> -&gt; server端</li>
</ol>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">addr</span>;</span></span><br><span class="line"><span class="comment">// 绑定成功之后，指定的sun_path中的套接字文件会自动生成。</span></span><br><span class="line"></span><br><span class="line">bind(lfd, addr, len);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>监听</li>
</ol>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">listen(lfd, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>等待并接受连接请求</li>
</ol>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">cliaddr</span>;</span></span><br><span class="line"><span class="type">int</span> cfd = accept(lfd, &amp;cliaddr, len);</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>通信<br>  接收数据：read&#x2F;recv<br>  发送数据：write&#x2F;send</p>
</li>
<li><p>关闭连接<br>close();</p>
</li>
</ol>
<br>

<p><strong>客户端</strong></p>
<ol>
<li>创建通信的套接字</li>
</ol>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> fd = socket(AF_UNIX/AF_LOCAL, SOCK_STREAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>监听的套接字绑定本地的IP,端口</li>
</ol>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">addr</span>;</span></span><br><span class="line"><span class="comment">// 绑定成功之后，指定的sun_path中的套接字文件会自动生成。</span></span><br><span class="line"></span><br><span class="line">bind(lfd, addr, len);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>连接服务器</li>
</ol>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">serveraddr</span>;</span></span><br><span class="line"></span><br><span class="line">connect(fd, &amp;serveraddr, <span class="keyword">sizeof</span>(serveraddr));</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>通信<br>  接收数据：read&#x2F;recv<br>  发送数据：write&#x2F;send</p>
</li>
<li><p>关闭连接<br>close();</p>
</li>
</ol>
<br>

<br>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 头文件: sys/un.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNIX_PATH_MAX 108</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> &#123;</span></span><br><span class="line">	<span class="type">sa_family_t</span> sun_family; <span class="comment">// 地址族协议 af_local</span></span><br><span class="line">	<span class="type">char</span> sun_path[UNIX_PATH_MAX]; <span class="comment">// 套接字文件的路径, 这是一个伪文件, 大小永远=0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>

<br>

<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>注意使用 <strong>strcpy</strong> 来设置 sockaddr_un 结构体中的 <strong>sun_path</strong> 的内容</p>
<p><strong>服务端</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    unlink(<span class="string">&quot;server.sock&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建监听的套接字</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_LOCAL, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.绑定本地套接字文件</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sun_family = AF_LOCAL;</span><br><span class="line">    <span class="built_in">strcpy</span>(addr.sun_path, <span class="string">&quot;server.sock&quot;</span>);</span><br><span class="line">    <span class="type">int</span> ret = bind(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.等待客户端连接</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;cliaddr, &amp;len);</span><br><span class="line">    <span class="keyword">if</span>(cfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client socket filename: %s\n&quot;</span>, cliaddr.sun_path);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">        <span class="type">int</span> len = recv(cfd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client closed....\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client say : %s\n&quot;</span>, buf);</span><br><span class="line">            send(cfd, buf, len, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(cfd);</span><br><span class="line">    close(lfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<br>

<br>

<p><strong>客户端</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    unlink(<span class="string">&quot;client.sock&quot;</span>);	</span><br><span class="line">    <span class="comment">// 删除参数pathname 指定的文件. </span></span><br><span class="line">    <span class="comment">// 如果该文件名为最后连接点, 但有其他进程打开了此文件, 则在所有关于此文件的文件描述词皆关闭后才会删除. </span></span><br><span class="line">    <span class="comment">// 如果参数pathname 为一符号连接, 则此连接会被删除。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建套接字</span></span><br><span class="line">    <span class="type">int</span> cfd = socket(AF_LOCAL, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(cfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.绑定本地套接字文件</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sun_family = AF_LOCAL;</span><br><span class="line">    <span class="built_in">strcpy</span>(addr.sun_path, <span class="string">&quot;client.sock&quot;</span>);</span><br><span class="line">    <span class="type">int</span> ret = bind(cfd, (<span class="keyword">struct</span> sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.连接服务器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">seraddr</span>;</span></span><br><span class="line">    seraddr.sun_family = AF_LOCAL;</span><br><span class="line">    <span class="built_in">strcpy</span>(seraddr.sun_path, <span class="string">&quot;server.sock&quot;</span>);</span><br><span class="line">    ret = connect(cfd, (<span class="keyword">struct</span> sockaddr *)&amp;seraddr, <span class="keyword">sizeof</span>(seraddr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.通信</span></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;hello, i am client %d\n&quot;</span>, num++);</span><br><span class="line">        send(cfd, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client say : %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="type">int</span> len = recv(cfd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;server closed....\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;server say : %s\n&quot;</span>, buf);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(cfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<br>

<br>

]]></content>
      <categories>
        <category>C++开发</category>
        <category>高性能服务器项目</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux多进程</title>
    <url>/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="2-Linux多进程开发"><a href="#2-Linux多进程开发" class="headerlink" title="2.Linux多进程开发"></a>2.Linux多进程开发</h1><hr>
<br>

<h2 id="2-1-进程概述"><a href="#2-1-进程概述" class="headerlink" title="2.1 进程概述"></a>2.1 进程概述</h2><p><strong>程序和进程</strong></p>
<blockquote>
<p><strong>程序</strong></p>
<p>程序是包含一系列信息的文件，这些文件描述了如何在运行时创建一个进程。</p>
<p>包含内容：</p>
<ul>
<li>二进制格式标识：每个程序文件都包含用于描述可执行文件格式的元信息。内核利用此信息来解释文件中的其他信息。（ELF可执行链接格式）</li>
<li>机器语言指令：对程序算法进行编码。</li>
<li>程序入口地址：标识程序开始执行时的起始指令位置。</li>
<li>数据：程序文件包含的变量初始值和程序使用的字面量值（如字符串）。</li>
<li>符号表及重定位表：描述程序中函数和变量的位置及名称。这些表格有多重用途，其中包括调试和运行时的符号解析（动态链接）。</li>
<li>共享库和动态链接信息：程序文件所包含的一些字段，列出了程序运行时需要使用的共享库，以及加载共享库的动态链接器的路径名。</li>
<li>其他信息：程序文件还包含其他信息，用来描述如何创建进程。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>进程</strong></p>
<ul>
<li>进程是正在运行的程序的实例。<ul>
<li>是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。</li>
<li>是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。</li>
</ul>
</li>
<li>可以用一个程序来创建多个进程，进程是由内核定义的抽象实体，并为该实体分配用以执行程序的各项系统资源。<ul>
<li>从内核的角度看，进程由用户内存空间和一些列的内核数据结构组成，其中用户内存空间包含了程序代码及代码所使用的变量，而内核数据结构则用于维护进程状态信息。</li>
<li>记录在内核数据结构中的信息包括许多与进程相关的标识号（IDs）、虚拟内存表、打开文件的描述符表，信号传递及处理的有关信息、进程资源使用及限制、当前工作目录和大量的其他信息。</li>
</ul>
</li>
</ul>
</blockquote>
<br>

<p><strong>单道、多道程序设计</strong></p>
<p>单道程序：在计算机内存中只允许一个的程序运行。</p>
<p>多道程序：计算机内存中同时存放多道相互独立的程序使它们在管理程序控制下，相互穿插运行，两个或两个以上程序在计算机系统中处于开始到结束之间的状态，这些车程序共享计算机资源。（提高CPU的利用率）</p>
<ul>
<li>对于单CPU系统而言，宏观上可以使多个程序像是同时运行，实际上任意时刻CPU上运行的程序只有一个。</li>
<li>在多道程序设计模型中，多个程序轮流使用CPU。</li>
</ul>
<br>

<p><strong>时间片</strong></p>
<p>时间片 timeslice 又称为“量子 quantum”或“处理器片processor slice”，是操作系统分配给每个正在运行的进程微观上的一段CPU时间。</p>
<p>时间片由操作系统内核的调度程序分配给每个进程。</p>
<br>

<p><strong>并行和并发</strong></p>
<p>并行（parallel）：指在同一时刻，有多条指令在多个处理器上同时执行。</p>
<p>并发（concurrency）：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。</p>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230204223514971-16759624275181.png" alt="image-20230204223514971"></p>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230204223803946-16759624275193.png" alt="image-20230204223803946"></p>
 <br>

<p><strong>进程控制块 PCB</strong></p>
<p>内核为每个进程分配以一个 PCB 进程控制块，维护进程相关的信息，Linux内核的进程控制块是 task_struct 结构体。</p>
<p>在 &#x2F;usr&#x2F;src&#x2F;linux-headers-xxx&#x2F;include&#x2F;linux&#x2F;sched.h 文件中可以查看 struct task_struct 结构体定义，其部分内部成员如下：</p>
<ul>
<li>进程id：系统中每个进程有唯一的 id ，用 pid_t 类型表示，是一个非负整数</li>
<li>进程的状态：就绪、运行、挂起、停止等状态</li>
<li>进程切换时需要保存和恢复的一些CPU寄存器信息</li>
<li>描述虚拟地址空间的信息</li>
<li>描述控制终端的信息</li>
<li>当前工作目录</li>
<li>umask掩码</li>
<li>文件描述符表，包含很多执行file结构体的指针</li>
<li>和信号相关的信息</li>
<li>用户id和组id</li>
<li>会话（session）和进程组</li>
<li>进程可以使用的资源上限（可用ulimit指令查看系统内核资源上限）</li>
</ul>
<p><br><br><br></p>
<h2 id="2-2-进程状态转换"><a href="#2-2-进程状态转换" class="headerlink" title="2.2 进程状态转换"></a>2.2 进程状态转换</h2><h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><p>进程状态反映进程执行过程的变化。</p>
<p><code>三态模型</code>中，进程状态分为三个基本状态 —— 就绪态、运行态、阻塞态。</p>
<blockquote>
<p><strong>运行态</strong>：进程占有处理器正在运行。</p>
<p><strong>就绪态</strong>：进程具备运行条件，等待系统分配处理器以便运行。当进程分配到除CPU外的所有必要资源后，只要再获得CPU，便可立即执行。多个就绪进程排成队列，称为就绪队列。</p>
<p><strong>阻塞态</strong>：又称为 等待态(wait) 或 睡眠态(sleep)，指进程不具备运行条件，正在等待某个事件的完成。</p>
</blockquote>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230204225943684-16759624275192.png" alt="image-20230204225943684"></p>
<p><code>五态模型</code>中，进程状态分为 ——  新建态、就绪态、运行态、阻塞态、终止态。</p>
<blockquote>
<p><strong>新建态</strong>：进程刚被创建时的状态，尚未进入就绪队列</p>
<p><strong>终止态</strong>：进程完成任务达到正常结束点，或出现无法克服的错误而异常终止，或被操作系统及有终止权的进程所终止时所处的状态。进入终止态的进程不再执行，但依然保留再操作系统中等待善后。一旦其他进程完成了对终止态进程的信息抽取之后，操作系统将删除该进程。</p>
</blockquote>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230204230502376-16759624275195.png" alt="image-20230204230502376"></p>
<br>

<h3 id="进程相关指令"><a href="#进程相关指令" class="headerlink" title="进程相关指令"></a>进程相关指令</h3><p><strong>查看进程</strong></p>
<p><code>ps aux/ajx</code></p>
<p>a：显示终端上的所有进程，包括其他用户的进程</p>
<p>u：显示进程的详细信息</p>
<p>x：显示没有控制终端的进程</p>
<p>j：列出与作业控制相关的进程</p>
<br>

<blockquote>
<p>stat标识</p>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230204232608821-16759624275196.png" alt="image-20230204232608821"></p>
</blockquote>
<br>

<p><strong>实时显示进程状态</strong></p>
<p><code>top</code></p>
<p>可以在 top 命令后加 -d 来指定显示信息更新的时间间隔</p>
<p>在 top 命令执行后，可以按一下按键对显示结果进行排序</p>
<ul>
<li>M 根据内存使用量</li>
<li>P 根据CPU占有率</li>
<li>T 根据进程运行时间长短</li>
<li>U 根据用户名筛选</li>
<li>K 输入指定的 PID 杀死进程</li>
</ul>
<br>

<p><strong>杀死进程</strong></p>
<p><code>kill [-signal] pid</code></p>
<p><code>kill -l</code>列出所有signal信号(信号宏)</p>
<p>比如：</p>
<ul>
<li><p><code>kill -SIGKILL 进程ID</code></p>
</li>
<li><p><code>kill -9 进程ID</code> </p>
</li>
<li><p><code>killall name</code> 根据进程名杀死进程</p>
</li>
</ul>
<br>

<p><strong>进程号和相关函数</strong></p>
<ul>
<li><p>每个进程都由<strong>进程号</strong>来表示，其类型为 pid_t（整型），进程号范围：0~32767。</p>
</li>
<li><p>任何进程（除init进程）都是由另一个进程创建，即父进程， PPID 为父进程号</p>
</li>
<li><p><strong>进程组</strong>是一个或多个进程的集合。他们相互关联，进程组可以接收同一终端的各种信号，关联的进程有一个进程组号 PGID 。默认情况下，当前的进程号会当做当前的进程组号。</p>
</li>
</ul>
<p>相关函数：</p>
<ul>
<li><code>pid_t getpid(void);</code></li>
<li><code>pid_t getppid(void);</code></li>
<li><code>pid_t getpgid(pid_t pid);</code></li>
</ul>
<br>

<br>

<h2 id="2-3-进程创建与调试"><a href="#2-3-进程创建与调试" class="headerlink" title="2.3 进程创建与调试"></a>2.3 进程创建与调试</h2><p>系统允许一个进程创建新进程，即紫禁城，子进程还可以创建新的子进程，形成树结构模型。</p>
<h3 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a>fork函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建子进程</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		- 成功：子进程中返回0，父进程中返回子进程 ID </span></span><br><span class="line"><span class="comment">		- 失败：子进程不被创建，父进程中返回-1，并设置errno</span></span><br><span class="line"><span class="comment">		失败的两个主要原因：</span></span><br><span class="line"><span class="comment">		1. 当前系统的进程数已经达到了系统规定的上限，这时 errno 的值被设置为 EAGAIN</span></span><br><span class="line"><span class="comment">		2. 系统内存不足，这是 errno 的值被设置为 ENOMEM</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<br>

<p>用法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//父进程要执行的内容</span></span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//子进程要执行的内容</span></span><br><span class="line">    	...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//都会执行的内容</span></span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<h3 id="父、子进程虚拟地址空间情况"><a href="#父、子进程虚拟地址空间情况" class="headerlink" title="父、子进程虚拟地址空间情况"></a>父、子进程虚拟地址空间情况</h3><p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230205003125065-16759624275194.png" alt="image-20230205003125065"></p>
<p>进程的实际pid在内核空间</p>
<p>变量pid的值在栈空间</p>
<br>

<blockquote>
<p>fork() 是通过 写时拷贝（copy-on-write） 实现。</p>
<p>写时拷贝时一钟可以推迟甚至避免拷贝数据的技术。内核此时并不复制整个进程的地址空间，而是让父子进程共享一个地址空间。</p>
<p>只有在需要写入的时候才会复制地址空间，从而使得各个进程拥有各自的地址空间，在此之前只有以只读方式共享。</p>
<p>注意：fork后父子进程共享文件</p>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230205011611597-16759624275197.png" alt="image-20230205011611597"></p>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230205011543783-167596242752027.png" alt="image-20230205011543783"></p>
</blockquote>
<br>

<blockquote>
<p>不同的进程访问同样的逻辑地址（虚拟地址）而对应的物理地址不同，是由于各自页表的不同。</p>
<p>linux系统下每个进程都拥有自己的页表，父进程fork出新的子进程时，子进程拷贝一份父进程的页表，且父子进程将页表状态修改为写保护。当父进程或子进程发生写操作时将会发生缺页异常，缺页异常处理函数将会为子进程分配新的物理地址。</p>
</blockquote>
<br>

<br>

<h3 id="父子进程关系"><a href="#父子进程关系" class="headerlink" title="父子进程关系"></a>父子进程关系</h3><p><strong>不同点</strong></p>
<ol>
<li>fork()函数的返回值不同<ul>
<li>父进程中：&gt;0 返回子进程的ID</li>
<li>子进程中：&#x3D;0</li>
</ul>
</li>
<li>PCB中的一些数据<ul>
<li>当前进程的id pid</li>
<li>当前进程的父进程id ppid</li>
<li>信号集</li>
</ul>
</li>
</ol>
<br>

<p><strong>共同点</strong></p>
<p>某些状态下：子进程刚被创建出来，还没有执行任何的写数据的操作</p>
<pre><code>- 用户区的数据
- 文件描述符表
</code></pre>
<p>父子进程对变量是不是共享的？</p>
<ul>
<li>刚开始是共享的，如果数据发生修改则不共享</li>
<li>读时共享，写时拷贝</li>
</ul>
<br>

<h3 id="GDB多进程调试"><a href="#GDB多进程调试" class="headerlink" title="GDB多进程调试"></a>GDB多进程调试</h3><p>GDB默认只能跟踪一个进程，可以在fork函数调用前，通过指令设置 GDB 调试工具跟踪父进程或者是子进程，默认跟踪父进程。</p>
<br>

<ul>
<li>设置调试父进程或子进程：</li>
</ul>
<p><code>set follow-fork-mod [parent(default) | child]</code></p>
<ul>
<li>设置调试模式：</li>
</ul>
<p><code>set detach-on-fork [on(default) | off]</code></p>
<p>​	on：调试当前进程时，其他进程继续运行</p>
<p>​	off：调试当前进程时，其他进程被 GDB 挂起</p>
<ul>
<li>查看调试的进程：</li>
</ul>
<p><code>info inferiors</code></p>
<ul>
<li>切换当前调试的进程：</li>
</ul>
<p><code>inferior 编号</code>（若切换的进程被挂起，切换后先 c ）</p>
<ul>
<li>使进程脱离 GDB 调试：</li>
</ul>
<p><code>detach inferiors id</code></p>
<br>

<p><br><br></p>
<br>

<h2 id="2-4-exec函数族"><a href="#2-4-exec函数族" class="headerlink" title="2.4 exec函数族"></a>2.4 exec函数族</h2><p>c++有函数重载，c语言没有；</p>
<p>函数族即一系列功能相似的函数。</p>
<br>

<ul>
<li>exec 函数族的作用是根据指定文件名找到可执行文件，并用它来取代调用进程的内容，换句话说，就是在调用进程内部执行一个可执行文件。（实际应用时一般在子进程中执行 exec函数族）</li>
<li>exec 函数族的函数执行成功后不会返回，因为调用进程的实体，包括代码段、数据段和堆栈等都已经被新的内容取代，只留下进程ID等一些表面上的信息仍保持原样。只有调用失败了，才会返回－１，从原程序的调用点接着往下执行。</li>
</ul>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230205022237610-16759624275198.png" alt="image-20230205022237610"></p>
<br>

<p><strong>exec函数族</strong></p>
<blockquote>
<p>exec后的字母表示传参方式和搜索规则</p>
<ul>
<li><p>l(list)	参数地址列表，以空指针结尾</p>
</li>
<li><p>v(vector)  存有个参数地址的指针数组的地址</p>
</li>
<li><p>p(path)	按 PATH 环境变量指定的目录搜索可执行文件</p>
</li>
<li><p>e(environment) 存有环境变量字符串地址的指针数组的地址</p>
</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ...<span class="comment">/* (char *) NULL */</span>)</span>；</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- path：需要指定的执行文件的路径或名称（相对路径或绝对路径）（推荐使用绝对路径）</span></span><br><span class="line"><span class="comment">		- arg：可执行文件的参数列表（第一个参数一般没什么作用，为了方便，一般写的是执行程序的名称，从第二个参数开始往后，就是程序执行所需的参数列表，并以 NULL 结尾（哨兵））</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		只有调用失败，才有返回值-1，并设置errno。</span></span><br><span class="line"><span class="comment">		调用成功没有返回值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg, ...<span class="comment">/* (char *) NULL */</span>)</span>；</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	会到环境变量中查找指定的可执行文件，如果找到了就执行，找不到就执行原程序</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- file：需要执行的可执行文件的文件名</span></span><br><span class="line"><span class="comment">		- arg：可执行文件的参数列表（第一个参数一般没什么作用，为了方便，一般写的是执行程序的名称，从第二个参数开始往后，就是程序执行所需的参数列表，并以 NULL 结尾（哨兵））</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		只有调用失败，才有返回值-1，并设置errno。</span></span><br><span class="line"><span class="comment">		调用成功没有返回值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ...<span class="comment">/*, (char *) NULL, char *const envp[] */</span>)</span>；</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *<span class="type">const</span> argv[])</span>；</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">用例：</span></span><br><span class="line"><span class="comment">	char * argv[] = &#123;&quot;ps&quot;, &quot;aux&quot;, NULL&#125;;</span></span><br><span class="line"><span class="comment">	execv(&quot;/bin/ps&quot;, arg);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[])</span>；</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">execvpe</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>；</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>；</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">用例：</span></span><br><span class="line"><span class="comment">	char * argv[] = &#123;&quot;ps&quot;, &quot;aux&quot;, NULL&#125;;</span></span><br><span class="line"><span class="comment">	char * envp[] = &#123;&quot;/home/nowcoder&quot;, &quot;/home/aaa&quot;, &quot;/home/bbb&quot;&#125;;</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	execve(&quot;ps&quot;, arg, envp);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<p><br><br></p>
<h2 id="2-5-进程控制"><a href="#2-5-进程控制" class="headerlink" title="2.5 进程控制"></a>2.5 进程控制</h2><h3 id="进程退出"><a href="#进程退出" class="headerlink" title="进程退出"></a>进程退出</h3><p><strong>exit函数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#incldue <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> _exit(<span class="type">int</span> status);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- status：进程退出时的一个状态信息。父进程回收子进程资源的时候可以获取到。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	exit是标准C库的函数，比_exit多做了</span></span><br><span class="line"><span class="comment">	1.调用退出处理函数</span></span><br><span class="line"><span class="comment">	2.刷新I/O缓存</span></span><br><span class="line"><span class="comment">	3.关闭文件描述符</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230205024702546-16759624275209.png" alt="image-20230205024702546"></p>
<p><br><br></p>
<h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h3><p>父进程运行结束，但子进程还在运行，这样的子进程就成为孤儿进程（Orphan Process）</p>
<br>

<p>每当出现一个孤儿进程时，内核就把孤儿进程的父进程设置为init进程，而init进程会循环地 wait() 它的已经退出的子进程。（init进程会回收运行结束的孤儿进程）</p>
<br>

<p>没什么危害</p>
<br>

<h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><p>每个进程结束之后，会释放自己地址空间中的用户区数据，内核去的PCB则需要父进程去释放</p>
<p>子进程终止后，父进程尚未将其回收，子进程残留资源（PCB）存放于内核中，变成僵尸进程</p>
<ul>
<li>僵尸进程不能被 kill -9 杀死</li>
<li>如果父进程不调用 wait() 或 waitpid() ，那么保留的信息就不会释放，进程号会一直被占用</li>
<li>危害：系统的进程号有限，如果出现大量僵尸进程，会导致系统无法产生新的进程</li>
</ul>
<br>

<h3 id="进程回收"><a href="#进程回收" class="headerlink" title="进程回收"></a>进程回收</h3><p>在每个进程退出的时候，内核释放该进程所有的资源、包括打开的文件、占用的内存等。但是仍为其保留一定的信息，这些信息主要指 PCB 的信息（包括进程号、退出状态、运行时间等）</p>
<p>父进程可以通过 wait() 或 waitpid()得到子进程的退出状态，并彻底清除掉这个进程</p>
<ul>
<li>wait() 或 waitpid() 功能一样，区别在于： 	wait() 会阻塞；<br>waitpid() 可以设置不阻塞，且可以指定等待哪个子进程结束；</li>
<li>一次wait或waitpid调用只能清理一个子进程，清理多个子进程应该使用循环</li>
</ul>
<br>

<h4 id="wait函数"><a href="#wait函数" class="headerlink" title="wait函数"></a>wait函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *wstatus)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	功能：等待任意一个子进程结束，如果任意一个子进程结束了，此函数会回收子进程的资源。</span></span><br><span class="line"><span class="comment">	参数：int *wstatus</span></span><br><span class="line"><span class="comment">		进程退出时的状态信息，传入的是一个int指针，是一个传出参数</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		成功：返回被回收的子进程的id</span></span><br><span class="line"><span class="comment">		失败：返回-1（所有的子进程都结束了，调用函数失败）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	调用wait函数的进程会被挂起（阻塞），知道它的一个子进程退出或者收到一个不能被忽略的信号时才被唤醒（相当于继续往下执行）</span></span><br><span class="line"><span class="comment">	如果没有子进程了/子进程都结束了，函数立刻返回，返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<p><strong>退出信息相关宏函数</strong></p>
<ul>
<li><p>​	函数					返回值</p>
<hr>
</li>
<li><p>WIFEXITED(status)	非0，进程正常退出</p>
</li>
<li><p>WEXITSTATUS(status)  如果上宏为真，获取进程退出的状态（exit的参数）</p>
</li>
<li><p>WIFSIGNALED(status)  非0，进程异常终止</p>
</li>
<li><p>WTERMSIG(status)     如果上宏为真，获取使进程终止的信号编号</p>
</li>
<li><p>WIFSTOPPED(status)   非0，进程处于暂停状态</p>
</li>
<li><p>WSTOPSIG(status)     如果上宏为真，获取使进程暂停的信号编号</p>
</li>
<li><p>WIFCONTINUED(status) 非0，进程暂停后已经继续运行</p>
</li>
</ul>
<br>

<br>

<h4 id="waitpid函数"><a href="#waitpid函数" class="headerlink" title="waitpid函数"></a>waitpid函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *wstatus, <span class="type">int</span> options)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	功能：回收指定进程号的子进程；可以设置是否阻塞。</span></span><br><span class="line"><span class="comment">	wait(&amp;wstatus); 等价于 waitpid(-1, &amp;wstatus, 0);</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- pid：指定子进程的id</span></span><br><span class="line"><span class="comment">			&gt; 0  ：某个子进程的id</span></span><br><span class="line"><span class="comment">			  0  ：回收当前进程组的所有子进程</span></span><br><span class="line"><span class="comment">			  -1 ：回收所有的子进程	（最常用）</span></span><br><span class="line"><span class="comment">			&lt; -1 ：某个进程组组id的绝对值，回收指定进程组中的子进程</span></span><br><span class="line"><span class="comment">		- wstatus：进程退出时的状态信息，传入的是一个int指针，是一个传出参数</span></span><br><span class="line"><span class="comment">		- options：设置阻塞或非阻塞</span></span><br><span class="line"><span class="comment">			0    ：阻塞</span></span><br><span class="line"><span class="comment">			宏值  ：WNOHANG 非阻塞（没有子进程退出的话立即返回）</span></span><br><span class="line"><span class="comment">				   WUNTRACED</span></span><br><span class="line"><span class="comment">				   WCONTINUED</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		&gt; 0 ：返回被回收的子进程的id</span></span><br><span class="line"><span class="comment">		= 0 ：options=WNOHANG时，表示还有子进程没有退出</span></span><br><span class="line"><span class="comment">		= -1：错误，或者没有子进程了</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	调用wait函数的进程会被挂起（阻塞），知道它的一个子进程退出或者收到一个不能被忽略的信号时才被唤醒（相当于继续往下执行）</span></span><br><span class="line"><span class="comment">	如果没有子进程了/子进程都结束了，函数立刻返回，返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<br>

<h2 id="2-6-进程间通信"><a href="#2-6-进程间通信" class="headerlink" title="2.6 进程间通信"></a>2.6 进程间通信</h2><h3 id="2-6-1-进程间通信简介"><a href="#2-6-1-进程间通信简介" class="headerlink" title="2.6.1 进程间通信简介"></a>2.6.1 进程间通信简介</h3><p>不同的进程需要进行信息的交互和状态的传递等，因此需要进程间通信（IPC：Inter Processes Communication</p>
<p><strong>进程通信目的：</strong></p>
<ul>
<li>数据传输：一个进程需要将它的数据发送给另一个进程</li>
<li>通知事件：一个进程需要向另一个或一组进程发送信息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）</li>
<li>资源共享：多个进程之间共享同样的资源。（需要用到内核提供的互斥和同步机制）</li>
<li>进程控制：有些进程希望完全控制另一个进程的运行（如 Debug 进程gdb），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道其状态改变</li>
</ul>
<br>

<p><strong>Linux进程间通信的方式：</strong></p>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230205232903586-167596242752010.png" alt="image-20230205232903586"></p>
<br>

<br>

<br>

<h3 id="2-6-2-匿名管道"><a href="#2-6-2-匿名管道" class="headerlink" title="2.6.2 匿名管道"></a>2.6.2 匿名管道</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>管道 也叫匿名管道。是 UNIX 系统 IPC 的最古老形式，所有的 UNIX 系统都支持这种通信机制。</p>
<br>

<p><strong>案例解析：</strong></p>
<p>​	统计一个目录中文件的数目命令：<code>ls | wc -l</code>	（管道符 | ）</p>
<p>为了执行该命令，shell 创建了两个进程分别执行 ls 和 wc</p>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230205233552602-167596242752011.png" alt="image-20230205233552602"></p>
<p>ls进程的标准输出 stdout 指向管道写入端</p>
<p>wc进程的标准输入 stdin 指向管道读取端</p>
<br>

<p><strong>特点</strong></p>
<ul>
<li>管道 其实是一个在<code>内核内存中</code>维护的缓冲器，这个缓冲器的存储能力是有限的，不同操作系统中可能不同</li>
<li>管道拥有文件的特质：读操作、写操作，<u>匿名管道没有文件实体，有名管道有文件实体，但不存储数据。</u>可以按照操作文件的方式操作管道</li>
<li>一个管道是一个<code>字节流</code>，使用管道时不存在消息或者消息边界的概念，从管道读取数据的进程可以读取任意大小的数据块，而不管写入进程写入管道的数据库的大小是多少</li>
<li>通过管道传递的数据是顺序的</li>
<li>在管道中的数据的传递方向是单向的，一端写入，一端读取，是半双工的（有两个传递方向，同一时刻内只能通一个方向）</li>
<li>从管道读取数据是一次性操作，数据一旦被读走，就从管道中被抛弃，释放空间以便写更多的数据，在管道中无法使用lseek()来随机访问数据</li>
<li>匿名管道只能在具有公共祖先的进程之间使用（父子进程共享文件描述符表，有相同的管道）</li>
</ul>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230206013639551-167596242752012.png" alt="image-20230206013639551"></p>
<br>

<p><strong>管道的数据结构</strong></p>
<p>环形队列（重复利用节点空间）</p>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230206014318131-167596242752013.png" alt="image-20230206014318131"></p>
<br>

<h4 id="管道的使用"><a href="#管道的使用" class="headerlink" title="管道的使用"></a>管道的使用</h4><ul>
<li><p>创建匿名管道</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	创建一个匿名管道，用于进程间通信</span></span><br><span class="line"><span class="comment">	参数： int pipefd[2]：传出参数</span></span><br><span class="line"><span class="comment">			pipefd[0] 管道的读端</span></span><br><span class="line"><span class="comment">			pipefd[1] 管道的写端</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		成功 0</span></span><br><span class="line"><span class="comment">		失败 -1</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	管道默认是阻塞的：</span></span><br><span class="line"><span class="comment">		如果管道中没有数据，read阻塞；</span></span><br><span class="line"><span class="comment">		如果管道满了，write阻塞；</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	注意：匿名管道只能用于具有关系的进程之间的通信（父子进程，兄弟进程...）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现：子进程发送数据给父进程，父进程读取到数据输出</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在fork之前创建管道</span></span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> ret = pipe(pipefd);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="comment">// 从管道的读取端读取数据</span></span><br><span class="line">        close(pipefd[<span class="number">1</span>]);</span><br><span class="line">        </span><br><span class="line">    	<span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> len = read(pipefd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent recv : %s, pid: %d\n&quot;</span>, buf, getpid());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        close(pipefd[<span class="number">0</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="type">char</span> *str = <span class="string">&quot;hello, i am child&quot;</span>;</span><br><span class="line">        write(pipefd[<span class="number">1</span>], str, <span class="built_in">strlen</span>(str));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看管道缓冲大小命令:<code>ulimit -a</code></p>
</li>
<li><p>查看管道缓冲大小函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">fpathconf</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> name)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	获取文件的配置信息值</span></span><br><span class="line"><span class="comment">	参数 name：宏值，表明要查看的内容</span></span><br><span class="line"><span class="comment">		_PC_PIPE_BUF</span></span><br><span class="line"><span class="comment">		更多参数参考文档</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<br></li>
</ul>
<blockquote>
<p>规定：</p>
<ul>
<li>使用匿名管道实际开发时，父子进程不相互收发数据，而是规定好一个进程读一个进程写</li>
<li>读的进程关闭写端；写的进程关闭读端；</li>
</ul>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230206022417540-167596242752014.png" alt="image-20230206022417540"></p>
</blockquote>
<br>

<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>实现<code>ps aux | grep xxx</code></p>
<p>父子进程间通信</p>
<ul>
<li><p>子进程：ps aux，结束后将数据发送给父进程</p>
</li>
<li><p>父进程：获取数据，并过滤</p>
<p>pipe()</p>
<p>execlp()</p>
<p>dup2() 子进程将标准输出 stdout_fileno 重定向到管道的写端</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建管道</span></span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> ret = pipe(fd);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="comment">// 关闭写端</span></span><br><span class="line">        close(fd[<span class="number">1</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从管道中读取</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> len = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>((len = read(fd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf)<span class="number">-1</span>)) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="comment">// 过滤数据并输出  过滤功能还没写          </span></span><br><span class="line">        	<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf); </span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="comment">// 子进程</span></span><br><span class="line">        <span class="comment">// 关闭读端</span></span><br><span class="line">        close(fd[<span class="number">0</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 文件描述符的重定向 stdout_fileno -&gt; fd[1]</span></span><br><span class="line">        dup2(fd[<span class="number">1</span>], STDOUT_FILENO);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 执行 ps aux</span></span><br><span class="line">        execlp(<span class="string">&quot;ps&quot;</span>, <span class="string">&quot;ps&quot;</span>, <span class="string">&quot;aux&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        perror(<span class="string">&quot;execlp&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   	<span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<h4 id="管道读写特点和非阻塞的设置"><a href="#管道读写特点和非阻塞的设置" class="headerlink" title="管道读写特点和非阻塞的设置"></a>管道读写特点和非阻塞的设置</h4><p><strong>读写特点（阻塞I&#x2F;O下）</strong></p>
<ol>
<li>如果所有的指向 管道写端 的文件描述符都关闭了<code>（写端引用计数为0）</code>，有进程从管道的读端读数据，<code>那么管道中剩余的数据被读取以后，再次read会返回 0</code>，就像读到文件末尾一样。</li>
<li>如果有指向 管道写端 的文件描述符没有关闭<code>（写端引用计数大于0）</code>，而持有管道写端的进程也<code>没有往管道中写数据</code>，这时有进程从管道的读端读数据，<code>那么管道中剩余的数据被读取以后，再次read会阻塞</code>，直到管道中有数据可以读了才读取数据并返回。</li>
<li>如果所有的指向 管道读端 的文件描述符都关闭了<code>（读端引用计数为0）</code>，这个时候向管道中写数据，那么该进程会收到一个信号 SIGPIPE ，通常会导致进程异常终止。</li>
<li>如果有指向 管道读端 的文件描述符没有关闭<code>（读端引用计数大于0）</code>，而持有管道读端的进程也<code>没有往管道中读数据</code>，这时有进程从管道的写端写数据，<code>那么管道被写满的时候，再次调用write会阻塞</code>，直到管道中有空位置才能再次写入数据并返回。</li>
</ol>
<blockquote>
<p><strong>总结：</strong></p>
<p>​	读管道：</p>
<p>​		管道中有数据，read读取数据，返回实际读到的字节数。</p>
<p>​		管道中无数据：</p>
<p>​			写端被全部关闭，read返回0（相当于读到文件的末尾）<br>​			写端没有完全关闭，read阻塞等待</p>
<p>​	</p>
<p>​	写管道：</p>
<p>​		管道读端全部被关闭，进程异常终止（进程收到 SIGPIPE 信号）</p>
<p>​		管道读端没有全部关闭：</p>
<p>​			管道已满，write阻塞<br>​			管道未满，write将数据写入，返回实际写入的字节数</p>
</blockquote>
<br>

<br>

<p><strong>非阻塞设置</strong></p>
<p>fcntl函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> flags = fcntl(fd[<span class="number">0</span>], F_GETFL); <span class="comment">// 获取原来的flag</span></span><br><span class="line">flags |= O_NONBLOCK;			 <span class="comment">// 修改flag</span></span><br><span class="line">fcntl(fd[<span class="number">0</span>], F_SETFL, flags)；	<span class="comment">// 设置新的flag</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<h3 id="2-6-3-有名管道"><a href="#2-6-3-有名管道" class="headerlink" title="2.6.3 有名管道"></a>2.6.3 有名管道</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><ul>
<li>匿名管道由于无名，只能用于亲缘关系的进程间通信。为了扩大应用，提出了 有名管道 （FIFO），也叫命名管道，FIFO文件。</li>
<li>有名管道（FIFO）不同于匿名管道之处，<u>在于它提供了一个路径名与之关联</u>，以FIFO的文件形式存在于文件系统中，并且打开方式与普通文件相同。只要可以访问该路径，就能彼此通过有名管道相互通信，使得不相关的进程也能通信。</li>
</ul>
<br>

<p><strong>与匿名管道的不同之处：</strong></p>
<ol>
<li>FIFO 在文件系统中作为一个特殊文件存在，但 FIFO 中的内容却存放在内核区的内存中。</li>
<li>当使用 FIFO 的进程推出后，FIFO 文件将保存在文件系统中以便以后调用。</li>
<li>FIFO 有名，不相关的进程可以通过打开有名管道进行通信。</li>
</ol>
<br>

<h4 id="有名管道的使用"><a href="#有名管道的使用" class="headerlink" title="有名管道的使用"></a>有名管道的使用</h4><ul>
<li><p>通过命令创建：<code>mkfifo name</code></p>
</li>
<li><p>通过函数创建</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys.types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys.stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- pathname：管道名称的路径</span></span><br><span class="line"><span class="comment">		- mode：文件权限，和 open 的 mode 一样。</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		成功 0，失败 -1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>一旦使用 mkfifo 创建了一个 FIFO ，就可以使用 open 打开，以及使用常见的 I&#x2F;O 函数，如：read，write，unlink，close…</p>
</li>
<li><p>FIFO 严格遵循先进先出，读操作 总是从开始处返回数据，写操作 则把数据添加到末尾。所以不支持 lseek()等文件定位操作。</p>
</li>
</ul>
<br>

<h4 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h4><p><strong>基本使用</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 向管道中写数据</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断文件是否存在</span></span><br><span class="line">    <span class="type">int</span> ret = access(<span class="string">&quot;test&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">// 管道还未创建</span></span><br><span class="line">        ret = mkfifo(<span class="string">&quot;test&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打开管道（只写方式）</span></span><br><span class="line">    <span class="type">int</span> fd = open)<span class="string">&quot;test&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 写数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(buf,<span class="string">&quot;hello %d\n&quot;</span>, i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;write data: %s\n&quot;</span>, buf);</span><br><span class="line">        write(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    close(fd);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从管道中读取数据</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main1</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打开管道文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;test&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="type">int</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取数据</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> len = read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 写端断开连接了</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv buf: %s\n&quot;</span>,buf);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    close(fd);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<blockquote>
<p>open 注意事项：</p>
<ol>
<li>一个为只读而打开一个管道的进程会阻塞，直到另外一个进程为只写打开管道</li>
<li>一个为只写而打开一个管道的进程会阻塞，直到另外一个进程为只读打开管道</li>
</ol>
</blockquote>
<blockquote>
<p><strong>读管道：</strong></p>
<p>​	管道中有数据，read发怒hi实际督导的字节数</p>
<p>​	管道中无数据：<br>​		管道写端被全部关闭，read返回0 （相当于读到文件末尾）<br>​		管道写端没有全部关闭，read阻塞等待</p>
<p><strong>写管道：</strong></p>
<p>​	管道读端被全部关闭，进程异常终止（收到 SIGPIPE 信号）</p>
<p>​	管道读端没有全部关闭：<br>​		管道已满，write会阻塞<br>​		管道未满，write写入数据，返回实际写入的字节数</p>
</blockquote>
<br>

<br>

<p><strong>有名管道实现简单聊天</strong></p>
<p>只能交替地接收和发送</p>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230206212504676-167596242752015.png" alt="image-20230206212504676"></p>
<br>

<p>进程A</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.判断有名管道文件是否存在</span></span><br><span class="line">    <span class="type">int</span> ret = access(<span class="string">&quot;fifo1&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">// 文件不存在则创建</span></span><br><span class="line">        ret = mkfifo(<span class="string">&quot;fifo1&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">    	<span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">			perror(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">	ret = access(<span class="string">&quot;fifo2&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">// 文件不存在则创建</span></span><br><span class="line">        ret = mkfifo(<span class="string">&quot;fifo2&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">    	<span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">			perror(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 以只写方式打开管道 fifo1</span></span><br><span class="line">    <span class="type">int</span> fdw = open(<span class="string">&quot;fifo1&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span>(fdw == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开管道fifo1成功，等待写入...\n&quot;</span>)；</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 以只读方式打开管道 fifo2</span></span><br><span class="line">    <span class="type">int</span> fdr = open(<span class="string">&quot;fifo2&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fdr == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开管道fifo2成功，等待读取...\n&quot;</span>)；</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 循环写读数据</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line">    	<span class="comment">// 获取标准输入的数据    </span></span><br><span class="line">        fgets(buf, <span class="number">128</span>, <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="comment">// 发送信息，写入数据</span></span><br><span class="line">        ret = write(fdw, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 接收信息，读取数据</span></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line">        ret = read(fdr, buf, <span class="number">128</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">           	<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;buf: %s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    close(fdr);</span><br><span class="line">    close(fdw);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<p>进程B </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.判断有名管道文件是否存在</span></span><br><span class="line">    <span class="type">int</span> ret = access(<span class="string">&quot;fifo1&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">// 文件不存在则创建</span></span><br><span class="line">        ret = mkfifo(<span class="string">&quot;fifo1&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">    	<span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">			perror(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">	ret = access(<span class="string">&quot;fifo2&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">// 文件不存在则创建</span></span><br><span class="line">        ret = mkfifo(<span class="string">&quot;fifo2&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">    	<span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">			perror(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 以只读方式打开管道 fifo1</span></span><br><span class="line">    <span class="type">int</span> fdw = open(<span class="string">&quot;fifo1&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fdw == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开管道fifo1成功，等待读取...\n&quot;</span>)；</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 以只写方式打开管道 fifo2</span></span><br><span class="line">    <span class="type">int</span> fdr = open(<span class="string">&quot;fifo2&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span>(fdr == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开管道fifo2成功，等待写入...\n&quot;</span>)；</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 循环读写数据</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 接收信息，读取数据</span></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line">        ret = read(fdr, buf, <span class="number">128</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">           	<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;buf: %s\n&quot;</span>, buf);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line">    	<span class="comment">// 获取标准输入的数据    </span></span><br><span class="line">        fgets(buf, <span class="number">128</span>, <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="comment">// 发送信息，写入数据</span></span><br><span class="line">        ret = write(fdw, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    close(fdr);</span><br><span class="line">    close(fdw);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="2-6-4-内存映射"><a href="#2-6-4-内存映射" class="headerlink" title="2.6.4 内存映射"></a>2.6.4 内存映射</h3><p>内存映射 Memory-mapped I&#x2F;O ,是将磁盘文件的数据映射到内存，用户通过修改内存就能修改磁盘文件。</p>
<p>映射的是进程的虚拟地址空间，映射位置是共享库的位置</p>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230207021339909-167596242752017.png" alt="image-20230207021339909"></p>
<br>

<p><strong>相关系统调用</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	将一个文件或设备的数据映射到内存当中</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- addr：传入NULL，由内核决定后续处理</span></span><br><span class="line"><span class="comment">		- length：要映射的数据长度，不能为0.建议使用文件的长度	（使用 stat 或 lseek 可以获取文件长度）</span></span><br><span class="line"><span class="comment">		- prot：对申请的内存映射区的操作权限（不能与打开的文件有权限冲突）</span></span><br><span class="line"><span class="comment">			PROT_NONE 无权限</span></span><br><span class="line"><span class="comment">			PROT_EXEC 可执行</span></span><br><span class="line"><span class="comment">			PROT_READ 可读</span></span><br><span class="line"><span class="comment">			PROT_WRITE 可写</span></span><br><span class="line"><span class="comment">			（要操作映射内存，必须有读权限）</span></span><br><span class="line"><span class="comment">		- flags：</span></span><br><span class="line"><span class="comment">			MAP_SHARED	映射区的数据会自动和磁盘文件进行同步，进程间通信，必须设置该选项</span></span><br><span class="line"><span class="comment">			MAP_PRIVATE	不同步，内存映射区的数据改变不会修改源文件，而会创建一个新的文件 （copy on write）</span></span><br><span class="line"><span class="comment">		- fd：需要映射的文件的文件描述符，通过 open 得到的。 注意：文件大小要大于0，且 open 指定的权限不能和 prot 冲突。</span></span><br><span class="line"><span class="comment">		- offset：偏移量，文件数据的起始位置偏移，一般不使用（必须是4k的整数倍，0表示不偏移）</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		成功，返回映射到的内存首地址（虚拟地址）</span></span><br><span class="line"><span class="comment">		失败，返回 MAP_FAILED 即（void *) -1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	释放内存映射</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- addr：要释放的内存的首地址</span></span><br><span class="line"><span class="comment">		- length：要释放的内存大小，要和mmap函数中的length参数值一致</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<p><strong>实现进程间通信</strong></p>
<p>父子进程之间</p>
<blockquote>
<ul>
<li>在还没有子进程的时候<ul>
<li>通过唯一的父进程，先创建内存映射区</li>
</ul>
</li>
<li>有了内存映射区后，创建子进程</li>
<li>父子进程共享创建的内存映射区</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打开一个文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;test.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取文件大小</span></span><br><span class="line">    <span class="type">int</span> size = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建内存映射区</span></span><br><span class="line">    <span class="type">void</span> *ptr = mmap(<span class="literal">NULL</span>, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ptr == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(buf, (<span class="type">char</span> *)ptr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read data:%s\n&quot;</span>, buf);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">strcpy</span>((<span class="type">char</span> *)ptr, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关闭内存映射区</span></span><br><span class="line">    munmap(ptr, size);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<p>无关系的进程之间</p>
<blockquote>
<ul>
<li>准备一个大小不是0的磁盘文件</li>
<li>进程1 通过磁盘文件创建内存映射区</li>
<li>得到一个操作这块内存的指针</li>
<li>进程2 通过磁盘文件创建内存映射区</li>
<li>到到一个操作这块内存的指针</li>
<li>使用内存映射区通信</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main1</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打开一个文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;test.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取文件大小</span></span><br><span class="line">    <span class="type">int</span> size = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建内存映射区</span></span><br><span class="line">    <span class="type">void</span> *ptr = mmap(<span class="literal">NULL</span>, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ptr == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过获取文件数据</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(buf, (<span class="type">char</span> *)ptr);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;read data:%s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭内存映射区</span></span><br><span class="line">    munmap(ptr, size);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main2</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打开一个文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;test.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取文件大小</span></span><br><span class="line">    <span class="type">int</span> size = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建内存映射区</span></span><br><span class="line">    <span class="type">void</span> *ptr = mmap(<span class="literal">NULL</span>, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ptr == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 写入内存，修改文件</span></span><br><span class="line">    <span class="built_in">strcpy</span>((<span class="type">char</span> *)ptr, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关闭内存映射区</span></span><br><span class="line">    munmap(ptr, size);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<p><strong>思考问题</strong></p>
<ol>
<li>如果对mmap的返回值 (ptr) 做++操作 (ptr++) ，munmap能否成功</li>
</ol>
<blockquote>
<p>可以 ptr++; 但 munmap 会失败，只能通过首地址释放（提前保存）</p>
</blockquote>
<ol start="2">
<li>如果 open 时 O_RDONLY ，mmap 时 prot 参数指定 PROT_READ | PROT_WRITE 会怎样</li>
</ol>
<blockquote>
<p>错误，会返回MAP_FAILED。</p>
<p>open 函数中的权限要满足 mmap，即 prot &lt;&#x3D; open 的权限参数</p>
</blockquote>
<ol start="3">
<li>如果文件偏移量为1000会怎样</li>
</ol>
<blockquote>
<p>偏移量必须是 4k 的整数倍，否则会返回 MAP_FAILED</p>
</blockquote>
<ol start="4">
<li>mmap什么情况下会调用失败</li>
</ol>
<blockquote>
<ul>
<li>第二个参数：length &#x3D; 0</li>
<li>第三个参数：prot</li>
<li>没有指定读权限</li>
<li>参数 fd 在 open 时的权限不满足当前 prot</li>
</ul>
</blockquote>
<ol start="5">
<li>可以oepn的时候O_CREAT一个新文件来创建映射区吗</li>
</ol>
<blockquote>
<p>可以，但是创建的文件大小如果为 0 ，则不行</p>
<p>可以对新的文件进行拓展</p>
<pre><code>- lseek()
- truncate()
</code></pre>
</blockquote>
<ol start="6">
<li>mmap后关闭文件描述符，对mmap映射有没有影响</li>
</ol>
<blockquote>
<p>​	int fd &#x3D; open(“xxx”);</p>
<p>​	mmap(…, fd, …);</p>
<p>​	close(fd);</p>
<p>映射区还存在，创建的映射区的fd被关闭，没有任何影响</p>
</blockquote>
<ol start="7">
<li>对ptr越界操作会怎样</li>
</ol>
<blockquote>
<p>​	void * ptr &#x3D; mmap(NULL, 100, …);</p>
<p>越界操作会引发段错误</p>
</blockquote>
<br>

<br>

<p>除了进程间通信，还可以用来实现 <strong>文件复制</strong></p>
<ol>
<li>对原始的文件进行内存映射</li>
<li>创建新文件（并拓展</li>
<li>把新文件的数据映射到内存中</li>
<li>通过内存拷贝将第一个文件的数据拷贝到新的文件内存中</li>
<li>释放资源</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mmap.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对原始的文件进行内存映射</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;ori.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取原始文件大小</span></span><br><span class="line">    <span class="type">int</span> len = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个新的文件</span></span><br><span class="line">	<span class="type">int</span> fd1 = open(<span class="string">&quot;cpy.txt&quot;</span>, O_RDWR | O_CREAT, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd1 == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对新创建的文件进行拓展</span></span><br><span class="line">    truncate(<span class="string">&quot;cpy.txt&quot;</span>, len);</span><br><span class="line">    write(fd1, <span class="string">&quot; &quot;</span>, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分别做内存映射</span></span><br><span class="line">    <span class="type">void</span> *ptr = mmap(<span class="literal">NULL</span>,len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="type">void</span> *ptr1 = mmap(<span class="literal">NULL</span>,len, PROT_READ | PROT_WRITE, MAP_SHARED, fd1, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ptr == MAP_FAILED || ptr1 == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 内存拷贝</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr1, ptr, len);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放资源	（习惯上，先打开的后释放）</span></span><br><span class="line">    munmap(ptr1, len);</span><br><span class="line">    munmap(ptr, len);    </span><br><span class="line">    </span><br><span class="line">    close(fd1);</span><br><span class="line">    close(fd);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<p><strong>匿名映射</strong>(用于通信)</p>
<p>不需要文件实体进行内存映射，只能用于有关系的进程之间。</p>
<p>mmap 需要打开 <code>MAP_ANONYMOUS</code> 选项</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mmap.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建匿名内存映射区</span></span><br><span class="line">    <span class="type">int</span> len = <span class="number">4096</span>;</span><br><span class="line">    <span class="type">void</span> *ptr = mmap(<span class="literal">NULL</span>, len, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS，<span class="number">-1</span>， <span class="number">0</span>)；</span><br><span class="line">    <span class="keyword">if</span>(ptr == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 父子进程通信</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">strcpy</span>((<span class="type">char</span> *)ptr, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, (<span class="type">char</span> *)ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="type">int</span> ret = munmap(ptr, len);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;munmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<blockquote>
<p>与直接修改文件相比，在内存修改速度更快 </p>
</blockquote>
<br>

<h3 id="2-6-5-信号"><a href="#2-6-5-信号" class="headerlink" title="2.6.5 信号"></a>2.6.5 信号</h3><h4 id="信号概述"><a href="#信号概述" class="headerlink" title="信号概述"></a>信号概述</h4><p>信号是 Linux 进程通信最古老的方式之一，是事件发生时对进程的通知机制，有时又称为 <code>软件中断</code> ，它是在软件层次上对中断机制的一种模拟，是一种 <code>异步</code> 通信的方式。</p>
<p>信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断，转而处理某一个突发事件。</p>
<br>

<p>发往进程的诸多信号，通常都是源于<code>内核</code>。引发内核为进程产生信号的各类事件如下：</p>
<ul>
<li>对于前台进程，用户可以通过输入特殊的终端字符来发送信号。比如 Ctrl+C 通常会给进程发送一个中断信号。</li>
<li>硬件发生异常，即硬件检测到一个错误条件并通知内核，随机再由内核发送相应信号给相关进程。比如执行一条异常的机器语言指令，如除以0，或者引用了无法访问的内存区域。</li>
<li>系统状态的变化，比如 alarm 定时器到期将引起 SIGALRM 信号、进程执行的CPU时间超限、或者该进程的某个子进程退出。</li>
<li>运行 kill 命令或调用 kill 函数。</li>
</ul>
<br>

<p><strong>使用信号的两个目的</strong></p>
<ul>
<li>让进程知道已经发生了一个特定的事情</li>
<li>强迫进程执行它自己代码中的信号处理程序</li>
</ul>
<br>

<p><strong>特点</strong>：</p>
<ul>
<li>简单</li>
<li>不能携带大量信息</li>
<li>满足某个特定条件才发送</li>
<li>优先级比较高</li>
</ul>
<br>

<p>查看系统定义的信号列表：<code>kill -l</code></p>
<blockquote>
<p>前31个信号为常规信号，其余为实时信号</p>
</blockquote>
<br>

<p>查看信号的详细信息：<code>man 7 signal</code></p>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230207074413475-167596242752016.png" alt="image-20230207074413475"></p>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230207074659817-167596242752019.png" alt="image-20230207074659817"></p>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230207074814071-167596242752018.png" alt="image-20230207074814071"></p>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230207074951533-167596242752020.png" alt="image-20230207074951533"></p>
<br>

<p>进程的5个<strong>默认处理动作</strong></p>
<ul>
<li><p>Term 终止进程</p>
</li>
<li><p>Ign 当前进程忽略掉这个信号</p>
</li>
<li><p>Core 终止进程，并生成一个Core文件（保存进程异常退出的错误信息）</p>
<blockquote>
<p>通过 unlimit -c xxx 设置 core 文件生成</p>
<p>通过 gdb 打开生成的 core 文件</p>
</blockquote>
</li>
<li><p>Stop 暂停当前进程</p>
</li>
<li><p>Cont 继续执行当前被暂停的进程</p>
</li>
</ul>
<br>

<p>信号的3种<strong>状态</strong>：产生、未决、递达</p>
<br>

<blockquote>
<p>SIGKILL 和 SIGSTOP 信号不能被捕捉、阻塞或者忽略，只能执行默认动作</p>
</blockquote>
<br>

<br>

<h4 id="kill、raise、abort-函数"><a href="#kill、raise、abort-函数" class="headerlink" title="kill、raise、abort 函数"></a>kill、raise、abort 函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	给某个进程pid，发送某个信号sig</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- pid ：目标进程的 id</span></span><br><span class="line"><span class="comment">			&gt; 0 : 将信号发送给指定进程</span></span><br><span class="line"><span class="comment">			= 0 : 将信号发送给当前进程的进程组</span></span><br><span class="line"><span class="comment">			= -1 : 将信号发生给每一个有权限接收这个信号的进程</span></span><br><span class="line"><span class="comment">			&lt; -1 : 这个pid=某个进程组的gid取反</span></span><br><span class="line"><span class="comment">		- sig ：需要发送的信号编号或宏值，0表示不发送任何信号</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">raise</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	给当前进程发送某个信号sig</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- sig ：需要发送的信号编号或宏值，0表示不发送任何信号</span></span><br><span class="line"><span class="comment">		返回值：成功 0 ，失败 非 0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">abort</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	发送 SIGABRT 信号给当前进程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<h4 id="alarm-函数"><a href="#alarm-函数" class="headerlink" title="alarm 函数"></a>alarm 函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(unsigner <span class="type">int</span> seconds)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	设置定时器（闹钟）。函数调用后开始倒计时，当计时为0时，函数会给当前进程发送一个 SIGALARM 信号。</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- seconds：倒计时的时常，单位秒。若为0，则定时器无效（可以用 alarm(0); 取消定时器）</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		- 之前没有定时器，返回0</span></span><br><span class="line"><span class="comment">		- 之前有定时器，返回定时器剩余的时间</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	SIGALARM ： 默认终止当前的进程。</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	每一个进程都有且只有唯一的一个定时器。</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<blockquote>
<p>程序运行的实际时间 &#x3D; 内核时间 + 用户时间 + 切换、文件IO等消耗的时间</p>
</blockquote>
<blockquote>
<p>定时器与进程的状态无关。（采用自然定时法，无论进程出于什么状态，alarm都会计时）</p>
</blockquote>
<br>

<h4 id="setitimer-定时器函数"><a href="#setitimer-定时器函数" class="headerlink" title="setitimer 定时器函数"></a>setitimer 定时器函数</h4><p>周期性的定时</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时器值结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">it_interval</span>;</span>	<span class="comment">// 每个间隔的时间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">it_value</span>;</span>	<span class="comment">// 延迟多长时间启动定时器</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 时间值结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">    <span class="type">time_t</span> tv_sec;		<span class="comment">// seconds s</span></span><br><span class="line">    <span class="type">suseconds_t</span> tv_usec;	<span class="comment">// microseconds us</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setitimer</span><span class="params">(<span class="type">int</span> which, <span class="type">const</span> <span class="keyword">struct</span> itimerval *new_val, <span class="keyword">struct</span> itimerval *old_value)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	设置定时器（闹钟），替代 alarm 函数。精度微妙us，周期性计时。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- which : 定时器以什么时间计时</span></span><br><span class="line"><span class="comment">			ITIMER_REAL : 真实时间，时间到则发送SIGALARM ，常用</span></span><br><span class="line"><span class="comment">			ITIMER_VIRTUAL : 用户时间，时间到则发送 SIGVTALRM</span></span><br><span class="line"><span class="comment">			ITIMER_PROF : 以该进程在用户态和内核态下所消耗的时间来计算，时间到则发送 SIGPROF</span></span><br><span class="line"><span class="comment">			</span></span><br><span class="line"><span class="comment">		- new_val : 设置定时器的属性</span></span><br><span class="line"><span class="comment">		- old_value : 记录上一次的定时的时间参数，一般不使用，指定 NULL</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		成功 0 ，失败 -1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<h4 id="signal-信号捕捉函数"><a href="#signal-信号捕捉函数" class="headerlink" title="signal 信号捕捉函数"></a>signal 信号捕捉函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	设置某个信号的捕捉行为</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- signum ： 要捕捉的信号</span></span><br><span class="line"><span class="comment">		- handler ： 捕捉到信号后的处理</span></span><br><span class="line"><span class="comment">			可以是：</span></span><br><span class="line"><span class="comment">			SIG_IGN : 忽略</span></span><br><span class="line"><span class="comment">			SIG_DEL : 使用信号默认的行为</span></span><br><span class="line"><span class="comment">			回调函数 ： 由内核调用，程序员负责实现其功能</span></span><br><span class="line"><span class="comment">		回调函数：</span></span><br><span class="line"><span class="comment">			- 由程序员实现，提前准备好的，函数的类型根据实际需求，和函数指针的定义</span></span><br><span class="line"><span class="comment">			- 不是程序员调用，而是当信号产生，由内核调用</span></span><br><span class="line"><span class="comment">			- 函数指针是实现回调的手段，函数实现之后，将函数名放到函数指针的位置即可</span></span><br><span class="line"><span class="comment">			</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		成功，返回上一次注册的信号处理函数的地址，若是第一次则返回 NULL</span></span><br><span class="line"><span class="comment">		失败，返回 SIG_ERR ，并设置errno</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<blockquote>
<p>SIGKILL 和 SIGSTOP 信号不能被捕捉、阻塞或者忽略，只能执行默认动作</p>
</blockquote>
<br>

<p><strong>案例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myalarm</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sss\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//延迟3秒后启动间隔为2秒的定时器,启动时也会发送信号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册信号捕捉</span></span><br><span class="line">    <span class="comment">// signal(SIGALARM, SIG_IGN);</span></span><br><span class="line">    <span class="comment">// signal(SIGALARM, SIG_DEL);</span></span><br><span class="line">    <span class="comment">// void (* sighandler_t)(int); 函数指针</span></span><br><span class="line">    <span class="type">sighandler_t</span> ret1 = signal(SIGALARM, myalarm);</span><br><span class="line">    <span class="keyword">if</span>(ret1 == SIG_ERR) &#123;</span><br><span class="line">        perror(<span class="string">&quot;signal&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>)；</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">new_val</span>;</span></span><br><span class="line">    <span class="comment">// 间隔时间</span></span><br><span class="line">    new_val.it_interval.tv_sec = <span class="number">2</span>;</span><br><span class="line">    new_val.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 延迟时间</span></span><br><span class="line">    new_val.it_value.tv_sec = <span class="number">3</span>;</span><br><span class="line">    new_val.it.value.tv_usec = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> ret2 = setitimer(ITIMER_REAL, &amp;new_value, <span class="literal">NULL</span>);		<span class="comment">// 非阻塞的</span></span><br><span class="line">    <span class="keyword">if</span>(ret2 == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;setitimer&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<h4 id="信号集及相关函数"><a href="#信号集及相关函数" class="headerlink" title="信号集及相关函数"></a>信号集及相关函数</h4><p><strong>信号集</strong></p>
<ul>
<li>许多信号相关的系统调用都需要能表示一组不同的信号，多个信号可使用一个称之为信号集的数据结构来表示，其系统数据类型为 sigset_t</li>
<li>在 PCB 中有两个非常重要的信号集。一个称之为“阻塞信号集”，另一个称之为“未决信号集”。这两个信号集都是内核使用位图机制来实现的，但操作系统不允许我们直接对这两个信号集进行位操作，而需自定义另外一个集合，借助信号集操作函数来对 PCB 中的两个信号集进行修改。</li>
<li>”未决“，是一种状态，指的是<u>从信号的产生到信号被处理前</u>的这一段时间。</li>
<li>”阻塞“，是一个开关动作，指的是阻止信号被处理，但不是阻止信号产生。  </li>
<li>信号的阻塞就是让系统暂时保留信号，留待以后发送。由于另外有办法让系统忽略信号，所以一般情况下信号的阻塞只是暂时的，只是为了防止信号打断敏感的操作。</li>
</ul>
<br>

<p><strong>默认</strong></p>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230207122515067-167596242752021.png" alt="image-20230207122515067"></p>
<br>

<p><strong>操作信号集的函数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">//以下信号集相关的函数都是对自定义的信号集（参数set）进行操作</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	清空信号集中的数据，将所有标志位置 0</span></span><br><span class="line"><span class="comment">	参数：	set 要操作的信号集</span></span><br><span class="line"><span class="comment">	返回值：成功0，失败-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	将信号集中的所有标志位置 1</span></span><br><span class="line"><span class="comment">	参数：	set 要操作的信号集</span></span><br><span class="line"><span class="comment">	返回值：成功0，失败-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	设置信号集中的某一个信号对应得标志位为 1 ，表示阻塞这个信号</span></span><br><span class="line"><span class="comment">	参数：	</span></span><br><span class="line"><span class="comment">		- set 要操作的信号集</span></span><br><span class="line"><span class="comment">		- signum 需要设置的信号</span></span><br><span class="line"><span class="comment">	返回值：成功0，失败-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigdelset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	设置信号集中的某一个信号对应得标志位为 0 ，表示不阻塞这个信号</span></span><br><span class="line"><span class="comment">	参数：	</span></span><br><span class="line"><span class="comment">		- set 要操作的信号集</span></span><br><span class="line"><span class="comment">		- signum 需要设置的信号</span></span><br><span class="line"><span class="comment">	返回值：成功0，失败-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	判断某个信号是否阻塞</span></span><br><span class="line"><span class="comment">	参数：	</span></span><br><span class="line"><span class="comment">		- set 要操作的信号集</span></span><br><span class="line"><span class="comment">		- signum 需要判断的信号</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		- 1 ，signum被阻塞</span></span><br><span class="line"><span class="comment">		- 0 ，signum不阻塞</span></span><br><span class="line"><span class="comment">		- -1，调用失败</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<h4 id="sigprocmask-函数"><a href="#sigprocmask-函数" class="headerlink" title="sigprocmask 函数"></a>sigprocmask 函数</h4><p>将自己设置好的信号集应用到内核信号集中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oldset)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	将自定义信号集中的数据设置到内核中（设置阻塞，解除阻塞，替换）</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- how  如何对内和阻塞信号集进行处理</span></span><br><span class="line"><span class="comment">			SIG_BLOCK：将用户设置的阻塞信号集添加到内核中，内核中原来的数据不变	（假设内核中默认的阻塞信号集是mask，则令 mask | set ）</span></span><br><span class="line"><span class="comment">			SIG_UNBLOCK：根据用户设置的数据，对内核中的数据进行解除阻塞  （ mask &amp;= ~set ）</span></span><br><span class="line"><span class="comment">			SIG_SETMASK: 覆盖内核中原来的值</span></span><br><span class="line"><span class="comment">		- set  已经初始化的用户自定义的信号集</span></span><br><span class="line"><span class="comment">		- oldset  保存设置之前的内核中的阻塞信号集的状态，可以是NULL</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		成功 0</span></span><br><span class="line"><span class="comment">		失败 -1</span></span><br><span class="line"><span class="comment">			设置错误号：EFAULT、EINVAL</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigpending</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	获取内核中的未决信号集</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	参数 : set  传出参数，保存的是内存中的未决信号集的信息</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	返回值：成功0，失败-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<h4 id="sigaction-信号捕捉函数"><a href="#sigaction-信号捕捉函数" class="headerlink" title="sigaction 信号捕捉函数"></a>sigaction 信号捕捉函数</h4><p>跟 signal 函数作用类似</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> (*sa_handler)(<span class="type">int</span>);	<span class="comment">// 函数指针，指向的函数就是回调函数</span></span><br><span class="line">    <span class="type">void</span> (*sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span> *, <span class="type">void</span> *);		<span class="comment">// 不常用，需要就看看查文档</span></span><br><span class="line">    <span class="type">sigset_t</span> sa_mask;	<span class="comment">// 临时阻塞信号集，在信号捕捉函数执行过程中，临时阻塞某些信号</span></span><br><span class="line">    <span class="type">int</span> sa_flags;	<span class="comment">// 决定使用哪一个信号处理函数（ 0 表示使用 sa_handler，SA_SIGINFO 表示使用sa_sigaction</span></span><br><span class="line">    <span class="type">void</span> (*sa_restorer)(<span class="type">void</span>);	<span class="comment">// 废弃</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction *act, <span class="keyword">struct</span> sigaction *oldact)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	检查或改变信号的处理。信号捕捉</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- signum  指定的信号（ 除了SIGKILL 和 SIGSTOP ）</span></span><br><span class="line"><span class="comment">		- act  捕捉到信号后相应的处理动作</span></span><br><span class="line"><span class="comment">		- oldact  上一次对信号捕捉设置的处理动作，一般不使用，传递 NULL</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		成功 0</span></span><br><span class="line"><span class="comment">		失败 -1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<blockquote>
<p>由于编程标准原因，尽量使用 sigaction</p>
</blockquote>
<br>

<p>如果在回调函数执行过程中又收到信号，则会阻塞回调函数优先处理信号（解决方案：设置临时阻塞信号集）</p>
<br>

<p><strong>内核实现信号捕捉的过程</strong></p>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230207223806887-167596242752026.png" alt="image-20230207223806887"></p>
<blockquote>
<p>内核态的 do_signal() 和 sys_sigreturn()</p>
</blockquote>
<br>

<br>

<h4 id="SIGCHLD-信号"><a href="#SIGCHLD-信号" class="headerlink" title="SIGCHLD 信号"></a>SIGCHLD 信号</h4><p>产生条件：</p>
<ul>
<li>子进程终止时</li>
<li>子进程接收到 SIGSTOP 信号并停止时</li>
<li>子进程处在停止态，接收到 SIGCONT 信号唤醒时</li>
</ul>
<p>以上情况会由内核给父进程发送 SIGCHLD 信号，父进程默认忽略。</p>
<br>

<p><strong>解决僵尸进程问题</strong></p>
<ul>
<li>利用子进程终止时发送 SIGCHLD 信号</li>
<li>创建子进程前，先阻塞 SIGCHLD ，等回调函数注册完之后再解除阻塞</li>
</ul>
<br>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子进程资源回收 回调函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">myFun</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;捕捉信号 %d\n&quot;</span>, num);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> ret = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG);</span><br><span class="line">        <span class="keyword">if</span>(ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child die %d\n&quot;</span>, ret);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 还有子进程存活</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="comment">// 没有子进程了，回收完毕</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打开阻塞</span></span><br><span class="line">    <span class="type">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>. SIGCHLD);</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;<span class="built_in">set</span>, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">        act.sa_flags = <span class="number">0</span>;</span><br><span class="line">        act.sa_handler = myFun;</span><br><span class="line">        sigemptyset(&amp;act.sa_mask);</span><br><span class="line">        sigaction(SIGCHLD, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 解除阻塞</span></span><br><span class="line">        sigprocmask(SIG_UNBLOCK, &amp;<span class="built_in">set</span>, <span class="literal">NULL</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child %d\n&quot;</span>, getpid());</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><br><br></p>
<h3 id="2-6-6-共享内存"><a href="#2-6-6-共享内存" class="headerlink" title="2.6.6 共享内存"></a>2.6.6 共享内存</h3><p>效率最高的进程间通信方式</p>
<p>（内存映射需要用到文件）</p>
<br>

<ul>
<li>共享内存允许两个或多个进程共享<code>物理内存</code>的同一块区域（通常称为 段 )。由于一个共享内存段会被称为一个进程用户空间的一部分，因此这种 IPC 机制无需内核介入（实际上还是会用到系统调用，但相对较少）。所有需要做的就是让一个进程将数据复制进共享内存中，并且这部分数据会对其他所有共享同一个段的进程可用。</li>
<li>与管道等要求 发送进程 将数据从用户空间的缓冲区复制进内核内存 和 接收进程 将数据从内核内存复制进用户空间的缓冲区 的做法相比，共享内存方式速度更快。</li>
</ul>
<br>

<p><strong>使用步骤</strong></p>
<ol>
<li>调用 shmget() 创建一个新共享内存段或区的一个既有共享内存段的标识符（即由其他进程创建的共享内存段）。这个调用将返回后续调用中需要用到的共享内存标识符。</li>
<li>使用 shmat() 来附上共享内存段，也就是使该段成为调用进程的虚拟内存的一部分。</li>
<li>此刻在程序中可以像对待其他可用内存那样对待这个共享内存段。为引用这块共享内存，程序需要使用由 shmat() 调用返回的 addr 值，它是一个指向进程的虚拟地址空间中该共享内存段的起点的指针</li>
<li>调用 shmdt() 来分离共享内存段。调用后，进程就无法再引用这块共享内存。（这一步是可选的，并且在进程终止时会自动完成）</li>
<li>调用 shmctl() 来删除共享内存段。只有当当前所有附加内存段的进程都与之分离之后内存段才会销毁。（只有一个进程需要执行这一步）</li>
</ol>
<p><br><br></p>
<p><strong>函数接口</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	创建一个新的共享内存段，或者获取一个既有的共享内存段的标识</span></span><br><span class="line"><span class="comment">	新创建的内存段中的数据都会被初始化为0</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- key	key_t时整型，通过这个参数找到或者创建一个共享内存。一般使用16进制表示，非0值</span></span><br><span class="line"><span class="comment">		- size	共享内存的大小（实际按页划分）</span></span><br><span class="line"><span class="comment">		- shmflg 属性</span></span><br><span class="line"><span class="comment">			- 访问权限</span></span><br><span class="line"><span class="comment">			- 附加属性：创建/判断共享内存是否存在</span></span><br><span class="line"><span class="comment">				- 创建：IPC_CREAT</span></span><br><span class="line"><span class="comment">				- 判断共享内存是否存在：IPC_EXCL，需要和IPC_CREAT一起使用</span></span><br><span class="line"><span class="comment">				如 IPC_CREAT | IPC_EXCL | 0664</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		失败 -1，设置错误号</span></span><br><span class="line"><span class="comment">		成功 &gt;0,返回共享内存的引用 ID ，后面操作共享内存即通过这个值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">shmat</span><span class="params">(<span class="type">int</span> shmid, consst <span class="type">void</span> *shmaddr, <span class="type">int</span> shmflg)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	和当前的进程进行关联</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- shmid：共享内存的标识id，由shmget返回值获取</span></span><br><span class="line"><span class="comment">		- shmaddr：申请的共享内存的起始地址，指定NULL，由内核决定</span></span><br><span class="line"><span class="comment">		- shmflg：对共享内存的操作</span></span><br><span class="line"><span class="comment">			读：SHM_RDONLY，必须要有读权限</span></span><br><span class="line"><span class="comment">			读写：0</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		成功 返回共享内存的首地址</span></span><br><span class="line"><span class="comment">		失败 （void*)-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *shmaddr)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	解除当前进程和共享内存的关联</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- shmaddr：共享内存的首地址</span></span><br><span class="line"><span class="comment">	返回值：成功0，失败-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmctl</span><span class="params">(<span class="type">int</span> shmid, <span class="type">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	对共享内存进行操作（共享内存需要删除才会消失，创建共享内存的进程被销毁了对共享内存是没有影响的）</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- shmid：共享内存id</span></span><br><span class="line"><span class="comment">		- cmd：要做的操作</span></span><br><span class="line"><span class="comment">			IPC_STAT 获取共享内存的当前状态</span></span><br><span class="line"><span class="comment">			IPC_SET 设置共享内存的状态</span></span><br><span class="line"><span class="comment">			IPC_RMID 标记共享内存被销毁</span></span><br><span class="line"><span class="comment">		- buf：需要设置或者获取的共享内存的属性信息</span></span><br><span class="line"><span class="comment">			IPC_STAT：buf存储数据，传出参数</span></span><br><span class="line"><span class="comment">			IPC_SET：buf中需要初始化数据，设置到内核中，传入参数</span></span><br><span class="line"><span class="comment">			IPC_RMID：没有用，NULL</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<blockquote>
<p>shmid_ds结构体</p>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230208120249528-167596242752025.png" alt="image-20230208120249528"></p>
</blockquote>
<br>

<p><strong>案例</strong></p>
<p>write.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个共享内存</span></span><br><span class="line">    <span class="type">int</span> shmid = shmget(<span class="number">100</span>, <span class="number">0</span>, IPC_CREAT);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 和当前进程进行关联</span></span><br><span class="line">    <span class="type">void</span> *ptr = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 写数据</span></span><br><span class="line">    <span class="type">char</span> *str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, str, <span class="built_in">strlen</span>(str)+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 暂停一下</span></span><br><span class="line">    getchar();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解除关联</span></span><br><span class="line">    shmdt(ptr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除共享内存</span></span><br><span class="line">    shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<p>read.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取一个共享内存</span></span><br><span class="line">    <span class="type">int</span> shmid = shmget(<span class="number">100</span>, <span class="number">4096</span>, IPC_CREAT | <span class="number">0664</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 和当前进程进行关联</span></span><br><span class="line">    <span class="type">void</span> *ptr = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,(<span class="type">char</span> *)ptr);</span><br><span class="line">    <span class="comment">// 暂停一下</span></span><br><span class="line">    getchar();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解除关联</span></span><br><span class="line">    shmdt(ptr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除共享内存</span></span><br><span class="line">    shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<blockquote>
<p><strong>删除机制</strong></p>
<p>shmctl(shmid, IPC_RMID, NULL);</p>
<p>当关联进程数 &gt;&#x3D; 1 时，调用上面的函数删除共享内存并不会直接删除，而是把 key 值置为0，标记删除；</p>
<p>当关联进程数 &#x3D; 0 时，共享内存才会真正删除。</p>
</blockquote>
<br>

<br>

<p><strong>ftok函数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">key_t</span> <span class="title function_">ftok</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> proj_id)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	根据指定的路径名和 int 值，生成一个共享内存的 key ，可以作为shmget函数的参数</span></span><br><span class="line"><span class="comment">    参数：</span></span><br><span class="line"><span class="comment">		- pathname：指定一个存在的路径</span></span><br><span class="line"><span class="comment">		- proj_id：int类型的值（4B），但这个系统调用指挥使用其中1个字节</span></span><br><span class="line"><span class="comment">				   范围：0~255，一般指定一个字符 &#x27;a&#x27;</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<br>

<p><strong>问题</strong></p>
<ol>
<li>系统如何知道一块共享内存被多少个进程关联？<ul>
<li>共享内存维护了一个 shmid_ds 结构体，该结构体的成员 shm_nattach 记录了关联进程数</li>
</ul>
</li>
<li>可不可以对共享内存进行多次删除<ul>
<li>可以，当还有关联进程的时候，共享内存只是标记删除。而直到没有关联进程才会被真正删除。</li>
<li>key 为 0 ：被标记删除，不再能被关联</li>
</ul>
</li>
<li>共享内存与内存映射的区别<ul>
<li>共享内存可以直接创建，内存映射需要磁盘文件（匿名映射除外）</li>
<li>共享内存效率更高</li>
<li><strong>内存：</strong><br>共享内存，所有进程操作的是同一块共享内存（物理）；<br>内存映射，每个进程再自己的虚拟地址空间中有一个独立的内存。</li>
<li><strong>数据安全：</strong><ul>
<li>进程突然退出<br>共享内存还存在，内存映射区消失。</li>
<li>电脑突然宕机<br>共享内存中的数据消失，内存映射区的数据在磁盘文件中仍存在。</li>
</ul>
</li>
<li><strong>生命周期：</strong><ul>
<li>共享内存：进程退出，共享内存仍存在，需要手动删除或关机（进程退出会自动取消关联）</li>
<li>内存映射区：进程退出，映射区销毁</li>
</ul>
</li>
</ul>
</li>
</ol>
<br>

<p><strong>一些操作命令</strong>（System V）</p>
<p><code>ipcs</code></p>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230208122145744-167596242752022.png" alt="image-20230208122145744"></p>
<p><code>ipcrm</code></p>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230208122153825-167596242752023.png" alt="image-20230208122153825"></p>
<p><br><br></p>
<h3 id="补充：2-6-7-消息队列"><a href="#补充：2-6-7-消息队列" class="headerlink" title="补充：2.6.7 消息队列"></a>补充：2.6.7 消息队列</h3><p><br><br><br></p>
<h2 id="2-7-守护进程"><a href="#2-7-守护进程" class="headerlink" title="2.7 守护进程"></a>2.7 守护进程</h2><h3 id="终端、进程组、会话"><a href="#终端、进程组、会话" class="headerlink" title="终端、进程组、会话"></a>终端、进程组、会话</h3><p><strong>终端</strong></p>
<ul>
<li>在 UNIX 系统中，用户通过 终端 登陆到系统后得到一个 shell 进程，这个终端进程为 shell 进程的 控制终端 （Controlling Termianl) ，进程中，控制终端是保存在 PCB 中的信息，而 fork() 会复制 PCB 中的信息，因此由 shell 进程启动的其他进程的控制终端也是这个终端。</li>
<li>默认情况下（没有重定向），每个进程的标准输入、标准输出和标准错误输出（文件描述符）都指向控制终端，进程从标准输入读也就是读用户的键盘输入，进程往标准输出或标准错误输出写也就是输出到显示器上。</li>
<li>在控制终端输入一些特殊的控制键可以给前台进程发送信号，例如 Ctrl+C 会产生 SIGINT 信号，Ctrl+\ 会产生 SIGQUIT 信号。</li>
</ul>
<br>

<p><strong>进程组</strong></p>
<ul>
<li>进程组和会话在进程之间形成了一种两级层次关系：进程组是一组相关进程的集合，会话是一组相关进程组的集合。</li>
<li>进程组和会话是为支持 <u>shell作业控制</u> 而定义的抽象概念，用户通过 shell 能够交互式地在前台或后台运行命令。</li>
</ul>
<br>

<ul>
<li>进程组由一个或多个共享同一进程组标识符（PGID）的进程组成。一个进程组拥有一个 进程组首进程 （组长），该进程是创建该组的进程，<u>其进程 ID 为该进程组的 ID</u> ，新进程会继承父进程所属的进程组 ID 。</li>
<li>进程组有一个生命周期，起开始时间为首进程创建组的时刻，结束时间为最后一个成员进程退出的时刻。一个进程可能会因为终止而退出进程组，也可能会因为加入另一个进程组而退出进程组。进程组首进程无需是最后一个离开的成员。</li>
</ul>
<br>



<p><strong>会话</strong></p>
<ul>
<li>会话是一组进程组的集合。会话首进程是创建该新会话的进程，其进程ID会成为会话ID。新进程会继承其父进程的会话ID。</li>
<li>一个会话中的所有进程共享单个控制终端。控制终端会在会话首进程首次打开一个终端设备时被建立。一个终端最多可能成为一个会话的控制终端。</li>
<li>在任意时刻，会话中的其中一个进程组会成为终端的前台进程组，其他进程会成为后台进程组。只有前台进程组中的进程才能从控制终端中读取输入。当用户在控制终端中输入终端字符生成信号后，该信号会被发送到前台进程组中的所有成员。</li>
<li>当控制终端的连接建立起来之后，会话首进程会成为该终端的控制进程。</li>
</ul>
<br>

<p><strong>三者关系图</strong></p>
<p>指令 </p>
<p><code>fing / 2 &gt; /dev/null | wc -l &amp;</code>( &amp; 后台运行指令 )</p>
<p><code>sort &lt; longlist | uniq -c</code></p>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230208194637948-167596242752024.png" alt="image-20230208194637948"></p>
<blockquote>
<p>来自评论区：</p>
<p>为什么两条命令产生了两个新的进程组，并且不同于bach进程组:</p>
<p>关于find和wc为什么父进程是bash(400)，但是进程组ID确是658，而不是复制父进程的组ID。其实fork函数产生的子进程才是复制父进程的组ID。那通过这种命令产生的子进程，组ID是怎么确立的？在《Linux&#x2F;UNIX系统编程手册》2.13 中提到，“shell执行的每个程序都会在一个新进程内发起”，这句话解释了为什么find、wc、sort、uniq这四个都是一个单独的进程。“除了Bourne shell以外，几乎所有主流shell都提供了一种交互式特性，名为任务控制。该特性允许用户同时执行并操纵多条命令或管道。在支持任务控制的shell中，会将管道内所有进程置于一个新进程组或任务中。如果情况很简单，shell命令行只包含一条命令，那么就会创建一个只包含单个进程的新进程组。进程组中每个进程都具有相同的进程组标识符，其实就是进程组组长的ID”，这段话可以解释为什么两条命令产生了两个新的进程组，并且不同于bach进程组。这种shell命令创建子进程一定要和fork函数区分开来。</p>
</blockquote>
<br>

<br>

<p><strong>相关函数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取当前进程的进程组</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgrp</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// 获取指定进程的进程组</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br><span class="line"><span class="comment">// 设置指定进程的组id</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setpgid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">pid_t</span> pgid)</span>;</span><br><span class="line"><span class="comment">// 获取指定进程的会话id</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getsid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br><span class="line"><span class="comment">// 设置当前进程的会话id</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">setsid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><br><br></p>
<h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><p>守护进程( Daemon Process )，也就是通常说的 Daemon 进程（精灵进程），是Linux中的后台服务进程。其生存周期较长，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生地事件。进程名一般以 d 结尾。</p>
<br>

<p><strong>特征</strong></p>
<ul>
<li>生命周期长，守护进程会在系统启动的时候被创建并一直运行直至系统被关闭。</li>
<li>在后台运行并且不拥有控制终端。没有控制终端确保了内核永远不会为守护进程自动生成任何控制信号以及终端相关的信号（如 SIGINT、SIGQUIT）</li>
</ul>
<br>

<blockquote>
<p>Linux的大多数服务器就是用守护进程实现的，比如，Internet服务器 inetd ，Web服务器 httpd 等</p>
</blockquote>
<br>

<p><strong>创建步骤</strong></p>
<ul>
<li>*执行 fork()，然后父进程退出，子进程继续执行<ul>
<li>假设从命令行启动进程，父进程在退出后会使终端出现shell提示符；提前退出就不会出现了</li>
<li>子进程能确保自己不是进程组的首进程</li>
</ul>
</li>
<li>*子进程调用 setsid() 开启一个新会话（<ul>
<li>用setsid新建会话的首进程不能是进程组的首进程，否则导致组id重复</li>
<li>新建会话是为了控制终端，setsid() 新建的会话在终端连接建立之前默认无控制终端</li>
</ul>
</li>
<li>（非必须）清除进程的 umask 以确保当守护进程创建文件和目录时拥有所需的权限</li>
<li>（非必须）修改进程的当前工作目录，通常改为根目录（ &#x2F; ）</li>
<li>关闭守护进程从其父进程继承而来的所有打开着的文件描述符<ul>
<li>守护进程脱离了控制终端，但是没有脱离终端</li>
<li>避免守护进程通过标准输出等到终端读写数据</li>
<li>以及关闭其他继承过来的文件描述符，解除文件占用</li>
</ul>
</li>
<li>在关闭了文件描述符0、1、2之后，守护进程通常会打开 &#x2F;dev&#x2F;null 并使用 dup2() 使所有这些描述符指向这个设备<ul>
<li>某些系统调用会使用到0、1、2文件描述符，所以不能关闭</li>
<li>重定向后相当于丢弃掉数据</li>
</ul>
</li>
<li>*核心业务逻辑</li>
</ul>
<br>

<p><strong>案例</strong></p>
<p>写一个守护进程，每个2s获取一次系统时间，并将时间写入到磁盘文件中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">work</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="comment">// 捕捉到信号之后，获取系统时间并写入磁盘</span></span><br><span class="line">    <span class="type">time_t</span> ret = time(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> * <span class="title">loc</span> =</span> localtime(&amp;ret);</span><br><span class="line">    <span class="comment">// 转换格式</span></span><br><span class="line">    <span class="comment">// char buf[1024];</span></span><br><span class="line">    <span class="comment">// sprintf(buf, &quot;%d:%d:%d\n&quot;,loc-&gt;tm_hour,loc-&gt;tm_min,loc-&gt;tm_sec);</span></span><br><span class="line">    <span class="comment">// printf(&quot;%s\n&quot;,buf);</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *str = asctime(loc);</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;time.txt&quot;</span>, O_RDWR | O_CREAT | O_APPEND, <span class="number">0664</span>);</span><br><span class="line">    write(fd, str, <span class="built_in">strlen</span>(str));</span><br><span class="line">    write(fd, <span class="string">&quot;\n&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;\n&quot;</span>));    </span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建子进程，退出父进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子进程重新创建一个会话</span></span><br><span class="line">    setsid();</span><br><span class="line">    <span class="comment">// 设置掩码</span></span><br><span class="line">    umask(<span class="number">022</span>);</span><br><span class="line">    <span class="comment">// 更改工作目录</span></span><br><span class="line">    chdir(<span class="string">&quot;/root/user&quot;</span>);</span><br><span class="line">    <span class="comment">// 关闭、重定向文件描述符</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/dev/null&quot;</span>,O_RDWR);</span><br><span class="line">    dup2(fd,STDIN_FILENO);</span><br><span class="line">    dup2(fd,STDOUT_FILENO);</span><br><span class="line">    dup2(fd,STDERR_FILENO);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 业务逻辑</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册信号捕捉</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    act.sa_handler = work;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    sigaction(SIGALRM, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建定时器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">val</span>;</span></span><br><span class="line">    val.it_value.tv_sec = <span class="number">2</span>;</span><br><span class="line">    val.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">    val.it_interval.tv_sec = <span class="number">2</span>;</span><br><span class="line">    val.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    setitimer(ITIMER_REAL, &amp;val, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<br>

<p>第二章完结！</p>
]]></content>
      <categories>
        <category>C++开发</category>
        <category>高性能服务器项目</category>
      </categories>
      <tags>
        <tag>多进程</tag>
      </tags>
  </entry>
</search>
