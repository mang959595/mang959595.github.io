<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2024开年大吉</title>
    <url>/2024/01/01/2024%E5%BC%80%E5%B9%B4%E5%A4%A7%E5%90%89/</url>
    <content><![CDATA[<p>哈哈，没想到距离上一次反思已经快过去一年了，上次反思还是在 2023.2.12 寒假那会儿。</p>
<p>这一次，主要是回顾2023年，展望2024年。</p>
<br>

<p>2023这一年囊括了大三下和大四上这两个学期，按理来说应该是本科找工作的最关键的时期。目前呢，我还是无offer人士，本来现在还0offer的话应该是很焦虑的，但我感觉还好，因为现在还在西山居实习。这会儿实习也来到第三个月了，后面或许有机会拿到项目组的offer。不过拿不到也没事，毕竟这段时候还是有所收获的</p>
<span id="more"></span>

<br>

<br>

<p><br>首先是回顾一下2023年的情况吧。</p>
<h2 id="2023时间线："><a href="#2023时间线：" class="headerlink" title="2023时间线："></a>2023时间线：</h2><h3 id="1月"><a href="#1月" class="headerlink" title="1月"></a>1月</h3><ul>
<li>一月份的话我可能还在打游戏，那会儿玩夜猫永恒玩疯了。</li>
<li>大概是到了1月底，也就是大年初七左右，我突然感受到了一股压力，开始慌慌张张地复习了起来。复习是看牛客的webserver项目视频，内容大概就是把游双的《Linux高性能服务器编程》提炼了出来，稍微复习到了一些操作系统的概念和Linux的API，以及计网的东西。</li>
</ul>
<h3 id="2月"><a href="#2月" class="headerlink" title="2月"></a>2月</h3><ul>
<li>记得那会儿是2月20多号才补上个学期的期末考试，而我是等到2.17回学校之后才开始期末复习，这段时间里面就没法看别的了。</li>
<li>在前面半个月的时间里，应该是在看牛客的视频，然后就是在刷牛客101题。</li>
</ul>
<h3 id="3月"><a href="#3月" class="headerlink" title="3月"></a>3月</h3><ul>
<li><p>三月份充了一年力扣的会员，开始逐步转移到这边刷题，然后还挑了力扣里面的一些八股总结来看。</p>
</li>
<li><p>另外就是开始写webserver的代码，因为牛客视频里的那个比较简单，所以我又去找了经典的TinyWebserver来写。与其说是写，不如说是抄吧，基本就是跟着别人的博客还有代码过了一遍，不少地方还有点知其然而不知其所以然。</p>
</li>
<li><p>还有就是把之前操作系统课设写的那个协程给捋了捋，也给当作一个项目来用了。</p>
<p><img src="/2024/01/01/2024%E5%BC%80%E5%B9%B4%E5%A4%A7%E5%90%89/image-20240101024131237.png" alt="刷题热点图"></p>
</li>
</ul>
<h3 id="4月"><a href="#4月" class="headerlink" title="4月"></a>4月</h3><ul>
<li>四月份开始一边高强度刷题看八股，一边投简历了。</li>
<li>从下图可以看到，投的公司不多，但都来自各行各业。</li>
<li>这个月的主要战绩是把华为的笔试过了。</li>
</ul>
<p><img src="/2024/01/01/2024%E5%BC%80%E5%B9%B4%E5%A4%A7%E5%90%89/image-20240101024258966.png" alt="image-20240101024258966"></p>
<h3 id="5月"><a href="#5月" class="headerlink" title="5月"></a>5月</h3><ul>
<li>五月份一开始，就葬送了去华为的可能。因为五一出去玩了，没有复习八股和项目，导致面华为约面的时候被打了个措手不及。不过究其原因还是自己对基础知识的理解不够深刻，以及对项目的认识也不够深刻。</li>
<li>华为一面G了之后，备受打击，好在这个时候收到了西山居技术训练营的面试。面试特别简单，一面十几分钟，二面就是跟hr聊天和oc了。</li>
<li>大概隔了两个星期之后，西山居发了训练营的offer，然后我也接了。这期间，过了阿里灵犀的一面，一面问了大概1小时10分的八股，从C++，到操作系统，到计算机网络，到数据结构和算法，很多都是常问的面试题，但是每一题都会挖得很深，问到不会为止。通过这次面试也发现自己对基础知识的理解还是不够深入的，没有构建起一个互联的体系。</li>
<li>在收到西山居训练营的offer之后，我把阿里这边的二面拒了。二面按理来说应该是会问项目，我知道自己对项目的理解不够深。其实如果好好再去准备一下也是可以面一面的，面了不管过没过都能有所收获。但是！但是我把二面拒了，现在想想，好想打屎我这个懒B。此外我也把CVTE的笔试给丢了。</li>
<li>在拿了offer之后，我决定往游戏行业靠了，毕竟我也是一个臭打游戏的。我开始入门Unity，还花钱买了麦扣的 3D RPG项目，跟着做了一遍。按后面来看，其实没必要买，免费的部分就足够入门了。而且这个教程也就那样，顶多就是能帮助新手熟悉一下Unity的各个部分，往深了就没了，代码什么的其实写的一般。</li>
</ul>
<h3 id="6月"><a href="#6月" class="headerlink" title="6月"></a>6月</h3><ul>
<li>继续学了一点Unity，可惜后来没有按我当时的计划清单里写的，再做一个带有网络对战的 Unity Demo。</li>
<li>6月中间是生了场病，病了两个星期，直接把这个月给搞砸了。</li>
<li>病好了之后我就又开始狂打游戏了，这个月回头一看几乎是一片空白，毫无收获。</li>
</ul>
<h3 id="7月"><a href="#7月" class="headerlink" title="7月"></a>7月</h3><ul>
<li>六月底七月初有期末考，我那会儿应该是在复习吧。</li>
<li>7月18号开始训练营，去之前那段时间我应该就多看了一点Unity，别的也来不及看了。</li>
<li>然后就是训练营的前2周，是在上课和做作业，客户端、服务端、渲染都讲了些，也都实践了一下，详细内容懒得码字了，简历、实习总结里有。</li>
</ul>
<h3 id="8月"><a href="#8月" class="headerlink" title="8月"></a>8月</h3><ul>
<li>训练营的后半部分是进行更多的实践，根据策划文档完成作业。文档内容分了单机和联网两部分，联网的内容可以自己拓展，服务端除了完成文档上的内容，我和我那个给力的队友还加了房间管理和多人游戏同步的内容。</li>
<li>8月18号训练营就结束了，虽说顺利拿到了继续实习offer，但是这次还是发现了自己的一些不足，之前在学校动手实践实在太少了。</li>
<li>这次训练营让我了解游戏开发大概是怎样的一个情况，提升了我的编码和调试能力（但此时还是很渣）。</li>
<li>回去学校之后，先是给自己放空了一个星期。本来打算九月就回去珠海继续实习，但是因为后面9月和10月要校内实习，我就得看导师放不放我远程实习。</li>
</ul>
<h3 id="9月"><a href="#9月" class="headerlink" title="9月"></a>9月</h3><ul>
<li>问了导师，导师的回答比较模糊，然后我又去问辅导员和教务员，都没能得到我想要的回答。又因为我对图形学和渲染一直有点爱慕之情，就打算干脆先在学校待两个月再去珠海，这段时间先学一学图形学和 Unity Shader，说不定以后还有机会做做TA啥的。哈哈，因为小时候玩游戏总是很关注画质，所以自己对这方面是有一点天然的兴趣的。可惜了解得太晚了，等到快大四才知道这个方向，现在转这个方向估计是找不了工作的。</li>
<li>八月底和九月初其实还行，把GAMES101过了一遍，然后把Unity Shader精要也看了一般。可惜，我还是太懒了，全都是浅看辄止，没有动手实践。</li>
<li>后面就开始完蛋了。因为校内实习的事情把我搞得有点烦，然后当时还误以为导师很高冷，我就没有再和导师沟通，校内实习直接啥也没干。现在来看真的很蠢，导师人可好了，有什么事情直接问就行了，不回的话可能是人家比较忙，再多Call一下就行了，实在不行直接上办公室敲门算了。然后我还把EVA剧场版看了，看完就更EMO了，开始天天打游戏，不思进取，秋招直接简历0投递，0准备。</li>
</ul>
<h3 id="10月"><a href="#10月" class="headerlink" title="10月"></a>10月</h3><ul>
<li>到了十月，本来我是想10月9号就偷跑回珠海的，但是申请晚了，只能10月18号回。</li>
<li>十月第一周，国庆假期，不用想，啥也没干。第二周，也学不了啥了，索性当作最后的疯狂游戏时光。</li>
<li>然后就是回来实习了，第一周只有两天半，大概把文档过了一下，环境搭了一下，还把go语言的语法过了一遍，可惜后来完全用不到go。</li>
<li>实习第二周，开始过之前项目的代码，但是只是从命名、语法规范等的角度来重构。</li>
</ul>
<h3 id="11月"><a href="#11月" class="headerlink" title="11月"></a>11月</h3><ul>
<li>实习第三周，说是要看libuv源码，但是实际看的是别人的博客。然后用自己乱搞的测试客户端来测试项目，出现了一些奇怪的问题，后面就围绕这个问题开始看代码和调试。</li>
<li>实习第四周，这次真看了libuv源码，然后调试，找到问题并解决。按师傅和导师的要求，整理了一份文档，内容包括对libuv源码层面的介绍和我的问题解决过程。</li>
<li>实习第五周，开始接服务了。接服务就是把这边的游戏服务端通用微服务框架里的各个服务应用到Demo项目里，主要是先看协议和文档了解业务逻辑，然后敲代码，敲完就在客户端画点UI测一下。这周先把客户端网络处理部分的代码重构了，然后接了登录服务。</li>
<li>实习第六周，继续接服务，包括在线服务，邮件服务，名字服务。</li>
<li>实习第七周，继续接服务，包括聊天服务，好友服务，总计花了三周。</li>
</ul>
<h3 id="12月"><a href="#12月" class="headerlink" title="12月"></a>12月</h3><ul>
<li><p>实习第八周，接完服务不知道干嘛了，看了一周《Lua程序设计》，但没有实践，效率低下。另外把整个项目里面打日志的代码封装了一下。</p>
</li>
<li><p>实习第九周，和导师过了一遍接完服务后的代码，重新规范了一下代码，然后从模块设计的层面重构了一下，补充完善了很多功能，主要是针对网络连接的。</p>
</li>
<li><p>实习第十周，本来这周是要接中心服务和测试的，然后第一天确实接了，把正常情况下的协议测了一遍。后面请假了，回去填校内实习的坑。</p>
</li>
<li><p>实习第十一周，把Lua嵌入C++的方式整合完毕了，又把连接管理几乎重写了，后面可以顺畅地重写其他逻辑了。</p>
</li>
</ul>
<br>

<br>

<p>实习的这两个月，写了应该快1万行代码了，我的动手能力是实打实的锻炼到了。然后就是，对于后端接触的这些东西有了一个清晰一点的概念映像了，对一些业务逻辑，对项目里的实际要求，也有了更多的认识。</p>
<br>

<br>

<p>好了，下面就来到2024了。</p>
<br>

<br>

<h2 id="2024规划："><a href="#2024规划：" class="headerlink" title="2024规划："></a>2024规划：</h2><br>

<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>回顾完了2023，给自己一句简短的总结，大概就是“努力过了，但又没完全努力”。</p>
<p>相比起我在朋友圈看到的，比如有些同学已经顺利保研，或者是收获了腾讯、美团、网易等大厂的offer，我的收获就不值一提了。</p>
<p>但是，别人也不是一蹴而就，每个人总会有一段压力巨大的时期，如果扛过去了，并且稳扎稳打逐步爬升，总能有好结果的。</p>
<p>而我呢，也算是在逐步前进吧，但是三天打鱼两天晒网的现象还是比较严重，也就导致了最终跟别人比起来有些相形见绌。</p>
<p>说实话，看到同班的同学拿到大厂offer，还是挺眼红的。总有一种感觉在说，凭什么别人可以，你就不可以了。也希望者能够成为2024年的一些动力吧，毕竟，我的大学生涯比较失败的原因有很大的部分在于没有明确的目标和源源不断的动力。</p>
<br>

<br>

<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ul>
<li>上半年：<ul>
<li>顺利毕业</li>
<li>找到合心的工作</li>
</ul>
</li>
<li>下半年：<ul>
<li>迅速融入工作环境</li>
<li>争取找到新的目标</li>
</ul>
</li>
</ul>
<br>

<h3 id="眼下："><a href="#眼下：" class="headerlink" title="眼下："></a>眼下：</h3><p>眼前需要应付的事情有：实习，毕业设计，春招。</p>
<p>实习：</p>
<ul>
<li>现在已经进入收尾阶段了，目前需要用Lua把之前的东西再过一遍。然后可以多看一些测试的东西，多了解框架里面一些服务。</li>
</ul>
<p>毕设：</p>
<ul>
<li>估计还是得等实习结束才抽的出时间和精力来搞。</li>
</ul>
<p>春招准备：</p>
<ul>
<li>八股，项目，算法这三个过一遍就行了。</li>
<li>另外要加强一下自己的沟通和表达，以及多注意其他非技术的因素。</li>
</ul>
<br>

<br>

<p><img src="/2024/01/01/2024%E5%BC%80%E5%B9%B4%E5%A4%A7%E5%90%89/image-20240101192141010.png" alt="image-20240101192141010"></p>
<br>

<p>再之后的事情再看吧，希望2024的开头能顺顺利利，给后续铺垫基础。</p>
<br>

<br>
]]></content>
      <categories>
        <category>反思录</category>
      </categories>
      <tags>
        <tag>时间</tag>
      </tags>
  </entry>
  <entry>
    <title>3D RPG Demo回顾</title>
    <url>/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/</url>
    <content><![CDATA[<h1 id="3D-RPG-Demo回顾"><a href="#3D-RPG-Demo回顾" class="headerlink" title="3D RPG Demo回顾"></a>3D RPG Demo回顾</h1><h2 id="1-创建项目"><a href="#1-创建项目" class="headerlink" title="1.创建项目"></a>1.创建项目</h2><p>包含 <strong>项目创建，渲染管线设置，资源导入，资源材质渲染升级</strong></p>
<span id="more"></span>

<ul>
<li>新建3D项目</li>
<li>Window-&gt;PackageManager(Packages&#x2F; Unity Registry)中下载和导入 <strong>Universal RP</strong> 通用渲染管线</li>
<li>在Assets目录中创建 Pipeline Asseet<ul>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602103502206.png" alt="image-20230602103502206" style="zoom:67%;"></li>
</ul>
</li>
<li>导入PackageManager(Packages&#x2F; My Assets)中的资源包</li>
<li>升级资源项目的材质Material到URP<ul>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602104131868.png" alt="image-20230602104131868" style="zoom: 67%;"></li>
<li>Window-&gt;Rendering-&gt;Render Pipeline Converter</li>
</ul>
</li>
</ul>
<h2 id="2-场景搭建"><a href="#2-场景搭建" class="headerlink" title="2.场景搭建"></a>2.场景搭建</h2><p>包括 <strong>天空盒，阴影，光照，场景搭建</strong></p>
<ul>
<li><p>天空盒设置</p>
<ul>
<li>Window-&gt;renderinh-&gt;lighting-&gt;Environment</li>
</ul>
</li>
<li><p>阴影设置</p>
<ul>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602104716284.png" alt="image-20230602104716284"></li>
<li>在<strong>渲染管线配置文件</strong>中设置Shadow字段的参数</li>
</ul>
</li>
<li><p>光照设置</p>
<ul>
<li><p>Window-&gt;renderinh-&gt;lighting-&gt;Scene</p>
</li>
<li><p>通过设置 Lighting Settings 文件，配置光照参数</p>
</li>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602105125399.png" alt="image-20230602105125399" style="zoom:80%;">

<p>设置是否在生成场景时自动渲染光照</p>
</li>
<li><p>光源：在Environment中设置光源 Environment Lighting&#x2F;Source</p>
</li>
</ul>
</li>
<li><p>场景物体摆放</p>
<ul>
<li><p>shift+F 抓取顶点</p>
</li>
<li><p>ctrl+shift+F 快速设置transform</p>
</li>
<li><p>利用空Object分割 Hierarchy 中的各类型对象</p>
</li>
<li><p>Polybrush插件</p>
<ul>
<li><p>安装：</p>
<ul>
<li>Window-&gt;PackageManager(Packages&#x2F; Unity Registry)</li>
<li>导入样例Shader<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602105808946.png" alt="image-20230602105808946" style="zoom:80%;"></li>
</ul>
</li>
<li><p>使用：Tools菜单&#x2F;Polybrush Window <img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602110016714.png" alt="image-20230602110016714" style="zoom:80%;"></p>
</li>
<li><p>使用Polybrush自带的ShaderGraph来创建材质<br><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602110307916.png" alt="image-20230602110307916"></p>
<p>使用了该材质的物体可以使用Polybrush的颜色刷子</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>场景模型创建 —— ProBuilder</p>
<ul>
<li><p>安装：跟PolyBrush差不多</p>
<p><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602110912896.png" alt="image-20230602110912896"></p>
</li>
<li><p><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602111158996.png" alt="image-20230602111158996"></p>
</li>
<li><p>新版本的参数名称有不同<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602111249173.png" alt="image-20230602111249173"></p>
</li>
</ul>
</li>
<li><p>启用Preview Package：ProGrids</p>
<ul>
<li><p>Edit&#x2F;Project Setting</p>
</li>
<li><p><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602111434848.png" alt="image-20230602111434848"></p>
</li>
<li><p>Tools&#x2F;ProGrids</p>
</li>
</ul>
</li>
</ul>
<h2 id="3-地图导航烘焙"><a href="#3-地图导航烘焙" class="headerlink" title="3.地图导航烘焙"></a>3.地图导航烘焙</h2><h3 id="Navigation"><a href="#Navigation" class="headerlink" title="Navigation"></a>Navigation</h3><ul>
<li>开启：Window-&gt;AI-&gt;Navigation</li>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602112337244.png" alt="image-20230602112337244" style="zoom:80%;">
- Agent 表示的是 移动物
- 可以设置坡度、Agent模型体积等参数</li>
<li>设置物体为导航路面<ul>
<li>Static：Navigation static<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602112516103.png" alt="image-20230602112516103" style="zoom:80%;"></li>
<li>设置是否 Walkable<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602112459426.png" alt="image-20230602112459426" style="zoom:80%;"></li>
</ul>
</li>
<li>为人物添加导航组件<ul>
<li>Nav Mesh Agent：导航网格人物代理组件<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602113028687.png" alt="image-20230602113028687" style="zoom:80%;"><ul>
<li>相关参数：<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602113243270.png" alt="image-20230602113243270" style="zoom:80%;"></li>
</ul>
</li>
</ul>
</li>
<li>为障碍物添加导航组件<ul>
<li>Nav Mesh Obstacle</li>
<li>carve：可以实时切割导航路面<br><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602113445563.png" alt="image-20230602113445563"></li>
</ul>
</li>
<li>跳跃设置：没有用到</li>
</ul>
<h2 id="4-鼠标控制和人物移动控制"><a href="#4-鼠标控制和人物移动控制" class="headerlink" title="4.鼠标控制和人物移动控制"></a>4.鼠标控制和人物移动控制</h2><h3 id="MouseManager脚本"><a href="#MouseManager脚本" class="headerlink" title="MouseManager脚本"></a>MouseManager脚本</h3><ul>
<li><p>挂载在空物体 Mouse Manager</p>
</li>
<li><p>设置鼠标点击事件的处理</p>
<ul>
<li>UnityEngine.Event<ul>
<li>[System.Serializable] 序列化处理非MonoBehaviour子类，使得Unity界面中能够查看和设置该属性<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/../../../游戏开发/3D RPG/3D RPG 回顾/image-20230602115927683.png" alt="image-20230602115927683" style="zoom:80%;">
<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602120050100.png" alt="image-20230602120050100" style="zoom:80%;"></li>
<li>设置事件处理<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602120216706.png" alt="image-20230602120216706" style="zoom:80%;">
- 将事件设置为NavMeshAgent自带的Destination，表示导航位置。</li>
</ul>
</li>
</ul>
</li>
<li><p>获取鼠标点击位置：利用射线和collider发生碰撞</p>
<ul>
<li><p>API：</p>
<ul>
<li>Camera.ScreenPointToRay(Vector3 position) 从屏幕发射到position的射线</li>
<li>Physics.Raycast(Ray ray, out RaycastHit hitInfo) 检测射线的碰撞</li>
</ul>
</li>
<li><p>相关参数：</p>
<ul>
<li>RaycastHit hitInfo 作为Physics.Raycast的传出参数，保存有射线的碰撞信息</li>
</ul>
</li>
<li><p>代码：</p>
<ul>
<li><p>射线发射，判断射线碰撞物体，根据物体标签设置鼠标贴图</p>
<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602121109491.png" alt="image-20230602121109491" style="zoom:80%;">
</li>
<li><p>点击鼠标，触发事件处理 OnMouseClicked.Invoke(hitInfo.point) 就是 前面设置的 NavMeshAgent.Destination</p>
<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602121411322.png" alt="image-20230602121411322" style="zoom:80%;">
<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/../../../游戏开发/3D RPG/3D RPG 回顾/image-20230602121305501.png" alt="image-20230602121305501" style="zoom:80%;"></li>
</ul>
</li>
</ul>
</li>
<li><p>移动控制小细节：NavMeshAgent组件 的参数</p>
<ul>
<li>Stopping Distance 的大小设置可以跟攻击距离有关联</li>
<li>速度，角速度，加速度</li>
<li>自动制动 Auto Braking：提前减速，否则就是匀速到达并停止</li>
</ul>
</li>
<li><p>指针贴图设置</p>
<ul>
<li>导入PNG格式的鼠标贴图，并设置相关参数</li>
<li>脚本代码中，用 Texture2D 类型的变量保存贴图内容</li>
<li>控制代码<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602124442960.png" alt="image-20230602124442960" style="zoom: 67%;"></li>
<li>注意鼠标点击的原始位置是在 鼠标贴图的左上角顶点 ，通过 SetCursor() 的第二个参数来设置偏移使得鼠标点击位置位于贴图中央</li>
</ul>
</li>
</ul>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>写法</p>
 <img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602122814252.png" alt="image-20230602122814252" style="zoom: 80%;">
<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/../../../游戏开发/3D RPG/3D RPG 回顾/image-20230602122801102.png" alt="image-20230602122801102" style="zoom:67%;">

<p><strong>只需</strong>保证Mouse Manager的实例<strong>有且仅有一份</strong>就行了，不关心实例是否保持为最早创建的实例。</p>
<h3 id="PlayerController"><a href="#PlayerController" class="headerlink" title="PlayerController"></a>PlayerController</h3><ul>
<li>鼠标移动事件：弃用上面的 UnityEngine.Events&#x2F;EventVector3，改用 System&#x2F;event Action&lt;xxx&gt; ,xxx为参数<ul>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602123546809.png" alt="image-20230602123546809" style="zoom:80%;"></li>
<li>工作原理：<ul>
<li>创建事件 OnMouseClicked</li>
<li>将事件处理函数注册到该事件 OnMouseClicked +&#x3D; xxx;</li>
<li>事件发生时，调用 OnMouseClicked.Invoke(arg) 会唤起所有注册了的事件处理函数</li>
</ul>
</li>
<li>代码：<ul>
<li>事件处理以及注册（PlayerController中），涉及NavMeshAgent组件<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602123936237.png" alt="image-20230602123936237" style="zoom:80%;"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="5-相机设置"><a href="#5-相机设置" class="headerlink" title="5.相机设置"></a>5.相机设置</h2><h3 id="相机跟踪"><a href="#相机跟踪" class="headerlink" title="相机跟踪"></a>相机跟踪</h3><ul>
<li><p>安装 Cinemashine 工具</p>
</li>
<li><p>创建虚拟相机 virtual Cinemashine，设置 MainCamera的brain</p>
</li>
<li><p>设置虚拟相机的参数</p>
<ul>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602150704716.png" alt="image-20230602150704716"></li>
<li>Aim参数-do nothing</li>
<li>follow参数-playerObjcet<ul>
<li>可以给人物加一个lookAtPoint来作为相机跟随对象</li>
</ul>
</li>
<li>虚拟相机的位置可以通过Ctrl+Shift+F调整</li>
</ul>
</li>
</ul>
<h3 id="视图后处理"><a href="#视图后处理" class="headerlink" title="视图后处理"></a>视图后处理</h3><h4 id="设置迷雾"><a href="#设置迷雾" class="headerlink" title="设置迷雾"></a>设置迷雾</h4><ul>
<li>Window-&gt;Rendering-&gt;lighting-&gt;environment-&gt;fog<ul>
<li>能见度</li>
<li>颜色</li>
</ul>
</li>
<li>Scene内也要开启fog</li>
</ul>
<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602151605304.png" alt="image-20230602151605304" style="zoom:80%;">

<h4 id="Post-Processing"><a href="#Post-Processing" class="headerlink" title="Post Processing"></a>Post Processing</h4><ul>
<li><p>Main Camera中启动PostProcessing</p>
<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602151731551.png" alt="image-20230602151731551" style="zoom:80%;">
</li>
<li><p>创建 Global Volume 对象</p>
<ul>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602151427826.png" alt="image-20230602151427826" style="zoom:80%;"></li>
<li>创建 Profile ，添加并设置各种效果 Add Override<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602151630478.png" alt="image-20230602151630478" style="zoom:80%;">
- Bloom 泛光
- Color Adjustment 曝光、对比度、饱和等
- ToneMapping 色调
- Depth Of Field 景深
- Chromatic Aberration 畸变、鱼眼效果
- ...</li>
</ul>
</li>
</ul>
<h3 id="Cinemashine之-FreeLook-Camera"><a href="#Cinemashine之-FreeLook-Camera" class="headerlink" title="Cinemashine之 FreeLook Camera"></a>Cinemashine之 FreeLook Camera</h3><ul>
<li>设置 Follow 和 Look At</li>
<li>相机移动控制：<ul>
<li>Axis Control <ul>
<li>Input Axis Name：<br>可以在Project Setting-InputManager里查看<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230606161237318.png" alt="image-20230606161237318" style="zoom:80%;"></li>
</ul>
</li>
<li>Orbits 移动范围<ul>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230606161432763.png" alt="image-20230606161432763" style="zoom:80%;"></li>
<li>Binding Mode 设置移动跟随 <img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230606161858979.png" alt="image-20230606161858979" style="zoom:80%;"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="6-动画控制"><a href="#6-动画控制" class="headerlink" title="6.动画控制"></a>6.动画控制</h2><ul>
<li><p>添加 Animator 组件</p>
</li>
<li><p>创建 Animator Controller 动画控制器，并设置到Animator组件中</p>
<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602152928218.png" alt="image-20230602152928218" style="zoom:80%;">

<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602153026204.png" alt="image-20230602153026204" style="zoom:80%;">
</li>
<li><p>打开动画控制器</p>
<ul>
<li>在 Base Layer 创建 Blend Tree，控制基本的移动动作<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602153228523.png" alt="image-20230602153228523" style="zoom:67%;"></li>
<li>在 Blend Tree 中添加参数：Speed(float)</li>
<li>在 Blend Tree 中添加 Motion Field，并设置相应动画以及数值控制<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602153717925.png" alt="image-20230602153717925" style="zoom:80%;"></li>
</ul>
</li>
<li><p>代码：</p>
<ul>
<li>先获取 Animator 组件给anim变量</li>
<li>设置 Speed 的值<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602154108267.png" alt="image-20230602154108267" style="zoom:80%;">
- agent.velocity获取速度
- sqrMagnitude将Vector3的速度数值转为float</li>
</ul>
</li>
</ul>
<h2 id="7-利用ShaderGraph实现剔除遮挡的效果"><a href="#7-利用ShaderGraph实现剔除遮挡的效果" class="headerlink" title="7.利用ShaderGraph实现剔除遮挡的效果"></a>7.利用ShaderGraph实现剔除遮挡的效果</h2><p>ShaderGraph提供了可视化编辑渲染管线的功能</p>
<ul>
<li><p>创建 Unlit Shader Graph</p>
<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602155500819.png" alt="image-20230602155500819" style="zoom:80%;">
</li>
<li><p>基于该 Shader，创建一个 Material 供后续使用</p>
</li>
<li><p>打开 Shader Graph 窗口</p>
<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602162619599.png" alt="image-20230602162619599" style="zoom:80%;">
</li>
<li><p>菲涅尔效果</p>
<ul>
<li>创建 Fresnel Effect 的Node结点<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602162733920.png" alt="image-20230602162733920" style="zoom:80%;"></li>
<li>创建 Color 变量，并与菲尼尔效果节点相乘，输出给 Fragment 的 Base Color<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602163708773.png" alt="image-20230602163708773" style="zoom:80%;"></li>
</ul>
</li>
<li><p>噪点效果：</p>
<ul>
<li>创建 Dither node，并输出到 Fragment 的 Alpha</li>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602170950278.png" alt="image-20230602170950278" style="zoom:80%;"></li>
</ul>
</li>
<li><p>Alpha阈值设置</p>
<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602171106967.png" alt="image-20230602171106967" style="zoom:80%;"></li>
<li><p>在 Pipeline Setting 中应用该Shader</p>
<ul>
<li>打开的是另一个 URPRenderPipelineAsset 文件，带_Render后缀<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602171331027.png" alt="image-20230602171331027" style="zoom:80%;"></li>
<li>添加两个 Render Object<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602171358318.png" alt="image-20230602171358318" style="zoom:80%;">
- 一个是被遮挡的渲染模式
  - 首先取消勾选 Write Depth
    <img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602171804718.png" alt="image-20230602171804718" style="zoom: 67%;">
  - 将 Depth Test 设为 Greater
  - 设置 Layer Mask 为 Player图层
    <img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602171948351.png" alt="image-20230602171948351" style="zoom:67%;">
- 一个是不被遮挡的渲染模式
  设置 Layer Mask 为Player图层即可，其他的为默认</li>
</ul>
</li>
</ul>
<p>附加Tip：</p>
<p>如何使得场景中的树木不遮挡鼠标射线?</p>
<ul>
<li>方法一：将树木的 Layer 设为 Ignore Raycast</li>
<li>方法二：关闭树木的 Collider 组件</li>
</ul>
<h2 id="8-敌人"><a href="#8-敌人" class="headerlink" title="8.敌人"></a>8.敌人</h2><h3 id="属性和状态"><a href="#属性和状态" class="headerlink" title="属性和状态"></a>属性和状态</h3><ul>
<li><p>在脚本代码中自动添加组件 </p>
<ul>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230606153916500.png" alt="image-20230606153916500" style="zoom:80%;"></li>
</ul>
</li>
<li><p>状态机构思：</p>
<ul>
<li>站桩 or 巡逻</li>
<li>追击</li>
<li>死亡</li>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230606154305351.png" alt="image-20230606154305351" style="zoom:80%;"></li>
</ul>
</li>
<li><p>其他细节：</p>
<ul>
<li>Layer 增加一层Enemy，用于在PipelineSetting里的Layer Mask加上实现遮挡剔除</li>
<li>Tag 也加上Enemy，用来设置鼠标贴图</li>
</ul>
</li>
</ul>
<h4 id="追击状态"><a href="#追击状态" class="headerlink" title="追击状态"></a>追击状态</h4><p><strong>范围内发现Player</strong></p>
<ul>
<li>视野变量，表示视野范围</li>
<li>Physics API<ul>
<li>OverlapSphere(position, Radius)  返回范围内的一组collider<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230606162604976.png" alt="image-20230606162604976" style="zoom:80%;"></li>
</ul>
</li>
</ul>
<p><strong>敌人动画控制</strong></p>
<p>思路</p>
<ul>
<li>追击</li>
<li>脱战，回到站桩或巡逻</li>
<li>攻击范围内攻击</li>
</ul>
<p>动画控制器Layer：</p>
<ul>
<li>基本移动<ul>
<li>idolNormal作为初始动画</li>
<li>WalkFWD行走动画，并用bool变量做条件</li>
<li>RunFWD跑动动画</li>
</ul>
</li>
<li>攻击<ul>
<li>权值设置，覆盖&#x2F;叠加前面Layer的动画<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230606163720456.png" alt="image-20230606163720456" style="zoom:80%;"></li>
<li>如何从其他Layer的动画状态切换过来 —— 创建空state，代表之前的任何一个Layer，并连接到Entry<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230606164123342.png" alt="image-20230606164123342" style="zoom:80%;"></li>
<li>战斗状态动画控制，两个bool<ul>
<li>追击 Chase —— 其他动画&lt; - &gt;攻击动画</li>
<li>跟踪 Follow —— 攻击动画&lt; - &gt;跑动动画</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>代码</p>
<ul>
<li>更新动画变量<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230606164427284.png" alt="image-20230606164427284" style="zoom:80%;"></li>
<li>更新脚本变量<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230606164742822.png" alt="image-20230606164742822" style="zoom:80%;"></li>
</ul>
<h4 id="巡逻状态"><a href="#巡逻状态" class="headerlink" title="巡逻状态"></a>巡逻状态</h4><p><strong>随即巡逻点</strong></p>
<ul>
<li>辅助线API <img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230606165110165.png" alt="image-20230606165110165" style="zoom:80%;"></li>
<li>随机获取范围内的某个点<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230606165758352.png" alt="image-20230606165758352" style="zoom:80%;">
- 获取当前位置范围内的随机点，也可更改为获取固定范围内的随机点
- 可能出现的问题是获取到的点位置不可达</li>
<li>问题解决：<ul>
<li>导航API：<br>SamplePosition() 在指定范围内，找到导航网格上最近的指定Area的点<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230606170502168.png" alt="image-20230606170502168" style="zoom:80%;">
<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/../../../游戏开发/3D RPG/3D RPG 回顾/image-20230606171016841.png" alt="image-20230606171016841" style="zoom:80%;">
- NavMesh.AllAreas：
  <img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230606170616067.png" alt="image-20230606170616067" style="zoom:80%;"></li>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230606170308989.png" alt="image-20230606170308989" style="zoom:80%;"></li>
</ul>
</li>
</ul>
<p><strong>状态控制代码</strong></p>
<ul>
<li>动画变量设置，移动速度设置</li>
<li>若到达目标位置内，获取新的目标点</li>
<li>若未到达目标位置，则继续移动</li>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230606165433686.png" alt="image-20230606165433686" style="zoom:80%;"></li>
</ul>
<p><strong>在巡逻点停留</strong></p>
<ul>
<li>LookAtTime 和 RemainLookAtTime 变量</li>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230606171222823.png" alt="image-20230606171222823" style="zoom:80%;"></li>
<li>在获取随机点后更新 RemainLookAtTime</li>
</ul>
<p><strong>脱战后回到巡逻状态</strong></p>
 <img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230606171443224.png" alt="image-20230606171443224" style="zoom:80%;">





<h4 id="守卫状态"><a href="#守卫状态" class="headerlink" title="守卫状态"></a>守卫状态</h4><ul>
<li>定点站桩</li>
<li>若不在站桩点，则走回站桩点站桩</li>
<li>走动、站桩的动画控制（bool动画变量）<ul>
<li>回到站桩点时，利用插值计算，平滑地使对象转向原来的方向</li>
</ul>
</li>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608105415137.png" alt="image-20230608105415137" style="zoom:80%;"></li>
</ul>
<h4 id="死亡状态"><a href="#死亡状态" class="headerlink" title="死亡状态"></a>死亡状态</h4><ul>
<li><p><strong>动画管理</strong></p>
<ul>
<li>创建新的Layer，Death，并设置覆盖指数为1</li>
<li>创建一个空的动画State，表示上一个动画状态<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608105557358.png" alt="image-20230608105557358"></li>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608105819149.png" alt="image-20230608105819149" style="zoom: 67%;">
- 受攻击：Trigger变量，Hit，被攻击（暴击）时触发
  - 在动画事件里面判断和设置 
    <img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608110608686.png" alt="image-20230608110608686" style="zoom:80%;">
- 死亡：bool变量。Death，血量为0
  - 取消勾选，取消自循环播放
    <img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608105857413.png" alt="image-20230608105857413" style="zoom:80%;"></li>
</ul>
</li>
<li><p>主角的受伤和死亡的动画管理类似</p>
</li>
<li><p><strong>脚本管理</strong></p>
<ul>
<li>用一个bool表示是否死亡，并且同步States状态<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608110206112.png" alt="image-20230608110206112" style="zoom:80%;"></li>
<li>状态机状态处理<ul>
<li>关闭导航Agent，Collider等组件</li>
<li>延迟销毁 gameObject 对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="主角攻击（移动与动画）"><a href="#主角攻击（移动与动画）" class="headerlink" title="主角攻击（移动与动画）"></a>主角攻击（移动与动画）</h3><ul>
<li><p>类似OnMouseClicked事件，在Mouse Manager中增加一个OnEnemyClicked事件</p>
<ul>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230606155002407.png" alt="image-20230606155002407" style="zoom:80%;"></li>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230606154924557.png" alt="image-20230606154924557" style="zoom:80%;"></li>
</ul>
</li>
<li><p>还要在PlayerController中注册这个事件的回调函数EvntAttack</p>
<ul>
<li>利用 协程 + while循环 控制移动 MoveToAttcakTarge<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230606155634741.png" alt="image-20230606155634741" style="zoom:80%;"></li>
<li>还要考虑到 <strong>攻击CD，攻击范围，暴击</strong> 等</li>
<li>可以在普通的移动中加上一步终止协程，否则攻击触发之后无法改变状态直至执行完这次攻击。</li>
</ul>
</li>
<li><p>动画</p>
<ul>
<li>直接拖动画文件到动画编辑窗口内，然后添加动画关联变换，设置变换条件<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230606155918381.png" alt="image-20230606155918381" style="zoom:80%;"></li>
</ul>
</li>
</ul>
<h3 id="敌人攻击"><a href="#敌人攻击" class="headerlink" title="敌人攻击"></a>敌人攻击</h3><ul>
<li>攻击动作处于状态机的 Chase 状态</li>
<li>根据相对位置和攻击距离，管理对象的动作状态（isFollow, isStopped)</li>
<li>攻击CD控制</li>
<li>暴击控制，bool动画变量</li>
<li>动画控制<ul>
<li>在攻击动画和idol动画之间切换</li>
<li>使用 Trigger 动画变量</li>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608101757617.png" alt="image-20230608101757617" style="zoom:80%;"></li>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608101741123.png" alt="image-20230608101741123" style="zoom:80%;"></li>
</ul>
</li>
</ul>
<h2 id="9-人物属性和数值"><a href="#9-人物属性和数值" class="headerlink" title="9.人物属性和数值"></a>9.人物属性和数值</h2><p>使用 <strong>ScriptableObject</strong> 脚本帮助生成 Asset 文件，可以制作数值模板、设置模板</p>
<p>比如<br><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230607230044721.png" alt="image-20230607230044721" style="zoom:80%;"></p>
<h3 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h3><p><strong>ScriptableObject脚本</strong></p>
<ul>
<li>脚本继承自<ul>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230607230259807.png" alt="image-20230607230259807"></li>
</ul>
</li>
<li>在create菜单中添加选项<ul>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230607230344849.png" alt="image-20230607230344849"></li>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230607230426920.png" alt="image-20230607230426920" style="zoom:80%;"></li>
</ul>
</li>
<li>为Asset文件设置字段名称和属性变量<ul>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230607230629919.png" alt="image-20230607230629919" style="zoom:80%;"></li>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230607230604591.png" alt="image-20230607230604591" style="zoom:80%;"></li>
</ul>
</li>
</ul>
<p><strong>Mono Behaviour脚本</strong></p>
<ul>
<li>管理 Asset 中的数值</li>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230607230808777.png" alt="image-20230607230808777" style="zoom:80%;"></li>
<li>将 Asset 中的数值读取到 Stats 脚本文件中。简化后续的数值访问（不用 Stats.Data.xxx ）。<ul>
<li>利用C# properties 属性 的语法</li>
<li>例如：MaxHealth<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230607231157397.png" alt="image-20230607231157397" style="zoom:80%;"></li>
</ul>
</li>
<li>#region xxx，#endregion 管理代码块</li>
</ul>
<h3 id="攻击属性"><a href="#攻击属性" class="headerlink" title="攻击属性"></a>攻击属性</h3><ul>
<li>数值模板：同样先创建Scriptable object脚本文件管理所创建的Asset文件的数值内容</li>
<li>数值控制：再使用Mono脚本作为组件管理数值（在脚本内获取Asset数值文件资源）</li>
</ul>
<h3 id="伤害数值计算"><a href="#伤害数值计算" class="headerlink" title="伤害数值计算"></a>伤害数值计算</h3><ul>
<li>在数值控制脚本内声明和定义攻击伤害计算方法</li>
<li>伤害处理方法以两个数值控制脚本对象作参数（attacker，defender）</li>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608103721171.png" alt="image-20230608103721171" style="zoom:80%;"></li>
</ul>
<h3 id="伤害生效处理（动画事件）"><a href="#伤害生效处理（动画事件）" class="headerlink" title="伤害生效处理（动画事件）"></a>伤害生效处理（动画事件）</h3><p>简单的处理：采用动画事件，而非使用物理方法判断攻击是否生效。</p>
<ul>
<li>Animation窗口<ul>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608103949432.png" alt="image-20230608103949432" style="zoom:80%;"></li>
</ul>
</li>
<li>攻击事件函数&#x2F;方法<ul>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608104342103.png" alt="image-20230608104342103" style="zoom:80%;"></li>
</ul>
</li>
<li>关键帧+动画事件<ul>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608104431072.png" alt="image-20230608104431072" style="zoom:80%;"></li>
</ul>
</li>
</ul>
<h2 id="10-泛型单例模式-与-Game-Manager"><a href="#10-泛型单例模式-与-Game-Manager" class="headerlink" title="10.泛型单例模式 与 Game Manager"></a>10.泛型单例模式 与 Game Manager</h2><h3 id="GameManager"><a href="#GameManager" class="headerlink" title="GameManager"></a>GameManager</h3><ul>
<li><p>在主角死亡时，可以用Game Manager广播主角死亡的消息</p>
</li>
<li><p>特殊图标的Script文件，用 空object 挂载</p>
<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608111154847.png" alt="image-20230608111154847" style="zoom:80%;"></li>
<li><p>Game Manager存有PlayerStats数据脚本，游戏中其他的对象要访问Player的数据时，通过Game Manager访问</p>
<ul>
<li>Game Manager 如何获取Player的数据脚本？<ul>
<li>采用 观察者 模式，反向注册，当Player生成的时候，向Game Manager注册</li>
<li>Game Manager提供注册接口<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608111649709.png" alt="image-20230608111649709" style="zoom:80%;"></li>
<li>Player注册<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608113646462.png" alt="image-20230608113646462" style="zoom:80%;"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="泛型单例模式"><a href="#泛型单例模式" class="headerlink" title="泛型单例模式"></a>泛型单例模式</h3><ul>
<li>语法<ul>
<li>泛型单例脚本<br><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608111837904.png" alt="image-20230608111837904"></li>
<li>泛型&lt;T&gt;，并且约束T为继承自 Singleton&lt;T&gt; 的类</li>
<li>不约束T能放任何类，比如Singleton&lt;Animator&gt;，约束后只能放继承自Singleton&lt;T&gt;的类，比如Singleton&lt;MouseManager&gt;</li>
<li>具体类型单例脚本<br><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608113122412.png" alt="image-20230608113122412"></li>
</ul>
</li>
<li>生成实例（严格上说是饿汉）<ul>
<li>场景生成时，Awake创建了新的Manager<ul>
<li>若原来的实例没被销毁，则销毁新生成的泛型单例对象</li>
<li>若原来的实例被销毁了，更新实例为当前泛型单例对象</li>
</ul>
</li>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608112618150.png" alt="image-20230608112618150" style="zoom:80%;"></li>
</ul>
</li>
<li>获取实例（私有变量，公开属性）<ul>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608112252141.png" alt="image-20230608112252141" style="zoom:80%;"></li>
</ul>
</li>
<li>析构<ul>
<li>当实例对象就是当前单例对象时，销毁单例对象的同时也将实例对象销毁。<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608112953207.png" alt="image-20230608112953207" style="zoom:80%;"></li>
</ul>
</li>
<li>具体类型脚本继承单例类型脚本后<ul>
<li>重写Awake，DontDestroyOnLoad(this)使得切换场景时不析构该脚本对象。<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608113523815.png" alt="image-20230608113523815" style="zoom:80%;"></li>
</ul>
</li>
</ul>
<h2 id="11-接口-与-观察者模式：订阅和广播"><a href="#11-接口-与-观察者模式：订阅和广播" class="headerlink" title="11.接口 与 观察者模式：订阅和广播"></a>11.接口 与 观察者模式：订阅和广播</h2><p>主要广播的是Player死亡的消息</p>
<h3 id="EndGameObserver-接口"><a href="#EndGameObserver-接口" class="headerlink" title="EndGameObserver 接口"></a>EndGameObserver 接口</h3><p>如名称所示，该接口意为 游戏结束的观测者 ，其接口方法则是 游戏结束时的处理方法 。</p>
<ul>
<li>接口的脚本文件以I开头<ul>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608121427054.png" alt="image-20230608121427054" style="zoom:80%;"></li>
</ul>
</li>
<li>接口声明<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608121512905.png" alt="image-20230608121512905" style="zoom:80%;"></li>
<li>接口方法，使用（继承）了接口的脚本都要实现接口方法<ul>
<li>EndNotify</li>
</ul>
</li>
<li>继承接口和实现接口方法<ul>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608121727677.png" alt="image-20230608121727677" style="zoom:80%;"></li>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608121813288.png" alt="image-20230608121813288" style="zoom:80%;"></li>
</ul>
</li>
</ul>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>Game Manager 记录所有实现了接口的对象，并在事件发生时广播消息给这些对象。</p>
<p>游戏对象作为观察者，并在Game Manager中注册，以在适当的时候接收广播消息。</p>
<ul>
<li><p>Game Manager</p>
<ul>
<li>提供注册函数和注销函数<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608122127201.png" alt="image-20230608122127201" style="zoom:80%;"></li>
<li>广播消息<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608122509030.png" alt="image-20230608122509030" style="zoom:80%;"></li>
</ul>
</li>
<li><p>在游戏对象的Controller脚本中进行注册和注销（启用和关闭时）</p>
<ul>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608122257093.png" alt="image-20230608122257093" style="zoom:80%;"></li>
</ul>
</li>
<li><p>在Player死亡时，由PlayerController启动Game Manager的广播</p>
<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608122732454.png" alt="image-20230608122732454" style="zoom:80%;"></li>
</ul>
<h3 id="接口方法的具体实现"><a href="#接口方法的具体实现" class="headerlink" title="接口方法的具体实现"></a>接口方法的具体实现</h3><ul>
<li>胜利动画<ul>
<li>单独建一个Layer，启用覆盖，并用一个bool值控制，可以从任何动画状态切换进入<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608123619992.png" alt="image-20230608123619992" style="zoom:80%;"></li>
<li>并且取消勾选 Cant Transition To Self</li>
</ul>
</li>
<li>停止其他动画状态</li>
<li>攻击目标置空</li>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608123512271.png" alt="image-20230608123512271" style="zoom:80%;"></li>
</ul>
<h2 id="12-更多敌人"><a href="#12-更多敌人" class="headerlink" title="12.更多敌人"></a>12.更多敌人</h2><h3 id="独享数据文件"><a href="#独享数据文件" class="headerlink" title="独享数据文件"></a>独享数据文件</h3><ul>
<li>将 源Scriptable Object文件 作为模板，初始化一份独有的Scriptable Object文件来实际管理数值。<ul>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608124419519.png" alt="image-20230608124419519" style="zoom:80%;"></li>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608124607913.png" alt="image-20230608124607913" style="zoom:80%;"></li>
</ul>
</li>
</ul>
<h3 id="制作已有类型敌人（史莱姆和乌龟）"><a href="#制作已有类型敌人（史莱姆和乌龟）" class="headerlink" title="制作已有类型敌人（史莱姆和乌龟）"></a>制作已有类型敌人（史莱姆和乌龟）</h3><ul>
<li>相同的Controller脚本，附带相同的组件</li>
<li>自建Asset数据模板文件，并填写基础数值</li>
<li>动画：制作Animator Controller，可以用 Animator Override Controller 快速利用原有的其他Animator Controller。<ul>
<li>只能替换动画<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608134433661.png" alt="image-20230608134433661" style="zoom:80%;"></li>
<li>对有Override关系的动画控制器进行修改的话，会相互影响</li>
</ul>
</li>
<li>保存prefab</li>
</ul>
<h3 id="制作新类型敌人（兽人和石头人）"><a href="#制作新类型敌人（兽人和石头人）" class="headerlink" title="制作新类型敌人（兽人和石头人）"></a>制作新类型敌人（兽人和石头人）</h3><h4 id="兽人"><a href="#兽人" class="headerlink" title="兽人"></a>兽人</h4><ul>
<li>动画：新建Animator Controller，可以通过复制得到后进行修改，不会影响原来的动画控制器。<ul>
<li>更换动画文件</li>
<li>暴击攻击换成技能攻击，修改动画变量和切换条件</li>
</ul>
</li>
<li>脚本：主要多实现了技能攻击<ul>
<li>继承通用Controller</li>
<li>实现 KickOff 动画事件（击退效果）<ul>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608140925727.png" alt="image-20230608140925727" style="zoom:80%;"></li>
<li>采用NavMeshAgent的velocity方法施加力<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608164531038.png" alt="image-20230608164531038" style="zoom:80%;"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="其他内容"><a href="#其他内容" class="headerlink" title="其他内容"></a>其他内容</h4><h5 id="动画状态机"><a href="#动画状态机" class="headerlink" title="动画状态机"></a>动画状态机</h5><p><strong>角色被攻击后，设置眩晕或受击时无法移动</strong></p>
<ul>
<li>为动画状态添加Behaviour脚本<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608165206326.png" alt="image-20230608165206326" style="zoom:80%;"></li>
<li>Unity内置的状态机脚本<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608165455352.png" alt="image-20230608165455352" style="zoom:80%;">
- 分别设定 进入动画、动画执行、退出动画...时的执行内容
- 注意NavMeshAgent组件在角色死亡时会先销毁，而动画执行未结束，导致这里报错。可以将死亡时的处理代码改为将NavMeshAgent组件的Radius置0，达到死亡后对导航不挡路的效果。</li>
</ul>
<h5 id="拓展方法"><a href="#拓展方法" class="headerlink" title="拓展方法"></a>拓展方法</h5><p>给一个类加一个自己写的方法，这里是给 Transform 类添加内容</p>
<ul>
<li>语法要求：public static 类，无继承<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608185319267.png" alt="image-20230608185319267" style="zoom:80%;"></li>
<li>添加的是攻击扇形范围的角度，以及判断攻击目标是否处于角度范围内的方法<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608191039779.png" alt="image-20230608191039779" style="zoom:80%;">
- this Transform xxx 指定要添加内容的类
- Transform target 是方法的参数</li>
<li>使用：直接用transform组件调用自定义方法<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608191241671.png" alt="image-20230608191241671" style="zoom:80%;"></li>
</ul>
<h4 id="石头人"><a href="#石头人" class="headerlink" title="石头人"></a>石头人</h4><ul>
<li>动画：override 兽人的动画控制器</li>
<li>脚本：继承同样Controller</li>
<li>普通攻击带击退 ，远程攻击扔石头+击退</li>
<li>设计数值（基本数值，攻击距离，冷却，力度 …)</li>
</ul>
<p><strong>扔石头</strong></p>
<ul>
<li>对于石头<ul>
<li>为石头prefab添加控制脚本、刚体、碰撞体等组件</li>
<li>石头在生成时就飞向攻击目标（抛射），生成位置为举手抛出时的position（利用手部模型子对象的Transform）</li>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608203209013.png" alt="image-20230608203209013"></li>
</ul>
</li>
<li>对于石头人<ul>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608202826309.png" alt="image-20230608202826309" style="zoom:80%;"></li>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608203244331.png" alt="image-20230608203244331" style="zoom:80%;"></li>
</ul>
</li>
</ul>
<p><strong>玩家击回石头</strong></p>
<ul>
<li><p>石头的三个状态</p>
<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608213629690.png" alt="image-20230608213629690" style="zoom:80%;">
</li>
<li><p>Hit Player</p>
<ul>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608214016997.png" alt="image-20230608214016997" style="zoom:80%;"></li>
<li>击退 + 造成伤害</li>
<li>切换状态为 Hit Nothing</li>
<li>在数据控制脚本中重载伤害计算方法<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608214217045.png" alt="image-20230608214217045" style="zoom:80%;"></li>
</ul>
</li>
<li><p>Hit Enemy</p>
<ul>
<li>伤害造成（对石头人），并销毁自身<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608214824954.png" alt="image-20230608214824954" style="zoom:80%;"></li>
<li>玩家击打石头<ul>
<li>设置石头的标签为 attackable</li>
<li>Mouse Manager添加对该标签物体的鼠标指针管理（OnEnemyClicked信号触发）<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608215320548.png" alt="image-20230608215320548" style="zoom:80%;"></li>
<li>在Player Controller里对 Hit动画事件 做文章，若攻击对象是石头，则造成击飞效果<br><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608220000170.png" alt="image-20230608220000170"><ul>
<li>要在打击后，设置石头的初速度</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Hit Nothing</p>
<ul>
<li><p>一种是击中玩家后，切换为 Hit Nothing 状态</p>
</li>
<li><p>另一种情况是，未击中玩家，当速度下降接近0时，切换为 Hit Nothing 状态</p>
<ul>
<li>在 FixedUpdate 中读写物理相关的数据</li>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608215906297.png" alt="image-20230608215906297" style="zoom:80%;"></li>
</ul>
</li>
</ul>
</li>
<li><p>另外要给小狗加上刚体组件，防止跟石头穿模。并且要勾选 is Kinematic 。</p>
</li>
</ul>
<p><strong>粒子效果：石头碎裂</strong></p>
<ul>
<li><p>在Hierarchy中创建碎石效果</p>
<ul>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608220428244.png" alt="image-20230608220428244" style="zoom:80%;"></li>
</ul>
</li>
<li><p>设置各种各样的参数</p>
<ul>
<li>Gravity Modifier 重力下落效果</li>
<li>Collision 与其他物体产生碰撞<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608220903263.png" alt="image-20230608220903263" style="zoom:80%;"></li>
<li>Start Lifetime 生命周期</li>
<li>Start Size 设为随机尺寸<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608221203967.png" alt="image-20230608221203967" style="zoom: 67%;"></li>
<li>Renderer<ul>
<li>Render mode 改为 Mesh</li>
<li>Mesh文件采用石头的Mesh</li>
<li>设置材质</li>
</ul>
</li>
<li>角度变化<ul>
<li>Rotation By Speed</li>
<li>Rotation over Lifetime</li>
</ul>
</li>
</ul>
</li>
<li><p>保存为prefab</p>
</li>
<li><p>脚本获取效果并触发效果</p>
<ul>
<li>用gameObject变量获取</li>
<li>在石头的HitEnemy状态处理代码中生成效果<br><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608221624698.png" alt="image-20230608221624698"></li>
</ul>
</li>
</ul>
<h2 id="13-简单UI"><a href="#13-简单UI" class="headerlink" title="13.简单UI"></a>13.简单UI</h2><h3 id="血条"><a href="#血条" class="headerlink" title="血条"></a>血条</h3><ul>
<li>创建画布 Canvas<ul>
<li>Render Mode 采用 World Space</li>
<li>Event Camera 设为 Main Camera</li>
</ul>
</li>
<li>创建画布的子物体：<ul>
<li>创建 Image 来作为血条</li>
<li>两条长方 square ，一红一绿，通过覆盖和改变长度来表现血条</li>
</ul>
</li>
<li>创建脚本控制UI的生成 : HealthBarUI.cs 每个有血条的角色都要挂载<ul>
<li>在每一个角色头上生成、展示血条</li>
<li>提前给每个角色prefab加一个空的子物体表示血条位置，或者也可以自己在代码中计算位置</li>
<li>脚本需要的数据成员<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608235352306.png" alt="image-20230608235352306" style="zoom:80%;">
- 相机Transform组件用于使血条平面始终平行于相机画面</li>
<li>更新血量事件。参数为当前血量和最大血量。<br><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608235059330.png" alt="image-20230608235059330"><ul>
<li>在每次攻击发生时进行触发事件（TakeDamage伤害计算函数，在数据控制脚本中）<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608235233226.png" alt="image-20230608235233226" style="zoom:80%;"></li>
<li>注册事件处理函数<ul>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230609000013087.png" alt="image-20230609000013087" style="zoom: 80%;"></li>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230609000127215.png" alt="image-20230609000127215"></li>
</ul>
</li>
</ul>
</li>
<li>血条位置更新<ul>
<li>LateUpdate的执行时机实在本帧完成后。也可用于相机跟随之类的功能。</li>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230609000412130.png" alt="image-20230609000412130" style="zoom:80%;"></li>
</ul>
</li>
<li>若血条设置不是永久显示，需要更新显示计时<ul>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230609000711625.png" alt="image-20230609000711625" style="zoom:80%;"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="经验值与升级"><a href="#经验值与升级" class="headerlink" title="经验值与升级"></a>经验值与升级</h3><h4 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h4><p><strong>玩家数据脚本</strong></p>
<ul>
<li><p>在玩家的 Scriptable Object 文件中</p>
<ul>
<li>添加跟等级有关的数据字段<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230610011457529.png" alt="image-20230610011457529" style="zoom:80%;"></li>
<li>添加经验更新方法<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230610011612004.png" alt="image-20230610011612004" style="zoom:80%;"></li>
<li>升级处理方法<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230610011829408.png" alt="image-20230610011829408" style="zoom:80%;"></li>
</ul>
</li>
<li><p>在外部的攻击活动中调用经验更新（击杀时）</p>
<ul>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230610012111972.png" alt="image-20230610012111972" style="zoom:80%;"></li>
</ul>
</li>
</ul>
<p><strong>UI控制脚本</strong></p>
<ul>
<li>获取UI物件<ul>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230610015511118.png" alt="image-20230610015511118" style="zoom:80%;"></li>
</ul>
</li>
<li>更新UI物件：生命值、经验值、文字<ul>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230610015632242.png" alt="image-20230610015632242"></li>
<li>不建议在Update中更新<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230610015742815.png" alt="image-20230610015742815" style="zoom:80%;"></li>
</ul>
</li>
</ul>
<h4 id="UI处理"><a href="#UI处理" class="headerlink" title="UI处理"></a>UI处理</h4><p>创建画布 Canvas</p>
<ul>
<li>Render Mode: Screen Space-Overlay </li>
<li>Canvas Scaler 的 Scale Mode 设为 <img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/../../../游戏开发/3D RPG/3D RPG 回顾/image-20230610015100042.png" alt="image-20230610015100042" style="zoom: 67%;">
<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230610015131065.png" alt="image-20230610015131065" style="zoom:67%;"></li>
</ul>
<p><strong>玩家血条</strong></p>
<ul>
<li>在画布下创建 Image<ul>
<li>调整布局位置，按住 alt+shift 选择左上角<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230610014416713.png" alt="image-20230610014416713" style="zoom:80%;"></li>
<li>调整大小，具体位置，颜色</li>
<li>还需要一个子 Image 覆盖实现血条滑动效果<ul>
<li>应该是绿色，然后调整Image Type相关参数<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230610014624384.png" alt="image-20230610014624384" style="zoom:80%;"></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>经验条</strong></p>
<ul>
<li>复制上面的血条，调整一下外观即可</li>
</ul>
<p><strong>等级</strong></p>
<ul>
<li>创建一个 Text 然后同上调整位置和外观</li>
</ul>
<h2 id="14-场景切换"><a href="#14-场景切换" class="headerlink" title="14.场景切换"></a>14.场景切换</h2><h3 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a>传送门</h3><ul>
<li>创建 Lit Shader Graph<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230610123834553.png" alt="image-20230610123834553" style="zoom:80%;"></li>
<li>打开 shader graph <ul>
<li>设定显示模式<br><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230610123948606.png" alt="image-20230610123948606"></li>
<li>创建基本节点：Twirl<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230610124147731.png" alt="image-20230610124147731" style="zoom: 67%;"></li>
<li>与 Voronol 叠加<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230610124217404.png" alt="image-20230610124217404" style="zoom:80%;"></li>
<li>将时间和一个float变量相乘，作为offset控制旋转速度，并用另一个float设置强度strength<br><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230610124503197.png" alt="image-20230610124503197"><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/../../../游戏开发/3D RPG/3D RPG 回顾/image-20230610124605348.png" alt="image-20230610124605348" style="zoom: 67%;"></li>
<li>设置2D纹理，建立 Sample Texture 2D节点，并用一个 Texture 2D 变量指定纹理图片<br><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230610124906224.png" alt="image-20230610124906224"></li>
<li>加上颜色，输出到片段着色器的 Emission<br><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230610124956317.png" alt="image-20230610124956317"></li>
<li>再加上透明通道<br><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230610125033851.png" alt="image-20230610125033851"><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/../../../游戏开发/3D RPG/3D RPG 回顾/image-20230610125112548.png" alt="image-20230610125112548" style="zoom:80%;"></li>
<li>双向显示，在Graph Inspector中勾选Two Sided</li>
</ul>
</li>
<li>利用做好的 Shader 创建 Material<br><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230610125227192.png" alt="image-20230610125227192"></li>
<li>创建一个 Quad 物体并把材质附上，在Mesh Renderer关闭阴影，勾选 Always Refresh 查看效果<br><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230610125333402.png" alt="image-20230610125333402"></li>
<li>Shader中的颜色节点勾选HDR，可以调整效果更亮&#x2F;更暗</li>
<li>使用Power节点可以再增强效果<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230610125649902.png" alt="image-20230610125649902" style="zoom: 67%;"></li>
</ul>
<p><strong>传送</strong></p>
<p>每个传送门表示了 自身地点 和 传送目的地 。</p>
<ul>
<li><p>给每个传送门创建一个空子物体，作为其传送点</p>
<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230610125932333.png" alt="image-20230610125932333" style="zoom:80%;">
<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/../../../游戏开发/3D RPG/3D RPG 回顾/image-20230610125853188.png" alt="image-20230610125853188" style="zoom:80%;">
</li>
<li><p>两个脚本管理传送</p>
<ul>
<li>TransitionPoint.cs 管理传送门标签，作为传送门的组件<br><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230610130600330.png" alt="image-20230610130600330"><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230610130615401.png" alt="image-20230610130615401" style="zoom:80%;"></li>
<li>TransitionDestination.cs 管理传送目的地<br><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230610130539683.png" alt="image-20230610130539683"></li>
</ul>
</li>
<li><p>传送门 碰撞检测触发传送</p>
<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230610130857682.png" alt="image-20230610130857682" style="zoom:80%;">
![image-20230610130813083](3D-RPG-Demo回顾/image-20230610130813083.png)

<p>在Update里检测按键传送</p>
</li>
</ul>
<h3 id="传送"><a href="#传送" class="headerlink" title="传送"></a>传送</h3><p>用脚本控制场景切换：SceneController.cs</p>
<p>利用协程异步加载场景和切换角色位置</p>
<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230626201210879.png" alt="image-20230626201210879" style="zoom:80%;">

<h4 id="同场景传送"><a href="#同场景传送" class="headerlink" title="同场景传送"></a>同场景传送</h4><p>传送过程：  </p>
<ul>
<li>获取游戏主角的object，及其agent</li>
<li>全局查找到目标传送点对象</li>
<li>停用Player对象的Agent，切换Player对象的位置角度到传送点，再启用Agent</li>
</ul>
<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230626191336726.png" alt="image-20230626191336726" style="zoom:80%;">





<h4 id="跨场景传送"><a href="#跨场景传送" class="headerlink" title="跨场景传送"></a>跨场景传送</h4><p>传送过程：  </p>
<ul>
<li>异步加载场景</li>
<li>重新初始化主角的prefab，位于传送门位置</li>
<li>停用Player对象的Agent，切换Player对象的位置角度到传送点，再启用Agent</li>
</ul>
<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230626201615795.png" alt="image-20230626201615795" style="zoom:80%;">

<ul>
<li>对各种Manager，最好启用DontDestroyOnLoad<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230626201816138.png" alt="image-20230626201816138" style="zoom:80%;"></li>
</ul>
<h2 id="15-数据保存"><a href="#15-数据保存" class="headerlink" title="15.数据保存"></a>15.数据保存</h2><h2 id="16-主菜单"><a href="#16-主菜单" class="headerlink" title="16.主菜单"></a>16.主菜单</h2><h3 id="主菜单"><a href="#主菜单" class="headerlink" title="主菜单"></a>主菜单</h3><h3 id="场景切换淡入淡出"><a href="#场景切换淡入淡出" class="headerlink" title="场景切换淡入淡出"></a>场景切换淡入淡出</h3><h2 id="17-打包程序"><a href="#17-打包程序" class="headerlink" title="17.打包程序"></a>17.打包程序</h2>]]></content>
      <categories>
        <category>游戏开发</category>
        <category>客户端</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP之协议机制</title>
    <url>/2023/05/11/TCP%E4%B9%8B%E5%8D%8F%E8%AE%AE%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="TCP之协议机制"><a href="#TCP之协议机制" class="headerlink" title="TCP之协议机制"></a>TCP之协议机制</h1><hr>
<p>主要讨论TCP实现可靠的信息传输的几种机制：<strong>重传机制</strong>、<strong>流量控制（滑动窗口）</strong>、<strong>拥塞控制</strong></p>
<p>此外还有<strong>粘包</strong>问题<strong>拆包</strong>处理</p>
<hr>
<span id="more"></span>

<h2 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h2><h3 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h3><p><strong>数据的发送方</strong>，在发送数据后，以<strong>收到ack响应</strong>作为数据成功发送的标志。</p>
<p>在发送数据时会设置一个<strong>定时器</strong>，若在限定时间内没有收到ack响应，说明<u>发送的数据丢失</u>（或<u>ack丢失</u>），需要<strong>重传</strong>。</p>
<blockquote>
<p>RTT 和 RTO</p>
<ul>
<li><strong>RTT</strong>，Round-Trip Time 往返时延，即从发送数据到收到ack的时间大小。</li>
<li><strong>RTO</strong>，Restransmission Timeout 超时重传时间，超时定时器设置。</li>
</ul>
<p><strong>RTO</strong> 应该设置为略大于 <strong>RTT</strong> 的大小。并且根据网络实际情况，RTT和RTO都是动态变化的。</p>
</blockquote>
<h3 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h3><h4 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h4><p>不依靠<strong>时间</strong>来判断是否需要重传，而是按<strong>收到的ack</strong>判断。减少了判定重传所需的时间。</p>
<ul>
<li><p>发送方发送的数据包seq&#x3D;2丢失了，且后续还有成功发送的数据包</p>
</li>
<li><p>此时接收方没有收到seq&#x3D;2，于是在此后都会回应ack&#x3D;2；</p>
</li>
<li><p>发送方收到几次相同的ack&#x3D;2，说明seq&#x3D;2丢失了，于是触发了重传。</p>
</li>
</ul>
<img src="/2023/05/11/TCP%E4%B9%8B%E5%8D%8F%E8%AE%AE%E6%9C%BA%E5%88%B6/image-20230511225957231.png" alt="image-20230511225957231" style="zoom:80%;">



<p>这里会有一个问题：如何确定需要重传的内容（除了重传ack&#x3D;2对应的包，<strong>是否还需要重传后续所有的包</strong>）</p>
<h4 id="SACK-选择性确认"><a href="#SACK-选择性确认" class="headerlink" title="SACK 选择性确认"></a>SACK 选择性确认</h4><p><strong>通信双方</strong>需要在TCP头部选项字段里添加<strong>SACK选项</strong>。</p>
<p>情况</p>
<ul>
<li>发送方发送的数据丢失</li>
</ul>
<p>ack数据包中会有 记录<strong>已接收的数据情况</strong>的内容，于是发送方可以根据情况来选择要重发的数据包。</p>
<ul>
<li>接收方发现收到的数据seq非目标序列号时，会回发原来的 ack，但会使用 sack 记录当前的接收情况。</li>
<li>这种情况下 ack 会比 sack 小</li>
</ul>
<p><img src="/2023/05/11/TCP%E4%B9%8B%E5%8D%8F%E8%AE%AE%E6%9C%BA%E5%88%B6/image-20230511233550529.png" alt="image-20230511233550529"></p>
<p><strong>Duplicate SACK 重复选择性确认</strong></p>
<p>也即D-SACK，接收方通过记录<strong>重复接收的数据</strong>，让发送方明确数据是否丢失。</p>
<p>情况：</p>
<ul>
<li>ack丢失</li>
<li>网络延时</li>
</ul>
<p>ack 会比 sack 大</p>
<p>作用：</p>
<ul>
<li>可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;</li>
<li>可以知道是不是「发送方」的数据包被网络延迟了;</li>
<li>可以知道网络中是不是把「发送方」的数据包给复制了;</li>
</ul>
<h2 id="流量控制-滑动窗口"><a href="#流量控制-滑动窗口" class="headerlink" title="流量控制-滑动窗口"></a>流量控制-滑动窗口</h2><h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p>解决的问题：</p>
<ul>
<li>每发送一份数据，都要等到收到ack之后才发送下一份数据。</li>
<li>效率低</li>
</ul>
<p>使用的方法：</p>
<ul>
<li>发送窗口的实现实际上是操作系统开辟的一个<strong>缓存空间</strong>，发送方主机在等到确认应答返回之前，必须<strong>在缓冲区中保留已发送的数据</strong>。如果按期收到确认应答（根据<strong>最新的ack</strong>即可，<strong>累计确认</strong>），此时数据就可以从缓存区清除。</li>
<li><strong>TCP头部</strong>中的<strong>window</strong>大小字段，用来表示接收方<strong>接收窗口</strong>的空闲空间大小。发送方可以根据接受方发来的ack中的window字段来调整发送的数据量。</li>
<li>发送方的<strong>发送窗口</strong><br><img src="/2023/05/11/TCP%E4%B9%8B%E5%8D%8F%E8%AE%AE%E6%9C%BA%E5%88%B6/image-20230512000432964.png" alt="image-20230512000432964"><ul>
<li>需要记录 1.<strong>窗口起始地址</strong> 2.<strong>下一个可发送字节的地址</strong> 3.<strong>窗口末尾下一个字节的地址</strong>（起始地址+窗口大小的偏移）</li>
</ul>
</li>
<li>接收方的<strong>接收窗口</strong><br><img src="/2023/05/11/TCP%E4%B9%8B%E5%8D%8F%E8%AE%AE%E6%9C%BA%E5%88%B6/image-20230512000733074.png" alt="image-20230512000733074"><ul>
<li>需要记录 1.<strong>窗口起始地址</strong> 2.<strong>期望的下一个字节的地址</strong> 3.<strong>窗口末尾下一个字节的地址</strong></li>
<li>接收窗口中的数据在<strong>接收方回送ack且应用层提取之后</strong>就可以移除并更新窗口</li>
</ul>
</li>
</ul>
<h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>解决的问题：</p>
<ul>
<li>发送方不能无脑的发数据给接收方，要考虑接收方处理能力。</li>
<li>如果一直无脑的发数据给对方，但对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费。</li>
</ul>
<p>解决的方法：</p>
<ul>
<li>设置滑动窗口</li>
<li>动态调整滑动窗口大小（窗口大小代表着缓冲区情况）</li>
</ul>
<p><img src="/2023/05/11/TCP%E4%B9%8B%E5%8D%8F%E8%AE%AE%E6%9C%BA%E5%88%B6/image-20230512001914792.png" alt="image-20230512001914792"></p>
<p>注意：</p>
<ul>
<li>如果发生了先减少缓冲区内存，再收缩窗口，就会出现丢包的现象。</li>
<li>为了防止这种情况发生，TCP 规定是<strong>不允许同时减少缓存又收缩窗口</strong>的，而是采用<strong>先收缩窗口</strong>，过段时间<strong>再减少缓存</strong>，这样就可以避免了丢包情况</li>
</ul>
<h4 id="窗口关闭（大小为0）"><a href="#窗口关闭（大小为0）" class="headerlink" title="窗口关闭（大小为0）"></a>窗口关闭（大小为0）</h4><p>窗口关闭后潜在的死锁问题（后面开启窗口的ack包丢失所导致）</p>
<img src="/2023/05/11/TCP%E4%B9%8B%E5%8D%8F%E8%AE%AE%E6%9C%BA%E5%88%B6/image-20230512002308803.png" alt="image-20230512002308803" style="zoom:80%;">

<ul>
<li>为了解决这个问题，TCP 为每个连接设有一个持续定时器，<strong>只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。</strong></li>
<li>如果持续计时器超时，就会发送<strong>窗口探测 ( Window probe ) 报文</strong>，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。</li>
<li>若探测成功则继续发送数据，否则每次探测会更新计时器，到达上限则会使用RST断开连接。</li>
</ul>
<h4 id="糊涂窗口综合症（小额数据发送）"><a href="#糊涂窗口综合症（小额数据发送）" class="headerlink" title="糊涂窗口综合症（小额数据发送）"></a>糊涂窗口综合症（小额数据发送）</h4><p>情况：</p>
<ul>
<li>接收方繁忙时处理数据效率很低，导致接收窗口很小，使得发送方的发送窗口也很小</li>
<li>每次接收方处理一点数据就腾出几个字节的窗口空间，并告诉发送方。而发送方立即发送几个字节的数据。（TCP头部就40多字节了，因此效率很低）</li>
</ul>
<p>解决方法：</p>
<ul>
<li><p>接收方：当接收方窗口小于某个大小（MSS，1&#x2F;2缓冲区大小）时，统统当作 <strong>0</strong> 告诉发送方，不让发送方发数据。</p>
</li>
<li><p>发送方：<strong>Nagle</strong> 算法，<strong>延迟发送</strong>，满足下面<strong>任意一个</strong>条件才发送，否则把要发的数据屯着。</p>
<ul>
<li>条件一：要等到窗口大小 &gt;&#x3D; <code>MSS</code> 并且 数据大小 &gt;&#x3D; <code>MSS</code>；</li>
<li>条件二：收到之前发送数据的 <code>ack</code> 回包；</li>
</ul>
<blockquote>
<p>如果对于一些需要小数据包交互的场景的程序，比如，telnet 或 ssh 这样的交互性比较强的程序，则需要关闭 Nagle 算法。</p>
<p>setsockopt TCP_NODELAY</p>
</blockquote>
</li>
</ul>
<h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>流量控制只是对双方的发送和接收能力进行协调配合，对于<strong>网络情况</strong>的控制则需要<strong>拥塞控制</strong>机制来做到。</p>
<p>解决的问题：</p>
<ul>
<li>网络出现拥堵，会触发重传机制，如果不做限制，一直重传下去，则会导致网络情况越来越糟。</li>
<li>形成恶性循环。</li>
</ul>
<p>解决方法：</p>
<ul>
<li>TCP被设计成无私的协议，当发现网络发送拥堵时，会先减少自己发送的数据量</li>
<li>采用一个变量“ <strong>拥塞窗口</strong> <strong>cwnd</strong> ”实现拥塞控制<ul>
<li>只要网络中没有出现拥塞，<code>cwnd</code> 就会增大；</li>
<li>但网络中出现了拥塞，<code>cwnd</code> 就减少；</li>
</ul>
</li>
<li>发送窗口大小 <strong>swnd</strong> &#x3D; min(<strong>cwnd</strong>, <strong>rwnd</strong>)</li>
</ul>
<p>发生<strong>超时重传</strong>就认为网络出现拥塞；</p>
<p>四个拥塞控制算法：慢启动、拥塞避免、拥塞发生、快速恢复</p>
<h3 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h3><ul>
<li>当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。相当于每轮翻一倍。</li>
<li>发送包的数量呈<strong>指数增长</strong></li>
<li>当达到<strong>慢启动门限</strong> <strong>ssthresh</strong>(slow start threshold)后，转为 <strong>拥塞避免算法</strong></li>
</ul>
<p><img src="/2023/05/11/TCP%E4%B9%8B%E5%8D%8F%E8%AE%AE%E6%9C%BA%E5%88%B6/image-20230512013125907.png" alt="image-20230512013125907"></p>
<h3 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h3><ul>
<li>每当收到一个 ACK 时，cwnd 增加 <strong>1&#x2F;cwnd</strong>。相当于cwnd每轮增加 1 。</li>
<li>发送包的数量呈<strong>线性增长</strong>。</li>
<li>直到发送丢包，则转入<strong>拥塞发生</strong>算法</li>
</ul>
<p><img src="/2023/05/11/TCP%E4%B9%8B%E5%8D%8F%E8%AE%AE%E6%9C%BA%E5%88%B6/image-20230512013510913.png" alt="image-20230512013510913"></p>
<h3 id="拥塞发生"><a href="#拥塞发生" class="headerlink" title="拥塞发生"></a>拥塞发生</h3><p>对 <strong>超时重传</strong> 和 <strong>快速重传</strong> 有不同的策略：</p>
<p>针对超时重传（网络情况更为糟糕）</p>
<ul>
<li><code>ssthresh</code> 设为 <code>cwnd/2</code>，即将慢启动门限设为当前cwnd的一半。</li>
<li><code>cwnd</code> 重置为 <strong>初始化值</strong></li>
<li>重新开始<strong>慢启动</strong>。</li>
</ul>
<img src="/2023/05/11/TCP%E4%B9%8B%E5%8D%8F%E8%AE%AE%E6%9C%BA%E5%88%B6/image-20230512013838738.png" alt="超时重传拥塞发生" style="zoom:80%;">





<p>针对快速重传（网络情况可能不好）</p>
<ul>
<li><code>cwnd = cwnd/2</code> ，拥塞窗口减半;</li>
<li><code>ssthresh = cwnd</code>，慢启动门限设为减半后的拥塞窗口;</li>
<li>进入<strong>快速恢复算法</strong></li>
</ul>
<h3 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h3><p>快速重传和快速恢复算法一般同时使用。</p>
<ul>
<li><code>cwnd = ssthresh+3</code>， 相当于前面减半后直接+3（引发快速重传的三个数据包确定是收到了，所以直接+3）；</li>
<li>重传丢失的数据包</li>
<li>若收到重复的ack，则 cwnd+&#x3D;1（目的是为了尽快处理&#x2F;发送丢失的数据包）</li>
<li>若收到新数据的ack，则 cwnd &#x3D; ssthresh，并恢复为<strong>拥塞避免算法</strong>（做出自我牺牲）</li>
</ul>
<p>作为 <strong>拥塞发生(超时重传)&gt;&gt;慢启动</strong> 的加速版，即 <strong>拥塞发生(快速重传)&gt;&gt;快速恢复&gt;&gt;拥塞避免</strong> ，在正确处理完丢失的数据包之后，使得cwnd处于一个更高的起点。</p>
<p><img src="/2023/05/11/TCP%E4%B9%8B%E5%8D%8F%E8%AE%AE%E6%9C%BA%E5%88%B6/image-20230512014231996.png" alt="image-20230512014231996"></p>
]]></content>
      <categories>
        <category>网络</category>
        <category>TCP</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP之概念and三握四挥</title>
    <url>/2023/05/11/TCP%E4%B9%8B%E6%A6%82%E5%BF%B5and%E4%B8%89%E6%8F%A1%E5%9B%9B%E6%8C%A5/</url>
    <content><![CDATA[<h1 id="TCP之概念、三握四挥"><a href="#TCP之概念、三握四挥" class="headerlink" title="TCP之概念、三握四挥"></a>TCP之概念、三握四挥</h1><p>图片和部分文字来源<a href="https://xiaolincoding.com/network/3_tcp/tcp_interview.html">小林coding (xiaolincoding.com)</a></p>
<hr>
<p>TCP是传输层的协议，全称”<strong>传输控制协议</strong>“，用于在IP网络上实现数据和消息的<strong>可靠</strong>传输，并以建立<strong>连接</strong>的方式进行面向<strong>字节流</strong>的数据的传输。</p>
<span id="more"></span>

<br>

<p>在可靠性方面，TCP实现了：</p>
<ul>
<li><strong>连接的建立和断开</strong>，<strong>重传机制</strong>（定时器），<strong>流量控制</strong>（滑动窗口），<strong>拥塞控制</strong>等机制功能。</li>
<li>达到的可靠效果：网络包的收发是<strong>无损坏、无间隔、按序（seq，ack）、非冗余</strong></li>
</ul>
<hr>
<br>

<p><br><br></p>
<br>

<h2 id="TCP格式"><a href="#TCP格式" class="headerlink" title="TCP格式"></a>TCP格式</h2><h3 id="TCP头部"><a href="#TCP头部" class="headerlink" title="TCP头部"></a>TCP头部</h3><img src="/2023/05/11/TCP%E4%B9%8B%E6%A6%82%E5%BF%B5and%E4%B8%89%E6%8F%A1%E5%9B%9B%E6%8C%A5/image-20230510150751458.png" alt="image-20230510150751458" style="zoom:80%;">

<ul>
<li><strong>源端口号、目的端口号</strong></li>
<li><strong>序列号</strong>seq</li>
<li><strong>确认应答号</strong>ack</li>
<li><strong>首部长度</strong> 因为有长度不固定的选项字段，所以首部长度需要明确表示</li>
<li><strong>标志位</strong>（URG、ACK、PSH、RST、SYN、FIN）<ul>
<li>RST 是强制对方断开连接，说明出现异常</li>
<li>SYN 在建立连接时用到，同步</li>
<li>ACK 为确认应答标识</li>
<li>FIN 在断开连接时用到</li>
<li>URG 表示有紧急数据，并通过紧急指针定位</li>
<li>PSH 告诉接收方立即将数据交给应用层，不用等到缓冲区满了</li>
</ul>
</li>
<li><strong>窗口大小</strong></li>
<li>校验和、紧急指针</li>
<li><strong>选项</strong>（可变长度）</li>
</ul>
<br>

<br>

<h3 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h3><p>一个连接包括连接双方的：</p>
<ul>
<li>socket（IP + port）</li>
<li>滑窗大小（接收窗口、发送窗口）</li>
<li>序列号（seq）</li>
<li>…</li>
</ul>
<br>

<p>理论上可以一个服务端socket可以与 <strong>IP数量*端口数量</strong> 个socket建立连接，但实际上受系统<strong>fd数量</strong>、<strong>内存</strong>的限制。</p>
<br>

<br>

<h2 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h2><h3 id="UDP格式"><a href="#UDP格式" class="headerlink" title="UDP格式"></a>UDP格式</h3><p><strong>头部</strong></p>
<img src="/2023/05/11/TCP%E4%B9%8B%E6%A6%82%E5%BF%B5and%E4%B8%89%E6%8F%A1%E5%9B%9B%E6%8C%A5/image-20230510161730776.png" alt="image-20230510161730776" style="zoom:80%;">

<ul>
<li><strong>源端口号、目标端口号</strong></li>
<li><strong>包长度</strong>（数据报）</li>
<li><strong>校验和</strong>（可以校验首部和数据是否正确）</li>
</ul>
<br>

<br>

<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol>
<li>连接：TCP有连接，UDP无连接</li>
<li>传输对象：TCP一对一，<strong>UDP一对一、一对多、多对多</strong></li>
<li><strong>可靠性</strong>：TCP传输<strong>按序</strong>、<strong>无差错</strong>、<strong>不丢失</strong>、<strong>无重复</strong>，UDP不保证</li>
<li><strong>流量控制、拥塞控制</strong>：TCP的机制</li>
<li><strong>传输方式</strong>：TCP流式传输，面向<strong>字节流</strong>，保证数据<strong>顺序</strong>和<strong>可靠</strong>，但是<strong>数据没有边界</strong>（粘包问题）；UDP传输数据包，面向<strong>数据报</strong>，但可能会<strong>乱序和丢包</strong>。</li>
</ol>
<br>

<p><strong>应用场景</strong></p>
<p><strong>TCP</strong>：倾向可靠性要求的</p>
<ul>
<li>文件传输</li>
<li>HTTP&#x2F;HTTPS</li>
</ul>
<br>

<p><strong>UDP</strong>：倾向传输速率的、即时性的</p>
<ul>
<li>DNS，SNMP，数据量较少的</li>
<li>视频、音频、游戏</li>
<li>广播通信</li>
</ul>
<br>

<br>

<br>

<br>

<h2 id="TCP连接建立-三次握手"><a href="#TCP连接建立-三次握手" class="headerlink" title="TCP连接建立-三次握手"></a>TCP连接建立-三次握手</h2><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><img src="/2023/05/11/TCP%E4%B9%8B%E6%A6%82%E5%BF%B5and%E4%B8%89%E6%8F%A1%E5%9B%9B%E6%8C%A5/image-20230510163728483.png" alt="image-20230510163728483" style="zoom:80%;">

<ul>
<li>客户端(SYN_SENT) &gt; 服务端(LISTEN-&gt;SYN_RCVD)： SYN（seq&#x3D;c_x）</li>
<li>客户端(SYN_SENT-&gt;EST) &lt; 服务端(SYN_RCVD)：    SYN+ACK（seq&#x3D;s_x,ack&#x3D;c_x+1）</li>
<li>客户端(EST) &gt; 服务端(SYN_RCVD-&gt;EST)：         ACK（ack&#x3D;s_x+1）</li>
</ul>
<blockquote>
<p><strong>第三次</strong>握手可以<strong>携带数据</strong>，因为经过前两次握手已经确认同步了客户端这边的序列号</p>
</blockquote>
<br>

<br>

<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题:"></a>常见问题:</h3><h4 id="为什么是三次握手？"><a href="#为什么是三次握手？" class="headerlink" title="为什么是三次握手？"></a>为什么是三次握手？</h4><p>为什么不是两次：</p>
<p><strong>三次握手让服务端多了一个过渡状态即SYN_RECV，在此期间可以先确认连接的正确性，排除重复的历史连接</strong></p>
<p>客户端的第一次握手发送的SYN包（A）收到网络阻塞超时了，于是客户端重发新的SYN包（B）（并采用另一个seq号）;</p>
<p>但是服务端最终先收到了旧的SYN包（A），于是进行了第二次握手（回送ack&#x3D;A+1）:</p>
<ul>
<li><p>如果不进行第三次握手，此时就建立连接，会导致双方对客户端seq序列号的不同步：客户端用的是 B，服务端用的是 A</p>
</li>
<li><p>而进行第三次握手，客户端会检查第二次握手的ack&#x3D;A+1，发现并非期待的ack&#x3D;B+1，则会回送RST报文告诉服务端这个错误终止连接。并等待服务端回送正确的ack&#x3D;B+1。</p>
</li>
</ul>
<p>之后服务端收到最新的SYN（B）并回送正确的ack&#x3D;B+1，客户端收到后进行第三次握手，同步服务端这边的序列号。</p>
<blockquote>
<p>如果服务端<u>连续收到两个SYN报文（先A后B）</u>，即<u>没有在中间收到RST报文</u>，那么服务端第二次收到之后会回送 <strong>Challenge Ack</strong> 报文（其序列号仍是旧SYN报文的响应即ack&#x3D;A+1）</p>
</blockquote>
<p>阻止重复历史连接的目的是：<strong>为了避免资源浪费</strong></p>
<ul>
<li>三次握手中服务端会有一个 SYN_RCVD 状态，作为中间状态来确认连接的正确建立。</li>
<li>如果是两次握手，没有中间状态过渡，服务端收到SYN就立即建立连接，但服务端最终还是会收到客户端发来的RST报文断开连接，在此期间连接占用了系统资源（连接队列、socket_fd、内核内存），并且可能会发送数据（无效）</li>
</ul>
<br>

<p>为什么不是四次：</p>
<p><strong>三次握手的目的是建立连接并且同步双方初始序列号，同步序列号需要一来一回，理论上需要两个来回，但是中间的两步可以合并</strong></p>
<p>第一次握手和第二次握手同步了客户端的序列号：seq&#x3D;A，ack&#x3D;A+1</p>
<p>第二次握手和第三次握手同步了服务端的序列号：seq&#x3D;B，ack&#x3D;B+1</p>
<ul>
<li>第二次握手把 seq&#x3D;B, ack&#x3D;A+1 一起发了，所以相当于减少了一次握手，所以不是四次</li>
</ul>
<br>

<br>

<h4 id="为什么每次TCP连接建立时的序列号不同？"><a href="#为什么每次TCP连接建立时的序列号不同？" class="headerlink" title="为什么每次TCP连接建立时的序列号不同？"></a>为什么每次TCP连接建立时的序列号不同？</h4><ul>
<li>分辨不同的连接同步情况，主要是跟历史连接区分（前后两次连接建立时的seq都相同的话，后续发送的数据包的序列号也可能相同，如果历史连接的数据包延迟到新连接时才被接收，若序列号相同则会导致不应该的数据接收）</li>
</ul>
<blockquote>
<p>此外，还是有可能会发生历史数据包的seq冲突，还需要利用 <strong>时间戳</strong> 来分辨</p>
</blockquote>
<ul>
<li>防止黑客伪造相同序列号的报文让接收方接收</li>
</ul>
<p>初始序列号 ISN 的生成利用到了时钟和哈希算法，重复率很低。</p>
<br>

<br>

<h4 id="IP-层会分片（MTU），为什么TCP层还需要分片（MSS）"><a href="#IP-层会分片（MTU），为什么TCP层还需要分片（MSS）" class="headerlink" title="IP 层会分片（MTU），为什么TCP层还需要分片（MSS）"></a>IP 层会分片（MTU），为什么TCP层还需要分片（MSS）</h4><img src="/2023/05/11/TCP%E4%B9%8B%E6%A6%82%E5%BF%B5and%E4%B8%89%E6%8F%A1%E5%9B%9B%E6%8C%A5/image-20230510220202657.png" alt="image-20230510220202657" style="zoom:80%;">

<ul>
<li><strong>MTU</strong>：<strong>IP网络包的最大长度</strong>，以太网的一般为1500字节；</li>
<li><strong>MSS</strong>：IP网络包除去IP头、TCP头，剩下的<strong>TCP数据的最大长度</strong>；</li>
</ul>
<p>MTU是针对数据在IP层的分片大小，MSS是针对数据在TCP层的分片大小。</p>
<p>假设TCP层要发送的数据长度为3个MTU左右：（注意 <strong>重传</strong> 是TCP而不是IP的机制）</p>
<ul>
<li><strong>无MSS</strong>的情况下，数据通过3个IP包来发送，但只有第一个包中包含TCP头。如果<strong>其中一个IP包</strong>丢失了，因为<strong>唯一的TCP头</strong>中说明的数据长度应该是大概3个MTU的大小，无法确认丢失部分的长度，那么就得重新发送<strong>所有的IP包</strong>。</li>
<li><strong>有MSS</strong>的情况下（一般MSS长度略小于MTU，使得MSS分片不需要在MTU中再分），如果其中一个IP包丢失了，则可以根据缺失的TCP头（重传情况之一：收到重复的ack）来确定要重发哪一部分的数据，即只需重新发送少量IP包。</li>
</ul>
<blockquote>
<p><strong>建立连接的时候</strong>，通信双方会协商各自的MSS值</p>
</blockquote>
<br>

<br>

<h4 id="握手丢失的情况"><a href="#握手丢失的情况" class="headerlink" title="握手丢失的情况"></a>握手丢失的情况</h4><ol>
<li><strong>第一次握手丢失</strong></li>
</ol>
<ul>
<li>服务端没有收到SYN，则不会回送SYN-ACK；客户端长时间没收到ACK，触发超时重传，重新发送SYN。</li>
<li>重传次数：由内核文件中的参数<code>tcp_syn_retries</code>设置；超时时间：每次是上一次的2倍</li>
<li>当超时次数达到上限之后，若还是没有收到ACK，那么客户端就会断开</li>
</ul>
<ol start="2">
<li><strong>第二次握手丢失</strong></li>
</ol>
<ul>
<li>客户端长时间没有收到SYN-ACK，触发超时重传</li>
<li>服务端长时间没有收到第三次握手的ACK，触发超时重传</li>
<li>在达到重传次数上限后，若还没有收到回应，则会断开，CLOSE</li>
</ul>
<ol start="3">
<li><strong>第三次握手丢失</strong></li>
</ol>
<ul>
<li>服务端长时间没有收到第三次握手的ACK，触发超时重传</li>
<li>客户端已经建立起了连接，若收到服务端的重传，则会发送ACK</li>
<li>服务端达到重传次数上限，若还没有收到回应，则会断开，CLOSE</li>
<li><strong>客户端处于ESTABLISHED状态</strong>：<ul>
<li>若客户端不主动发数据，则长时间无数据交互，客户端最终会断开。</li>
<li>若客户端主动发数据，则会一直触发重传并到达上限断开。</li>
</ul>
</li>
</ul>
<br>

<br>

<h3 id="其他知识：SYN攻击、半连接队列、全连接队列"><a href="#其他知识：SYN攻击、半连接队列、全连接队列" class="headerlink" title="其他知识：SYN攻击、半连接队列、全连接队列"></a>其他知识：SYN攻击、半连接队列、全连接队列</h3><p>针对服务端的攻击，攻击者发送大量SYN包给服务端，但不进行第三次握手，使得服务端的TCP<strong>半连接队列</strong>爆满，无法正常接收后续的SYN连接请求。</p>
<blockquote>
<img src="/2023/05/11/TCP%E4%B9%8B%E6%A6%82%E5%BF%B5and%E4%B8%89%E6%8F%A1%E5%9B%9B%E6%8C%A5/image-20230511162030421.png" alt="image-20230511162030421" style="zoom: 67%;">

<p>半连接队列（SYN队列）：存放已进行第一次握手的客户端</p>
<p>全连接队列（accept队列）：存放已进行第三次握手的客户端</p>
<ul>
<li>收到第一次握手后把客户端放入SYN队列，并进行第二次握手；</li>
<li>收到第三次握手后把客户端移出SYN队列，并放入Accept队列；</li>
<li>应用程序执行accept()从Accept队列中取出客户端，建立起连接。</li>
</ul>
</blockquote>
<p><strong>应对方式</strong>：</p>
<ol>
<li>调大 netdev_max_backlog ：内核处理速度<u>小于</u>网卡接收数据速度时的额外数据缓存队列大小。</li>
<li>增大 TCP半连接队列 ：<ul>
<li>增大 net.ipv4.tcp_max_syn_backlog</li>
<li>增大 listen() 函数中的 backlog</li>
<li>增大 net.core.somaxconn</li>
</ul>
</li>
<li>开启 net.ipv4.tcp_syncookies ：SYN队列满了以后，服务端对于收到的新的SYN连接请求，根据算法算出cookie并直接进行第二次握手，且将cookie作为seq。服务端收到第三次握手时，检查ack&#x3D;cookie+1，并将客户端连接放入全连接Accept队列。</li>
<li>减少 SYN+ACK 重传次数（修改内核参数）：减少了无效连接的占用队列的时间。</li>
</ol>
<br>

<br>

<h2 id="TCP连接断开-四次挥手"><a href="#TCP连接断开-四次挥手" class="headerlink" title="TCP连接断开-四次挥手"></a>TCP连接断开-四次挥手</h2><h3 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h3><p>以客户端主动关闭连接为例。</p>
<img src="/2023/05/11/TCP%E4%B9%8B%E6%A6%82%E5%BF%B5and%E4%B8%89%E6%8F%A1%E5%9B%9B%E6%8C%A5/image-20230511163506620.png" alt="image-20230511163506620" style="zoom: 67%;">

<ol>
<li>客户端发送FIN，并进入<strong>FIN_WAIT_1</strong>状态；</li>
<li>服务端收到FIN，回送ACK，并进入<strong>CLOSED_WAIT</strong>状态；在服务端发送FIN之前，服务端还可以发送数据；</li>
<li>客户端收到ACK，进入<strong>FIN_WAIT_2</strong>状态，等待服务端的FIN，在此期间可以接收数据；</li>
<li>服务端处理完数据后，发送FIN，并进入<strong>LAST_ACK</strong>状态；</li>
<li>客户端收到FIN，回送ACK，并进入<strong>TIME_WAIT</strong>状态等待一段时间（留机会给服务端重发FIN），确保对方收到了ACK。之后连接正常关闭。</li>
<li>服务端收到ACK，连接关闭。</li>
</ol>
<br>

<br>

<h3 id="常见问题："><a href="#常见问题：" class="headerlink" title="常见问题："></a>常见问题：</h3><p>以客户端主动断开为例</p>
<h4 id="为什么是4次"><a href="#为什么是4次" class="headerlink" title="为什么是4次"></a>为什么是4次</h4><ul>
<li>关闭连接时，客户端先发送FIN包仅表示客户端不再发送数据，但能继续接收数据</li>
<li>服务端收到FIN后回送ACK，但在发送FIN之前还可以处理剩余数据并发送，等到不再需要发送数据之后才发送FIN，向客户端表示同一关闭连接</li>
</ul>
<p>如果中间无其余数据需要处理，可以合并服务端的ACK和FIN可以为合并为一次。</p>
<br>

<br>

<h4 id="挥手丢失的情况"><a href="#挥手丢失的情况" class="headerlink" title="挥手丢失的情况"></a>挥手丢失的情况</h4><p>FIN的重发次数由<code>tcp_orphan_retrie</code>设置</p>
<ol>
<li><strong>第一次挥手丢失</strong></li>
</ol>
<p>服务端没有收到FIN，则不会回送ACK。客户端没有收到ACK，触发超时重传，达到上限后直接断开连接，而此时服务端的连接还没关闭，则可分为有数据发送（重传到关闭）和无数据发送（长时间后关闭）的两种情况。</p>
<ol start="2">
<li><strong>第二次挥手丢失</strong></li>
</ol>
<p>服务端的ACK丢失，客户端没有收到ACK，触发超时重传，达到上限后直接断开连接，而此时服务端处于CLOSE_WAIT状态，后续会发送数据以及发送FIN。</p>
<ol start="3">
<li><strong>第三次挥手丢失</strong></li>
</ol>
<p>客户端收到ACK后，关于<strong>FIN_WAIT_2</strong>状态：</p>
<ul>
<li>若客户端采用的是close()关闭连接，则FIN_WAIT_2状态的持续时间由内核参数<code>tcp_fin_timeout</code>决定，在此时限内没有收到服务端的FIN的话会直接断开连接；</li>
<li>若客户端采用的是shutdown()关闭连接（明确表示后续还要接收数据，即只关闭客户端连接的<strong>发送</strong>方向，保留接收方向），则FIN_WAIT_2状态会一直持续；</li>
</ul>
<p>服务端收到FIN，并回送ACK后，处于<strong>CLOSE_WAIT</strong>状态，后续<strong>何时发送FIN</strong>则由<strong>程序中执行close()的时机</strong>决定。</p>
<ul>
<li>第三次挥手丢失，客户端没有回送ACK，服务端触发超时重传FIN，直到超限断开。</li>
<li>后续客户端则处于FIN_WAIT_2直到超时断开。</li>
</ul>
<ol start="4">
<li><strong>第四次挥手丢失</strong></li>
</ol>
<p>客户端发送ACK后进入TIME_WAIT状态（<strong>2MSL</strong>时间）。四挥丢失会触发服务端的FIN超时重传，客户端在TIME_WAIT状态内收到FIN的话也会重发ACK（并且<strong>重置2MSL定时器</strong>）。</p>
<ul>
<li>第四次挥手一直丢失，则服务端重发FIN次数达到上线后便会直接关闭。而客户端经过2MSL时长后便会关闭。</li>
</ul>
<br>

<br>

<h4 id="关于TIME-WAIT"><a href="#关于TIME-WAIT" class="headerlink" title="关于TIME_WAIT"></a>关于TIME_WAIT</h4><p><strong>为什么TIME_WAIT时长是2MSL</strong></p>
<p><code>MSL</code> 是 Maximum Segment Lifetime，<strong>报文最大生存时间</strong>。大概是消耗掉最大<strong>TTL</strong>的时间。（Linux下约30s）</p>
<p>TIME_WAIT 等待 2 倍的 MSL，比较合理的解释是： </p>
<ul>
<li>网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以<strong>一来一回需要等待 2 倍的时间</strong>。</li>
<li>相当于允许我方发送的报文丢失一次，<strong>留一个时间来接收对方可能重发的报文</strong>。比如，若 ACK 在一个 MSL 内丢失，这样被动方重发的 FIN 会在第 2 个 MSL 内到达。</li>
</ul>
<p>为什么不是4MSL、8MSL：因为连续丢包的概率很小，忽略不做处理的性价比更高。</p>
<br>

<br>

<p><strong>TIME_WAIT状态的作用</strong></p>
<ol>
<li>防止<strong>历史连接中的数据</strong>，被后面相同四元组的连接错误的接收。（发生seq绕回的情况，即报文seq出现重复而无法识别新老数据的情况）</li>
</ol>
<p>经过2MSL的时间可以确保旧连接的数据包全部失效。</p>
<ol start="2">
<li>保证<strong>被动关闭连接方</strong>（此例为服务端）能正确关闭</li>
</ol>
<p>即在客户端ACK丢失的情况下，<strong>让客户端有机会收到服务端重发的FIN</strong>，并重发ACK给服务端。</p>
<p>否则，在客户端关闭之后，服务端后续重发的FIN会返回RST报文</p>
<img src="/2023/05/11/TCP%E4%B9%8B%E6%A6%82%E5%BF%B5and%E4%B8%89%E6%8F%A1%E5%9B%9B%E6%8C%A5/image-20230511213003866.png" alt="image-20230511213003866" style="zoom:80%;">



<img src="/2023/05/11/TCP%E4%B9%8B%E6%A6%82%E5%BF%B5and%E4%B8%89%E6%8F%A1%E5%9B%9B%E6%8C%A5/image-20230511213043392.png" alt="image-20230511213043392" style="zoom: 80%;">



<p><strong>TIME_WAIT过多的影响</strong></p>
<ul>
<li>第一是占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等；</li>
<li>第二是占用端口资源；端口资源也是有限的，一般可以开启的端口为 <code>32768～61000</code>，也可以通过 <code>net.ipv4.ip_local_port_range</code>参数指定范围。</li>
</ul>
<p>可以分别对客户端（主要是端口）和服务端（主要是系统资源）进行分析</p>
<ul>
<li>如果<strong>服务端</strong>要避免过多的 TIME_WAIT 状态的连接，就<strong>永远不要主动断开连接</strong>，让客户端去断开，由分布在各处的客户端去承受 TIME_WAIT</li>
</ul>
<br>

<br>

<h4 id="优雅关闭连接"><a href="#优雅关闭连接" class="headerlink" title="优雅关闭连接"></a>优雅关闭连接</h4><ul>
<li>默认为优雅关闭连接，即正常地完成4次握手地流程。</li>
<li>不优雅地关闭连接，对 socket 设置 <em>SO_LINGER</em> 选项：<ul>
<li>使得调用close()后直接给对方发送RST报文，并关闭连接</li>
</ul>
</li>
</ul>
<br>

<br>

<h3 id="保活机制"><a href="#保活机制" class="headerlink" title="保活机制"></a>保活机制</h3><p>建立连接后，客户端发生了故障如<strong>宕机、断电</strong>的情况（<strong>进程崩溃</strong>的情况会自己发FIN或RST报文给对方），若服务端不主动发送数据给客户端，会发生什么？</p>
<p>长时间没有数据交互的情况，对应有<strong>保活机制</strong>，服务端会每隔一个时间间隔发送一个<strong>探测报文</strong>，如果连续几个探测报文都没有响应，则内核会认为连接失效并报告错误信息。</p>
<ul>
<li><p>tcp_keepalive_xxx 系列内核参数设置时间。</p>
</li>
<li><p>SO_KEEPALIVE 设置socket选项开启保活机制。</p>
</li>
</ul>
<p>此外，我们一般在<strong>应用层</strong>程序实现<strong>定时器、心跳</strong>之类的机制，来关闭长时间没有数据交互的连接。</p>
<br>

<p><br><br></p>
<br>
]]></content>
      <categories>
        <category>网络</category>
        <category>TCP</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity入门(一)</title>
    <url>/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/</url>
    <content><![CDATA[<h2 id="Unity新手入门（一）"><a href="#Unity新手入门（一）" class="headerlink" title="Unity新手入门（一）"></a>Unity新手入门（一）</h2><p>资料来源<a href="https://space.bilibili.com/34412870">擅码网-Monkey的个人空间_哔哩哔哩_bilibili</a></p>
<h3 id="（1）Unity基础使用"><a href="#（1）Unity基础使用" class="headerlink" title="（1）Unity基础使用"></a>（1）Unity基础使用</h3><p><strong>特点</strong>：开发跨平台，资源商店（含开发插件）</p>
<p><strong>界面</strong>：</p>
<ul>
<li>菜单栏</li>
<li>状态栏</li>
<li>操作界面</li>
</ul>
<span id="more"></span>

<p><strong>项目结构</strong>：</p>
<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230524185031458.png" alt="image-20230524185031458" style="zoom:80%;">

<p><strong>Editor</strong> <strong>界面和组织</strong>：</p>
<ul>
<li>Project<ul>
<li>目录文件结构</li>
</ul>
</li>
<li>Hierarchy<ul>
<li>含有场景内的Gameobj对象</li>
</ul>
</li>
<li>Inspector<ul>
<li>检查面板</li>
</ul>
</li>
<li>Scene<ul>
<li>场景视图</li>
</ul>
</li>
</ul>
<p><strong>场景视图内的操作</strong>：</p>
<ul>
<li>几何模型，素材模型</li>
<li>坐标系（世界坐标系、局部坐标系）</li>
<li>选择物体按F快速定位，或双击物体</li>
<li>ALT +鼠标左键旋转、+右键拉远拉近</li>
<li>光源预渲染失败：需要到lighting设置中generate</li>
<li>观察模式：透视persp，正交iso</li>
</ul>
<h3 id="（2）游戏物体与组件"><a href="#（2）游戏物体与组件" class="headerlink" title="（2）游戏物体与组件"></a>（2）游戏物体与组件</h3><h4 id="游戏物体"><a href="#游戏物体" class="headerlink" title="游戏物体"></a>游戏物体</h4><p>场景中所有物体都是GameObject</p>
<p>操作：</p>
<ul>
<li>F2重命名</li>
<li>shift+点击首个和末尾的obj可以多选</li>
<li>ctrl单个选择</li>
<li>Gizmos菜单Scene界面显示设置</li>
</ul>
<h4 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h4><p>inspector窗口</p>
<p>挂载于GameObject的各种Component</p>
<h4 id="项目资产管理"><a href="#项目资产管理" class="headerlink" title="项目资产管理"></a>项目资产管理</h4><p>Assets文件夹内容管理</p>
<p>创建各类二级文件夹</p>
<h4 id="模型与材质"><a href="#模型与材质" class="headerlink" title="模型与材质"></a>模型与材质</h4><p>模型 Model</p>
<p>材质 Material</p>
<p>纹理贴图 Texture</p>
<p><strong>材质球制作</strong></p>
<p>贴图与模型之间的中间过渡——材质球</p>
<ul>
<li><p>Create material</p>
</li>
<li><p>纹理贴图拖到材质的Albedo参数</p>
<ul>
<li>Albedo：反照率[贴图]；用于体现模型的纹理，颜色。</li>
</ul>
</li>
<li><p>材质球拖到模型的组件位置</p>
</li>
</ul>
<h4 id="资源复用和预制体"><a href="#资源复用和预制体" class="headerlink" title="资源复用和预制体"></a>资源复用和预制体</h4><p>Prefab</p>
<p>获取外部资源的Prefab后，放到编辑器内进行二次编辑，然后保存为自己的Prefab</p>
<p> <img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230524194033102.png" alt="image-20230524194033102"></p>
<p>编辑prefab</p>
<ul>
<li>直接编辑文件</li>
<li>点击Hierarchy中prefab对应的游戏对象的 &gt; icon</li>
<li>点击对象的Inspector的Open选项</li>
<li>直接在场景内编辑预制体游戏对象，编辑后点Override-&gt; Apply all</li>
</ul>
<p>断开prefab关联</p>
<ul>
<li>右键Hierarchy中的游戏对象，选择Prefab-&gt;Unpack</li>
</ul>
<h4 id="基础组件"><a href="#基础组件" class="headerlink" title="基础组件"></a>基础组件</h4><h5 id="Transform-组件"><a href="#Transform-组件" class="headerlink" title="Transform 组件"></a>Transform 组件</h5><ul>
<li>位置</li>
<li>旋转</li>
<li>缩放</li>
</ul>
<p>位置是相对于世界坐标轴，旋转和缩放是相对于物体自身坐标轴。</p>
<p>GameObject最基本的组件——Transform。</p>
<p>Empty object可以用来控制层级关系，是天然的父物体。</p>
<h5 id="摄像机组件"><a href="#摄像机组件" class="headerlink" title="摄像机组件"></a>摄像机组件</h5><ul>
<li>视锥体</li>
<li>选中物体 Align with View（按ctrl+shift+f 快速改变位置 </li>
<li>第一人称、第三人称、上帝视角、过肩视角…</li>
</ul>
<p>常用参数：</p>
<ul>
<li>投影 Projection：<ul>
<li>透视 perspective：可以设置Field of View视野范围FOV</li>
<li>正交 Orthographic：可以设置 矩形大小Size</li>
</ul>
</li>
<li>裁剪面 Clipping Planes：<ul>
<li>near，far 控制视锥体的两个面距离摄像机的距离</li>
</ul>
</li>
</ul>
<p> <img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230524201739062.png" alt="image-20230524201739062"></p>
<h5 id="灯光组件"><a href="#灯光组件" class="headerlink" title="灯光组件"></a>灯光组件</h5><p>类型：</p>
<ul>
<li>方向光（太阳）<ul>
<li><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230524202214099.png" alt="image-20230524202214099"></li>
</ul>
</li>
<li>点光源（灯泡）</li>
<li>聚光灯（探照灯）</li>
</ul>
<p>部分属性</p>
<p> <img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230524202327394.png" alt="image-20230524202327394"></p>
<p> <img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230524203010795.png" alt="image-20230524203010795"></p>
<p>重点：<strong>阴影</strong> 和 <strong>光照模式</strong></p>
<h4 id="Shader-与-PBR"><a href="#Shader-与-PBR" class="headerlink" title="Shader 与 PBR"></a>Shader 与 PBR</h4><h5 id="Shader"><a href="#Shader" class="headerlink" title="Shader"></a>Shader</h5><p>着色器 Shader，包含如下属性等。 跟材质球是 蛋壳(材质球Material) 和 蛋清蛋黄(着色器Shader) 的关系，即一个负责展示表现效果，一个负责效果的实现</p>
<p> <img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230524203324571.png" alt="image-20230524203324571"></p>
<p>基本信息</p>
<p><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230524203426130.png" alt="image-20230524203426130"></p>
<h5 id="PBR"><a href="#PBR" class="headerlink" title="PBR"></a>PBR</h5><p>Physicallly-Based-Rendering 基于物理的渲染</p>
<p><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230524203605166.png" alt="image-20230524203605166"></p>
<p>工作流程  </p>
<p><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230524204152889.png" alt="image-20230524204152889"></p>
<h5 id="Unity-标准着色器"><a href="#Unity-标准着色器" class="headerlink" title="Unity 标准着色器"></a>Unity 标准着色器</h5><ul>
<li>材质球的默认 Shader着色器 为 Standard Shader (Unity内的 PBR 渲染Shader)</li>
</ul>
<p>材质球的三种常用效果</p>
<ul>
<li>单贴图：将Texture拖到Albedo属性上</li>
<li>单颜色：直接修改Albedo属性的颜色项</li>
<li>地面瓷砖效果：<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230524234036586.png" alt="image-20230524234036586" style="zoom: 67%;"></li>
</ul>
<p>贴图 - 材质球 - Shader - 游戏物体 之间的关系</p>
<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230524234516928.png" alt="image-20230524234516928" style="zoom:80%;">





<h4 id="脚本代码（脚本组件）"><a href="#脚本代码（脚本组件）" class="headerlink" title="脚本代码（脚本组件）"></a>脚本代码（脚本组件）</h4><p>即 C# 脚本代码 </p>
<ul>
<li>创建script后要立即重命名，使得脚本名和类名一致。</li>
<li>往GameObject上挂脚本组件，相当于new一个脚本对象供后续使用。</li>
</ul>
 <img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230525001709436.png" alt="image-20230525001709436" style="zoom:67%;">



<p><strong>普通C#项目文件与 Unity C#文件对比</strong></p>
<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230525002444458.png" alt="image-20230525002444458" style="zoom: 67%;">





<h5 id="脚本生命周期"><a href="#脚本生命周期" class="headerlink" title="脚本生命周期"></a>脚本生命周期</h5><ul>
<li><p>C# 控制台项目的脚本类对象生命周期（方法&#x2F;函数）：构造，使用字段、属性、方法，析构</p>
</li>
<li><p>继承MonoBehaviour类的脚本类对象的九大生命周期（方法&#x2F;函数）：</p>
<ol>
<li>Awake 函数 :</li>
</ol>
<p>在加载场景时运行 , 即在游戏开始之前初始化变量或者游戏状态 . 只执行一次</p>
<ol start="2">
<li>OnEnable 函数 :</li>
</ol>
<p>在激活当前脚本时调用 , 每激活一次就调用一次该方法</p>
<ol start="3">
<li>Start 函数 :</li>
</ol>
<p>在第一次启动时执行 , 用于游戏对象的初始化 , 在Awake 函数之后执行,只执行一次</p>
<ol start="4">
<li><p>Fixed Update : 固定频率调用 , 与硬件无关, 可以在 Edit -&gt; Project Setting -&gt; Time -&gt; Fixed Time Step 修改</p>
</li>
<li><p>Update : 几乎每一帧都在调用 , 取决于你的电脑硬件 , 不稳定</p>
</li>
<li><p>LateUpdate : 在Update函数之后调用 , 一般用作摄像机跟随</p>
</li>
<li><p>OnGUI 函数 : 调用速度是上面的两倍 , 一般用于老版本的 GUI 显示</p>
</li>
<li><p>OnDisable 函数 : 和 OnEnable 函数成对出现 , 只要从激活状态变为取消激活状态 , 就会执行一次 (和 OnEnable互斥)</p>
</li>
<li><p>OnDestroy 函数 : 当前游戏对象或游戏组件被销毁时执行</p>
</li>
</ol>
</li>
<li><p>不加访问权限修饰的字段、属性、方法默认为private</p>
</li>
</ul>
<h5 id="获取鼠标键盘操作状态"><a href="#获取鼠标键盘操作状态" class="headerlink" title="获取鼠标键盘操作状态"></a>获取鼠标键盘操作状态</h5><p>时刻检测，在Update里面调用</p>
<p><strong>鼠标</strong></p>
<p><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230525185943332.png" alt="image-20230525185943332"></p>
<p>键盘</p>
<p><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230525190200986.png" alt="image-20230525190200986"></p>
<h5 id="从脚本代码理解游戏对象和组件"><a href="#从脚本代码理解游戏对象和组件" class="headerlink" title="从脚本代码理解游戏对象和组件"></a>从脚本代码理解游戏对象和组件</h5><ul>
<li><p>值传递：基本类型赋值</p>
</li>
<li><p>引用传递：非基本类型赋值，相当于浅拷贝</p>
</li>
</ul>
<p><strong>GameObject 和 gameObject</strong></p>
<p><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230525191849546.png" alt="image-20230525191849546"></p>
<p><strong>命名方法</strong></p>
<ul>
<li>小驼峰命名：首个单词小写，其余单词首字母大写</li>
<li>帕斯卡命名（大驼峰）：每个单词首字母都大写</li>
</ul>
<p><strong>持有对象关系</strong></p>
<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230525193241066.png" alt="image-20230525193241066" style="zoom:80%;">

<ul>
<li>持有<strong>自身游戏对象</strong>：使用gameObject属性获取</li>
<li>持有<strong>其他游戏物体对象</strong><ul>
<li><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230525192845788.png" alt="image-20230525192845788" style="zoom: 67%;"></li>
<li>可以用成员变量来存放引用，延长使用周期<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230525193100022.png" alt="image-20230525193100022" style="zoom:67%;"></li>
</ul>
</li>
<li>持有<strong>自身组件对象</strong><ul>
<li><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230525193218416.png" alt="image-20230525193218416" style="zoom:67%;"></li>
</ul>
</li>
<li>持有其他游戏对象的组件对象<ul>
<li>结合前面“持有<strong>其他游戏物体对象</strong>”和“持有<strong>自身组件对象</strong>”</li>
</ul>
</li>
</ul>
<h4 id="Transform组件的代码控制"><a href="#Transform组件的代码控制" class="headerlink" title="Transform组件的代码控制"></a>Transform组件的代码控制</h4><h5 id="移动物体位置"><a href="#移动物体位置" class="headerlink" title="移动物体位置"></a>移动物体位置</h5><ul>
<li>Translate()方法<ul>
<li><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230525200237435.png" alt="image-20230525200237435" style="zoom:80%;"></li>
</ul>
</li>
<li>结合键盘输入，可以设置四方向移动</li>
</ul>
<h3 id="（3）物理系统"><a href="#（3）物理系统" class="headerlink" title="（3）物理系统"></a>（3）物理系统</h3><ul>
<li>三个最基础的系统：<strong>物理、动画、UI</strong></li>
<li>此外还有<strong>输入控制、特效、导航、音效、渲染、热更新系统</strong>等</li>
</ul>
<p>Unity物理系统：模拟了 <strong>重力</strong> 和 <strong>碰撞</strong></p>
<ul>
<li><p>分有 3D物理（基于PhysX引擎） 和 2D物理（基于Box2D引擎）</p>
</li>
<li><p>主要有 刚体组件（重力） 和 碰撞器组件（碰撞）</p>
</li>
</ul>
<h4 id="刚体"><a href="#刚体" class="headerlink" title="刚体"></a>刚体</h4><p>刚体组件的参数：</p>
<ul>
<li>Mass 质量</li>
<li>Drag 阻力</li>
<li>Angular Drag 角阻力</li>
<li>Use Gravity 重力开关</li>
<li>Is Kinematic 运动学开关</li>
</ul>
<p>移动刚体组件的位置</p>
<ul>
<li>MovePosition(Vector3)方法<ul>
<li><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230525202623202.png" alt="image-20230525202623202" style="zoom:67%;"></li>
</ul>
</li>
</ul>
<p>刚体组件添加动力</p>
<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230525203319825.png" alt="image-20230525203319825" style="zoom:67%;">



<p><strong>固定更新</strong></p>
<p>Update 和 FixedUpdate</p>
<p><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230525204535359.png" alt="image-20230525204535359"></p>
<p><strong>控制组件的启用与否</strong></p>
<ul>
<li>Inspector界面勾选</li>
<li>代码控制：<ul>
<li>GameObject<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230525204925251.png" alt="image-20230525204925251" style="zoom:80%;"></li>
<li>Component<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230525205107297.png" alt="image-20230525205107297" style="zoom:80%;"></li>
</ul>
</li>
</ul>
<p><strong>轴向约束控制</strong></p>
<p>Constraints约束</p>
<ul>
<li>position和rotation</li>
<li>xyz三个轴</li>
</ul>
<h4 id="（非物理组件）网格-Mesh"><a href="#（非物理组件）网格-Mesh" class="headerlink" title="（非物理组件）网格 Mesh"></a>（非物理组件）网格 Mesh</h4><p>网格：三维模型的数据文件，美术完成三维建模就是完成模型的网格制作。三维模型由点线面组成。</p>
<ul>
<li><p><strong>Mesh Filter组件</strong></p>
<ul>
<li>设置网格模型（文件）</li>
<li><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230525205549024.png" alt="image-20230525205549024" style="zoom:80%;"></li>
</ul>
</li>
<li><p><strong>Mesh Renderer组件</strong></p>
<ul>
<li>设置网格模型的渲染</li>
<li>核心参数<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230525205947620.png" alt="image-20230525205947620" style="zoom:80%;"></li>
</ul>
</li>
</ul>
<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230525210116122.png" alt="image-20230525210116122" style="zoom:80%;">





<h4 id="碰撞器"><a href="#碰撞器" class="headerlink" title="碰撞器"></a>碰撞器</h4><p>和刚体组件配合使用</p>
<ul>
<li>Box、Sphere、Mesh、Capsule四种常用collider模型</li>
</ul>
<p>参数：</p>
<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230525211319012.png" alt="image-20230525211319012" style="zoom:80%;">



<h5 id="碰撞检测"><a href="#碰撞检测" class="headerlink" title="碰撞检测"></a>碰撞检测</h5><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230525212908508.png" alt="image-20230525212908508" style="zoom:80%;">

<ul>
<li>collision Detection 参数设置碰撞检测频率</li>
<li>gameObject.Collision 只读属性，返回物理碰撞到的游戏物体</li>
</ul>
<h5 id="触发检测"><a href="#触发检测" class="headerlink" title="触发检测"></a>触发检测</h5><p>Collider组件的 Is Trigger 选项</p>
<ul>
<li>勾选后，不会产生物理碰撞，而是进行触发检测</li>
<li>触发的三种状态跟碰撞检测相同</li>
</ul>
<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230526141317266.png" alt="image-20230526141317266" style="zoom:80%;">

<ul>
<li>gameObject.Collider 只读属性，返回物理触发到的游戏物体</li>
</ul>
<h3 id="（4）Transfom组件控制"><a href="#（4）Transfom组件控制" class="headerlink" title="（4）Transfom组件控制"></a>（4）Transfom组件控制</h3><h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><ul>
<li>欧拉角<ul>
<li>存在万向锁</li>
</ul>
</li>
<li>四元数<ul>
<li>无法直观地表示旋转角度</li>
</ul>
</li>
</ul>
<p>Unity的使用</p>
<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230526143606371.png" alt="image-20230526143606371" style="zoom:80%;">

<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230526143748810.png" alt="image-20230526143748810" style="zoom:80%;">



<p><strong>游戏物体持续旋转</strong></p>
<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230526143913425.png" alt="image-20230526143913425" style="zoom:80%;">



<p><strong>中心点的改变</strong></p>
<ul>
<li>创建空子物体，移动到特定位置</li>
<li>空子物体改为同级空物体</li>
<li>将原物体作为空物体的子物体</li>
</ul>
<p>Scene界面的设置</p>
<p><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230526145520652.png" alt="image-20230526145520652"></p>
<p><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230526145531225.png" alt="image-20230526145531225"></p>
<h3 id="Unity协程相关"><a href="#Unity协程相关" class="headerlink" title="Unity协程相关"></a>Unity协程相关</h3><p>切换时机</p>
<p><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230526151919486.png" alt="image-20230526151919486"></p>
<p><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxNDgwODM5,size_16,color_FFFFFF,t_70.png" alt="img"></p>
]]></content>
      <categories>
        <category>游戏开发</category>
        <category>客户端</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity入门(二)</title>
    <url>/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/</url>
    <content><![CDATA[<h2 id="Unity新手入门（二）"><a href="#Unity新手入门（二）" class="headerlink" title="Unity新手入门（二）"></a>Unity新手入门（二）</h2><p>资料来源<a href="https://space.bilibili.com/34412870">擅码网-Monkey的个人空间_哔哩哔哩_bilibili</a></p>
<span id="more"></span>

<h3 id="UI系统"><a href="#UI系统" class="headerlink" title="UI系统"></a>UI系统</h3><p>指UGUI</p>
<p>由UI游戏对象和UI组件</p>
<h4 id="两大UI游戏对象"><a href="#两大UI游戏对象" class="headerlink" title="两大UI游戏对象"></a>两大UI游戏对象</h4><p><strong>Canvas 画布</strong></p>
<ul>
<li>画布Gameobject，是所有 UI Gameobject (如Image、text等)的父物体；</li>
</ul>
<p><strong>EventSystem 事件系统</strong></p>
<ul>
<li>用于响应和处理用户对UI的各种操作</li>
<li>同一场景内，Canvas可以有多个，EventSystem只能有一个</li>
</ul>
<h4 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h4><p>由两部分组成：</p>
<ul>
<li>UI布局组件 Layout</li>
<li>UI元素组件 UI</li>
</ul>
<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230526155807850.png" alt="image-20230526155807850" style="zoom: 67%;">



<h5 id="Text组件"><a href="#Text组件" class="headerlink" title="Text组件"></a>Text组件</h5><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230526160528295.png" alt="image-20230526160528295" style="zoom:67%;">

<p>字体.ttf格式</p>
<h5 id="Text-TMP组件"><a href="#Text-TMP组件" class="headerlink" title="Text TMP组件"></a>Text TMP组件</h5><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230526160937644.png" alt="image-20230526160937644" style="zoom:67%;">

<p>字体.SDF格式</p>
<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230526162202757.png" alt="image-20230526162202757" style="zoom:80%;">

<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230526162352685.png" alt="image-20230526162352685" style="zoom:80%;">

<h5 id="Image组件"><a href="#Image组件" class="headerlink" title="Image组件"></a>Image组件</h5><p>常用的图片格式为PNG，可以存储透明通道。</p>
<ul>
<li>图片素材的管理<ul>
<li><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230526161620578.png" alt="image-20230526161620578" style="zoom:67%;"></li>
</ul>
</li>
<li>参数<ul>
<li><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230526161749972.png" alt="image-20230526161749972" style="zoom:67%;"></li>
</ul>
</li>
</ul>
<h5 id="Button组件"><a href="#Button组件" class="headerlink" title="Button组件"></a>Button组件</h5><p><strong>普通Button</strong></p>
<p>Interactable可交互</p>
<p>Transition过渡模式</p>
<ul>
<li>Color Tint颜色过渡<ul>
<li><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230526163008977.png" alt="image-20230526163008977" style="zoom:80%;"></li>
</ul>
</li>
</ul>
<p><strong>TMP Button</strong></p>
<ul>
<li>跟普通button的区别在于子text物体的格式：普通和TMP两种格式</li>
</ul>
<p><strong>点击事件</strong></p>
<ul>
<li>点击按钮，触发事件，执行事件处理函数</li>
<li><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230526163512810.png" alt="image-20230526163512810" style="zoom:80%;"></li>
</ul>
<h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230526164636319.png" alt="image-20230526164636319" style="zoom:80%;">

<h5 id="TextMeshPro插件"><a href="#TextMeshPro插件" class="headerlink" title="TextMeshPro插件"></a>TextMeshPro插件</h5><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230526164203169.png" alt="image-20230526164203169" style="zoom:80%;">

<p><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230526164441402.png" alt="image-20230526164441402"></p>
<p>TMP中文字体文件的实质是<strong>图集</strong></p>
<h3 id="特效系统"><a href="#特效系统" class="headerlink" title="特效系统"></a>特效系统</h3><p>Unity的特效系统主要是</p>
<ul>
<li>粒子系统 Particle System</li>
<li>力场 Force Field</li>
<li>拖尾 Trail</li>
<li>线 Line</li>
</ul>
<h4 id="拖尾渲染器组件"><a href="#拖尾渲染器组件" class="headerlink" title="拖尾渲染器组件"></a>拖尾渲染器组件</h4><p><strong>参数</strong></p>
<ul>
<li>宽度设置</li>
<li>其他<ul>
<li><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230526170224474.png" alt="image-20230526170224474" style="zoom:80%;"></li>
</ul>
</li>
</ul>
<p><strong>材质</strong></p>
<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230526170434673.png" alt="image-20230526170434673" style="zoom:80%;">

<p><strong>调试面板</strong></p>
<p><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230526170622052.png" alt="image-20230526170622052"></p>
<p><strong>细节</strong></p>
<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230526170836210.png" alt="image-20230526170836210" style="zoom:80%;">





<h4 id="线渲染器"><a href="#线渲染器" class="headerlink" title="线渲染器"></a>线渲染器</h4><p>用途：绘制“特效线”，如激光，台球线，或各种辅助线。</p>
<p>基本使用</p>
<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527190643282.png" alt="image-20230527190643282" style="zoom:80%;">

<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527191836723.png" alt="image-20230527191836723" style="zoom:80%;">



<h3 id="音效系统"><a href="#音效系统" class="headerlink" title="音效系统"></a>音效系统</h3><p>各种音效</p>
<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527191958959.png" alt="image-20230527191958959" style="zoom:80%;">



<p>Unity内的音效系统，两大核心：</p>
<ul>
<li>播放音效</li>
<li>监听音效</li>
</ul>
<p>音效产生器：</p>
<ul>
<li>AudioSource<ul>
<li>参数：<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527193709932.png" alt="image-20230527193709932" style="zoom:80%;"></li>
<li><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527193727920.png" alt="image-20230527193727920" style="zoom:80%;"></li>
</ul>
</li>
</ul>
<p>音效文件：</p>
<ul>
<li>AudioClip</li>
</ul>
<p>音频监听器：</p>
<ul>
<li>AudioListener</li>
</ul>
<h3 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h3><hr>
<h4 id="Resource类"><a href="#Resource类" class="headerlink" title="Resource类"></a>Resource类</h4><ul>
<li>用于资源文件的加载</li>
<li>需要先创建&#x2F;Assets&#x2F;Resources文件夹存放资源文件</li>
<li>常用资源类型<ul>
<li><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527194338981.png" alt="image-20230527194338981" style="zoom:80%;"></li>
</ul>
</li>
</ul>
<p><strong>单个资源加载</strong></p>
<p><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527194551425.png" alt="image-20230527194551425"></p>
<p><strong>多个资源加载</strong></p>
<p><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527194745834.png" alt="image-20230527194745834"></p>
<h4 id="AudioSource"><a href="#AudioSource" class="headerlink" title="AudioSource"></a>AudioSource</h4><p><strong>AudioSource组件</strong></p>
<p>AudioSource类的.clip字段对应AudioSource组件的AudioClip参数</p>
<p>AudioSource组件的使用</p>
<p><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527195339288.png" alt="image-20230527195339288"></p>
<p><strong>AudioSource类</strong></p>
<ul>
<li>在指定位置播放小段音频（one shot）<ul>
<li><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527195604149.png" alt="image-20230527195604149" style="zoom:80%;"></li>
<li><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527195634797.png" alt="image-20230527195634797" style="zoom:80%;"></li>
</ul>
</li>
</ul>
<h4 id="游戏物体设置"><a href="#游戏物体设置" class="headerlink" title="游戏物体设置"></a>游戏物体设置</h4><p><strong>两类资源</strong></p>
<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527200104757.png" alt="image-20230527200104757" style="zoom:80%;">

<ul>
<li>纯资源</li>
<li>GameObject资源<ul>
<li>需要多一步实例化instantiate，相当于new出来</li>
</ul>
</li>
</ul>
<h5 id="实例化游戏物体"><a href="#实例化游戏物体" class="headerlink" title="实例化游戏物体"></a>实例化游戏物体</h5><p><strong>API</strong></p>
<p><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527200451065.png" alt="image-20230527200451065"></p>
<p><strong>预制体</strong></p>
<p><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527200739291.png" alt="image-20230527200739291"></p>
<p><strong>实例化操作的作用</strong></p>
<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527200913883.png" alt="image-20230527200913883" style="zoom:80%;">





<h5 id="销毁游戏物体"><a href="#销毁游戏物体" class="headerlink" title="销毁游戏物体"></a>销毁游戏物体</h5><ul>
<li>实例化和销毁对游戏物体的出生和死亡</li>
<li>比在如战死后进行销毁</li>
</ul>
<p><strong>API</strong></p>
<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527201131059.png" alt="image-20230527201131059" style="zoom:80%;">



<h5 id="添加-x2F-移除组件"><a href="#添加-x2F-移除组件" class="headerlink" title="添加&#x2F;移除组件"></a>添加&#x2F;移除组件</h5><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527201356611.png" alt="image-20230527201356611" style="zoom:80%;">



<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527201424529.png" alt="image-20230527201424529" style="zoom:80%;">



<p>移除方式：</p>
<ul>
<li>使用GetComponent&lt;T&gt;()获取组件</li>
<li>使用Destroy()销毁组件</li>
</ul>
<h4 id="脚本生命周期"><a href="#脚本生命周期" class="headerlink" title="脚本生命周期"></a>脚本生命周期</h4><p><strong>三种状态</strong></p>
<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527201712437.png" alt="image-20230527201712437" style="zoom:80%;">



<p><strong>脚本生命周期</strong></p>
<p><strong>GameObject生命周期</strong></p>
<p><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxNDgwODM5,size_16,color_FFFFFF,t_70.png" alt="img"></p>
<p><strong>脚本生命周期</strong>（MonoBehaviour类的子类）</p>
<p><strong>说明</strong></p>
<p>开启状态：</p>
<p><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527202238558.png" alt="image-20230527202238558"></p>
<ul>
<li>awake和start只会执行一次</li>
</ul>
<p>进行中状态：</p>
<p><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527202645563.png" alt="image-20230527202645563"></p>
<p>结束状态：</p>
<p><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527202909950.png" alt="image-20230527202909950"></p>
<p><strong>其他问题</strong></p>
<p>Awake和Start</p>
<p><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527203357409.png" alt="image-20230527203357409"></p>
<ul>
<li>A脚本调用B脚本为例，B脚本的初始化操作要放在Awake内完成，然后A脚本在Start内查找B脚本并调用其方法。</li>
</ul>
<h4 id="Invoke函数"><a href="#Invoke函数" class="headerlink" title="Invoke函数"></a>Invoke函数</h4><p>延迟调用、重复调用</p>
<p><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527205946049.png" alt="image-20230527205946049"></p>
<p><strong>API</strong></p>
<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527210036874.png" alt="image-20230527210036874" style="zoom:80%;">

<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527210217620.png" alt="image-20230527210217620" style="zoom:80%;">

<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527210254671.png" alt="image-20230527210254671" style="zoom:80%;">





<h4 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h4><p><strong>介绍</strong></p>
<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527210709676.png" alt="image-20230527210709676" style="zoom:80%;">

<ul>
<li>协程方法</li>
<li>协程操作：开启，关闭</li>
</ul>
<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527210756780.png" alt="image-20230527210756780" style="zoom:80%;">

<ul>
<li>Unity的线程比较特殊，大多数内容在主线程中执行。</li>
<li>子线程无法调用引擎相关API，于是采用协程来替代线程。</li>
</ul>
<p><strong>语法</strong></p>
<ul>
<li>协程方法的编写<ul>
<li><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527211004688.png" alt="image-20230527211004688" style="zoom:80%;"></li>
</ul>
</li>
<li>开启协程<ul>
<li><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527211644562.png" alt="image-20230527211644562" style="zoom:80%;"></li>
</ul>
</li>
<li>终止协程<ul>
<li><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527211809047.png" alt="image-20230527211809047" style="zoom:80%;"></li>
</ul>
</li>
</ul>
<p><strong>应用</strong></p>
<ul>
<li>物体移动，每帧移动一点点<ul>
<li>while循环配合yield return null</li>
<li><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527213237458.png" alt="image-20230527213237458" style="zoom:80%;"></li>
</ul>
</li>
<li>。</li>
<li>。</li>
<li>。</li>
</ul>
<p><strong>生命周期</strong></p>
<p><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527213458805.png" alt="image-20230527213458805"></p>
<ul>
<li>不使用协程，while循环的代码会在1帧内完成。</li>
<li>使用协程，可以达到每帧分步完成的效果</li>
</ul>
<p><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527213807780.png" alt="image-20230527213807780"></p>
<p><strong>协程的运行时机</strong></p>
<ul>
<li><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527213329201.png" alt="image-20230527213329201"></li>
<li><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527213339744.png" alt="image-20230527213339744"></li>
</ul>
<p><strong>由其他脚本调用的情况</strong></p>
<ul>
<li>原始：其他脚本使用该脚本的引用来调用StartCorotine</li>
<li>常用：该脚本封装好协程开启和关闭的代码，供其他脚本调用</li>
</ul>
<p><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527214016638.png" alt="image-20230527214016638"></p>
<p><strong>协程与Invoke对比</strong></p>
<ul>
<li>相同之处<ul>
<li>都是MonoBehaviour类中定义的公开方法</li>
<li>都可以实现延迟调用</li>
</ul>
</li>
<li>不同之处<ul>
<li>协程可以动态传递参数，Invoke只能使用无参方法</li>
<li>协程的方法体内可以多次延迟，Invoke只能在开启时延迟</li>
</ul>
</li>
</ul>
<h4 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h4><p>问题：</p>
<p>对于同一个游戏物体的脚本组件 ——</p>
 <img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230529151745528.png" alt="image-20230529151745528" style="zoom: 67%;">

<p>解决：</p>
<ul>
<li>给同级、子级脚本发送消息</li>
</ul>
<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230529151838922.png" alt="image-20230529151838922" style="zoom:67%;">

<ul>
<li>给同级、子级脚本广播发送消息</li>
</ul>
<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230529152349402.png" alt="image-20230529152349402" style="zoom: 67%;">

<ul>
<li>给父级脚本发送消息</li>
</ul>
<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230529161205066.png" alt="image-20230529161205066" style="zoom:67%;">





<h4 id="GameObject查找"><a href="#GameObject查找" class="headerlink" title="GameObject查找"></a>GameObject查找</h4><p><strong>全局名称查找</strong></p>
<ul>
<li><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230529162445884.png" alt="image-20230529162445884" style="zoom:50%;"></li>
<li><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230529162601624.png" alt="image-20230529162601624" style="zoom:50%;"> 
- 如果要持有隐藏的物体：<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230529163003658.png" alt="image-20230529163003658" style="zoom:50%;"></li>
<li>含有重名的游戏物体的情况：<ul>
<li><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230529163142987.png" alt="image-20230529163142987" style="zoom:50%;"></li>
</ul>
</li>
</ul>
<p>采用路径查找</p>
<ul>
<li><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230529163233301.png" alt="image-20230529163233301" style="zoom: 50%;"></li>
</ul>
<p><strong>全局标签查找</strong></p>
 <img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230529163616238.png" alt="image-20230529163616238" style="zoom:50%;">

<p><strong>API</strong></p>
<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230529163710271.png" alt="image-20230529163710271" style="zoom:67%;">







<h4 id="Transform查找"><a href="#Transform查找" class="headerlink" title="Transform查找"></a>Transform查找</h4><p><strong>查找子物体</strong></p>
 <img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230529165243944.png" alt="image-20230529165243944" style="zoom: 50%;">

 <img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230529165407539.png" alt="image-20230529165407539" style="zoom:50%;">



<p><strong>查找子物体组件</strong></p>
 <img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230529165518177.png" alt="image-20230529165518177" style="zoom:50%;">

<p>可以获取多层嵌套的子物体及其组件</p>
 <img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230529165757497.png" alt="image-20230529165757497" style="zoom:50%;">





<p><strong>两种查找的对比</strong></p>
<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230529211353535.png" alt="image-20230529211353535" style="zoom:80%;">



<h3 id="物理射线"><a href="#物理射线" class="headerlink" title="物理射线"></a>物理射线</h3><ul>
<li>可以与collider发生碰撞</li>
<li>从<strong>起点</strong>往<strong>指定方向</strong>无限延申的物理射线</li>
</ul>
<h4 id="创建物理射线"><a href="#创建物理射线" class="headerlink" title="创建物理射线"></a>创建物理射线</h4><ul>
<li>射线结构体：<strong>Ray</strong></li>
<li>创建方式：<ul>
<li>直接new一个Ray对象</li>
<li>通过摄像机相关API构造<ul>
<li><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230531153113688.png" alt="image-20230531153113688" style="zoom:67%;"></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>主摄像机</strong></p>
 <img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230531152955214.png" alt="image-20230531152955214" style="zoom:67%;">

<h4 id="检测物理射线"><a href="#检测物理射线" class="headerlink" title="检测物理射线"></a>检测物理射线</h4><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230531153432898.png" alt="image-20230531153432898" style="zoom:67%;">



<p><strong>绘制线段</strong></p>
<ul>
<li>Scene中显示射线</li>
</ul>
 <img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230531154612018.png" alt="image-20230531154612018" style="zoom:67%;">

<ul>
<li>游戏中的射线</li>
</ul>
 <img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230531154825692.png" alt="image-20230531154825692" style="zoom:67%;">



<h3 id="插值运算"><a href="#插值运算" class="headerlink" title="插值运算"></a>插值运算</h3><h4 id="Time时间类"><a href="#Time时间类" class="headerlink" title="Time时间类"></a>Time时间类</h4><p><strong>API</strong></p>
 <img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230531173033800.png" alt="image-20230531173033800" style="zoom:67%;">



<h4 id="Mathf数学类"><a href="#Mathf数学类" class="headerlink" title="Mathf数学类"></a>Mathf数学类</h4> <img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230531174106687.png" alt="image-20230531174106687" style="zoom:50%;">

<ul>
<li>角度与弧度转换<ul>
<li><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230531174038979.png" alt="image-20230531174038979" style="zoom: 50%;"></li>
</ul>
</li>
</ul>
<h4 id="插值运算-1"><a href="#插值运算-1" class="headerlink" title="插值运算"></a>插值运算</h4><p>确定两个参数A和B，从A平滑过渡到B</p>
 <img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230531174411627.png" alt="image-20230531174411627" style="zoom: 67%;">

<p><strong>使用</strong>：</p>
<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230531174502851.png" alt="image-20230531174502851" style="zoom:67%;">

 <img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230531174606819.png" alt="image-20230531174606819" style="zoom: 50%;">

 <img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230531174714699.png" alt="image-20230531174714699" style="zoom:50%;">

 <img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230531174741231.png" alt="image-20230531174741231" style="zoom:50%;">



<p><strong>采用累加插值系数解决前快后慢</strong></p>
 <img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230531212916531.png" alt="image-20230531212916531" style="zoom:67%;">



<p><strong>其他插值API</strong></p>
<ul>
<li>向量插值<ul>
<li><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230531213456923.png" alt="image-20230531213456923" style="zoom:50%;"></li>
</ul>
</li>
<li>四元数插值<ul>
<li><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230531213735772.png" alt="image-20230531213735772" style="zoom:50%;"></li>
</ul>
</li>
</ul>
<h3 id="Unity核心类的继承关系"><a href="#Unity核心类的继承关系" class="headerlink" title="Unity核心类的继承关系"></a>Unity核心类的继承关系</h3><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230531214121060.png" alt="image-20230531214121060">

<p>Unity安全模式</p>
<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230531220339763.png" alt="image-20230531220339763" style="zoom:67%;">
]]></content>
      <categories>
        <category>游戏开发</category>
        <category>客户端</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>git简单入门</title>
    <url>/2023/02/12/git%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="Git简单入门"><a href="#Git简单入门" class="headerlink" title="Git简单入门"></a>Git简单入门</h1><p>基本命令</p>
<p>git </p>
<p><img src="/2023/02/12/git%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/image-20230212074446947.png" alt="image-20230212074446947"></p>
<p>更多命令</p>
<p><img src="/2023/02/12/git%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/image-20230212074320214.png" alt="image-20230212074320214"></p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>用不同电脑写hexo博客</title>
    <url>/2022/07/11/%E4%B8%8D%E5%90%8C%E7%94%B5%E8%84%91%E5%86%99hexo%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="基于GitHub双分支方法"><a href="#基于GitHub双分支方法" class="headerlink" title="基于GitHub双分支方法"></a>基于GitHub双分支方法</h1><h2 id="1-在每次编辑之前"><a href="#1-在每次编辑之前" class="headerlink" title="1. 在每次编辑之前"></a>1. 在每次编辑之前</h2><hr>
<p>需要先 <code>git pull</code> 拉取hexo分支的内容到本地，即同步更新，然后再进行上述操作。</p>
<hr>
<p><br><br><br></p>
<h2 id="2-修改本地文件和编辑博客内容"><a href="#2-修改本地文件和编辑博客内容" class="headerlink" title="2. 修改本地文件和编辑博客内容"></a>2. 修改本地文件和编辑博客内容</h2><hr>
<p>Windows下用 git bash 打开本地文件夹</p>
<p>然后就是 <code>hexo new [layout] &lt;title&gt;</code> 创建新文件</p>
<img src="/2022/07/11/%E4%B8%8D%E5%90%8C%E7%94%B5%E8%84%91%E5%86%99hexo%E5%8D%9A%E5%AE%A2/07/11/%E4%B8%8D%E5%90%8C%E7%94%B5%E8%84%91%E5%86%99hexo%E5%8D%9A%E5%AE%A2/1.png" class>

<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/156915260">相关hexo操作</a></p>
</blockquote>
<blockquote>
<p><a href="https://markdown.com.cn/basic-syntax/">markdown语法</a></p>
</blockquote>
<blockquote>
<p>图片插入格式 <code>&#123;% asset_img example.jpg This is an example image %&#125;</code></p>
</blockquote>
<hr>
<p><br><br><br></p>
<h2 id="3-编辑和修改完成之后"><a href="#3-编辑和修改完成之后" class="headerlink" title="3. 编辑和修改完成之后"></a>3. 编辑和修改完成之后</h2><hr>
<p>先归并到hexo分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;xxx&quot;&#x27;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<p>再用</p>
<p> <code>hexo d -g</code></p>
<p> 部署到master分支中的网页上。</p>
<hr>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>初探GPU运作方式及特点</title>
    <url>/2023/06/01/%E5%88%9D%E6%8E%A2GPU%E8%BF%90%E4%BD%9C%E6%96%B9%E5%BC%8F%E5%8F%8A%E7%89%B9%E7%82%B9/</url>
    <content><![CDATA[<h1 id="GPU的特点以及与CPU有何不同"><a href="#GPU的特点以及与CPU有何不同" class="headerlink" title="GPU的特点以及与CPU有何不同"></a>GPU的特点以及与CPU有何不同</h1><h2 id="New-Bing-的回答"><a href="#New-Bing-的回答" class="headerlink" title="New Bing 的回答"></a>New Bing 的回答</h2><p>GPU和CPU的区别在于它们的设计目标不同。</p>
<ul>
<li>CPU需要<strong>很强的通用性</strong>来处理<strong>各种不同的数据类型</strong>，同时又要逻辑判断又会引入大量的<strong>分支跳转和中断</strong>的处理。这些都使得CPU的内部结构异常复杂。</li>
<li>而GPU面对的则是<strong>类型高度统一的</strong>、<strong>相互无依赖的</strong>大规模数据和<strong>不需要被打断的</strong>纯净的计算环境。</li>
<li>于是CPU和GPU就呈现出非常不同的架构。GPU采用了<u>数量众多的计算单元和超长的流水线</u>，但只有<u>非常简单的控制逻辑</u>并<u>省去了Cache</u><a href="https://blog.csdn.net/shuiyixin/article/details/82915378">1</a>。</li>
</ul>
<p>简单来说，&#96;GPU是专门为PC或者嵌入式设备进行<strong>图像运算工作</strong>的微处理器，而CPU则是一台计算机的<strong>控制和运算核心</strong>，它主要功能便是解释计算机发出的指令以及处理电脑软件中的大数据<a href="https://zhidao.baidu.com/question/422288800.html">2</a>。</p>
<span id="more"></span>

<p>相关链接：</p>
<p><a href="https://zhuanlan.zhihu.com/p/592006016">聊聊GPU与CPU的区别 - 知乎 (zhihu.com)</a></p>
<h2 id="架构对比"><a href="#架构对比" class="headerlink" title="架构对比"></a>架构对比</h2><p>CPU and GPU</p>
<p> <img src="/2023/06/01/%E5%88%9D%E6%8E%A2GPU%E8%BF%90%E4%BD%9C%E6%96%B9%E5%BC%8F%E5%8F%8A%E7%89%B9%E7%82%B9/image-20230601192543579.png" alt="image-20230601192543579" style="zoom: 55%;"> <img src="/2023/06/01/%E5%88%9D%E6%8E%A2GPU%E8%BF%90%E4%BD%9C%E6%96%B9%E5%BC%8F%E5%8F%8A%E7%89%B9%E7%82%B9/image-20230601192628892.png" alt="image-20230601192628892" style="zoom: 60%;"></p>
<img src="/2023/06/01/%E5%88%9D%E6%8E%A2GPU%E8%BF%90%E4%BD%9C%E6%96%B9%E5%BC%8F%E5%8F%8A%E7%89%B9%E7%82%B9/image-20230601194723789.png" alt="image-20230601194723789" style="zoom:67%;"> 

<ul>
<li>CPU 基于低延时的设计：</li>
<li>CPU有强大的ALU（算术运算单元）,它可以在很少的时钟周期内完成算术计算。<ul>
<li>当今的CPU可以达到64bit 双精度。执行双精度浮点源算的加法和乘法只需要1～3个时钟周期。CPU的时钟周期的频率是非常高的，达到1.532～3gigahertz(千兆HZ, 10的9次方).大的缓存也可以降低延时。保存很多的数据放在缓存里面，当需要访问的这些数据，只要在之前访问过的，如今直接在缓存里面取即可。</li>
<li>复杂的逻辑控制单元。当程序含有多个分支的时候，它通过提供分支预测的能力来降低延时。数据转发。 当一些指令依赖前面的指令结果时，数据转发的逻辑控制单元决定这些指令在pipeline中的位置并且尽可能快的转发一个指令的结果给后续的指令。这些动作需要很多的对比电路单元和转发电路单元。</li>
</ul>
</li>
</ul>
 <img src="/2023/06/01/%E5%88%9D%E6%8E%A2GPU%E8%BF%90%E4%BD%9C%E6%96%B9%E5%BC%8F%E5%8F%8A%E7%89%B9%E7%82%B9/image-20230601194746798.png" alt="image-20230601194746798" style="zoom:67%;">

<ul>
<li>GPU是基于大的吞吐量设计。<ul>
<li>GPU的特点是有很多的ALU和很少的cache. 缓存的目的不是保存后面需要访问的数据的，这点和CPU不同，而是为thread提高服务的。如果有很多线程需要访问同一个相同的数据，缓存会合并这些访问，然后再去访问dram（因为需要访问的数据保存在dram中而不是cache里面），获取数据后cache会转发这个数据给对应的线程，这个时候是数据转发的角色。但是由于需要访问dram，自然会带来延时的问题。</li>
</ul>
</li>
<li>GPU的控制单元（左边黄色区域块）可以把多个的访问合并成少的访问。<ul>
<li>GPU的虽然有dram延时，却有非常多的ALU和非常多的thread. 为啦平衡内存延时的问题，我们可以中充分利用多的ALU的特性达到一个非常大的吞吐量的效果。尽可能多的分配多的Threads.通常来看GPU ALU会有非常重的pipeline就是因为这样。所以与CPU擅长逻辑控制，串行的运算。和通用类型数据运算不同，GPU擅长的是大规模并发计算，这也正是密码破解等所需要的。所以GPU除了图像处理，也越来越多的参与到计算当中来。</li>
</ul>
</li>
</ul>
<h3 id="GPU的由来"><a href="#GPU的由来" class="headerlink" title="GPU的由来"></a><strong>GPU的由来</strong></h3><p>计算机对图像进行实时渲染， 一般需要经过<strong>图形流水线</strong>的过程：<code>顶点处理-&gt;图元处理-&gt;栅格化-&gt;片段处理-&gt;像素操作</code>, 期间需要大量的计算，比如 640×480的分辨率的屏幕，为了显示游戏画面，大概有30万个像素需要渲染 ，为了让人眼看到画面动起来，其不像电影一样只需要24帧，至少需要60帧，即每秒我们需要完成 1800 万次单个像素的渲染，每个像素都需要经过<strong>图形流水线过程</strong>，需要耗费大量资源。</p>
<p>由于图像渲染的流程是固定的，通过硬件来解决这个问题，那就设计一个不需要考虑CPU的流水线停顿、乱序执行、 分支预测、内存管理、IO等等的各类问题的芯片，这其实就是GPU。</p>
<h3 id="GPU优化设计思路"><a href="#GPU优化设计思路" class="headerlink" title="GPU优化设计思路"></a>GPU优化设计思路</h3><p>现代的 GPU 为了图形渲染、深度学习上有相较于CPU更强大的性能，做出来哪些设计上的优化：</p>
<ol>
<li>由于GPU不需要考虑CPU的流水线停顿、乱序执行、分支预测等等的各类问题，只需要流式计算的功能，所以内部许多CPU的电路是不需要的，这样就节约了大量空间</li>
<li>由于GPU相比CPU电路就简单多了，这样就可以塞入更多的电路，即更多的”核”，他们都是<strong>并行</strong>的，能够极大提升性能</li>
<li>除了塞更多的核，为了更大程度提升GPU的性能，还采用 <strong>SIMT</strong> 技术，可以把多条数据，交给不同的线程去处理。类似于CPU中，SIMD技术，但是其只能一次性取出了固定长度的多个数据，放到寄存器里面，用一个指令去执行</li>
<li>GPU同样采用<strong>超线程</strong>技术，当任务计算遇到停顿的时候，调度一些别的计算任务给当前的 ALU ，这样就需要保证核心中提供更多的执行上下文给ALU算数计算单元使用</li>
</ol>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>CPU和GPU因为最初用来处理的任务就不同，所以设计上有不小的区别，而某些任务和GPU最初用来解决的问题比较相似，所以用GPU来算了，GPU的运算速度取决于雇了多少小学生，CPU的运算速度取决于请了多么厉害的教授，教授处理复杂任务的能力是碾压小学生的，但是对于没那么复杂的任务，还是顶不住人多。</p>
<p>当然现在的GPU也能做一些稍微复杂的工作了，相当于升级成初中生高中生的水平，但还需要CPU来把数据喂到嘴边才能开始干活，究竟还是靠CPU来管的。</p>
]]></content>
      <categories>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>GPU, 图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>初探图形流水线（渲染管线）</title>
    <url>/2023/06/01/%E5%88%9D%E6%8E%A2%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E6%B5%81%E6%B0%B4%E7%BA%BF%EF%BC%88%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%EF%BC%89/</url>
    <content><![CDATA[<h1 id="什么是图形流水线"><a href="#什么是图形流水线" class="headerlink" title="什么是图形流水线"></a>什么是图形流水线</h1><p>链接：</p>
<p><a href="https://zhuanlan.zhihu.com/p/137780634">猴子也能看懂的渲染管线（Render Pipeline） - 知乎 (zhihu.com)</a></p>
<p>一图流：</p>
<img src="/2023/06/01/%E5%88%9D%E6%8E%A2%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E6%B5%81%E6%B0%B4%E7%BA%BF%EF%BC%88%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%EF%BC%89/image-20230601195513975.png" alt="image-20230601195513975" style="zoom:80%;">

<span id="more"></span>

<img src="/2023/06/01/%E5%88%9D%E6%8E%A2%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E6%B5%81%E6%B0%B4%E7%BA%BF%EF%BC%88%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%EF%BC%89/image-20230602162311045.png" alt="image-20230602162311045" style="zoom:80%;">



<p>相关概念：</p>
<ul>
<li>显存<ul>
<li>GPU显存是一种高速缓存，用于存储图形处理器需要的数据。GPU显存是专门为图形处理器设计的，因此它具有比CPU内存更高的带宽和更低的延迟。GPU显存通常用于存储<strong>纹理、顶点数据、渲染目标和其他与图形相关</strong>的数据。</li>
</ul>
</li>
<li>渲染管线<ul>
<li>渲染管线是一种将<strong>3D场景转换为2D图像</strong>的过程，它包括<strong>几何处理、光照计算、纹理映射等多个阶段</strong>。这些阶段可以被分为<strong>顶点处理</strong>、<strong>光栅化</strong>和<strong>像素处理</strong>三个部分。</li>
</ul>
</li>
<li>渲染图元<ul>
<li>渲染图元是指在图形处理流水线中的基本图形单元，例如点、线和三角形。在渲染过程中，这些基本图形单元被组合成更复杂的几何体，例如多边形和曲面。这些几何体可以被进一步处理，例如进行光照计算、纹理映射等操作。最终，这些几何体被转换为像素，并在屏幕上显示出来。</li>
</ul>
</li>
<li>顶点<ul>
<li>在图形处理流水线中，顶点是指几何体的基本构成单元。在三维图形中，顶点通常由三个浮点数表示，分别表示顶点的x、y和z坐标。在渲染过程中，顶点被组合成更复杂的几何体，例如多边形和曲面。这些几何体可以被进一步处理，例如进行光照计算、纹理映射等操作。最终，这些几何体被转换为像素，并在屏幕上显示出来。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>图形学, 渲染管线</tag>
      </tags>
  </entry>
  <entry>
    <title>珍惜时间</title>
    <url>/2023/02/12/%E5%90%B8%E5%8F%96%E6%95%99%E8%AE%AD/</url>
    <content><![CDATA[<p><a href="https://www.bilibili.com/video/BV1YR4y187Dw/?spm_id_from=333.1007.tianma.2-1-4.click&vd_source=c36c31c15822f9e983f85418bfdcddd9">如何欺骗大脑爱上做困难的事 远离超量多巴胺让你沉迷学习</a></p>
<p>现在是2023年2月12日，凌晨1：33…</p>
<p>临近大三下学期开学，目前三线作战，一条线是考试复习，一条线是SRP项目，一条线是实习秋招。感觉时间非常紧张，精神压力也非常大。甚至考试上已经放弃了某一难啃的科目。</p>
<p>那么时间为什么又会如此紧迫？</p>
<span id="more"></span>

<br>

<br>

<br>

<p>这里需要展开一场自我反思</p>
<br>

<br>

<br>

<br>

<h2 id="拷打FW"><a href="#拷打FW" class="headerlink" title="拷打FW"></a>拷打FW</h2><h3 id="一事无成"><a href="#一事无成" class="headerlink" title="一事无成"></a>一事无成</h3><p>其实我是很早就了解到大学应该做什么的（可惜不知道具体该如何去做）。在<strong>大一上学期，差不多2020年10月份的时候</strong>，已经有学长指明了三条路：1.竞赛（CTF，ACM…） 2.工作（尽早去实习） 3.绩点科研（搞成绩以及进实验室）</p>
<br>

<p><strong>竞赛：</strong></p>
<p>那时候又刚好听了CTF的讲座，于是心中默认自己以后要走安全路线。可惜我太高估自己了，选择了pwn路线来入门CTF。因为很多前置知识都没学过，也不知道要去学，去哪学，也就没有一个循序渐进的学习过程，所以就学不下去了。</p>
<p>连一点语言基础、操作系统方面的知识都没有，所以看那些什么虚拟地址空间、段、函数引用表等词汇完全没有概念，即使是到网上查资料看视频，也很难消化进去。比起艰难地去理解一些新概念，打游戏实在爽快多了，所以我也就没有学下去了。（现在想想，当时也不太会检索信息）</p>
<br>

<p>到了大二自己还是有一点这方面的想法，也稍微付出了多一点的时间，浅浅地捡了一点东西，去应付招新的事。结果，花的时间和学的东西还是太少了，只能用特殊方式入队。</p>
<p>入队后，又没有驱动力去学了，就一直搁置着，后面也没有参加过一次比赛。</p>
<br>

<p>现在回想，也许我应该选一个简单一点的方向，或者是，学的时候直接从解题入手，边做题边学新概念。在学习过程中，以解出题目作为激励，或许我就能学的下去，从而形成一个良性循环。</p>
<p>不过还是得怪自己太懒了。</p>
<p><br><br></p>
<p><strong>工作：</strong></p>
<p>当时，我默认自己不读研，本科毕业就工作。所以我应该是尽早往工作路线靠拢，但是，那会儿实在是不知道要学什么方向。</p>
<p><strong>开始的开始</strong></p>
<p>真正开始学习计算机之前，也就是中学时期，我因为喜欢玩各种单机游戏，就曾有过日后做一名游戏开发者的想法。在高考完的暑假，我也买了一本C语言的教材。可惜当时并不知道怎么学习这些东西，还按照高中的学习方式，学一点就记一点（比如C语言的关键字还要列出来然后去背…），导致效率很低。于是没学多少就没一点兴趣了（好像也没那么少，可惜没有进度没有推到内存管理和网络编程相的部分）。unity也不知道因为什么始终没有开始学。</p>
<blockquote>
<p>翻看了那时候的笔记，感觉那是高考结束到目前为止，自己最认真学习的一段时间了，泪目啊</p>
<p>好恨啊，如果当时的学习方式对了，后面这几年应该会顺利很多</p>
</blockquote>
<p>又因为中学过得太憋屈了，加上自控力差，高考完的那个暑假就疯狂的玩。当时我对未来十分憧憬、充满动力，然而这些还是没能变成我的自制力。</p>
<br>

<p><strong>路线</strong></p>
<p>到后来，每一年，每一学期，都会更新自己的方向。一会儿是游戏开发，一会儿是Linux C++，一会儿是信息安全，一会儿是区块链。看到网上的一些信息，就会影响自己的心态，忧虑这个那个。再加上我的学习方式不正确，就导致什么都没有学好。</p>
<br>

<p><strong>数据结构与算法</strong></p>
<p>大一寒假（两年前），有学长告诉我们得趁早刷题，可惜我当时不了解这方面的重要性，以及该如何去学，答案稍微看不懂，就不想学了。也不知道原来平时C++上机的内容，就是一些数据结构和算法题。每次只能看着大神们30分钟解决战斗，潇洒离开机房，而自己只有羡慕的份。</p>
<p>在数据结构和算法题这方面，后面又是因为学习方式不对，搁置了很长一段时间（还有自己懒惰）。</p>
<p>直到最近换了方式，先分类，然后边做题边看别人的总结，才顺利起来。</p>
<br>

<p><strong>编程语言</strong></p>
<p>这个应该是我大三之前就要掌握好的。</p>
<p>大一的时候决定要学C++，可惜，学了基本语法和一点点面向对象、泛型编程之后就停了，也就是学完课本上的一点东西就停了。还记得两年前的寒假，我在艰难地翻看C++课本，因为太关注那些语法规则，那些细枝末节，导致因小失大，学得很难受而学不下去。</p>
<p>又因为课本上没有STL的内容，STL的东西也没学到。</p>
<p>也不知道有系统编程，网络编程这些东西，虽然那会儿还没学操作系统和计算机网络。我要是能够意识到这两点，就应该早点自学操作系统和计算机网络，不用等到大二下学期才去学。</p>
<p>还有应该面向项目来学习编程语言，在学语言的同时，又能掌握工程技能。可惜自己太懒，浅学即止。</p>
<p>到现在因为要找实习找工作，需要项目经验，才从网上找视频一步一步跟着构建。对了，在项目选择这方面，我又浪费了不少时间。</p>
<p>除了做项目，C++其实还有好多需要学的，哎…</p>
<br>

<br>

<p><strong>本科学习</strong></p>
<p>这是我在选择摆烂的同时，又不愿放弃的东西。</p>
<p>大一上学期玩得很嗨，把学分最高的两门数学可都丢了。</p>
<p>大一下学期，稍微知耻而后勇了一点，但是还是把学分最高的数学丢了。并且该学好的专业课，也没好好学。</p>
<p>大二上学期（大一虽然浪飞了，但是分流后的排名也不是说毫无保研希望），于是就想在这方面努力一点，最后这学期的成绩总体也还不错，但还是够高，某些科目拖了后腿。分析原因，主要还是因为自己贪玩，没有花足够的时间学习。</p>
<p>大二下学期，明显后劲不足了，但是三门专业课都还行，就计算机网络稍微拖了一点后腿（这时候还没意识到计网的重要性），政治课成绩掉大分。</p>
<p>大三上学期，现在正在复习的。其实一开始还是打算好好学，然而还是第n次虎头蛇尾。有一个原因是因为自己选的课太多，但也只是我的借口罢了。</p>
<br>

<p>为什么说不愿放弃：因为对于主要科目，我在学习的时候都会做好很多笔记，包括大一被我丢掉的数学分析、线性代数。</p>
<p>为什么又说是摆烂：虽然做了笔记，但是，就仅限于笔记。该刷题的科目，我几乎都没有刷题；该深入实践的科目，我都是应付任务。</p>
<p>最后成绩不上不下，不下是因为我确实学了，不上是因为我没有花更多时间去加强我学的东西。</p>
<p>其实想要分数更高，只要再多刷一点题就行了，笔记甚至也可以不做。而我在笔记上面花费了大量时间，最后也没有好好利用笔记去提高分数（但保住了下限），只能说怪谁呢？怪自己SB，认命了。</p>
<br>

<br>

<br>

<br>

<h3 id="时间都去哪了"><a href="#时间都去哪了" class="headerlink" title="时间都去哪了"></a>时间都去哪了</h3><p>上了大学后，我生活的各项内容占比，大概是：</p>
<p>（计算方式： 实际时间*权值）</p>
<ol>
<li>打游戏</li>
<li>踢球</li>
<li>刷视频，刷知乎</li>
<li>学习</li>
</ol>
<br>

<p>这个权值，可以认为是实际做事时的优先级</p>
<p>权值排行：</p>
<p>top1 踢球</p>
<p>top2 打游戏</p>
<p>top3 刷视频，刷知乎</p>
<p>top4 学习</p>
<p>而我认为的，正确的优先级排行应该是：</p>
<p>top1 学习</p>
<p>top2 踢球</p>
<p>top3 打游戏</p>
<p>top4 刷视频，刷知乎</p>
<br>

<p>实际时间排行:</p>
<ol>
<li>学习（上课）</li>
<li>打游戏</li>
<li>踢球</li>
<li>学习（课后）or 刷视频，刷知乎</li>
</ol>
<br>

<br>

<p><strong>关于游戏：</strong></p>
<p>有很多个晚上，我在宿舍里快乐开黑打 LOL ，可以从六七点打到九点十点，或者是从九点十点，打倒十二点断网。如果是白天，可以打一整个下午。只要是开始了游戏，就会持续很久，没有说打一把两把就关了的。除了LOL，又有很多时间贡献给了 Planeside2，骑马与砍杀，饥荒……</p>
<p>我知道自己深陷其中，也尝试过很多次物理戒断，但是一直不能解决这个问题。把这个游戏卸载了，过段时间就会去玩没有卸载地游戏。把所有游戏都卸载了，过段时间又会忍不住重新下回来一个。每次破戒，都会破得很彻底。</p>
<p>也许根本原因在于自制力不足，我习惯了中学时期的种种约束，现在给予了我足够的自由，我却不能够合理地去发展。</p>
<br>

<p><strong>关于踢球：</strong></p>
<p>虽然说运动强身健体，但是踢球确实占据了我不少时间和精力。每次踢球，一般是从四五点，踢到六七点，然后吃饭、洗澡、歇息，一晃就八点多九点多，也快半天时间。而且踢完球了，一般也提不起学习的念头，就又是游戏，短视频…</p>
<p>一周多则踢个3次4次，少则1次2次，时间也就这么消失了。</p>
<br>

<p><strong>关于刷视频：</strong></p>
<p>这个没什么好说的，手机打开，只要一点进去，时间就消失了。尤其是微信视频号，毫无营养的视频非常多，但却能让我在半夜刷上一两个小时。因为太容易点到这个玩意儿了，现在我已经把视频号给撤了。</p>
<p>另外就是B站，知乎…很多没意义没营养的内容，都消耗了我不少时间。并且，知乎的很多负能量在不经意间击碎了我对未来的憧憬，陡增焦虑。</p>
<br>

<p><strong>剖析每一天的时间：</strong></p>
<p>每学期都有一段时间课比较多，一段时间没什么课</p>
<ul>
<li>有课：获得逃课技能之前，上完课之后的时间，几乎都不想学习。习得逃课技能之后，该逃不该逃的课也都逃过了，逃了之后有去自学的，也有去游戏人生的，还有去踢球的…</li>
<li>没课：没课一般是中午起床，吃个饭之后就一点多了。这个时候要么会犯困（奇了怪了），要么没忍住点开了游戏，通常来说一下午就又没了。如果衔接踢球的话，这一天就没了。衔接学习的话，多半是在完成作业什么的，完成任务罢了。到了比较晚的时候，就轮到短视频、新媒体什么的来抢占我的时间了。</li>
</ul>
<br>

<p><strong>再仔细回想，发现我用来学习的时间几乎都在深夜。好像只有在这个时候我才能保持专注，才能进入状态。</strong></p>
<p>浪费了一天的时间后，夜里常常感到愧疚。这个时候我就有动力学习了，而一旦进入状态，我就舍不得去睡觉。或许这就是我深夜学习的原因。</p>
<br>

<p><strong>放长假：</strong></p>
<p>每个假期都会带几本书回家，然而一点也没看。</p>
<p>在家里就是阴间作息+游戏人生。完全没有考虑学习什么的，有的话也是浅尝即止，觉得香不过游戏。</p>
<p>直到这个寒假的前2&#x2F;3部分，也还是如此。虽然刚回家的那几天都有刷题。</p>
<p>到现在因为面临春招实习的压力（很可能寄了，来不及），这段时间才开始猛学，才开始追悔莫及。</p>
<br>

<br>

<p>就像我在一天中的深夜里学习一样，在某些时间段的尾段，我也是冲刺地学习。这并不是一个好的现象和方式，因为情况通常都是时间不够充裕，大脑不能稳定和冷静地运行。冲刺式的学习不能够深入知识和技术，通常只是以应付任务作为目的，达到应付任务的效果。</p>
<br>

<p>这样子的一天一天连在一起，就成了我不堪回首的大学时光。（虽然也就过了5&#x2F;8，还有一点抢救的机会）</p>
<br>

<br>

<br>

<h3 id="为什么会这样"><a href="#为什么会这样" class="headerlink" title="为什么会这样"></a>为什么会这样</h3><p>不妨回忆一下高中生涯，跟现在很相似。高一高二处于半摆烂状态，高三开始冲刺，就像我半摆烂到现在开始冲刺。高三冲刺到最后填平了前面摆烂挖的坑，结果也还不错。而现在，我实在不敢去奢求未来有多好的结果，只要不是烂果就行了。但是冲刺不能停，这点必须时刻提醒自己。</p>
<br>

<p>这种 半摆烂+冲刺 现象的成因如何解释。</p>
<ul>
<li><p>先说为什么会出现冲刺：时间临近终点，即将取得某种结果。此时，我会明确的希望自己能达到什么层次，确定自己的风格路线，并去了解应该如何去实现目标。</p>
<ul>
<li><p>概括下来就是：</p>
<p>​	一定的野心 + 明确的目标 + 合适的方法</p>
<p>分析高三冲刺：</p>
<p>​	希望中学生涯有个好的结尾  + 92计算机专业 + 学习方法比较正确</p>
<p>分析现在的冲刺：</p>
<p>​	希望毕业有个匹配的工作 + C++服务器开发 + 我不好说</p>
</li>
</ul>
</li>
<li><p>再说为什么会半摆烂：无非就是，没有明确的目标，学习方式不对，迷茫，没有动力，自制力不足，玩心太重…</p>
</li>
</ul>
<br>

<p>补救措施：</p>
<ul>
<li>目标，现在有了</li>
<li>路线，有了</li>
<li>学习方式，这个感觉得参考别人了</li>
<li>动力，压力都变成动力了</li>
<li>自制力，只能改，从好习惯开始</li>
<li>玩心重，不敢玩了</li>
</ul>
<p>还有一个，自我监督。</p>
<br>

<br>

<h3 id="以后怎么办"><a href="#以后怎么办" class="headerlink" title="以后怎么办"></a>以后怎么办</h3><p>高三和现在又有些许不同：高三靠约束，现在靠自律；高三有贵人相伴，现在孤身奋战。约束养不成我的自控力，但代替了我的自控力；而贵人在我低落的时候给了我不少鼓励，在我松懈的时候给了我十足的动力。而目前形势严峻。</p>
<p>我不好说未来会是什么结果，只能再次提醒自己，冲刺不能停。</p>
<p>还有就是，吸取教训。不要过了这个坎，就觉得万事大吉，等到下一个坎到来，又像现在这样猴急。</p>
<p>先从养成习惯开始吧，两个目标：<strong>规律作息，按时三餐</strong>。</p>
<img src="/2023/02/12/%E5%90%B8%E5%8F%96%E6%95%99%E8%AE%AD/image-20230212062855952.png" alt="image-20230212062855952">

<br>

<p>今晚无论有什么事情没做，也要在12点前熄灯睡觉</p>
<br>

<br>

<br>

<br>

<br>

<p>而现在是2023年2月12日，早上6点27。本来是想反思一下自己的拖延症和网瘾，一不小心反思了一个晚上。</p>
]]></content>
      <categories>
        <category>反思录</category>
      </categories>
      <tags>
        <tag>时间</tag>
        <tag>拷打</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用UDP做到TCP的效果</title>
    <url>/2023/05/11/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8UDP%E5%81%9A%E5%88%B0TCP%E7%9A%84%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<h1 id="使用UDP做到TCP的效果"><a href="#使用UDP做到TCP的效果" class="headerlink" title="使用UDP做到TCP的效果"></a>使用UDP做到TCP的效果</h1><p>图片和部分文字来自<a href="https://xiaolincoding.com/network/3_tcp/quic.html#quic-%E5%AF%B9%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%94%B9%E8%BF%9B">4.17 如何基于 UDP 协议实现可靠传输？ | 小林coding (xiaolincoding.com)</a></p>
<hr>
<p>即基于UDP协议实现<strong>可靠传输</strong>，以 <strong>QUIC</strong> 协议为例</p>
<p>TCP存在的几个问题：</p>
<ul>
<li>需要建立连接，会产生<strong>延迟</strong></li>
<li>Http2及之前的版本使用TCP存在<strong>队头阻塞</strong></li>
<li><strong>网络迁移</strong>需要重新建立连接</li>
</ul>
<span id="more"></span>

<p>QUIC需要实现的效果：</p>
<ul>
<li>可靠传输</li>
<li>解决队头阻塞</li>
<li>流量控制</li>
<li>拥塞控制</li>
<li>更快的建立连接</li>
<li>迁移连接</li>
</ul>
<h2 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h2><p>在应用层下功夫：</p>
<p><img src="/2023/05/11/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8UDP%E5%81%9A%E5%88%B0TCP%E7%9A%84%E6%95%88%E6%9E%9C/image-20230512223729083.png" alt="image-20230512223729083"></p>
<p>以 HTTP3.0 为例：</p>
<p>UDP格式照旧，但是<strong>UDP的数据内容</strong>则包含了多层用户层的协议数据：QUIC包、QUIC帧、最后才是HTTP&#x2F;3的帧。</p>
<h3 id="QUIC-Packet-header"><a href="#QUIC-Packet-header" class="headerlink" title="QUIC Packet header"></a>QUIC Packet header</h3><p>分为</p>
<ul>
<li><p><strong>Long</strong> Packet header <strong>首次建立连接</strong></p>
<ul>
<li><strong>源连接ID</strong>、<strong>目标连接ID</strong></li>
</ul>
</li>
<li><p><strong>Short</strong> Packet header <strong>日常传输数据</strong></p>
<ul>
<li><strong>目标连接ID</strong></li>
<li>编号 Packet Number，类似seq，但是<strong>严格单调递增</strong>，数据发生重传也使用递增的编号（可以通过ACK的不同判定是哪个重传的包还是原始包被收到了，便于计算 RTT ）</li>
<li>数据负载</li>
</ul>
</li>
<li><p>需要 <strong>三次握手</strong> ，协商<strong>连接ID</strong>。</p>
</li>
<li><p>后续发送数据只需要指定目标连接ID。</p>
</li>
<li><p>编号<strong>单调递增</strong>，使得支持<strong>乱序确认</strong></p>
</li>
<li><p>编号单调递增，使得发生重传时，窗口可以继续移动，解决队头阻塞</p>
</li>
</ul>
<h3 id="QUIC-Frame-header"><a href="#QUIC-Frame-header" class="headerlink" title="QUIC Frame header"></a>QUIC Frame header</h3><p>QUIC帧放在QUIC包的数据负载部分。</p>
<p>Frame分有不同类型，各自有不同的格式和功能。</p>
<p>以 Stream 类型为例（类似HTTP&#x2F;2的Stream），一条<strong>Stream</strong>对应一次<strong>HTTP请求和响应</strong>，格式包含：</p>
<ul>
<li>Stream <strong>ID</strong></li>
<li><strong>Offset</strong>，类似seq</li>
<li><strong>Length</strong></li>
<li>数据负载</li>
</ul>
<p>通过 <strong>Stream ID + Offset</strong> 来体现<strong>数据的有序性</strong>，标识具体数据内容。</p>
<p>即 QUIC 通过<strong>单向递增的 Packet Number</strong>，配合 <strong>Stream ID 与 Offset</strong> 字段信息，可以<strong>支持乱序确认</strong>而不影响数据包的<strong>正确组装</strong>。</p>
<h2 id="解决队头阻塞"><a href="#解决队头阻塞" class="headerlink" title="解决队头阻塞"></a>解决队头阻塞</h2><p><strong>接收窗口</strong>的队头阻塞。</p>
<p>若有<strong>数据丢失</strong>，或者是<strong>乱序</strong>，TCP只有在处理完丢失或未收到的数据之后，才能继续移动窗口。</p>
<p>于是在一段时间内，<strong>接收窗口停留</strong>，导致后面的数据无法接收，造成队头阻塞。</p>
<p>HTTP&#x2F;2 的Stream是在TCP基础之上，将一次HTTP请求和响应抽象成一条Stream，通过Stream ID标识。</p>
<p>对于并发的HTTP请求和响应，<strong>不同的Stream</strong>可以<strong>乱序</strong>发送和接收，<u>而<strong>每条Stream内的数据</strong>则需要保证<strong>有序</strong>发送和接收。</u></p>
<p>因为<strong>多条Stream会共用一条TCP连接</strong>，如果某一条Stream出现阻塞，则会阻塞整个TCP连接的窗口，造成队头阻塞。</p>
<p>HTTP&#x2F;3使用QUIC之后，每条Stream内的数据也可以做到乱序的接收（并进行有序的重组）。（通过 递增编号 和 Stream ID+Offset 机制实现）</p>
<p>QUIC为每条Stream都建立了一个窗口，则当某条Stream出现阻塞，只有一个窗口停滞，其他Stream的窗口还还能继续接收数据。</p>
<h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>接收方通过：</p>
<ul>
<li>window_update Frame 告知窗口大小</li>
<li>Block Frame 告知窗口关闭</li>
</ul>
<p>两种级别的流量控制：</p>
<ul>
<li><strong>Stream</strong> 级别：<ul>
<li>Stream 可以认为就是一条 HTTP 请求，每个 Stream 都有独立的滑动窗口，所以每个 Stream 都可以做流量控制，防止单个 Stream 消耗连接（Connection）的全部接收缓冲。</li>
</ul>
</li>
<li><strong>Connection</strong> 级别<ul>
<li>限制连接中所有 Stream 相加起来的总字节数，防止发送方超过连接的缓冲容量。</li>
</ul>
</li>
</ul>
<p>Connection级别限制了连接的总流量，Stream级别保证了流量的分配均匀。</p>
<h3 id="Stream-级"><a href="#Stream-级" class="headerlink" title="Stream 级"></a>Stream 级</h3><p><strong>接收方</strong>：</p>
<img src="/2023/05/11/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8UDP%E5%81%9A%E5%88%B0TCP%E7%9A%84%E6%95%88%E6%9E%9C/image-20230513140555364.png" alt="image-20230513140555364" style="zoom:80%;">

<p><strong>发送方</strong>：</p>
<p><img src="/2023/05/11/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8UDP%E5%81%9A%E5%88%B0TCP%E7%9A%84%E6%95%88%E6%9E%9C/image-20230513142006952.png" alt="发生重传"></p>
<p>上面的数字是 <strong>编号</strong></p>
<p>控制数据发送的唯一限制就是<strong>最大绝对字节偏移量</strong>，该值是接收方基于当前已经提交的偏移量（连续已确认并向上层应用提交的数据包offset）和发送方协商得出。</p>
<h3 id="Connection-级"><a href="#Connection-级" class="headerlink" title="Connection 级"></a>Connection 级</h3><img src="/2023/05/11/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8UDP%E5%81%9A%E5%88%B0TCP%E7%9A%84%E6%95%88%E6%9E%9C/image-20230513142217715.png" alt="image-20230513142217715" style="zoom:80%;">

<p>可用窗口大小就是各个Stream可用窗口大小之和。</p>
<ul>
<li>各个Stream的流量不超过各个Stream窗口</li>
<li>所有Stream的流量不超过Connection窗口</li>
</ul>
<h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>参照TCP的拥塞控制，但QUIC可以作更多改进，且更容易进行修改和普及应用。</p>
<ul>
<li>TCP 更改拥塞控制算法是对系统中所有应用都生效，无法根据不同应用设定不同的拥塞控制策略。</li>
<li>但是因为 QUIC 处于应用层，所以就<strong>可以针对不同的应用设置不同的拥塞控制算法</strong>，这样灵活性就很高了</li>
</ul>
<h2 id="快速建立连接"><a href="#快速建立连接" class="headerlink" title="快速建立连接"></a>快速建立连接</h2><p>对于HTTP：</p>
<ul>
<li><p>HTTP&#x2F;3之前的连接建立：TCP三次握手+TLS四次握手</p>
</li>
<li><p>QUIC建立连接只需一次握手</p>
</li>
</ul>
<p><strong>HTTP&#x2F;3的 QUIC 内部包含了 TLS</strong>，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商，甚至在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果。</p>
<h2 id="迁移连接"><a href="#迁移连接" class="headerlink" title="迁移连接"></a>迁移连接</h2><ul>
<li><p>TCP连接 是通过四元组来标识通信两端，若网络环境发生变化导致IP或端口改变，则需要重新建立连接，代价较高。</p>
</li>
<li><p>QUIC 通过<strong>连接 ID</strong>来标记通信两端，连接建立时双方协商好各自的 <strong>连接ID</strong>。当网络环境变化时，只要仍保有<strong>上下文信息</strong>（比如<strong>连接 ID</strong>、<strong>TLS 密钥</strong>等），就可以“无缝”地复用原连接，消除重连的成本，达到了<strong>连接迁移</strong>的功能。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
        <category>UDP</category>
      </categories>
      <tags>
        <tag>TCP, UDP</tag>
      </tags>
  </entry>
  <entry>
    <title>异常的分类和处理</title>
    <url>/2024/01/11/%E5%BC%82%E5%B8%B8%E7%9A%84%E5%88%86%E7%B1%BB%E5%92%8C%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="异常的分类"><a href="#异常的分类" class="headerlink" title="异常的分类"></a>异常的分类</h2><br>

<h3 id="异常分类和处理思路"><a href="#异常分类和处理思路" class="headerlink" title="异常分类和处理思路"></a>异常分类和处理思路</h3><ul>
<li><p><strong>网络异常</strong>：如连接超时、连接中断、DNS解析失败等。</p>
<ol>
<li><strong>错误重试</strong>：对于临时性的网络异常，可以尝试重新执行失败的操作，如重新建立连接或重新发送请求。</li>
<li><strong>超时设置</strong>：为网络操作设置合理的超时时间，当操作耗时超过设定的阈值时，应该放弃当前操作并进行适当的处理。</li>
<li><strong>断线重连</strong>：针对长连接的情况，当检测到连接断开时，可以尝试自动重新建立连接，以保持与服务端的通信。</li>
<li><strong>异常通知</strong>：将网络异常信息记录下来，并向相关人员发送通知，以便及时发现和处理潜在的问题。</li>
<li><strong>降级处理</strong>：对于一些关键操作，可以提供备用方案或者降级处理，以确保系统在部分网络异常的情况下仍能够正常运行。</li>
<li><strong>连接池管理</strong>：对于频繁建立连接的场景，使用连接池可以减少连接建立的开销，同时在连接出现问题时能够及时进行回收和重建。</li>
<li><strong>异常捕获和处理</strong>：在代码中合理捕获网络相关异常，并进行适当的处理，包括错误日志记录、资源释放等。</li>
</ol>
<br>

<span id="more"></span>
</li>
<li><p><strong>数据库异常</strong>：包括连接失败、查询错误、事务处理问题等。</p>
<ul>
<li><strong>连接失败</strong>：实施连接池技术，通过合适的配置和管理来减少连接失败的可能性，并在连接失败时进行重试操作。另外，确保数据库连接字符串配置正确，以避免连接失败。</li>
<li><strong>查询错误</strong>：编写健壮的SQL查询语句，进行输入验证和参数化查询，以防止SQL注入攻击，并通过合适的异常处理机制来捕获并处理查询错误。</li>
<li><strong>事务处理问题</strong>：使用数据库事务来确保原子性、一致性、隔离性和持久性（ACID特性），并在遇到事务处理问题时实施适当的回滚操作或补偿措施，以维护数据的完整性。</li>
<li><strong>连接超时和资源释放</strong>：设置合理的数据库连接超时时间，及时释放数据库连接以避免资源泄露。同时，使用try-with-resources或类似的语言特性来确保在使用后关闭数据库连接和释放相关资源。</li>
<li><strong>监控和报警</strong>：建立数据库性能监控系统，追踪数据库连接池的使用情况、查询性能等指标，并设置报警规则以便及时发现潜在的数据库异常情况。</li>
<li><strong>日志记录</strong>：在应用程序中添加适当的日志记录，记录数据库操作的详细信息，以便在发生异常时进行故障诊断和排查。</li>
</ul>
<br>
</li>
<li><p><strong>文件系统异常</strong>：例如文件不存在、权限不足、IO错误等。</p>
<br>
</li>
<li><p><strong>代码逻辑异常</strong>：由于程序设计或实现问题引起的异常，比如空指针引用、数组越界等。</p>
<ul>
<li><strong>代码审查</strong>：定期进行代码审查，特别关注潜在的空指针引用、数组越界等问题。通过同行评审或利用静态代码分析工具来发现可能存在的问题。</li>
<li><strong>输入验证</strong>：对外部输入数据进行严格验证，确保输入符合预期的格式和范围。这可以有效防止数组越界等问题。</li>
<li><strong>异常处理</strong>：在代码中增加适当的异常处理机制，捕获并处理可能导致空指针引用或数组越界的情况，以避免程序崩溃。</li>
<li><strong>单元测试</strong>：编写全面的单元测试用例，覆盖各种边界条件和异常情况，以确保代码在面对异常时能够正确处理。</li>
<li><strong>日志记录</strong>：在程序中添加适当的日志记录，可以帮助开发人员追踪程序执行过程中出现的异常情况，以便快速定位和修复问题。</li>
</ul>
<br>
</li>
<li><p><strong>第三方服务异常</strong>：调用外部服务时出现的异常，如API调用失败、认证问题等。</p>
<ul>
<li><strong>异常捕获和日志记录</strong>：在调用第三方服务的地方，使用合适的异常处理机制来捕获异常，并将异常信息作为日志记录下来，以便后续的分析和研究。</li>
<li><strong>重试机制</strong>：当第三方服务发生异常时，可以尝试进行重试操作。重试的次数和时间间隔可以根据具体情况进行调整。使用指数退避算法，逐渐增加重试间隔时间，可以避免过度压力和频繁调用外部服务。同时，需要控制重试次数，以免无限制地重试导致系统资源耗尽。</li>
<li><strong>用户友好的错误提示</strong>：对于用户发起的请求，如果第三方服务发生异常，需要向用户展示有意义的错误提示信息，以便用户理解和解决问题。可以根据异常类型返回相应的错误码和错误信息，或提供相关的解决方法。</li>
<li><strong>降级处理和备选方案</strong>：当第三方服务无法正常提供服务时，可以考虑降级处理，使用备选方案或本地缓存数据来代替。例如，如果某些服务不可用，可以使用默认值或预先缓存的数据进行响应，以保持系统的可用性。</li>
<li><strong>监控和报警</strong>：及时监控第三方服务的可用性和性能，通过合适的监控系统来收集指标数据，识别潜在的问题和风险。当发生异常时，触发报警机制，及时通知相关团队进行处理和恢复。</li>
</ul>
<br>
</li>
<li><p><strong>资源耗尽异常</strong>：内存、CPU、线程池等资源耗尽导致的异常。</p>
<ul>
<li><strong>异常处理与回滚</strong>：当发生资源耗尽异常时，可以先捕获异常并进行相应的处理。可能的处理方式包括中止当前操作，回滚事务，释放资源，关闭连接等。这样可以尽量避免异常向上传递，导致更严重的问题。</li>
<li><strong>重新分配资源</strong>：对于发生资源耗尽的情况，可以考虑重新分配或增加资源。例如，增加服务器的内存，增加线程池的大小，使用更高配置的硬件等。然后重新启动系统，并确保资源得到合理分配，以避免资源耗尽重复发生。</li>
<li><strong>快速定位问题原因</strong>：对于资源耗尽，需要迅速定位具体的原因。可以通过查看系统日志、监控工具和性能分析工具等来定位导致资源耗尽的具体原因，例如错误的配置、持续高负载、死锁等。</li>
<li><strong>限制资源使用量</strong>：通过调整相应的配置参数，限制系统的资源使用量。例如，降低线程池的大小，限制请求的并发数，设置合理的内存使用上限等。这样可以在资源耗尽异常发生时，避免进一步的资源浪费。</li>
</ul>
<br>
</li>
<li><p><strong>安全异常</strong>：包括拒绝访问、未经授权的操作等安全相关异常。</p>
</li>
</ul>
<br>

<h3 id="异常捕获和处理方式"><a href="#异常捕获和处理方式" class="headerlink" title="异常捕获和处理方式"></a>异常捕获和处理方式</h3><p><strong>使用 exception 机制</strong></p>
<ol>
<li>Try-Catch语句：使用try块包围可能引发异常的代码，然后使用catch块捕获并处理相应的异常。</li>
<li>Finally块：可以在try-catch结构中添加finally块，无论是否发生异常，其中的代码都会被执行，通常用于资源清理等操作。</li>
<li>异常类型匹配：针对不同类型的异常，可以使用多个catch块进行捕获和处理，以执行针对特定异常类型的特定逻辑。</li>
<li>抛出异常：在遇到无法处理的情况下，可以通过throw语句主动抛出异常，以通知调用者或上层代码出现了问题。</li>
<li>异常链传递：在捕获异常后，可以选择将当前异常封装在新的异常中并重新抛出，以保留原始异常信息，并让调用者能够更清晰地了解异常发生的上下文。</li>
<li>自定义异常：针对特定业务场景，可以创建自定义的异常类来标识和处理特定的异常情况，使得异常处理更加具体和精确。</li>
<li>异常处理策略：针对不同类型的异常，可以采取不同的处理策略，如重试、回滚、记录日志、通知相关人员等。</li>
</ol>
<p><strong>不使用 exception 机制</strong></p>
<ol>
<li>返回错误码或错误状态：在函数或方法调用发生异常时，返回一个特定的错误码或错误状态，由调用方来检查并处理异常情况。</li>
<li>回调机制：通过回调函数或回调接口将异常信息传递给调用方，让调用方自行处理异常情况。</li>
<li>异步通知：使用异步通知机制，当发生异常时向相关组件或模块发送通知，由接收方来处理异常情况。</li>
<li>使用断言：在开发阶段通过断言来检查程序中的不变量和前置条件，以及对可能出现异常的地方进行预先检查。</li>
<li>使用条件判断语句：在执行关键操作之前，通过条件判断语句来检查输入参数、环境状态等，以避免可能引发异常的情况发生。</li>
</ol>
<br>

<br>

<h2 id="异常的传递（不使用-Try-Catch）"><a href="#异常的传递（不使用-Try-Catch）" class="headerlink" title="异常的传递（不使用 Try Catch）"></a>异常的传递（不使用 Try Catch）</h2><h3 id="网络层操作失败产生的异常"><a href="#网络层操作失败产生的异常" class="headerlink" title="网络层操作失败产生的异常"></a>网络层操作失败产生的异常</h3><p>此处以网络操作 connect 为例</p>
<h4 id="从网络库的操作开始往上看"><a href="#从网络库的操作开始往上看" class="headerlink" title="从网络库的操作开始往上看"></a>从网络库的操作开始往上看</h4><p>以使用 libuv 网络库中的 uv_tcp_connect 函数为例</p>
<ul>
<li>其返回值是一个 int，代表一个 error code，为0则表示成功，否则表示失败</li>
<li>error code 的值是事先定义好的</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">uv_tcp_connect</span><span class="params">(<span class="type">uv_connect_t</span>* req,</span></span><br><span class="line"><span class="params">                   <span class="type">uv_tcp_t</span>* handle,</span></span><br><span class="line"><span class="params">                   <span class="type">const</span> <span class="keyword">struct</span> sockaddr* addr,</span></span><br><span class="line"><span class="params">                   uv_connect_cb cb)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> addrlen;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (handle-&gt;type != UV_TCP)</span><br><span class="line">    <span class="keyword">return</span> UV_EINVAL;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (addr-&gt;sa_family == AF_INET)</span><br><span class="line">    addrlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (addr-&gt;sa_family == AF_INET6)</span><br><span class="line">    addrlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in6);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> UV_EINVAL;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> uv__tcp_connect(req, handle, addr, addrlen, cb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<br>

<p>上层的用户函数可能是一个 init() 函数，用来初始化一些网络资源</p>
<ul>
<li>用户使用时，根据 uv_tcp_connect 函数的返回值判断执行是否成功即可</li>
<li>此处使用 goto Exit0 转到单一出口处，进行用户 Init 函数中的错误处理，并通过 return false 返回用户函数的执行结果</li>
</ul>
<p><img src="/2024/01/11/%E5%BC%82%E5%B8%B8%E7%9A%84%E5%88%86%E7%B1%BB%E5%92%8C%E5%A4%84%E7%90%86/Users\kingsoft\Desktop\blog\mang959595.github.io\source_posts\异常的分类和处理.assets\image-20240111140902402.png" alt="image-20240111140902402"></p>
<p><img src="/2024/01/11/%E5%BC%82%E5%B8%B8%E7%9A%84%E5%88%86%E7%B1%BB%E5%92%8C%E5%A4%84%E7%90%86/Users\kingsoft\Desktop\blog\mang959595.github.io\source_posts\异常的分类和处理.assets\image-20240111141135793.png" alt="image-20240111141135793"></p>
<br>

<br>

<p>再往上层看调用了 Init() 函数的地方，这里是在一个断线重连的操作中调用了 Init() ，即函数 TryReconnect()</p>
<ul>
<li>通过判断Init()的结果，可以区分重连请求成功还是失败（此处并非真正的重连成功，只是connect请求成功。当连接建立时，会在 uv_tcp_connect 设置的回调函数中对连接结果进行判断和处理）</li>
<li>此处同样使用goto，对重连请求失败的情况进行处理，并将结果返回给再上一层</li>
</ul>
<p><img src="/2024/01/11/%E5%BC%82%E5%B8%B8%E7%9A%84%E5%88%86%E7%B1%BB%E5%92%8C%E5%A4%84%E7%90%86/Users\kingsoft\Desktop\blog\mang959595.github.io\source_posts\异常的分类和处理.assets\image-20240111141930566.png" alt="image-20240111141930566"></p>
<br>

<br>

<p>再往上一层看，哪里调用了 TryReconnect()，这里是在一个Update里面定期对掉线队列里的连接进行重连尝试</p>
<ul>
<li>但是这里是直接将重连函数结果丢弃了</li>
<li>结合前面来看，在 TryReconnect 函数里已经把失败情况下的连接重新加到了掉线队列里，所以此处丢弃 TryReconnect 结果是没问题的，但是最好还是判断一下并输出日志，方便查看情况。</li>
</ul>
<p><img src="/2024/01/11/%E5%BC%82%E5%B8%B8%E7%9A%84%E5%88%86%E7%B1%BB%E5%92%8C%E5%A4%84%E7%90%86/Users\kingsoft\Desktop\blog\mang959595.github.io\source_posts\异常的分类和处理.assets\image-20240111142939480.png" alt="image-20240111142939480"></p>
<br>

<br>

<h4 id="从网络库的操作开始往下看"><a href="#从网络库的操作开始往下看" class="headerlink" title="从网络库的操作开始往下看"></a>从网络库的操作开始往下看</h4><p>直接上代码</p>
<p>第一层</p>
<ul>
<li>主要是进行了一些条件、参数的判断和处理</li>
<li>然后调用第二层函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 顶层第一层</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">uv_tcp_connect</span><span class="params">(<span class="type">uv_connect_t</span>* req,</span></span><br><span class="line"><span class="params">                   <span class="type">uv_tcp_t</span>* handle,</span></span><br><span class="line"><span class="params">                   <span class="type">const</span> <span class="keyword">struct</span> sockaddr* addr,</span></span><br><span class="line"><span class="params">                   uv_connect_cb cb)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> addrlen;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (handle-&gt;type != UV_TCP)</span><br><span class="line">    <span class="keyword">return</span> UV_EINVAL;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (addr-&gt;sa_family == AF_INET)</span><br><span class="line">    addrlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (addr-&gt;sa_family == AF_INET6)</span><br><span class="line">    addrlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in6);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> UV_EINVAL;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> uv__tcp_connect(req, handle, addr, addrlen, cb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<br>

<p>第二层</p>
<ul>
<li>进行错误码的转换</li>
<li>调用第三层函数，获取其 error code 并按需转换</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第二层</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">uv__tcp_connect</span><span class="params">(<span class="type">uv_connect_t</span>* req,</span></span><br><span class="line"><span class="params">                    <span class="type">uv_tcp_t</span>* handle,</span></span><br><span class="line"><span class="params">                    <span class="type">const</span> <span class="keyword">struct</span> sockaddr* addr,</span></span><br><span class="line"><span class="params">                    <span class="type">unsigned</span> <span class="type">int</span> addrlen,</span></span><br><span class="line"><span class="params">                    uv_connect_cb cb)</span> &#123;</span><br><span class="line">  <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">  err = uv_tcp_try_connect(req, handle, addr, addrlen, cb);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">return</span> uv_translate_sys_error(err); <span class="comment">// 只是将一些系统错误码换成libuv的错误码</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<br>

<p>第三层</p>
<ul>
<li>真正进行底层的系统调用，包含各个过程的子函数</li>
<li>一般是直接返回各个过程中异常的错误码</li>
<li>也有不太一样的，比如 handle-&gt;delayed_error<ul>
<li>在 uv_tcp_try_bind 里面，WSAEADDRINUSE 错误是不直接返回错误码的，而是暂且认为 uv_tcp_connect 请求成功，并设置tcp句柄的 delayed_error ，最终在处理 pending req 时将错误信息传递到 uv_tcp_connect  请求设置的回调函数中进行处理</li>
<li><img src="/2024/01/11/%E5%BC%82%E5%B8%B8%E7%9A%84%E5%88%86%E7%B1%BB%E5%92%8C%E5%A4%84%E7%90%86/Users\kingsoft\Desktop\blog\mang959595.github.io\source_posts\异常的分类和处理.assets\image-20240111150833055.png" alt="uv_try_bind内部"></li>
<li><img src="/2024/01/11/%E5%BC%82%E5%B8%B8%E7%9A%84%E5%88%86%E7%B1%BB%E5%92%8C%E5%A4%84%E7%90%86/Users\kingsoft\Desktop\blog\mang959595.github.io\source_posts\异常的分类和处理.assets\image-20240111151150825.png" alt="回调函数"></li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第三层</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">uv_tcp_try_connect</span><span class="params">(<span class="type">uv_connect_t</span>* req,</span></span><br><span class="line"><span class="params">                              <span class="type">uv_tcp_t</span>* handle,</span></span><br><span class="line"><span class="params">                              <span class="type">const</span> <span class="keyword">struct</span> sockaddr* addr,</span></span><br><span class="line"><span class="params">                              <span class="type">unsigned</span> <span class="type">int</span> addrlen,</span></span><br><span class="line"><span class="params">                              uv_connect_cb cb)</span> &#123;</span><br><span class="line">  <span class="type">uv_loop_t</span>* loop = handle-&gt;loop;</span><br><span class="line">  TCP_INITIAL_RTO_PARAMETERS retransmit_ioctl;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span>* <span class="title">bind_addr</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">converted</span>;</span></span><br><span class="line">  BOOL success;</span><br><span class="line">  DWORD bytes;</span><br><span class="line">  <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 函数 1</span></span><br><span class="line">  err = uv__convert_to_localhost_if_unspecified(addr, &amp;converted);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">  <span class="keyword">if</span> (handle-&gt;delayed_error != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!(handle-&gt;flags &amp; UV_HANDLE_BOUND)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (addrlen == <span class="keyword">sizeof</span>(uv_addr_ip4_any_)) &#123;</span><br><span class="line">      bind_addr = (<span class="type">const</span> <span class="keyword">struct</span> sockaddr*) &amp;uv_addr_ip4_any_;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (addrlen == <span class="keyword">sizeof</span>(uv_addr_ip6_any_)) &#123;</span><br><span class="line">      bind_addr = (<span class="type">const</span> <span class="keyword">struct</span> sockaddr*) &amp;uv_addr_ip6_any_;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 函数 2</span></span><br><span class="line">    err = uv_tcp_try_bind(handle, bind_addr, addrlen, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">      <span class="keyword">return</span> err;</span><br><span class="line">    <span class="keyword">if</span> (handle-&gt;delayed_error != <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> out;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 异常情况</span></span><br><span class="line">  <span class="keyword">if</span> (!handle-&gt;tcp.conn.func_connectex) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!uv_get_connectex_function(handle-&gt;socket, &amp;handle-&gt;tcp.conn.func_connectex)) &#123;</span><br><span class="line">      <span class="keyword">return</span> WSAEAFNOSUPPORT;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* This makes connect() fail instantly if the target port on the localhost</span></span><br><span class="line"><span class="comment">   * is not reachable, instead of waiting for 2s. We do not care if this fails.</span></span><br><span class="line"><span class="comment">   * This only works on Windows version 10.0.16299 and later.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (uv__is_fast_loopback_fail_supported() &amp;&amp; uv__is_loopback(&amp;converted)) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;retransmit_ioctl, <span class="number">0</span>, <span class="keyword">sizeof</span>(retransmit_ioctl));</span><br><span class="line">    retransmit_ioctl.Rtt = TCP_INITIAL_RTO_NO_SYN_RETRANSMISSIONS;</span><br><span class="line">    retransmit_ioctl.MaxSynRetransmissions = TCP_INITIAL_RTO_NO_SYN_RETRANSMISSIONS;</span><br><span class="line">        <span class="comment">// 配置 TCP 初始重传超时和最大 SYN 重传次数等参数</span></span><br><span class="line">    WSAIoctl(handle-&gt;socket,</span><br><span class="line">             SIO_TCP_INITIAL_RTO,</span><br><span class="line">             &amp;retransmit_ioctl,</span><br><span class="line">             <span class="keyword">sizeof</span>(retransmit_ioctl),</span><br><span class="line">             <span class="literal">NULL</span>,</span><br><span class="line">             <span class="number">0</span>,</span><br><span class="line">             &amp;bytes,</span><br><span class="line">             <span class="literal">NULL</span>,</span><br><span class="line">             <span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line"></span><br><span class="line">  UV_REQ_INIT(req, UV_CONNECT);</span><br><span class="line">  req-&gt;handle = (<span class="type">uv_stream_t</span>*) handle;</span><br><span class="line">  req-&gt;cb = cb;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;req-&gt;u.io.overlapped, <span class="number">0</span>, <span class="keyword">sizeof</span>(req-&gt;u.io.overlapped));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 无法立即处理的错误，不直接返回错误码给上层</span></span><br><span class="line">  <span class="comment">// 这里是把请求塞到tcp句柄的待办队列里，等下一个loop的时候将请求取出来，调用回调进行最终的(错误)处理</span></span><br><span class="line">  <span class="keyword">if</span> (handle-&gt;delayed_error != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/* Process the req without IOCP. */</span></span><br><span class="line">    handle-&gt;reqs_pending++;</span><br><span class="line">    REGISTER_HANDLE_REQ(loop, handle, req);</span><br><span class="line">    uv_insert_pending_req(loop, (<span class="type">uv_req_t</span>*)req);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用 Windows API，这里应该是通过加载动态库来调用的</span></span><br><span class="line">  success = handle-&gt;tcp.conn.func_connectex(handle-&gt;socket,</span><br><span class="line">                                            (<span class="type">const</span> <span class="keyword">struct</span> sockaddr*) &amp;converted,</span><br><span class="line">                                            addrlen,</span><br><span class="line">                                            <span class="literal">NULL</span>,</span><br><span class="line">                                            <span class="number">0</span>,</span><br><span class="line">                                            &amp;bytes,</span><br><span class="line">                                            &amp;req-&gt;u.io.overlapped);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (UV_SUCCEEDED_WITHOUT_IOCP(success)) &#123;</span><br><span class="line">    <span class="comment">/* Process the req without IOCP. */</span></span><br><span class="line">    handle-&gt;reqs_pending++;</span><br><span class="line">    REGISTER_HANDLE_REQ(loop, handle, req);</span><br><span class="line">    uv_insert_pending_req(loop, (<span class="type">uv_req_t</span>*)req);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (UV_SUCCEEDED_WITH_IOCP(success)) &#123;</span><br><span class="line">    <span class="comment">/* The req will be processed with IOCP. */</span></span><br><span class="line">    handle-&gt;reqs_pending++;</span><br><span class="line">    REGISTER_HANDLE_REQ(loop, handle, req);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 这里返回API调用出错的 Windows 错误码</span></span><br><span class="line">    <span class="keyword">return</span> WSAGetLastError();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<p>感兴趣的可以看一下 libuv 对待办队列中的请求完成结果的处理</p>
<ul>
<li>这里会对 delayed_error 状态进行判断，取出err并传给回调函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">uv_process_tcp_connect_req</span><span class="params">(<span class="type">uv_loop_t</span>* loop, <span class="type">uv_tcp_t</span>* handle,</span></span><br><span class="line"><span class="params">    <span class="type">uv_connect_t</span>* req)</span> &#123;</span><br><span class="line">  <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">  assert(handle-&gt;type == UV_TCP);</span><br><span class="line"></span><br><span class="line">  UNREGISTER_HANDLE_REQ(loop, handle, req);</span><br><span class="line"></span><br><span class="line">  err = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (handle-&gt;delayed_error) &#123;</span><br><span class="line">    <span class="comment">/* To smooth over the differences between unixes errors that</span></span><br><span class="line"><span class="comment">     * were reported synchronously on the first connect can be delayed</span></span><br><span class="line"><span class="comment">     * until the next tick--which is now.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    err = handle-&gt;delayed_error;</span><br><span class="line">    handle-&gt;delayed_error = <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (REQ_SUCCESS(req)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (handle-&gt;flags &amp; UV_HANDLE_CLOSING) &#123;</span><br><span class="line">      <span class="comment">/* use UV_ECANCELED for consistency with Unix */</span></span><br><span class="line">      err = ERROR_OPERATION_ABORTED;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (setsockopt(handle-&gt;socket,</span><br><span class="line">                          SOL_SOCKET,</span><br><span class="line">                          SO_UPDATE_CONNECT_CONTEXT,</span><br><span class="line">                          <span class="literal">NULL</span>,</span><br><span class="line">                          <span class="number">0</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      uv_connection_init((<span class="type">uv_stream_t</span>*)handle);</span><br><span class="line">      handle-&gt;flags |= UV_HANDLE_READABLE | UV_HANDLE_WRITABLE;</span><br><span class="line">      loop-&gt;active_tcp_streams++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      err = WSAGetLastError();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    err = GET_REQ_SOCK_ERROR(req);</span><br><span class="line">  &#125;</span><br><span class="line">  req-&gt;cb(req, uv_translate_sys_error(err));</span><br><span class="line"></span><br><span class="line">  DECREASE_PENDING_REQ_COUNT(handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程</category>
        <category>异常处理</category>
      </categories>
      <tags>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL基础学习</title>
    <url>/2024/01/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h2><p><strong>关系型数据库的三大范式</strong></p>
<ul>
<li>第一范式：<ul>
<li>单一字段只能表示一种数据（字段的原子性）</li>
<li>（否则可分为多个字段）</li>
</ul>
</li>
<li>第二范式：<ul>
<li>非主键必须依赖整个主键，而非部分主键</li>
<li>（否则可以分为多个表）</li>
</ul>
</li>
<li>第三范式：<ul>
<li>非主键必须直接依赖主键，不能间接依赖</li>
<li>（否则可以分为多个表）</li>
</ul>
</li>
</ul>
<span id="more"></span>

<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p><strong>事务的四大特性</strong></p>
<ul>
<li>原子性：事务中的操作 要么全部成功，要么全部失败回滚</li>
<li>一致性：一个事务执行前后，数据库的状态保持一致（类比能量守恒）</li>
<li>隔离性：一个事务只能读到已经提交的修改</li>
<li>持久性：一个事务一旦提交，对数据库中的数据的改变是永久性的，即使数据库系统遇到故障也不会丢失事务操作所做的修改。</li>
</ul>
<p><strong>事务的隔离等级</strong></p>
<p>前置概念</p>
<ul>
<li><strong>脏读</strong>：一个事务处理过程中读取了另一个未提交的事务中的数据<ul>
<li>当一个事务对数据进行修改但还没有提交时，其他事务可能会读取到这个尚未提交的数据。</li>
<li>类似的情况在并发编程中被称为<strong>竞态条件</strong>（Race Condition），它指的是多个线程同时访问临界资源，并且对该资源进行修改，从而导致结果的不确定性或错误。</li>
<li>数据库通常使用锁机制来控制并发访问。</li>
</ul>
</li>
<li><strong>不可重复读</strong><ul>
<li>一个事务范围内，多次相同的查询却返回了不同的数据值</li>
<li>原因是在查询间隔内，另一个事务修改了数据并提交了</li>
</ul>
</li>
<li><strong>幻读</strong><ul>
<li>对于一个事务，在前面进行了查询，之后又有其他事务插入或删除数据，导致前面查询到的数据失去有效性。</li>
<li>原因：使用了读取一致性级别不同的事务隔离级别</li>
</ul>
</li>
</ul>
<p>MySQL的四种隔离级别</p>
<ul>
<li><strong>串行化</strong> Serializable<ul>
<li>强制事务顺序，使之不可能相互冲突，解决幻读</li>
</ul>
</li>
<li><strong>可重复读</strong> Repeatable Read<ul>
<li>默认事务隔离级别，确保同一事务的多个实例在并发读取数据时，会看到同样的数据行，解决了不可重复读的问题。</li>
</ul>
</li>
<li><strong>读已提交</strong> Read Committed<ul>
<li>一个事务只能看见已经提交的事务所做的改变，避免脏读</li>
</ul>
</li>
<li><strong>读未提交</strong> Read Uncommitted<ul>
<li>所有的事务都可以看到其他未提交事务的执行结果</li>
</ul>
</li>
</ul>
<p>生存环境一般使用 <strong>读已提交RC</strong></p>
<ul>
<li>为什么使用RC而不是RR<ul>
<li>RR存在<u>间隙锁</u>，更容易出现死锁</li>
<li>RR级别下，<u>条件列未命中索引</u>会锁表，而RC级别下只锁行</li>
<li>可见RC的并发性高于RR</li>
<li>另外不可重复读问题<u>有时候</u>是可接受的</li>
</ul>
</li>
</ul>
<h2 id="编码与字符集"><a href="#编码与字符集" class="headerlink" title="编码与字符集"></a>编码与字符集</h2><p><strong>编码和字符集</strong></p>
<ul>
<li>ASCII<ul>
<li>单字符：8bits，1Byte</li>
<li>只能表示256个字符</li>
</ul>
</li>
<li>各种特殊编码，如中文的 GB2312，希腊语的 greek，俄语的 cp866</li>
<li>Unicode，统一各种编码为一种<ul>
<li>单字符：2~4Byte</li>
<li><img src="/2024/01/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%AD%A6%E4%B9%A0/image-20240104222222435.png" alt="image-20240104222222435" style="zoom:80%;"></li>
</ul>
</li>
<li>UTF-8<ul>
<li>优化了Unicode的字符中不必要的字节</li>
</ul>
</li>
<li>总结<ul>
<li>按照一定规则把符号和二进制码对应起来，这就是<strong>编码</strong>。而把n多这种已经编码的字符聚在一起，就是我们常说的<strong>字符集</strong>。</li>
<li>比如utf-8字符集就是所有utf-8编码格式的字符的合集。</li>
</ul>
</li>
</ul>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="索引概述"><a href="#索引概述" class="headerlink" title="索引概述"></a>索引概述</h3><blockquote>
<p>是什么</p>
<ul>
<li>索引用于加快磁盘数据的访问，属于用空间换时间</li>
<li>索引记录的内容有一组数据的关键字和数据各个部分的存储位置，通过某些数据结构（B树、B+树）组织关键字，在这样数据结构上对关键字进行查询，从而找到关键字对应数据的存储位置，再到磁盘中直接获取。</li>
<li>数据存储在磁盘中的某个位置，我们要访问某个磁盘中的数据<ul>
<li>在没有使用索引的情况下，就得把全部相关的数据加载到内存中（如果数据量很大，就需要加载多次，非常耗时），然后再从内存中遍历找到数据。</li>
<li>使用索引，只需将索引加载到内存，然后在索引中根据关键字找到数据的存储位置，便可直接找到磁盘中数据并进行加载<ul>
<li>一般来说不会一次性加载所有的索引节点，如果是B树，B+树，每次会根据需要加载一定数量的节点，对磁盘的访问次数最多等于树的高度</li>
<li>此外，对于高频使用的索引，还会将其缓存到内存中</li>
</ul>
</li>
</ul>
</li>
<li>索引键值一般就是该行数据某个列上的具体值</li>
</ul>
</blockquote>
<blockquote>
<p><strong>GPT</strong></p>
<p>Q: 对于数据库中的一列，为其建立索引，那么其键值是什么，查找某个数据的过程是怎样的</p>
<p>A:</p>
<p>在为数据库中的一列建立索引时，键值是该列中的具体值。具体来说，对于每个索引条目，键值是该列中一行数据的值。</p>
<p>当进行通过索引进行数据查询时，数据库系统会使用索引树的结构来加速查询过程。以下是查找某个数据的一般过程：</p>
<ol>
<li>查询条件：首先，根据查询语句中的条件确定需要查找的数据。</li>
<li>索引搜索：数据库会根据索引的键值进行搜索。如果该列上有索引，并且该索引适用于查询条件，则数据库系统会根据索引树进行搜索。</li>
<li>索引树遍历：数据库系统会依次遍历索引树的节点，从根节点开始，在每个节点选择合适的子节点继续查找，直到找到满足查询条件的数据。</li>
<li>数据访问：一旦找到满足条件的索引节点，数据库系统会使用该节点中的指针来访问相应的数据行。这可能涉及到磁盘读取操作，将数据从磁盘中加载到内存。</li>
<li>数据返回：找到满足条件的数据行后，数据库系统会将其返回给用户。</li>
</ol>
<p>需要注意的是，索引的目的是为了加速数据的查询操作。索引的建立和使用需要在一定程度上增加存储空间和维护开销。因此，对于不频繁搜索的列或一些其他条件，建立索引可能并不总是必要或有效的选择。</p>
</blockquote>
<p>作用</p>
<ul>
<li>数据是存储在磁盘上的</li>
<li>查询数据时，如果没有索引，会加载所有的数据到内存，依次进行检索，读取磁盘次数较多。</li>
<li>有了索引，就不需要加载所有数据，因为B+树的高度一般在2-4层，最多只需要读取2-4次磁盘，查询速度大大提升。</li>
</ul>
<p>优点：</p>
<ul>
<li><strong>加快数据查找的速度</strong></li>
<li>为用来排序或者是分组的字段添加索引，可以加快分组和排序的速度</li>
<li>加快表与表之间的连接</li>
</ul>
<p>缺点：</p>
<ul>
<li>建立索引需要<strong>占用物理空间</strong></li>
<li>会降低表的增删改的效率，因为每次对表记录进行增删改，需要进行<strong>动态维护索引</strong>，导致增删改时间变长</li>
</ul>
<p>使用场景</p>
<ul>
<li>经常用于查询的字段</li>
<li>经常用于连接的字段建立索引</li>
<li>经常需要排序的字段建立索引（建立索引就排好序了）</li>
</ul>
<p>不适用的</p>
<ul>
<li><code>where</code>条件中用不到的字段不适合建立索引</li>
<li>表记录较少</li>
<li>需要经常增删改</li>
<li><strong>参与列计算</strong>的列不适合建索引</li>
<li><strong>区分度不高</strong>的字段不适合建立索引，如性别</li>
</ul>
<h3 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h3><h4 id="线性索引"><a href="#线性索引" class="headerlink" title="线性索引"></a>线性索引</h4><ul>
<li>用有序数组组织索引</li>
<li>可以通过二分查找快速找到键值位置</li>
<li>当数据量太大时，可以分为多层线性索引，在最底层记录每一个数据的存储位置</li>
<li>缺点<ul>
<li>对于数组，增删的代价比较大</li>
</ul>
</li>
</ul>
<h4 id="B树索引"><a href="#B树索引" class="headerlink" title="B树索引"></a>B树索引</h4><p>2-3树即3阶B树</p>
<img src="/2024/01/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%AD%A6%E4%B9%A0/image-20240106191056937.png" alt="image-20240106191056937" style="zoom:80%;">

<h4 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h4><ul>
<li>中间结点中，只保存关键字的值（引导） </li>
<li>叶子节点中，保存关键字以及相应的数据记录（即数据记录存放在叶子结点）</li>
</ul>
<img src="/2024/01/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%AD%A6%E4%B9%A0/image-20240106192038264.png" alt="image-20240106192038264" style="zoom:80%;">

<ul>
<li>支持范围查找 ： 同一层的结点还通过链表相连</li>
</ul>
<blockquote>
<p>B树和B+树的插入、删除产生的分裂和合并以及层次变化的过程，可以去看下一华工数据结构慕课。</p>
</blockquote>
<ul>
<li>也有不完全一样的定义方式</li>
</ul>
<img src="/2024/01/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%AD%A6%E4%B9%A0/image-20240106225126484.png" alt="image-20240106225126484" style="zoom:80%;">

<h4 id="哈希表索引"><a href="#哈希表索引" class="headerlink" title="哈希表索引"></a>哈希表索引</h4><ul>
<li>哈希索引是基于哈希表实现的，对于每一行数据，存储引擎会对索引列进行哈希计算得到哈希码，并且哈希算法要尽量保证不同的列值计算出的哈希码值是不同的。</li>
<li>将哈希码的值作为哈希表的key值，将指向数据行的指针作为哈希表的value值。</li>
<li>这样查找一个数据的时间复杂度就是O(1)，一般多用于精确查找。</li>
</ul>
<p>与 B+树 索引的比较</p>
<ul>
<li>哈希索引<strong>不支持排序</strong>，因为哈希表是无序的。</li>
<li>哈希索引<strong>不支持范围查找</strong>。</li>
<li>哈希索引<strong>不支持模糊查询</strong>及多列索引的最左前缀匹配。</li>
<li>因为哈希表中会<strong>存在哈希冲突</strong>，所以哈希索引的性能是不稳定的，而B+树索引的性能是相对稳定的，每次查询都是从根节点到叶子节点。</li>
</ul>
<h4 id="为什么B-树比B树更适合实现数据库索引？"><a href="#为什么B-树比B树更适合实现数据库索引？" class="headerlink" title="为什么B+树比B树更适合实现数据库索引？"></a>为什么B+树比B树更适合实现数据库索引？</h4><ul>
<li>由于B+树的数据都存储在叶子结点中，叶子结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，而在数据库中基于范围的查询是非常频繁的，所以通常B+树用于数据库索引。</li>
<li>B+树的节点只存储索引key值，具体信息的地址存在于叶子节点的地址中。这就使以页为单位的索引中可以存放更多的节点。减少更多的I&#x2F;O支出。</li>
<li>B+树的查询效率更加稳定，任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</li>
</ul>
<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="架构篇"><a href="#架构篇" class="headerlink" title="架构篇"></a>架构篇</h3>]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>框架汇总</title>
    <url>/2022/07/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="算法学习"><a href="#算法学习" class="headerlink" title="算法学习"></a>算法学习</h1><br>

<h2 id="day1——核心框架汇总"><a href="#day1——核心框架汇总" class="headerlink" title="day1——核心框架汇总"></a>day1——核心框架汇总</h2><h3 id="1-框架思维"><a href="#1-框架思维" class="headerlink" title="1-框架思维"></a>1-框架思维</h3><h4 id="基本数据结构及其操作"><a href="#基本数据结构及其操作" class="headerlink" title="基本数据结构及其操作"></a>基本数据结构及其操作</h4><p>数据结构的存储方式只有两种：<strong>数组（顺序存储）和链表（链式存储）</strong></p>
<p>在此之上可以构成：<strong>散列表、栈、队列、堆、树、图等等各种数据结构</strong></p>
<p>基本操作：无非就是<strong>遍历 + 访问</strong>，再具体一点就是：<strong>增删查改</strong>。</p>
<p>数据结构种类很多，但它们存在的目的都是在不同的应用场景，尽可能高效地增删查改。</p>
<span id="more"></span>

<hr>
<h4 id="算法的框架思维"><a href="#算法的框架思维" class="headerlink" title="算法的框架思维"></a>算法的框架思维</h4><p>数组遍历框架</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">voidtraverse</span>(<span class="type">int</span>[]arr)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i &lt;arr.length; i++)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 迭代访问 arr[i]</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<p>链表遍历框架，兼具迭代和递归结构：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 基本的单链表节点 */</span></span><br><span class="line"></span><br><span class="line">classListNode&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">voidtraverse</span>(ListNodehead)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(ListNode p = head; p != null; p =p.next)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 迭代访问 p.val</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">voidtraverse</span>(ListNodehead)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归访问 head.val</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">traverse</span>(head.next);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<p>二叉树遍历框架，典型的非线性递归遍历结构：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 基本的二叉树节点 */</span></span><br><span class="line"></span><br><span class="line">classTreeNode&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">    TreeNode left, right;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">voidtraverse</span>(TreeNoderoot)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">traverse</span>(root.left);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">traverse</span>(root.right);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<p>N 叉树的遍历框架：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 基本的 N 叉树节点 */</span></span><br><span class="line"></span><br><span class="line">classTreeNode&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">    TreeNode[] children;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">voidtraverse</span>(TreeNoderoot)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(TreeNode child :root.children)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">traverse</span>(child);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>1、先学习像数组、链表这种基本数据结构的常用算法</strong></p>
<p><strong>2、学会基础算法之后，不要急着上来就刷回溯算法、动态规划这类笔试常考题，而应该先刷二叉树</strong></p>
<hr>
<br>

<h3 id="2-刷题心得"><a href="#2-刷题心得" class="headerlink" title="2-刷题心得"></a>2-刷题心得</h3><h4 id="数组-x2F-单链表系列算法"><a href="#数组-x2F-单链表系列算法" class="headerlink" title="数组&#x2F;单链表系列算法"></a>数组&#x2F;单链表系列算法</h4><blockquote>
<p>-<strong>单链表常考的技巧就是双指针</strong></p>
</blockquote>
<blockquote>
<p>-<strong>数组常用的技巧有很大一部分还是双指针相关的技巧，说白了是教你如何聪明地进行穷举</strong></p>
</blockquote>
<blockquote>
<p>-<strong>滑动窗口算法技巧，典型的快慢双指针，快慢指针中间就是滑动的「窗口」，主要用于解决子串问题。</strong></p>
</blockquote>
<blockquote>
<p>-**最后说说 <a href="https://labuladong.github.io/algo/2/20/24/">前缀和技巧</a> 和 <a href="https://labuladong.github.io/algo/2/20/25/">差分数组技巧</a>**。</p>
</blockquote>
<blockquote>
<blockquote>
<p>如果频繁地让你计算子数组的和，每次用 for 循环去遍历肯定没问题，但前缀和技巧预计算一个 <code>preSum</code> 数组，就可以避免循环。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>类似的，如果频繁地让你对子数组进行增减操作，也可以每次用 for 循环去操作，但差分数组技巧维护一个 <code>diff</code> 数组，也可以避免循环。</p>
</blockquote>
</blockquote>
<br>

<h4 id="二叉树系列算法"><a href="#二叉树系列算法" class="headerlink" title="二叉树系列算法"></a>二叉树系列算法</h4><p>二叉树题目的递归解法可以分两类思路，第一类是遍历一遍二叉树得出答案，第二类是通过分解问题计算出答案，这两类思路分别对应着 <a href="https://labuladong.github.io/algo/4/31/105/">回溯算法核心框架</a> 和 <a href="https://labuladong.github.io/algo/3/25/69/">动态规划核心框架</a>。</p>
<p>更进一步，图论相关的算法也是二叉树算法的延续。</p>
<p>比如 <a href="https://labuladong.github.io/algo/2/22/50/">图论基础</a>， <a href="https://labuladong.github.io/algo/2/22/51/">环判断和拓扑排序</a> 和 <a href="https://labuladong.github.io/algo/2/22/52/">二分图判定算法</a> 就用到了 DFS 算法；再比如 <a href="https://labuladong.github.io/algo/2/22/56/">Dijkstra 算法模板</a>，就是改造版 BFS 算法加上一个类似 dp table 的数组。</p>
<p>这些算法的本质都是穷举二（多）叉树，有机会的话通过剪枝或者备忘录的方式减少冗余计算，提高效率，就这么点事儿。</p>
<hr>
<br>

<h3 id="3-双指针（七道链表题）"><a href="#3-双指针（七道链表题）" class="headerlink" title="3-双指针（七道链表题）"></a>3-双指针（七道链表题）</h3><br>

<h4 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h4><p>用到了3个指针：指向原链表的p1、p2，连接链表的p</p>
<p>注意要新建一个空的链表头</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">ListNodemergeTwoLists</span>(ListNodel1,ListNodel2)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 虚拟头结点</span></span><br><span class="line"></span><br><span class="line">    ListNode dummy =<span class="built_in">newListNode</span>(<span class="number">-1</span>), p = dummy;</span><br><span class="line"></span><br><span class="line">    ListNode p1 = l1, p2 = l2;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p1 != null &amp;&amp; p2 != null)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较 p1 和 p2 两个指针</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将值较小的的节点接到 p 指针</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(p1.val&gt;p2.val)&#123;</span><br><span class="line"></span><br><span class="line">            p.next= p2;</span><br><span class="line"></span><br><span class="line">            p2 =p2.next;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">            p.next= p1;</span><br><span class="line"></span><br><span class="line">            p1 =p1.next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// p 指针不断前进</span></span><br><span class="line"></span><br><span class="line">        p =p.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p1 != null)&#123;</span><br><span class="line"></span><br><span class="line">        p.next= p1;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p2 != null)&#123;</span><br><span class="line"></span><br><span class="line">        p.next= p2;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    returndummy.next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<h4 id="链表的分解"><a href="#链表的分解" class="headerlink" title="链表的分解"></a>链表的分解</h4><p><img src="https://labuladong.github.io/algo/images/%e9%93%be%e8%a1%a8%e6%8a%80%e5%b7%a7/title4.jpg" alt="img"></p>
<br>

<h4 id="合并k个有序链表"><a href="#合并k个有序链表" class="headerlink" title="合并k个有序链表"></a>合并k个有序链表</h4><p>利用优先级队列（堆）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">ListNodemergeKLists</span>(ListNode[]lists)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(lists.length==<span class="number">0</span>)<span class="keyword">return</span> null;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 虚拟头结点</span></span><br><span class="line"></span><br><span class="line">    ListNode dummy =<span class="built_in">newListNode</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    ListNode p = dummy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优先级队列，最小堆</span></span><br><span class="line"></span><br><span class="line">    PriorityQueue&lt;ListNode&gt; pq =newPriorityQueue&lt;&gt;(</span><br><span class="line"></span><br><span class="line">        lists.length,(a, b)-&gt;(a.val-b.val));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 k 个链表的头结点加入最小堆</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(ListNode head : lists)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(head != null)</span><br><span class="line"></span><br><span class="line">            pq.<span class="built_in">add</span>(head);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!pq.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取最小节点，接到结果链表中</span></span><br><span class="line"></span><br><span class="line">        ListNode node =pq.<span class="built_in">poll</span>();</span><br><span class="line"></span><br><span class="line">        p.next= node;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node.next!= null)&#123;</span><br><span class="line"></span><br><span class="line">            pq.<span class="built_in">add</span>(node.next);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// p 指针不断前进</span></span><br><span class="line"></span><br><span class="line">        p =p.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    returndummy.next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>优先队列 <code>pq</code> 中的元素个数最多是 <code>k</code>，所以一次 <code>poll</code> 或者 <code>add</code> 方法的时间复杂度是 <code>O(logk)</code>；所有的链表节点都会被加入和弹出 <code>pq</code>，<strong>所以算法整体的时间复杂度是 <code>O(Nlogk)</code>，其中 <code>k</code> 是链表的条数，<code>N</code> 是这些链表的节点总数</strong>。</p>
<br>

<h4 id="寻找单链表的倒数第k个节点"><a href="#寻找单链表的倒数第k个节点" class="headerlink" title="寻找单链表的倒数第k个节点"></a>寻找单链表的倒数第k个节点</h4><p>不告诉链表长度；</p>
<p>只遍历一次链表的解法：用p1走k步后，p2再出发</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 返回链表的倒数第 k 个节点</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">ListNodefindFromEnd</span>(ListNodehead,intk)&#123;</span><br><span class="line"></span><br><span class="line">    ListNode p1 = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// p1 先走 k 步</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line"></span><br><span class="line">        p1 =p1.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode p2 = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// p1 和 p2 同时走 n - k 步</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p1 != null)&#123;</span><br><span class="line"></span><br><span class="line">        p2 =p2.next;</span><br><span class="line"></span><br><span class="line">        p1 =p1.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// p2 现在指向第 n - k + 1 个节点，即倒数第 k 个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p2;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<h4 id="寻找单链表的中点"><a href="#寻找单链表的中点" class="headerlink" title="寻找单链表的中点"></a>寻找单链表的中点</h4><p>利用快慢指针：快指针走两步，慢指针走一步</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">ListNodemiddleNode</span>(ListNodehead)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快慢指针初始化指向 head</span></span><br><span class="line"></span><br><span class="line">    ListNode slow = head, fast = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快指针走到末尾时停止</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(fast != null &amp;&amp;fast.next!= null)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 慢指针走一步，快指针走两步</span></span><br><span class="line"></span><br><span class="line">        slow =slow.next;</span><br><span class="line"></span><br><span class="line">        fast =fast.next.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 慢指针指向中点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>需要注意的是，如果链表长度为偶数，也就是说中点有两个的时候，我们这个解法返回的节点是靠后的那个节点。</p>
<br>

<h4 id="判断单链表是否包含环并找出环起点"><a href="#判断单链表是否包含环并找出环起点" class="headerlink" title="判断单链表是否包含环并找出环起点"></a>判断单链表是否包含环并找出环起点</h4><p>判断是否含环：快慢指针，如果最终快指针赶上慢指针说明有环。否则快指针遍历直到空指针。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">booleanhasCycle</span>(ListNodehead)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快慢指针初始化指向 head</span></span><br><span class="line"></span><br><span class="line">    ListNode slow = head, fast = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快指针走到末尾时停止</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(fast != null &amp;&amp;fast.next!= null)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 慢指针走一步，快指针走两步</span></span><br><span class="line"></span><br><span class="line">        slow =slow.next;</span><br><span class="line"></span><br><span class="line">        fast =fast.next.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 快慢指针相遇，说明含有环</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(slow == fast)&#123;</span><br><span class="line"></span><br><span class="line">            returntrue;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不包含环</span></span><br><span class="line"></span><br><span class="line">    returnfalse;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>若有环，如何判断环的起点</p>
<blockquote>
<p>当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">ListNodedetectCycle</span>(ListNodehead)&#123;</span><br><span class="line"></span><br><span class="line">    ListNode fast, slow;</span><br><span class="line"></span><br><span class="line">    fast = slow = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(fast != null &amp;&amp;fast.next!= null)&#123;</span><br><span class="line"></span><br><span class="line">        fast =fast.next.next;</span><br><span class="line"></span><br><span class="line">        slow =slow.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(fast == slow)<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上面的代码类似 hasCycle 函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fast == null ||fast.next== null)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// fast 遇到空指针说明没有环</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> null;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新指向头结点</span></span><br><span class="line"></span><br><span class="line">    slow = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快慢指针同步前进，相交点就是环起点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line"></span><br><span class="line">        fast =fast.next;</span><br><span class="line"></span><br><span class="line">        slow =slow.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<h4 id="判断两个单链表是否相交并找出交点"><a href="#判断两个单链表是否相交并找出交点" class="headerlink" title="判断两个单链表是否相交并找出交点"></a>判断两个单链表是否相交并找出交点</h4><p>不使用Hashmap的实现，即仅使用两个指针</p>
<blockquote>
<p>我们可以让 <code>p1</code> 遍历完链表 <code>A</code> 之后开始遍历链表 <code>B</code>，让 <code>p2</code> 遍历完链表 <code>B</code> 之后开始遍历链表 <code>A</code>，这样相当于「逻辑上」两条链表接在了一起。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">ListNodegetIntersectionNode</span>(ListNodeheadA,ListNodeheadB)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// p1 指向 A 链表头结点，p2 指向 B 链表头结点</span></span><br><span class="line"></span><br><span class="line">    ListNode p1 = headA, p2 = headB;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p1 != p2)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// p1 走一步，如果走到 A 链表末尾，转到 B 链表</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(p1 == null) p1 = headB;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>            p1 =p1.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// p2 走一步，如果走到 B 链表末尾，转到 A 链表</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(p2 == null) p2 = headA;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>            p2 =p2.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>或者通过预先求出两个链表的长度，来使p1、p2同时到达相交节点</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> lenA =<span class="number">0</span>, lenB =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算两条链表的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(ListNode p1 = headA; p1 != null; p1 =p1.next)&#123;</span><br><span class="line"></span><br><span class="line">        lenA++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(ListNode p2 = headB; p2 != null; p2 =p2.next)&#123;</span><br><span class="line"></span><br><span class="line">        lenB++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让 p1 和 p2 到达尾部的距离相同</span></span><br><span class="line"></span><br><span class="line">    ListNode p1 = headA, p2 = headB;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(lenA &gt; lenB)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i &lt; lenA - lenB; i++)&#123;</span><br><span class="line"></span><br><span class="line">            p1 =p1.next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i &lt; lenB - lenA; i++)&#123;</span><br><span class="line"></span><br><span class="line">            p2 =p2.next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 看两个指针是否会相同，p1 == p2 时有两种情况：</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、要么是两条链表不相交，他俩同时走到尾部空指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、要么是两条链表相交，他俩走到两条链表的相交点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p1 != p2)&#123;</span><br><span class="line"></span><br><span class="line">        p1 =p1.next;</span><br><span class="line"></span><br><span class="line">        p2 =p2.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<br>

<h3 id="4-双指针（七道数组题）"><a href="#4-双指针（七道数组题）" class="headerlink" title="4-双指针（七道数组题）"></a>4-双指针（七道数组题）</h3><blockquote>
<p>链表和数组题中的双指针有两种</p>
</blockquote>
<blockquote>
<p>-<strong>左右指针</strong>，就是两个指针相向而行或者相背而行；</p>
</blockquote>
<blockquote>
<p>-<strong>快慢指针</strong>，就是两个指针同向而行，一快一慢。</p>
</blockquote>
<br>

<h4 id="快慢指针技巧"><a href="#快慢指针技巧" class="headerlink" title="快慢指针技巧"></a>快慢指针技巧</h4><blockquote>
<p>原地修改数组</p>
</blockquote>
<h5 id="删除有序数组中的重复项"><a href="#删除有序数组中的重复项" class="headerlink" title="删除有序数组中的重复项"></a>删除有序数组中的重复项</h5><p>在不新开数组的情况下的解法</p>
<p><img src="https://labuladong.github.io/algo/images/%e6%95%b0%e7%bb%84%e5%8e%bb%e9%87%8d/1.gif" alt="img"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">intremoveDuplicates</span>(<span class="type">int</span>[]nums)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(nums.length==<span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">        return0;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> slow =<span class="number">0</span>, fast =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(fast &lt;nums.length)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums[fast]!=nums[slow])&#123;</span><br><span class="line"></span><br><span class="line">            slow++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 维护 nums[0..slow] 无重复</span></span><br><span class="line"></span><br><span class="line">            nums[slow]=nums[fast];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fast++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组长度为索引 + 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slow +<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于删除有序链表中的重复项呢？</p>
<p><img src="https://labuladong.github.io/algo/images/%e6%95%b0%e7%bb%84%e5%8e%bb%e9%87%8d/2.gif" alt="img"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">ListNodedeleteDuplicates</span>(ListNodehead)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(head == null)<span class="keyword">return</span> null;</span><br><span class="line"></span><br><span class="line">    ListNode slow = head, fast = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(fast != null)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(fast.val!=slow.val)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// nums[slow] = nums[fast];</span></span><br><span class="line"></span><br><span class="line">            slow.next= fast;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// slow++;</span></span><br><span class="line"></span><br><span class="line">            slow =slow.next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// fast++</span></span><br><span class="line"></span><br><span class="line">        fast =fast.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 断开与后面重复元素的连接</span></span><br><span class="line"></span><br><span class="line">    slow.next= null;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<h5 id="删除无序数组中的某个元素"><a href="#删除无序数组中的某个元素" class="headerlink" title="删除无序数组中的某个元素"></a>删除无序数组中的某个元素</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">intremoveElement</span>(<span class="type">int</span>[]nums,intval)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fast =<span class="number">0</span>, slow =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(fast &lt;nums.length)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums[fast]!= val)&#123;</span><br><span class="line"></span><br><span class="line">            nums[slow]=nums[fast];</span><br><span class="line"></span><br><span class="line">            slow++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fast++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里是先给 <code>nums[slow]</code> 赋值然后再给 slow++</p>
<br>

<h5 id="移动0"><a href="#移动0" class="headerlink" title="移动0"></a>移动0</h5><blockquote>
<p>比如说给你输入 <code>nums = [0,1,4,0,2]</code>，你的算法没有返回值，但是会把 <code>nums</code> 数组原地修改成 <code>[1,4,2,0,0]</code>。</p>
</blockquote>
<blockquote>
<p>其实就相当于移除 <code>nums</code> 中的所有 0，然后再把后面的元素都赋值为 0 即可。</p>
</blockquote>
<p>可以复用上一题的 <code>removeElement</code> 函数</p>
<br>

<h4 id="滑动窗口类型（快慢指针）"><a href="#滑动窗口类型（快慢指针）" class="headerlink" title="滑动窗口类型（快慢指针）"></a>滑动窗口类型（快慢指针）</h4><p>代码框架</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 滑动窗口算法框架 */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">voidslidingWindow</span>(strings,stringt)&#123;</span><br><span class="line"></span><br><span class="line">    unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; need, window;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c : t)need[c]++;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left =<span class="number">0</span>, right =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> valid =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(right &lt;s.<span class="built_in">size</span>())&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> c =s[right];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右移（增大）窗口</span></span><br><span class="line"></span><br><span class="line">        right++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(window needs shrink)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">char</span> d =s[left];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 左移（缩小）窗口</span></span><br><span class="line"></span><br><span class="line">            left++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>left</code> 指针在后，<code>right</code> 指针在前，两个指针中间的部分就是「窗口」，算法通过扩大和缩小「窗口」来解决某些问题。</p>
<hr>
<br>

<h4 id="左右指针技巧"><a href="#左右指针技巧" class="headerlink" title="左右指针技巧"></a>左右指针技巧</h4><h5 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h5><p>简单框架</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">intbinarySearch</span>(<span class="type">int</span>[]nums,inttarget)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一左一右两个指针相向而行</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left =<span class="number">0</span>, right =nums.length<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> mid =(right + left)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums[mid]== target)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">elseif</span>(nums[mid]&lt; target)</span><br><span class="line"></span><br><span class="line">            left = mid +<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">elseif</span>(nums[mid]&gt; target)</span><br><span class="line"></span><br><span class="line">            right = mid <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span><span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<h5 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h5><p>返回的下标是从1算起的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span>[] <span class="built_in">twoSum</span>(<span class="type">int</span>[] nums,<span class="type">int</span> target)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一左一右两个指针相向而行</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left =<span class="number">0</span>, right =nums.length<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> sum =nums[left]+nums[right];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 题目要求的索引是从 1 开始的</span></span><br><span class="line"></span><br><span class="line">            returnnewint[]&#123;left +<span class="number">1</span>, right +<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="built_in">elseif</span>(sum &lt; target)&#123;</span><br><span class="line"></span><br><span class="line">            left++; <span class="comment">// 让 sum 大一点 *</span></span><br><span class="line"></span><br><span class="line">        &#125;<span class="built_in">elseif</span>(sum &gt; target)&#123;</span><br><span class="line"></span><br><span class="line">            right--; <span class="comment">// 让 sum 小一点 *</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    returnnewint[]&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<h5 id="反转数组"><a href="#反转数组" class="headerlink" title="反转数组"></a>反转数组</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">voidreverseString</span>(<span class="type">char</span>[]s)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一左一右两个指针相向而行</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left =<span class="number">0</span>, right =s.length<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 交换 s[left] 和 s[right]</span></span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> temp =s[left];</span><br><span class="line"></span><br><span class="line">        s[left]=s[right];</span><br><span class="line"></span><br><span class="line">        s[right]= temp;</span><br><span class="line"></span><br><span class="line">        left++;</span><br><span class="line"></span><br><span class="line">        right--;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<h5 id="回文串匹配"><a href="#回文串匹配" class="headerlink" title="回文串匹配"></a>回文串匹配</h5><p>简单匹配</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">booleanisPalindrome</span>(Strings)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一左一右两个指针相向而行</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left =<span class="number">0</span>, right =s.<span class="built_in">length</span>()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">charAt</span>(left)!=s.<span class="built_in">charAt</span>(right))&#123;</span><br><span class="line"></span><br><span class="line">            returnfalse;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        left++;</span><br><span class="line"></span><br><span class="line">        right--;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    returntrue;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<p><strong>最长回文子串</strong></p>
<blockquote>
<p>左右指针从中间往两边延申</p>
</blockquote>
<blockquote>
<p>如果回文串的长度为奇数，参数 r &#x3D; l</p>
</blockquote>
<blockquote>
<p>如果回文串的长度为偶数，参数 r &#x3D; l+1</p>
</blockquote>
<blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 s 中寻找以 s[l] 和 s[r] 为中心的最长回文串</span></span><br><span class="line"><span class="built_in">Stringpalindrome</span>(Strings,intl,intr)&#123;</span><br><span class="line"><span class="comment">// 防止索引越界</span></span><br><span class="line"><span class="keyword">while</span>(l &gt;=<span class="number">0</span>&amp;&amp; r &lt;s.<span class="built_in">length</span>()</span><br><span class="line">&amp;&amp;s.<span class="built_in">charAt</span>(l)==s.<span class="built_in">charAt</span>(r))&#123;</span><br><span class="line"><span class="comment">// 双指针，向两边展开</span></span><br><span class="line">l--; r++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回以 s[l] 和 s[r] 为中心的最长回文串</span></span><br><span class="line">returns.<span class="built_in">substring</span>(l +<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">StringlongestPalindrome</span>(Strings)&#123;</span><br><span class="line"></span><br><span class="line">    String res =<span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i &lt;s.<span class="built_in">length</span>(); i++)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以 s[i] 为中心的最长回文子串</span></span><br><span class="line"></span><br><span class="line">        String s1 =<span class="built_in">palindrome</span>(s, i, i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以 s[i] 和 s[i+1] 为中心的最长回文子串</span></span><br><span class="line"></span><br><span class="line">        String s2 =<span class="built_in">palindrome</span>(s, i, i +<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// res = longest(res, s1, s2)</span></span><br><span class="line"></span><br><span class="line">        res =res.<span class="built_in">length</span>()&gt;s1.<span class="built_in">length</span>()? res : s1;</span><br><span class="line"></span><br><span class="line">        res =res.<span class="built_in">length</span>()&gt;s2.<span class="built_in">length</span>()? res : s2;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客看到的一大佬的汇总</title>
    <url>/2024/01/01/%E7%89%9B%E5%AE%A2%E7%9C%8B%E5%88%B0%E7%9A%84%E4%B8%80%E5%A4%A7%E4%BD%AC%E7%9A%84%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<p><img src="/2024/01/01/%E7%89%9B%E5%AE%A2%E7%9C%8B%E5%88%B0%E7%9A%84%E4%B8%80%E5%A4%A7%E4%BD%AC%E7%9A%84%E6%B1%87%E6%80%BB/image-20240101232202608.png" alt="太强了"></p>
<p><a href="https://www.nowcoder.com/discuss/543596390270640128?sourceSSR=users">2023秋招 游戏客户端 个人笔经汇总_牛客网 (nowcoder.com)</a></p>
]]></content>
      <categories>
        <category>面经汇总</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux多线程</title>
    <url>/2023/02/10/%E7%AC%AC%E4%B8%89%E7%AB%A0Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="第三章-Linux多线程开发"><a href="#第三章-Linux多线程开发" class="headerlink" title="第三章 Linux多线程开发"></a>第三章 Linux多线程开发</h1><hr>
<br>

<h2 id="3-1-线程"><a href="#3-1-线程" class="headerlink" title="3.1 线程"></a>3.1 线程</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><span id="more"></span>

<ul>
<li>与进程类似，线程是允许应用程序并发执行多个任务的一种机制。<ul>
<li>一个进程可以包含多个线程。</li>
<li>同一个程序中的所有线程均会独立执行相同程序，且共享同一份全局内存区域，其中包括初始化数据段、未初始化数据段，以及堆内存段。（传统意义上的 UNIX 进程只是多线程程序的一个特例，该进程只包含一个线程）</li>
</ul>
</li>
<li>进程是 CPU 分配资源的最小单位，线程是操作系统调度执行的最小单位</li>
<li>线程是轻量级的进程( LWP ,Light Weight Process )，在 Linux 环境下线程的本质仍是进程</li>
<li>查看指定进程的 LWP 号：<code>ps -Lf pid</code></li>
</ul>
<br>

<br>

<p><strong>线程与进程的区别</strong></p>
<p>进程：</p>
<ul>
<li>进程间的信息难以共享。由于除去只读代码段外，父子进程并未共享内存，因此必须采用一些进程间通信方式，在进程间进行信息交换</li>
<li>调用 fork() 来创建进程的代价相对较高，即便利用了 写时复制 技术，仍需要复制诸如内存页表和文件描述符表之类的多种进程属性</li>
</ul>
<br>

<p>线程：</p>
<ul>
<li>线程之间能够方便、快速的共享信息。只需要将数据复制到共享(全局或堆)变量中即可</li>
<li>创建线程比创建进程通常要快得多。线程间是共享虚拟地址空间的，无需采用写时复制来复制内存，也无需复制页表</li>
</ul>
<p><img src="/2023/02/10/%E7%AC%AC%E4%B8%89%E7%AB%A0Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20230208234052055.png" alt="image-20230208234052055"></p>
<p><strong>线程资源</strong></p>
<p>共享资源：</p>
<ul>
<li>进程id，父进程id</li>
<li>进程组id，会话id</li>
<li>用户id，用户组id</li>
<li>文件描述符表</li>
<li>信号处置（注册的、默认的）</li>
<li>文件系统的相关信息：umask、当前工作目录</li>
<li>虚拟地址空间（除了栈、.text段)</li>
</ul>
<br>

<p>非共享资源：</p>
<ul>
<li>线程id</li>
<li>信号掩码</li>
<li>线程特有数据</li>
<li>error 变量（线程特有）</li>
<li>实时调度策略 和 优先级</li>
<li>栈、本地变量和函数的调用链接信息</li>
</ul>
<br>

<p><strong>NPTL</strong></p>
<p>查看当前 pthread 库版本：<code>getconf GNU_LIBPTHREAD_VERSION</code></p>
<p><img src="/2023/02/10/%E7%AC%AC%E4%B8%89%E7%AB%A0Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20230208234720549.png" alt="image-20230208234720549"></p>
<br>

<br>

<br>

<h3 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h3><p>一般情况下，main函数所在的线程作为主线程（main线程），其余创建的称为子线程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	创建一个子线程</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- thread：传出参数，线程创建成功后，子线程的线程id被写入该变量</span></span><br><span class="line"><span class="comment">		- attr：设置线程的属性，一般使用默认值 NULL</span></span><br><span class="line"><span class="comment">		- start_routine：函数指针，子线程需要处理的逻辑代码</span></span><br><span class="line"><span class="comment">		- arg：作为start_routine的参数</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		成功 返回0</span></span><br><span class="line"><span class="comment">		失败 返回错误号。与之前的erron不太一样</span></span><br><span class="line"><span class="comment">		获取错误号信息：char *strerror(int errnum);</span></span><br><span class="line"><span class="comment">*/</span>	</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<blockquote>
<p>编译的时候要加 -pthread</p>
</blockquote>
<br>

<p><strong>案例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">callback</span><span class="params">(<span class="type">void</span>*arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child thread and arg: %d\n&quot;</span>,*(<span class="type">int</span> *)arg);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, callback, (<span class="type">void</span>*)&amp;num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span> *errstr = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;err:%s\n&quot;</span>,errstr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<br>

<br>

<h3 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于提前 return</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	终止一个线程，在哪个线程中调用就终止哪个线程</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- retval：需要传递一个指针，作为一个返回值，可以在 pthread_join() 中获取到</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前线程的线程id</span></span><br><span class="line"><span class="type">pthread_t</span> <span class="title function_">pthread_self</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较两个线程 ID 是否相等</span></span><br><span class="line"><span class="comment">// 不同的操作系统，pthread_t类型的实现不同，有的是无符号长整形，有的是结构体。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_equal</span><span class="params">(<span class="type">pthread_t</span> t1, <span class="type">pthread_t</span> t2)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<br>

<h3 id="连接已终止的线程"><a href="#连接已终止的线程" class="headerlink" title="连接已终止的线程"></a>连接已终止的线程</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	和一个已经终止的线程进行连接（阻塞的）</span></span><br><span class="line"><span class="comment">	回收子线程的资源（一次回收一个）</span></span><br><span class="line"><span class="comment">	一般在主线程中使用</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- thread：需要回收的子线程的id</span></span><br><span class="line"><span class="comment">		- retval：二级指针，接收子线程退出时的返回值</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		成功 0</span></span><br><span class="line"><span class="comment">		失败 非0 返回错误号</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<p><strong>接收返回值的join案例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> value =<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">callback</span><span class="params">(<span class="type">void</span>*arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child thread and arg: %d\n&quot;</span>,*(<span class="type">int</span> *)arg);</span><br><span class="line">    pthread_exit((<span class="type">void</span> *)&amp;value);	<span class="comment">// return (void *)&amp;value;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, callback, (<span class="type">void</span>*)&amp;num);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span> *errstr = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;err:%s\n&quot;</span>,errstr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 主线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 回收</span></span><br><span class="line">    <span class="type">int</span> *rtvalue;	<span class="comment">// 作接收的变量</span></span><br><span class="line">    ret = pthread_join(tid,(<span class="type">void</span> **)&amp;rtvalue);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span> *errstr = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;err:%s\n&quot;</span>,errstr);</span><br><span class="line">    &#125;	</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;get return value:%d\n&quot;</span>,*rtvalue);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<br>

<br>

<h3 id="线程分离"><a href="#线程分离" class="headerlink" title="线程分离"></a>线程分离</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	分离一个线程</span></span><br><span class="line"><span class="comment">	将指定线程标记为分离，当该线程终止时系统会自动回收资源，而不再需要别的线程来join回收</span></span><br><span class="line"><span class="comment">	不能 detach / join 一个已经分离的线程</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- thread：需要分离的线程的id</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		成功 0</span></span><br><span class="line"><span class="comment">		失败 非0 返回错误号</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<br>

<h3 id="线程取消"><a href="#线程取消" class="headerlink" title="线程取消"></a>线程取消</h3><ul>
<li>调用 pthread_cancel 之后，线程不会立即退出，而是等运行到某一 取消点 的时候才会真正取消</li>
<li>取消点：系统规定好的一些系统调用，一般在用户态切换到内核态的场景出现</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	取消线程，当子线程执行到一个取消点时，线程才会终止</span></span><br><span class="line"><span class="comment">	线程能否取消取决于线程的一些属性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<br>

<h3 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h3><p>pthread_create()的第二个参数传入线程属性</p>
<p><strong>相关函数</strong></p>
<p><img src="/2023/02/10/%E7%AC%AC%E4%B8%89%E7%AB%A0Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20230209190308454.png" alt="image-20230209190308454"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">线程属性类型 <span class="type">pthread_attr_t</span></span><br><span class="line"></span><br><span class="line">    变量初始化与回收</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_init</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	初始化线程属性变量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_destroy</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	释放线程属性变量的资源</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	属性设置和获取</span><br><span class="line">        </span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getdetachstate</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> </span></span><br><span class="line"><span class="params">*detachstate)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	获取线程分离的状态属性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setdetachstate</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> </span></span><br><span class="line"><span class="params">detachstate)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	设置线程分离的状态属性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<br>

<br>

<br>

<h2 id="3-2-同步互斥"><a href="#3-2-同步互斥" class="headerlink" title="3.2 同步互斥"></a>3.2 同步互斥</h2><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><ul>
<li>线程的主要优势在于能够通过全局变量来共享信息。但是要确保多个线程不会同时修改同一变量，或者某一线程不会读取正在由其他线程修改的变量。</li>
</ul>
<br>

<p><strong>临界区</strong></p>
<p>指访问某一共享资源的代码片段，并且这段代码的执行应该为 原子操作 ，也就是同时访问同一共享资源的其他线程不应该中断该片段的执行。</p>
<br>

<p><strong>同步与互斥</strong></p>
<p><strong>线程同步</strong> 就是协同步调，按预定的先后次序进行运行。如：你说完，我再说。线程同步是指多线程通过特定的设置（如互斥量，事件对象，临界区）来控制线程之间的执行顺序（即所谓的同步）也可以说是在线程之间通过同步建立起执行顺序的关系，如果没有同步，那线程之间是各自运行各自的，也即异步。</p>
<p><strong>线程互斥</strong> 是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步。</p>
<br>

<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><ul>
<li>为了线程更新共享变量时出现问题，可以使用互斥量 mutex( mutual exclusion ) 来确保同时仅有一个线程可以访问某项共享资源。可以使用互斥量来保证对任意共享资源的原子访问。</li>
<li>互斥量有两种状态：锁定locked 和 未锁定unlocked 。任何时刻，至多只有一个线程可以锁定该互斥量。试图对已经锁定的某一互斥量再次加锁，将可能阻塞线程或者报错失败，具体取决于加锁使用的方法。</li>
<li>一旦线程锁定互斥量，随即成为该互斥量的所有者，只有所有者才能给互斥量解锁。一般情况下，对每一共享资源（可能有多个相关变量组成）会使用不同的互斥量，每一线程在访问同一资源时将采用如下协议：<ul>
<li>锁定相应的互斥量</li>
<li>访问共享资源</li>
<li>对互斥量解锁</li>
</ul>
</li>
</ul>
<br>

<p><img src="/2023/02/10/%E7%AC%AC%E4%B8%89%E7%AB%A0Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20230210020752443.png" alt="image-20230210020752443"></p>
<br>

<br>

<p><strong>互斥量相关函数</strong></p>
<p>互斥量类型 <code>pthread_mutex_t</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	初始化互斥量</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- mutex：需要初始化的互斥变量</span></span><br><span class="line"><span class="comment">		- attr：互斥量相关的属性，一般NULL</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	restrict ：C语言的修饰符，被修饰的指针指向的内容不能由别的指针进行操作</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	释放互斥量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	给互斥量加锁</span></span><br><span class="line"><span class="comment">	阻塞的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	给互斥量尝试加锁</span></span><br><span class="line"><span class="comment">	非阻塞</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	解锁</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<br>

<br>

<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul>
<li>有时，一个线程需要同时访问两个或更多不同的共享资源，而每个资源又都有不同的互斥量管理。当超过一个线程加锁同一组互斥量时，就可能发送死锁</li>
</ul>
<p><img src="/2023/02/10/%E7%AC%AC%E4%B8%89%E7%AB%A0Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20230210022902860.png" alt="image-20230210022902860"></p>
<br>

<blockquote>
<p><strong>死锁</strong>：两个或两个以上的进程在执行过程中，因为夺取资源而造成的一种相互等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统发生了死锁。</p>
<p><strong>场景</strong>：</p>
<ul>
<li>忘记释放锁</li>
<li>重复加锁</li>
<li>多线程多锁，抢占资源</li>
</ul>
</blockquote>
<br>

<br>

<p>更多相关内容详见操作系统课程…</p>
<br>

<br>

<br>

<br>

<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><ul>
<li>当一个线程已经持有互斥锁时，互斥锁将所有试图进入临界区的线程都阻塞住。<br>但考虑一种情况：当前持有互斥锁的线程只是读共享资源，而同时有其他几个线程也想读取这个共享资源，但由于互斥锁的排他性，所有线程都无法获取锁，即无法读访问共享资源，但是实际上多个线程同时读访问共享资源并不会导致问题</li>
<li>在对数据的读写操作中，更多的是读操作，写操作较少。为了满足允许多个读出，而只允许单个写入的情况，线程提供了读写锁来实现。</li>
</ul>
<br>

<p><strong>读写锁特点</strong>：</p>
<ul>
<li>如果有其他线程 <strong>读数据</strong> ，则允许其他线程执行读操作，但不允许写操作</li>
<li>如果有其他线程 <strong>写数据</strong> ，则其他线程都不允许读、写操作</li>
<li>写是独占的，写的优先级更高</li>
</ul>
<br>

<br>

<p><strong>相关函数</strong></p>
<p>读写锁类型 <code>pthread_rwlock_t</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化读写锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_init</span><span class="params">(<span class="type">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock, <span class="type">const</span> <span class="type">pthread_rwlock_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回收读写锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_destroy</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加读锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_rdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试加读锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_tryrdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加写锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_wrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试加写锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_trywrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_unlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<br>

<br>

<p><strong>生产者与消费者模型</strong></p>
<p><img src="/2023/02/10/%E7%AC%AC%E4%B8%89%E7%AB%A0Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20230210040352527.png" alt="image-20230210040352527"></p>
<br>

<p>更多相关内容详见操作系统课程…</p>
<br>

<br>

<br>

<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>不是锁，能够配合互斥量使用实现线程的同步关系</p>
<p>类型 <code>pthread_cond_t</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="type">const</span> <span class="type">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回收</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待条件实现（阻塞）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待条件实现（阻塞指定的一段时间）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_timewait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="type">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> abstime)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒等待的一个或多个等待的线程</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒所有等待的线程</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<br>

<blockquote>
<p>注意当 wait 阻塞的时候，会将 互斥锁 解锁；</p>
<p>等到 wait 被唤醒之后，又会在原处重新 对 互斥锁 加锁</p>
</blockquote>
<br>

<br>

<br>

<br>

<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>类型 <code>sem_t</code></p>
<p>与条件变量类似，与互斥锁搭配使用，实现线程同步关系</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	信号量初始化</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		sem：信号量变量的地址</span></span><br><span class="line"><span class="comment">		pshared：0 表示用于线程间， 非0 表示用于进程间</span></span><br><span class="line"><span class="comment">		value：信号量中的值，可表示资源数量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放资源</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_destroy</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若信号量值为 0 就阻塞，信号量值大于 0 就 -1，</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_trywait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_timewait</span><span class="params">(<span class="type">sem_t</span> *sem,<span class="type">const</span> <span class="keyword">struct</span> timespec *abs_timeout)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号量值 +1 ，并且如果有的话就唤醒一个 wait 中的线程</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_getvalue</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> sval)</span>;</span><br></pre></td></tr></table></figure>

<br>

<blockquote>
<p>wait – post 对应 P – V 操作</p>
</blockquote>
<br>

<p>模拟生产者消费者</p>
<p>以资源容量为 8 为例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> resource = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> psem;</span><br><span class="line"><span class="type">sem_t</span> csem;</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">producer</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sem_wait(&amp;psem);</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        ++resource;</span><br><span class="line">        usleep(<span class="number">100</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;tid:%ld, produce : %d\n&quot;</span>,pthread_self(),resource);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        sem_post(&amp;csem);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">consumer</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sem_wait(&amp;csem);</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        --resource;</span><br><span class="line">        usleep(<span class="number">100</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;tid:%ld, consume : %d\n&quot;</span>,pthread_self(),resource);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        sem_post(&amp;psem);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    sem_init(&amp;psem, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">    sem_init(&amp;csem, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> ptids[<span class="number">5</span>],ctids[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">        pthread_create(&amp;ptids[i],<span class="literal">NULL</span>,producer,<span class="literal">NULL</span>);</span><br><span class="line">        pthread_create(&amp;ctids[i],<span class="literal">NULL</span>,consumer,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">        pthread_join(ptids[i],<span class="literal">NULL</span>);</span><br><span class="line">        pthread_join(ctids[i],<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    sem_destroy(&amp;psem);</span><br><span class="line">    sem_destroy(&amp;csem);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<p><img src="/2023/02/10/%E7%AC%AC%E4%B8%89%E7%AB%A0Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20230210071555920.png" alt="image-20230210071555920"></p>
<p><br><br><br></p>
<p>第三章完结！</p>
<br>

<br>







]]></content>
      <categories>
        <category>C++开发</category>
        <category>高性能服务器项目</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>第五章项目实战</title>
    <url>/2023/03/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h1 id="5-项目相关知识点"><a href="#5-项目相关知识点" class="headerlink" title="5.项目相关知识点"></a>5.项目相关知识点</h1><br>

<br>

<br>

<h2 id="5-1-阻塞-x2F-非阻塞，同步-x2F-异步"><a href="#5-1-阻塞-x2F-非阻塞，同步-x2F-异步" class="headerlink" title="5.1 阻塞&#x2F;非阻塞，同步&#x2F;异步"></a>5.1 阻塞&#x2F;非阻塞，同步&#x2F;异步</h2><p>此处是对于 <strong>网络IO</strong></p>
<p>IO的两个阶段：1.<strong>数据就绪</strong> 2.<strong>数据读写</strong></p>
<br>

<p><strong>数据就绪</strong>	操作系统、内核缓冲区中</p>
<ul>
<li>阻塞   ：调用IO方法的线程进入阻塞状态</li>
<li>非阻塞  ：不改变线程的状态，通过返回值判断</li>
</ul>
<br>

<p><strong>数据读写</strong>	缓冲区的数据&lt;–&gt;内存</p>
<ul>
<li>同步   : 应用程序自行读写</li>
<li>异步   : 操作系统辅助读写   （异步IO接口、通知方式）</li>
</ul>
<br>

<span id="more"></span>

<blockquote>
<img src="/2023/03/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20230303232426115.png" alt="image-20230303232426115" style="zoom:80%;">

<p>陈硕：在处理IO的时候，阻塞和非阻塞都是同步IO，只有使用了特殊的API才是异步IO</p>
</blockquote>
<br>

<p>对于网络IO</p>
<ul>
<li>一个典型的<strong>网络IO接口调用</strong>，分为两个阶段，分别是“<strong>数据就绪</strong>” 和 “<strong>数据读写</strong>”<ul>
<li><strong>数据就绪</strong>阶段分为<strong>阻塞和非阻塞</strong>，表现得结果就是，<strong>阻塞当前线程</strong>或是<strong>直接返回</strong>。</li>
</ul>
</li>
</ul>
<br>

<ul>
<li><p><strong>同步</strong>表示A向B请求调用一个网络IO接口时（或者调用某个业务逻辑API接口时），<strong>数据的读写</strong>都是由<strong>请求方A自己来完成的</strong>（不管是阻塞还是非阻塞）</p>
</li>
<li><p><strong>异步</strong>表示A向B请求调用一个网络IO接口时（或者调用某个业务逻辑API接口时），向B传入<strong>请求的事件</strong>以及<strong>事件发生时通知的方式</strong>，<strong>A就可以处理其它逻辑了</strong>，当B监听到事件处理完成后，会用事先约定好的通知方式，通知A处理结果。</p>
<ul>
<li><p>同步阻塞</p>
</li>
<li><p>同步非阻塞</p>
</li>
<li><p>异步阻塞</p>
</li>
<li><p>异步非阻塞</p>
</li>
</ul>
</li>
</ul>
<br>

<br>

<br>

<br>

<h2 id="5-2-Linux的五种IO模型"><a href="#5-2-Linux的五种IO模型" class="headerlink" title="5.2 Linux的五种IO模型"></a>5.2 Linux的五种IO模型</h2><img src="/2023/03/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20230303232426115.png" alt="image-20230303232426115" style="zoom:80%;">

<h3 id="阻塞-blocking"><a href="#阻塞-blocking" class="headerlink" title="阻塞 blocking"></a>阻塞 blocking</h3><p>调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的去检查这个函数有没有返回，必须等待这个函数返回才能进行下一步操作。</p>
<p>以read为例：</p>
<img src="/2023/03/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20230304000806869.png" alt="image-20230304000806869" style="zoom:80%;">

<br>

<h3 id="非阻塞-non-blocking（NIO）"><a href="#非阻塞-non-blocking（NIO）" class="headerlink" title="非阻塞 non-blocking（NIO）"></a>非阻塞 non-blocking（NIO）</h3><p>非阻塞等待，每隔一段时间就去检测IO事件是否就绪，若没有就绪就可以做其他事。</p>
<p>非阻塞I&#x2F;O执行系统调用总是立即返回，不管事件是否已经发生。若事件没有发生，则返回-1，此时可以根据errno区分情况。</p>
<p>对于<strong>accept，recv和send</strong>，事件未发生时，errno通常被设置为<strong>EAGAIN</strong>。</p>
<img src="/2023/03/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20230304001316512.png" alt="image-20230304001316512" style="zoom:80%;">

<br>

<h3 id="IO复用（multiplexing）"><a href="#IO复用（multiplexing）" class="headerlink" title="IO复用（multiplexing）"></a>IO复用（multiplexing）</h3><p>Linux用select&#x2F;poll&#x2F;epoll函数实现IO复用模型，这些函数也会使进程阻塞，但是和阻塞IO所不同的是这些函数<strong>可以同时阻塞多个IO操作</strong>。而且可以<strong>同时对多个读操作、写操作的IO函数进行检测</strong>。直到有数据可读或可写时，才真正调用IO操作函数。</p>
<p>用于在一个服务端线程中响应多个客户端，但是不是处理高并发的（多线程多进程）。</p>
<img src="/2023/03/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20230304002733110.png" alt="image-20230304002733110" style="zoom:80%;">

<br>

<h3 id="信号驱动（signal-driven）"><a href="#信号驱动（signal-driven）" class="headerlink" title="信号驱动（signal-driven）"></a>信号驱动（signal-driven）</h3><p>Linux用套接口进行信号驱动IO，安装一个<strong>信号处理函数</strong>，进程继续运行并不阻塞。当IO事件就绪，进程收到SIGIO信号，然后处理IO事件。</p>
<ul>
<li>内核在数据准备阶段是异步的，在数据读写结段是同步的</li>
<li>与非阻塞IO的区别在于它提供了消息通知机制，不需要用户进程不断轮询检查，减少了系统API的调用次数，提高了效率</li>
</ul>
<img src="/2023/03/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20230304003340232.png" alt="image-20230304003340232" style="zoom:80%;">

<br>

<h3 id="异步IO（asynchronous）"><a href="#异步IO（asynchronous）" class="headerlink" title="异步IO（asynchronous）"></a>异步IO（asynchronous）</h3><p>Linux中，可以调用 aio_read 函数告诉内核<strong>描述符缓冲区指针</strong>和<strong>缓冲区的大小</strong>、<strong>文件偏移</strong>及<strong>通知的方式</strong>等，然后立即返回，当内核将数据拷贝到缓冲区后，在通知应用程序。</p>
<img src="/2023/03/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20230304004046738.png" alt="image-20230304004046738" style="zoom:80%;">

<br>

<img src="/2023/03/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20230304004303084.png" alt="image-20230304004303084" style="zoom:80%;">

<br>

<br>

<br>

<br>

<h2 id="5-3-Web服务器简介及http协议"><a href="#5-3-Web服务器简介及http协议" class="headerlink" title="5.3 Web服务器简介及http协议"></a>5.3 Web服务器简介及http协议</h2><h3 id="Web-Server"><a href="#Web-Server" class="headerlink" title="Web Server"></a>Web Server</h3><p>网页服务器</p>
<p>一个 Web Server 就是一个<strong>服务器软件</strong>（程序），或者是<strong>运行这个服务器软件的硬件</strong>（计算机）。</p>
<p>其主要功能就是通过 <strong>HTTP</strong> 协议与<strong>客户端</strong>（通常是浏览器Browser）进行<strong>通信</strong>，来<strong>接收、存储、处理</strong>来自客户端的 <strong>HTTP请求</strong> ，并对其请求做出 <strong>HTTP响应</strong> ，返回给客户端其请求的内容（<strong>文件、网页等</strong>）或返回一个 <strong>Error 信息</strong>。</p>
<br>

<p><img src="/2023/03/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20230304004705396.png" alt="image-20230304004705396"></p>
<br>

<p>通常用户使用 Web浏览器 与相应服务器进行通信。在浏览器中键入<strong>”域名“或”IP:Port“</strong>，浏览器先将你的<strong>域名解析成相应的IP地址</strong>或者直接根据你的IP地址向对应的Web服务器发送一个 <strong>HTTP请求</strong> 。这一过程首先要通过<strong>TCP协议的三次握手</strong>建立与目标Web服务器的连接，然后HTTP协议生成针对目标Web服务器的<strong>HTTP请求报文</strong>，通过<strong>TCP、IP等协议</strong>发送到目标服务器上。</p>
<br>

<br>

<br>

<h3 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h3><p><strong>简介</strong></p>
<p><strong>超文本传输协议</strong>（Hypertext Transfer Protocol，HTTP）是一个简单的 <strong>请求-响应</strong> 协议，它通常运行在 TCP 之上。</p>
<ul>
<li>它指定了客户端可能发送给服务器<strong>什么样的消息</strong>以及得到<strong>什么样的响应</strong>。</li>
<li>请求和响应消息的<strong>头</strong>以 ASCII 形式给出；而<strong>消息内容</strong>则具有一个类似 MIME 的格式。</li>
<li>HTTP是万维网的数据通信的基础。</li>
</ul>
<p><strong>概述</strong></p>
<p>HTTP 是一个客户端终端（用户）和服务器端（网站）请求和应答的标准（TCP）。</p>
<ul>
<li>通过使用网页浏览器、网络爬虫或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口（默认端口为80）。我们称这个<strong>客户端</strong>为<strong>用户代理程序</strong>（user agent）。</li>
<li>应答的服务器上存储着一些资源，比如 HTML 文件和图像。我们称这个<strong>应答服务器</strong>为<strong>源服务器</strong>（origin server）。在用户代理和源服务器中间可能存在多个“<strong>中间层</strong>”，比如<strong>代理服务器</strong>、<strong>网关</strong>或者<strong>隧道</strong>（tunnel）。</li>
<li>尽管 TCP&#x2F;IP 协议是互联网上最流行的应用，HTTP 协议中，并没有规定必须使用它或它支持的层。事实上，HTTP可以在任何互联网协议上，或其他网络上实现。<strong>HTTP 假定其下层协议提供可靠的传输</strong>。因此，任何能够提供这种保证的协议都可以被其使用。因此也就是其在  TCP&#x2F;IP 协议族使用 TCP 作为其传输层。</li>
</ul>
<p>通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的 TCP 连接。HTTP服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如”HTTP&#x2F;1.1 200 OK”，以及返回的内容，如请求的文件、错误消息、或者其它信息。</p>
<br>

<p><strong>工作原理</strong></p>
<p>HTTP 协议定义 Web 客户端如何从 Web 服务器请求 Web 页面，以及服务器如何把 Web 页面传送给客户端。HTTP 协议采用了<strong>请求&#x2F;响应模型</strong>。</p>
<ul>
<li>客户端向服务器发送一个<strong>请求报文</strong>，请求报文包含<strong>请求的方法</strong>、<strong>URL</strong>、<strong>协议版本</strong>、<strong>请求头部</strong>和<strong>请求数据</strong>。</li>
<li>服务器以一个<strong>状态行</strong>作为响应，响应的内容包括<strong>协议的版本</strong>、<strong>成功或者错误代码</strong>、<strong>服务器信息</strong>、<strong>响应头部</strong>和<strong>响应数据</strong>。</li>
</ul>
<p><strong>HTTP请求&#x2F;响应的步骤：</strong></p>
<ol>
<li>客户端连接到 Web服务器<ul>
<li>客户端比如浏览器，与Web服务器的HTTP端口(默认为<strong>80</strong>)建立一个TCP套接字连接</li>
</ul>
</li>
<li>客户端发送HTTP请求<ul>
<li>通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由 <strong>请求行</strong>、<strong>请求头部</strong>、<strong>空行</strong>和<strong>请求数据</strong> 4部分组成</li>
</ul>
</li>
<li>服务器接受请求并返回HTTP响应<ul>
<li>Web服务器<strong>解析请求</strong>，<strong>定位请求资源</strong>。</li>
<li>服务器<strong>将资源副本写到TCP套接字</strong>，由客户端读取。</li>
<li>一个响应由 <strong>状态行</strong>、<strong>响应头部</strong>、<strong>空行</strong>和<strong>响应数据</strong> 4部分组成</li>
</ul>
</li>
<li>释放连接 TCP 连接<ul>
<li>若 connection 模式为 <strong>close</strong> ，则服务器主动关闭 TCP 连接，客户端被动关闭连接，释放TCP连接；</li>
<li>若 connection 模式为 <strong>keepalive</strong> ，则该连接会保持一段时间，在该时间内可以继续接收请求；</li>
</ul>
</li>
<li>客户端浏览器解析 HTML 内容<ul>
<li>客户端浏览器<strong>首先解析状态行</strong>，查看表明请求是否成功的状态代码。<strong>然后解析每一个响应头</strong>，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口显示。</li>
</ul>
</li>
</ol>
<br>

<p>例如：在浏览器地址栏输入URL，按下回车之后</p>
<ol>
<li>浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的IP地址</li>
<li>解析出IP地址后，根据该IP地址和默认端口80，和服务器建立TCP连接</li>
<li>浏览器发出读取文件（URL中域名后面部分对应的文件）的HTTP请求，该请求报文作为TCP三次握手的第三个报文的数据发送给服务器</li>
<li>服务器对浏览器请求做出响应，并把对应的HTML文本发送给浏览器</li>
<li>释放TCP连接</li>
<li>浏览器将解析该HTML文本并显示内容</li>
</ol>
<br>

<img src="/2023/03/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20230304011652447.png" alt="image-20230304011652447" style="zoom:80%;">

<blockquote>
<p>HTTP协议规定，请求从客户端发出，最后服务端响应请求并返回。也即，是先从客户端开始建立通信的，<strong>服务端在没有接收到请求之前不会发送响应</strong>。</p>
</blockquote>
<br>

<br>

<br>

<h3 id="http报文格式"><a href="#http报文格式" class="headerlink" title="http报文格式"></a>http报文格式</h3><p><img src="/2023/03/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20230304015519816.png" alt="请求报文格式"></p>
<p><img src="/2023/03/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20230304015552413.png" alt="响应报文格式"></p>
<br>

<p>Web服务器要<strong>解析请求，并生成响应信息</strong></p>
<br>

<p>我们要了解各种<strong>请求头响应头</strong>的含义，以及<strong>状态码</strong>的含义</p>
<img src="/2023/03/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20230304020932915.png" alt="image-20230304020932915" style="zoom:80%;">

<br>

<p>HTTP请求的各种<strong>请求方法</strong>，这里主要用 GET 和 POST<br><img src="/2023/03/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20230304021118740.png" alt="image-20230304021118740" style="zoom:80%;"></p>
<br>

<br>

<br>

<h2 id="5-4-服务器编程基本框架"><a href="#5-4-服务器编程基本框架" class="headerlink" title="5.4 服务器编程基本框架"></a>5.4 服务器编程基本框架</h2><p>以及两种高效的<strong>事件处理模式</strong></p>
<br>

<h3 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h3><p>Web 服务器程序种类繁多，但基本框架都一样，不同之处在于逻辑处理。</p>
<img src="/2023/03/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20230304022023757.png" alt="image-20230304022023757" style="zoom:80%;">

<table>
<thead>
<tr>
<th>模块</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>I&#x2F;O 处理单元</td>
<td>处理客户连接，读写网络数据</td>
</tr>
<tr>
<td>逻辑单元</td>
<td>业务进程或线程</td>
</tr>
<tr>
<td>网络存储单元</td>
<td>数据库、文件或缓存</td>
</tr>
<tr>
<td>请求队列</td>
<td>各单元之间的通信方式</td>
</tr>
</tbody></table>
<ul>
<li><p><strong>I&#x2F;O处理单元</strong>是服务器管理客户连接的模块。它通常要完成一下工作：</p>
<ul>
<li>等待并接受新的客户链接</li>
<li>接收客户数据</li>
<li>将服务器响应数据返回给客户端</li>
</ul>
<p>但是数据的收发不一定在I&#x2F;O处理单元中执行，也可能在逻辑单元中执行，具体取决于事件处理模式</p>
</li>
<li><p>一个<strong>逻辑单元</strong>通常是一个进程或线程。它分析并处理客户数据，然后将结果<strong>传递给I&#x2F;O处理单元</strong>或者<strong>直接发送给客户端</strong>（取决于事件处理模式）。服务器通常拥有多个逻辑单元，以实现对多个客户任务的并发处理</p>
</li>
<li><p><strong>网络存储单元</strong>可以是数据库、缓存和文件，但不是必须的</p>
</li>
<li><p><strong>请求队列</strong>是个单元之间的通信方式的抽象。</p>
<ul>
<li>I&#x2F;O处理单元接收到客户请求时，需要以某种方式通知一个逻辑单元来处理该请求。</li>
<li>同样，多个逻辑单元同时访问一个存储单元时，也需要采用某种机制来协调处理竞态条件。</li>
<li>请求队列通常被实现为<strong>池(进程池、线程池)的一部分</strong>。</li>
</ul>
</li>
</ul>
<br>

<br>

<h3 id="两种高效的事件处理模式"><a href="#两种高效的事件处理模式" class="headerlink" title="两种高效的事件处理模式"></a>两种高效的事件处理模式</h3><p>服务器程序通常需要处理三类事件：</p>
<ul>
<li>I&#x2F;O事件</li>
<li>信号</li>
<li>定时事件</li>
</ul>
<br>

<p>两种高效的事件处理模式：</p>
<ul>
<li><strong>Reactor</strong>   (一般用同步I&#x2F;O模型实现)</li>
<li><strong>Proactor</strong>  (一般用异步I&#x2F;O模型实现，或者用同步I&#x2F;O模型模拟)</li>
</ul>
<br>

<h4 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h4><ul>
<li><p>要求<strong>主线程</strong>(<strong>I&#x2F;O处理单元</strong>)只负责<u>监听文件描述符上是否有事件发生</u>，有的话就立即将该事件通知<strong>工作线程</strong>（<strong>逻辑单元</strong>），将socket可读可写事件放入<strong>请求队列</strong>，交给工作线程处理。除此之外，主线程不做任何其他实质性的工作。</p>
</li>
<li><p><u>读写数据，接受新的连接，以及处理客户请求</u>均在<strong>工作线程</strong>中完成。</p>
</li>
</ul>
<br>

<p>使用同步I&#x2F;O(epoll_wait为例)实现的Reactor模式的工作流程：</p>
<ol>
<li>主线程往epoll内核事件表中注册socket上的读就绪事件</li>
<li>主线程调用epoll_wait等待socket上有数据可读</li>
<li>当socket上有数据可读时，epoll_wait通知主线程。主线程则将socket可读事件放入请求队列</li>
<li>睡眠在请求队列上的某个工作线程被唤醒，它从socket读取数据，并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件</li>
<li>主线程调用epoll_wait等待socket可写</li>
<li>当socket可写时，epoll_wait通知主线程。主线程将socket可写事件放入请求队列</li>
<li>睡眠在请求队列上的某个工作线程被唤醒，他往socket上写入服务器处理客户请求的结果</li>
</ol>
<br>

<img src="/2023/03/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20230304030515214.png" alt="image-20230304030515214" style="zoom:90%;">

<br>

<br>

<h4 id="Proactor"><a href="#Proactor" class="headerlink" title="Proactor"></a>Proactor</h4><ul>
<li>将所有的<strong>I&#x2F;O操作</strong>都交给<strong>主线程和内核</strong>来处理(进行读、写)，<strong>工作线程仅仅负责业务逻辑</strong>。</li>
</ul>
<br>

<p>使用异步I&#x2F;O模型实现的Proactor模式的工作流程：（以 aio_read 和 aio_wirte 为例)</p>
<ol>
<li><strong>主线程</strong>调用 aio_read 函数向内核注册socket上的<strong>读完成事件</strong>，并告诉内核用户<strong>读缓冲区的位置</strong>，以及读操作完成时<strong>如何通知应用程序</strong>(这里以信号为例)</li>
<li>主线程继续处理其他逻辑</li>
<li>当socket上的数据被读入缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据已经可用</li>
<li><strong>应用程序</strong>预先定义好的<strong>信号处理函数</strong>选择一个工作线程来处理客户请求。<br><strong>工作线程</strong>处理完客户请求后，调用 aio_write 函数向内核注册socket上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序。</li>
<li>主线程继续处理其他逻辑</li>
<li>当用户数据被写入socket之后，内核将向应用程序发送以一个信号，以通知应用程序数据已经发送完毕</li>
<li>应用程序预先定义好的信号处理函数选择一个工作线程来做善后工作，比如决定是否关闭socket</li>
</ol>
<br>

<img src="/2023/03/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20230304032743438.png" alt="image-20230304032743438" style="zoom:90%;">



<br>

<br>

<h4 id="模拟Proactor模式"><a href="#模拟Proactor模式" class="headerlink" title="模拟Proactor模式"></a>模拟Proactor模式</h4><p>使用<strong>同步I&#x2F;O</strong>方式模拟Procator模式。</p>
<p><strong>原理</strong>：主线程执行数据读写操作，读写完成之后，主线程向工作线程通知这一”完成事件”。从工作线程的角度看，它们就直接获得了数据读写的结果，接下来要做的只是对读写的结果进行逻辑处理。</p>
<br>

<p>使用同步I&#x2F;O模型(epoll_wait为例)模拟Proactor模式的工作流程：</p>
<ol>
<li>主线程往epoll内核事件表中注册socket上的读就绪事件</li>
<li>主线程调用epoll_wait等待socket上有数据可读</li>
<li>当socket上有数据可读时，epoll_wait通知主线程。主线程从socket循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列</li>
<li>睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往epoll内核事件表中注册socket上的写就绪事件</li>
<li>主线程调用epoll_wait等待socket可写</li>
<li>当socket可写时，epoll_wait通知主线程。主线程往socket上写入服务器处理客户请求的结果</li>
</ol>
<br>

<img src="/2023/03/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20230304033941878.png" alt="image-20230304033941878" style="zoom:90%;">

<br>

<br>

<br>

<br>

<h2 id="5-5-线程同步机制类封装及线程池实现"><a href="#5-5-线程同步机制类封装及线程池实现" class="headerlink" title="5.5 线程同步机制类封装及线程池实现"></a>5.5 线程同步机制类封装及线程池实现</h2><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>线程池是由服务器预先创建的一组子线程，线程池中的线程数量应该和 CPU 数量差不多。</p>
<ul>
<li>线程池中的所有子线程都运行着相同的代码。</li>
<li>当有新的任务到来时，主线程将通过某种方式选择线程池中的某一个子线程来为之服务。</li>
<li>相于与动态的创建子线程，选择一个已经存在的子线程的代价显然要小得多。</li>
<li>至于主线程选择哪个子线程来为新任务服务，则有多种方式：<ul>
<li>主线程使用<strong>某种算法</strong>来主动选择子线程。最简单、最常用的算法是随机算法和 Round Robin（轮流选取）算法，但更优秀、更智能的算法将使任务在各个工作线程中更均匀地分配，从而减轻服务器的整体压力。</li>
<li>主线程和所有子线程通过一个<strong>共享的工作队列</strong>来同步，子线程都睡眠在该工作队列上。当有新的任务到来时，主线程将任务添加到工作队列中。这将唤醒正在等待任务的子线程，不过只有一个子线程将获得新任务的”接管权“，它可以从工作队列中取出任务并执行之，而其他子线程将继续睡眠在工作队列上。</li>
</ul>
</li>
</ul>
<br>

<p><img src="/2023/03/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20230304143320886.png" alt="线程池模型"></p>
<br>

<p><strong>线程数量</strong></p>
<p>线程池中的<strong>线程数量最直接的限制因素</strong>是中央处理器(CPU)的处理器(processors&#x2F;cores)的数量N ：如果你的CPU是4-cores的，对于<strong>CPU密集型</strong>的任务(如视频剪辑等消耗CPU计算资源的任务)来说，那线程池中的线程数量最好也设置为4（或者+1防止其他因素造成的线程阻塞）；对于<strong>IO密集型</strong>的任务，一般要多于CPU的核数，因为线程间竞争的不是CPU的计算资源而是IO，IO的处理一般较慢，多于cores数的线程将为CPU争取更多的任务，不至在线程处理IO的过程造成CPU空闲导致资源浪费。</p>
<p>还可以动态控制线程池中的线程数量。</p>
<br>

<p><strong>线程池的特点</strong></p>
<ul>
<li><strong>空间换时间</strong>，浪费服务器的硬件资源，换取运行效率。</li>
<li>池是一组资源的集合，这组资源在服务器启动之初就被完全创建好并初始化，这称为<strong>静态资源</strong>。</li>
<li>当服务器进入正式运行阶段，开始处理客户请求的时候，如果它需要相关的资源，可以直接从池中获取，<strong>无需动态分配</strong>。</li>
<li>当服务器处理完一个客户连接后，可以把相关的资源放回池中，<strong>无需执行系统调用释放资源</strong>。</li>
</ul>
<br>

<br>

<br>

<br>

<br>

<br>

<br>

<h2 id="5-6-其他内容"><a href="#5-6-其他内容" class="headerlink" title="5.6 其他内容"></a>5.6 其他内容</h2><p><strong>EPOLLONESHOT事件</strong></p>
<ul>
<li>即使可以使用 ET 模式，一个socket 上的某个事件还是可能被触发多次。这在并发程序中就会引起一个问题。比如一个线程在读取完某个 socket 上的数据后开始处理这些数据，而在数据的处理过程中该socket 上又有新数据可读（EPOLLIN 再次被触发），此时另外一个线程被唤醒来读取这些新的数据。于是就出现了两个线程同时操作一个 socket 的局面。一个socket连接在任一时刻都只被一个线程处理，可以使用 epoll 的 EPOLLONESHOT 事件实现。</li>
<li>对于注册了 EPOLLONESHOT 事件的文件描述符，操作系统最多触发其上注册的一个可读、可写或者异常事件，且只触发一次，除非我们使用 epoll_ctl 函数重置该文件描述符上注册的 EPOLLONESHOT 事件。这样，当一个线程在处理某个 socket 时，其他线程是不可能有机会操作该 socket 的。但反过来思考，注册了 EPOLLONESHOT 事件的 socket 一旦被某个线程处理完毕， 该线程就应该立即重置这个socket 上的 EPOLLONESHOT 事件，以确保这个 socket 下一次可读时，其 EPOLLIN 事件能被触发，进而让其他工作线程有机会继续处理这个 socket。</li>
</ul>
<br>

<br>

<br>

<p><strong>有限状态机</strong></p>
<ol>
<li>有限状态机：逻辑单元内部的一种高效编程方法：有限状态机（finite state machine）。有的应用层协议头部包含数据包类型字段，每种类型可以映射为逻辑单元的一种执行状态，服务器可以根据它来编写相应的处理逻辑。如下是一种状态独立的有限状态机：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">STATE_MACHINE</span>( Package _pack )</span><br><span class="line">&#123;</span><br><span class="line">	PackageType _type = _pack.<span class="built_in">GetType</span>();</span><br><span class="line">	<span class="keyword">switch</span>( _type )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> type_A:</span><br><span class="line">			<span class="built_in">process_package_A</span>( _pack );</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> type_B:</span><br><span class="line">			<span class="built_in">process_package_B</span>( _pack );</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;<span class="comment">// 上面是一个简单的有限状态机，只不过该状态机的每个状态都是相互独立的，即状态之间没有相互转移。</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>状态之间的转移是需要状态机内部驱动，如下代码：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">STATE_MACHINE</span>()</span><br><span class="line">&#123;</span><br><span class="line">	State cur_State = type_A;</span><br><span class="line">	<span class="keyword">while</span>( cur_State != type_C )</span><br><span class="line">	&#123;</span><br><span class="line">		Package _pack = <span class="built_in">getNewPackage</span>();</span><br><span class="line">		<span class="keyword">switch</span>( cur_State )</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> type_A:</span><br><span class="line">                <span class="built_in">process_package_state_A</span>( _pack );</span><br><span class="line">                cur_State = type_B;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> type_B:</span><br><span class="line">                <span class="built_in">process_package_state_B</span>( _pack );</span><br><span class="line">                cur_State = type_C;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该状态机包含三种状态：type_A、type_B 和 type_C，其中 type_A 是状态机的开始状态，type_C 是状态机的结束状态。状态机的当前状态记录在 cur_State 变量中。在一趟循环过程中，状态机先通getNewPackage 方法获得一个新的数据包，然后根据 cur_State 变量的值判断如何处理该数据包。数据包处理完之后，状态机通过给 cur_State 变量传递目标状态值来实现状态转移。那么当状态机进入下一趟循环时，它将执行新的状态对应的逻辑。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++开发</category>
        <category>高性能服务器</category>
      </categories>
      <tags>
        <tag>web服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux多进程</title>
    <url>/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="2-Linux多进程开发"><a href="#2-Linux多进程开发" class="headerlink" title="2.Linux多进程开发"></a>2.Linux多进程开发</h1><hr>
<br>

<h2 id="2-1-进程概述"><a href="#2-1-进程概述" class="headerlink" title="2.1 进程概述"></a>2.1 进程概述</h2><p><strong>程序和进程</strong></p>
<span id="more"></span>

<blockquote>
<p><strong>程序</strong></p>
<p>程序是包含一系列信息的文件，这些文件描述了如何在运行时创建一个进程。</p>
<p>包含内容：</p>
<ul>
<li>二进制格式标识：每个程序文件都包含用于描述可执行文件格式的元信息。内核利用此信息来解释文件中的其他信息。（ELF可执行链接格式）</li>
<li>机器语言指令：对程序算法进行编码。</li>
<li>程序入口地址：标识程序开始执行时的起始指令位置。</li>
<li>数据：程序文件包含的变量初始值和程序使用的字面量值（如字符串）。</li>
<li>符号表及重定位表：描述程序中函数和变量的位置及名称。这些表格有多重用途，其中包括调试和运行时的符号解析（动态链接）。</li>
<li>共享库和动态链接信息：程序文件所包含的一些字段，列出了程序运行时需要使用的共享库，以及加载共享库的动态链接器的路径名。</li>
<li>其他信息：程序文件还包含其他信息，用来描述如何创建进程。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>进程</strong></p>
<ul>
<li>进程是正在运行的程序的实例。<ul>
<li>是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。</li>
<li>是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。</li>
</ul>
</li>
<li>可以用一个程序来创建多个进程，进程是由内核定义的抽象实体，并为该实体分配用以执行程序的各项系统资源。<ul>
<li>从内核的角度看，进程由用户内存空间和一些列的内核数据结构组成，其中用户内存空间包含了程序代码及代码所使用的变量，而内核数据结构则用于维护进程状态信息。</li>
<li>记录在内核数据结构中的信息包括许多与进程相关的标识号（IDs）、虚拟内存表、打开文件的描述符表，信号传递及处理的有关信息、进程资源使用及限制、当前工作目录和大量的其他信息。</li>
</ul>
</li>
</ul>
</blockquote>
<br>

<p><strong>单道、多道程序设计</strong></p>
<p>单道程序：在计算机内存中只允许一个的程序运行。</p>
<p>多道程序：计算机内存中同时存放多道相互独立的程序使它们在管理程序控制下，相互穿插运行，两个或两个以上程序在计算机系统中处于开始到结束之间的状态，这些车程序共享计算机资源。（提高CPU的利用率）</p>
<ul>
<li>对于单CPU系统而言，宏观上可以使多个程序像是同时运行，实际上任意时刻CPU上运行的程序只有一个。</li>
<li>在多道程序设计模型中，多个程序轮流使用CPU。</li>
</ul>
<br>

<p><strong>时间片</strong></p>
<p>时间片 timeslice 又称为“量子 quantum”或“处理器片processor slice”，是操作系统分配给每个正在运行的进程微观上的一段CPU时间。</p>
<p>时间片由操作系统内核的调度程序分配给每个进程。</p>
<br>

<p><strong>并行和并发</strong></p>
<p>并行（parallel）：指在同一时刻，有多条指令在多个处理器上同时执行。</p>
<p>并发（concurrency）：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。</p>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230204223514971-16759624275181.png" alt="image-20230204223514971"></p>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230204223803946-16759624275193.png" alt="image-20230204223803946"></p>
 <br>

<p><strong>进程控制块 PCB</strong></p>
<p>内核为每个进程分配以一个 PCB 进程控制块，维护进程相关的信息，Linux内核的进程控制块是 task_struct 结构体。</p>
<p>在 &#x2F;usr&#x2F;src&#x2F;linux-headers-xxx&#x2F;include&#x2F;linux&#x2F;sched.h 文件中可以查看 struct task_struct 结构体定义，其部分内部成员如下：</p>
<ul>
<li>进程id：系统中每个进程有唯一的 id ，用 pid_t 类型表示，是一个非负整数</li>
<li>进程的状态：就绪、运行、挂起、停止等状态</li>
<li>进程切换时需要保存和恢复的一些CPU寄存器信息</li>
<li>描述虚拟地址空间的信息</li>
<li>描述控制终端的信息</li>
<li>当前工作目录</li>
<li>umask掩码</li>
<li>文件描述符表，包含很多执行file结构体的指针</li>
<li>和信号相关的信息</li>
<li>用户id和组id</li>
<li>会话（session）和进程组</li>
<li>进程可以使用的资源上限（可用ulimit指令查看系统内核资源上限）</li>
</ul>
<p><br><br><br></p>
<h2 id="2-2-进程状态转换"><a href="#2-2-进程状态转换" class="headerlink" title="2.2 进程状态转换"></a>2.2 进程状态转换</h2><h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><p>进程状态反映进程执行过程的变化。</p>
<p><code>三态模型</code>中，进程状态分为三个基本状态 —— 就绪态、运行态、阻塞态。</p>
<blockquote>
<p><strong>运行态</strong>：进程占有处理器正在运行。</p>
<p><strong>就绪态</strong>：进程具备运行条件，等待系统分配处理器以便运行。当进程分配到除CPU外的所有必要资源后，只要再获得CPU，便可立即执行。多个就绪进程排成队列，称为就绪队列。</p>
<p><strong>阻塞态</strong>：又称为 等待态(wait) 或 睡眠态(sleep)，指进程不具备运行条件，正在等待某个事件的完成。</p>
</blockquote>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230204225943684-16759624275192.png" alt="image-20230204225943684"></p>
<p><code>五态模型</code>中，进程状态分为 ——  新建态、就绪态、运行态、阻塞态、终止态。</p>
<blockquote>
<p><strong>新建态</strong>：进程刚被创建时的状态，尚未进入就绪队列</p>
<p><strong>终止态</strong>：进程完成任务达到正常结束点，或出现无法克服的错误而异常终止，或被操作系统及有终止权的进程所终止时所处的状态。进入终止态的进程不再执行，但依然保留再操作系统中等待善后。一旦其他进程完成了对终止态进程的信息抽取之后，操作系统将删除该进程。</p>
</blockquote>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230204230502376-16759624275195.png" alt="image-20230204230502376"></p>
<br>

<h3 id="进程相关指令"><a href="#进程相关指令" class="headerlink" title="进程相关指令"></a>进程相关指令</h3><p><strong>查看进程</strong></p>
<p><code>ps aux/ajx</code></p>
<p>a：显示终端上的所有进程，包括其他用户的进程</p>
<p>u：显示进程的详细信息</p>
<p>x：显示没有控制终端的进程</p>
<p>j：列出与作业控制相关的进程</p>
<br>

<blockquote>
<p>stat标识</p>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230204232608821-16759624275196.png" alt="image-20230204232608821"></p>
</blockquote>
<br>

<p><strong>实时显示进程状态</strong></p>
<p><code>top</code></p>
<p>可以在 top 命令后加 -d 来指定显示信息更新的时间间隔</p>
<p>在 top 命令执行后，可以按一下按键对显示结果进行排序</p>
<ul>
<li>M 根据内存使用量</li>
<li>P 根据CPU占有率</li>
<li>T 根据进程运行时间长短</li>
<li>U 根据用户名筛选</li>
<li>K 输入指定的 PID 杀死进程</li>
</ul>
<br>

<p><strong>杀死进程</strong></p>
<p><code>kill [-signal] pid</code></p>
<p><code>kill -l</code>列出所有signal信号(信号宏)</p>
<p>比如：</p>
<ul>
<li><p><code>kill -SIGKILL 进程ID</code></p>
</li>
<li><p><code>kill -9 进程ID</code> </p>
</li>
<li><p><code>killall name</code> 根据进程名杀死进程</p>
</li>
</ul>
<br>

<p><strong>进程号和相关函数</strong></p>
<ul>
<li><p>每个进程都由<strong>进程号</strong>来表示，其类型为 pid_t（整型），进程号范围：0~32767。</p>
</li>
<li><p>任何进程（除init进程）都是由另一个进程创建，即父进程， PPID 为父进程号</p>
</li>
<li><p><strong>进程组</strong>是一个或多个进程的集合。他们相互关联，进程组可以接收同一终端的各种信号，关联的进程有一个进程组号 PGID 。默认情况下，当前的进程号会当做当前的进程组号。</p>
</li>
</ul>
<p>相关函数：</p>
<ul>
<li><code>pid_t getpid(void);</code></li>
<li><code>pid_t getppid(void);</code></li>
<li><code>pid_t getpgid(pid_t pid);</code></li>
</ul>
<br>

<br>

<h2 id="2-3-进程创建与调试"><a href="#2-3-进程创建与调试" class="headerlink" title="2.3 进程创建与调试"></a>2.3 进程创建与调试</h2><p>系统允许一个进程创建新进程，即紫禁城，子进程还可以创建新的子进程，形成树结构模型。</p>
<h3 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a>fork函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建子进程</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		- 成功：子进程中返回0，父进程中返回子进程 ID </span></span><br><span class="line"><span class="comment">		- 失败：子进程不被创建，父进程中返回-1，并设置errno</span></span><br><span class="line"><span class="comment">		失败的两个主要原因：</span></span><br><span class="line"><span class="comment">		1. 当前系统的进程数已经达到了系统规定的上限，这时 errno 的值被设置为 EAGAIN</span></span><br><span class="line"><span class="comment">		2. 系统内存不足，这是 errno 的值被设置为 ENOMEM</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<br>

<p>用法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//父进程要执行的内容</span></span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//子进程要执行的内容</span></span><br><span class="line">    	...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//都会执行的内容</span></span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<h3 id="父、子进程虚拟地址空间情况"><a href="#父、子进程虚拟地址空间情况" class="headerlink" title="父、子进程虚拟地址空间情况"></a>父、子进程虚拟地址空间情况</h3><p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230205003125065-16759624275194.png" alt="image-20230205003125065"></p>
<p>进程的实际pid在内核空间</p>
<p>变量pid的值在栈空间</p>
<br>

<blockquote>
<p>fork() 是通过 写时拷贝（copy-on-write） 实现。</p>
<p>写时拷贝时一钟可以推迟甚至避免拷贝数据的技术。内核此时并不复制整个进程的地址空间，而是让父子进程共享一个地址空间。</p>
<p>只有在需要写入的时候才会复制地址空间，从而使得各个进程拥有各自的地址空间，在此之前只有以只读方式共享。</p>
<p>注意：fork后父子进程共享文件</p>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230205011611597-16759624275197.png" alt="image-20230205011611597"></p>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230205011543783-167596242752027.png" alt="image-20230205011543783"></p>
</blockquote>
<br>

<blockquote>
<p>不同的进程访问同样的逻辑地址（虚拟地址）而对应的物理地址不同，是由于各自页表的不同。</p>
<p>linux系统下每个进程都拥有自己的页表，父进程fork出新的子进程时，子进程拷贝一份父进程的页表，且父子进程将页表状态修改为写保护。当父进程或子进程发生写操作时将会发生缺页异常，缺页异常处理函数将会为子进程分配新的物理地址。</p>
</blockquote>
<br>

<br>

<h3 id="父子进程关系"><a href="#父子进程关系" class="headerlink" title="父子进程关系"></a>父子进程关系</h3><p><strong>不同点</strong></p>
<ol>
<li>fork()函数的返回值不同<ul>
<li>父进程中：&gt;0 返回子进程的ID</li>
<li>子进程中：&#x3D;0</li>
</ul>
</li>
<li>PCB中的一些数据<ul>
<li>当前进程的id pid</li>
<li>当前进程的父进程id ppid</li>
<li>信号集</li>
</ul>
</li>
</ol>
<br>

<p><strong>共同点</strong></p>
<p>某些状态下：子进程刚被创建出来，还没有执行任何的写数据的操作</p>
<pre><code>- 用户区的数据
- 文件描述符表
</code></pre>
<p>父子进程对变量是不是共享的？</p>
<ul>
<li>刚开始是共享的，如果数据发生修改则不共享</li>
<li>读时共享，写时拷贝</li>
</ul>
<br>

<h3 id="GDB多进程调试"><a href="#GDB多进程调试" class="headerlink" title="GDB多进程调试"></a>GDB多进程调试</h3><p>GDB默认只能跟踪一个进程，可以在fork函数调用前，通过指令设置 GDB 调试工具跟踪父进程或者是子进程，默认跟踪父进程。</p>
<br>

<ul>
<li>设置调试父进程或子进程：</li>
</ul>
<p><code>set follow-fork-mod [parent(default) | child]</code></p>
<ul>
<li>设置调试模式：</li>
</ul>
<p><code>set detach-on-fork [on(default) | off]</code></p>
<p>​	on：调试当前进程时，其他进程继续运行</p>
<p>​	off：调试当前进程时，其他进程被 GDB 挂起</p>
<ul>
<li>查看调试的进程：</li>
</ul>
<p><code>info inferiors</code></p>
<ul>
<li>切换当前调试的进程：</li>
</ul>
<p><code>inferior 编号</code>（若切换的进程被挂起，切换后先 c ）</p>
<ul>
<li>使进程脱离 GDB 调试：</li>
</ul>
<p><code>detach inferiors id</code></p>
<br>

<p><br><br></p>
<br>

<h2 id="2-4-exec函数族"><a href="#2-4-exec函数族" class="headerlink" title="2.4 exec函数族"></a>2.4 exec函数族</h2><p>c++有函数重载，c语言没有；</p>
<p>函数族即一系列功能相似的函数。</p>
<br>

<ul>
<li>exec 函数族的作用是根据指定文件名找到可执行文件，并用它来取代调用进程的内容，换句话说，就是在调用进程内部执行一个可执行文件。（实际应用时一般在子进程中执行 exec函数族）</li>
<li>exec 函数族的函数执行成功后不会返回，因为调用进程的实体，包括代码段、数据段和堆栈等都已经被新的内容取代，只留下进程ID等一些表面上的信息仍保持原样。只有调用失败了，才会返回－１，从原程序的调用点接着往下执行。</li>
</ul>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230205022237610-16759624275198.png" alt="image-20230205022237610"></p>
<br>

<p><strong>exec函数族</strong></p>
<blockquote>
<p>exec后的字母表示传参方式和搜索规则</p>
<ul>
<li><p>l(list)	参数地址列表，以空指针结尾</p>
</li>
<li><p>v(vector)  存有个参数地址的指针数组的地址</p>
</li>
<li><p>p(path)	按 PATH 环境变量指定的目录搜索可执行文件</p>
</li>
<li><p>e(environment) 存有环境变量字符串地址的指针数组的地址</p>
</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ...<span class="comment">/* (char *) NULL */</span>)</span>；</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- path：需要指定的执行文件的路径或名称（相对路径或绝对路径）（推荐使用绝对路径）</span></span><br><span class="line"><span class="comment">		- arg：可执行文件的参数列表（第一个参数一般没什么作用，为了方便，一般写的是执行程序的名称，从第二个参数开始往后，就是程序执行所需的参数列表，并以 NULL 结尾（哨兵））</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		只有调用失败，才有返回值-1，并设置errno。</span></span><br><span class="line"><span class="comment">		调用成功没有返回值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg, ...<span class="comment">/* (char *) NULL */</span>)</span>；</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	会到环境变量中查找指定的可执行文件，如果找到了就执行，找不到就执行原程序</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- file：需要执行的可执行文件的文件名</span></span><br><span class="line"><span class="comment">		- arg：可执行文件的参数列表（第一个参数一般没什么作用，为了方便，一般写的是执行程序的名称，从第二个参数开始往后，就是程序执行所需的参数列表，并以 NULL 结尾（哨兵））</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		只有调用失败，才有返回值-1，并设置errno。</span></span><br><span class="line"><span class="comment">		调用成功没有返回值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ...<span class="comment">/*, (char *) NULL, char *const envp[] */</span>)</span>；</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *<span class="type">const</span> argv[])</span>；</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">用例：</span></span><br><span class="line"><span class="comment">	char * argv[] = &#123;&quot;ps&quot;, &quot;aux&quot;, NULL&#125;;</span></span><br><span class="line"><span class="comment">	execv(&quot;/bin/ps&quot;, arg);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[])</span>；</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">execvpe</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>；</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>；</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">用例：</span></span><br><span class="line"><span class="comment">	char * argv[] = &#123;&quot;ps&quot;, &quot;aux&quot;, NULL&#125;;</span></span><br><span class="line"><span class="comment">	char * envp[] = &#123;&quot;/home/nowcoder&quot;, &quot;/home/aaa&quot;, &quot;/home/bbb&quot;&#125;;</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	execve(&quot;ps&quot;, arg, envp);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<p><br><br></p>
<h2 id="2-5-进程控制"><a href="#2-5-进程控制" class="headerlink" title="2.5 进程控制"></a>2.5 进程控制</h2><h3 id="进程退出"><a href="#进程退出" class="headerlink" title="进程退出"></a>进程退出</h3><p><strong>exit函数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#incldue <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> _exit(<span class="type">int</span> status);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- status：进程退出时的一个状态信息。父进程回收子进程资源的时候可以获取到。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	exit是标准C库的函数，比_exit多做了</span></span><br><span class="line"><span class="comment">	1.调用退出处理函数</span></span><br><span class="line"><span class="comment">	2.刷新I/O缓存</span></span><br><span class="line"><span class="comment">	3.关闭文件描述符</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230205024702546-16759624275209.png" alt="image-20230205024702546"></p>
<p><br><br></p>
<h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h3><p>父进程运行结束，但子进程还在运行，这样的子进程就成为孤儿进程（Orphan Process）</p>
<br>

<p>每当出现一个孤儿进程时，内核就把孤儿进程的父进程设置为init进程，而init进程会循环地 wait() 它的已经退出的子进程。（init进程会回收运行结束的孤儿进程）</p>
<br>

<p>没什么危害</p>
<br>

<h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><p>每个进程结束之后，会释放自己地址空间中的用户区数据，内核去的PCB则需要父进程去释放</p>
<p>子进程终止后，父进程尚未将其回收，子进程残留资源（PCB）存放于内核中，变成僵尸进程</p>
<ul>
<li>僵尸进程不能被 kill -9 杀死</li>
<li>如果父进程不调用 wait() 或 waitpid() ，那么保留的信息就不会释放，进程号会一直被占用</li>
<li>危害：系统的进程号有限，如果出现大量僵尸进程，会导致系统无法产生新的进程</li>
</ul>
<br>

<h3 id="进程回收"><a href="#进程回收" class="headerlink" title="进程回收"></a>进程回收</h3><p>在每个进程退出的时候，内核释放该进程所有的资源、包括打开的文件、占用的内存等。但是仍为其保留一定的信息，这些信息主要指 PCB 的信息（包括进程号、退出状态、运行时间等）</p>
<p>父进程可以通过 wait() 或 waitpid()得到子进程的退出状态，并彻底清除掉这个进程</p>
<ul>
<li>wait() 或 waitpid() 功能一样，区别在于： 	wait() 会阻塞；<br>waitpid() 可以设置不阻塞，且可以指定等待哪个子进程结束；</li>
<li>一次wait或waitpid调用只能清理一个子进程，清理多个子进程应该使用循环</li>
</ul>
<br>

<h4 id="wait函数"><a href="#wait函数" class="headerlink" title="wait函数"></a>wait函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *wstatus)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	功能：等待任意一个子进程结束，如果任意一个子进程结束了，此函数会回收子进程的资源。</span></span><br><span class="line"><span class="comment">	参数：int *wstatus</span></span><br><span class="line"><span class="comment">		进程退出时的状态信息，传入的是一个int指针，是一个传出参数</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		成功：返回被回收的子进程的id</span></span><br><span class="line"><span class="comment">		失败：返回-1（所有的子进程都结束了，调用函数失败）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	调用wait函数的进程会被挂起（阻塞），知道它的一个子进程退出或者收到一个不能被忽略的信号时才被唤醒（相当于继续往下执行）</span></span><br><span class="line"><span class="comment">	如果没有子进程了/子进程都结束了，函数立刻返回，返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<p><strong>退出信息相关宏函数</strong></p>
<ul>
<li><p>​	函数					返回值</p>
<hr>
</li>
<li><p>WIFEXITED(status)	非0，进程正常退出</p>
</li>
<li><p>WEXITSTATUS(status)  如果上宏为真，获取进程退出的状态（exit的参数）</p>
</li>
<li><p>WIFSIGNALED(status)  非0，进程异常终止</p>
</li>
<li><p>WTERMSIG(status)     如果上宏为真，获取使进程终止的信号编号</p>
</li>
<li><p>WIFSTOPPED(status)   非0，进程处于暂停状态</p>
</li>
<li><p>WSTOPSIG(status)     如果上宏为真，获取使进程暂停的信号编号</p>
</li>
<li><p>WIFCONTINUED(status) 非0，进程暂停后已经继续运行</p>
</li>
</ul>
<br>

<br>

<h4 id="waitpid函数"><a href="#waitpid函数" class="headerlink" title="waitpid函数"></a>waitpid函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *wstatus, <span class="type">int</span> options)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	功能：回收指定进程号的子进程；可以设置是否阻塞。</span></span><br><span class="line"><span class="comment">	wait(&amp;wstatus); 等价于 waitpid(-1, &amp;wstatus, 0);</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- pid：指定子进程的id</span></span><br><span class="line"><span class="comment">			&gt; 0  ：某个子进程的id</span></span><br><span class="line"><span class="comment">			  0  ：回收当前进程组的所有子进程</span></span><br><span class="line"><span class="comment">			  -1 ：回收所有的子进程	（最常用）</span></span><br><span class="line"><span class="comment">			&lt; -1 ：某个进程组组id的绝对值，回收指定进程组中的子进程</span></span><br><span class="line"><span class="comment">		- wstatus：进程退出时的状态信息，传入的是一个int指针，是一个传出参数</span></span><br><span class="line"><span class="comment">		- options：设置阻塞或非阻塞</span></span><br><span class="line"><span class="comment">			0    ：阻塞</span></span><br><span class="line"><span class="comment">			宏值  ：WNOHANG 非阻塞（没有子进程退出的话立即返回）</span></span><br><span class="line"><span class="comment">				   WUNTRACED</span></span><br><span class="line"><span class="comment">				   WCONTINUED</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		&gt; 0 ：返回被回收的子进程的id</span></span><br><span class="line"><span class="comment">		= 0 ：options=WNOHANG时，表示还有子进程没有退出</span></span><br><span class="line"><span class="comment">		= -1：错误，或者没有子进程了</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	调用wait函数的进程会被挂起（阻塞），知道它的一个子进程退出或者收到一个不能被忽略的信号时才被唤醒（相当于继续往下执行）</span></span><br><span class="line"><span class="comment">	如果没有子进程了/子进程都结束了，函数立刻返回，返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<br>

<h2 id="2-6-进程间通信"><a href="#2-6-进程间通信" class="headerlink" title="2.6 进程间通信"></a>2.6 进程间通信</h2><h3 id="2-6-1-进程间通信简介"><a href="#2-6-1-进程间通信简介" class="headerlink" title="2.6.1 进程间通信简介"></a>2.6.1 进程间通信简介</h3><p>不同的进程需要进行信息的交互和状态的传递等，因此需要进程间通信（IPC：Inter Processes Communication</p>
<p><strong>进程通信目的：</strong></p>
<ul>
<li>数据传输：一个进程需要将它的数据发送给另一个进程</li>
<li>通知事件：一个进程需要向另一个或一组进程发送信息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）</li>
<li>资源共享：多个进程之间共享同样的资源。（需要用到内核提供的互斥和同步机制）</li>
<li>进程控制：有些进程希望完全控制另一个进程的运行（如 Debug 进程gdb），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道其状态改变</li>
</ul>
<br>

<p><strong>Linux进程间通信的方式：</strong></p>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230205232903586-167596242752010.png" alt="image-20230205232903586"></p>
<br>

<br>

<br>

<h3 id="2-6-2-匿名管道"><a href="#2-6-2-匿名管道" class="headerlink" title="2.6.2 匿名管道"></a>2.6.2 匿名管道</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>管道 也叫匿名管道。是 UNIX 系统 IPC 的最古老形式，所有的 UNIX 系统都支持这种通信机制。</p>
<br>

<p><strong>案例解析：</strong></p>
<p>​	统计一个目录中文件的数目命令：<code>ls | wc -l</code>	（管道符 | ）</p>
<p>为了执行该命令，shell 创建了两个进程分别执行 ls 和 wc</p>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230205233552602-167596242752011.png" alt="image-20230205233552602"></p>
<p>ls进程的标准输出 stdout 指向管道写入端</p>
<p>wc进程的标准输入 stdin 指向管道读取端</p>
<br>

<p><strong>特点</strong></p>
<ul>
<li>管道 其实是一个在<code>内核内存中</code>维护的缓冲器，这个缓冲器的存储能力是有限的，不同操作系统中可能不同</li>
<li>管道拥有文件的特质：读操作、写操作，<u>匿名管道没有文件实体，有名管道有文件实体，但不存储数据。</u>可以按照操作文件的方式操作管道</li>
<li>一个管道是一个<code>字节流</code>，使用管道时不存在消息或者消息边界的概念，从管道读取数据的进程可以读取任意大小的数据块，而不管写入进程写入管道的数据库的大小是多少</li>
<li>通过管道传递的数据是顺序的</li>
<li>在管道中的数据的传递方向是单向的，一端写入，一端读取，是半双工的（有两个传递方向，同一时刻内只能通一个方向）</li>
<li>从管道读取数据是一次性操作，数据一旦被读走，就从管道中被抛弃，释放空间以便写更多的数据，在管道中无法使用lseek()来随机访问数据</li>
<li>匿名管道只能在具有公共祖先的进程之间使用（父子进程共享文件描述符表，有相同的管道）</li>
</ul>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230206013639551-167596242752012.png" alt="image-20230206013639551"></p>
<br>

<p><strong>管道的数据结构</strong></p>
<p>环形队列（重复利用节点空间）</p>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230206014318131-167596242752013.png" alt="image-20230206014318131"></p>
<br>

<h4 id="管道的使用"><a href="#管道的使用" class="headerlink" title="管道的使用"></a>管道的使用</h4><ul>
<li><p>创建匿名管道</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	创建一个匿名管道，用于进程间通信</span></span><br><span class="line"><span class="comment">	参数： int pipefd[2]：传出参数</span></span><br><span class="line"><span class="comment">			pipefd[0] 管道的读端</span></span><br><span class="line"><span class="comment">			pipefd[1] 管道的写端</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		成功 0</span></span><br><span class="line"><span class="comment">		失败 -1</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	管道默认是阻塞的：</span></span><br><span class="line"><span class="comment">		如果管道中没有数据，read阻塞；</span></span><br><span class="line"><span class="comment">		如果管道满了，write阻塞；</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	注意：匿名管道只能用于具有关系的进程之间的通信（父子进程，兄弟进程...）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现：子进程发送数据给父进程，父进程读取到数据输出</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在fork之前创建管道</span></span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> ret = pipe(pipefd);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="comment">// 从管道的读取端读取数据</span></span><br><span class="line">        close(pipefd[<span class="number">1</span>]);</span><br><span class="line">        </span><br><span class="line">    	<span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> len = read(pipefd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent recv : %s, pid: %d\n&quot;</span>, buf, getpid());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        close(pipefd[<span class="number">0</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="type">char</span> *str = <span class="string">&quot;hello, i am child&quot;</span>;</span><br><span class="line">        write(pipefd[<span class="number">1</span>], str, <span class="built_in">strlen</span>(str));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看管道缓冲大小命令:<code>ulimit -a</code></p>
</li>
<li><p>查看管道缓冲大小函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">fpathconf</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> name)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	获取文件的配置信息值</span></span><br><span class="line"><span class="comment">	参数 name：宏值，表明要查看的内容</span></span><br><span class="line"><span class="comment">		_PC_PIPE_BUF</span></span><br><span class="line"><span class="comment">		更多参数参考文档</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<br></li>
</ul>
<blockquote>
<p>规定：</p>
<ul>
<li>使用匿名管道实际开发时，父子进程不相互收发数据，而是规定好一个进程读一个进程写</li>
<li>读的进程关闭写端；写的进程关闭读端；</li>
</ul>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230206022417540-167596242752014.png" alt="image-20230206022417540"></p>
</blockquote>
<br>

<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>实现<code>ps aux | grep xxx</code></p>
<p>父子进程间通信</p>
<ul>
<li><p>子进程：ps aux，结束后将数据发送给父进程</p>
</li>
<li><p>父进程：获取数据，并过滤</p>
<p>pipe()</p>
<p>execlp()</p>
<p>dup2() 子进程将标准输出 stdout_fileno 重定向到管道的写端</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建管道</span></span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> ret = pipe(fd);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="comment">// 关闭写端</span></span><br><span class="line">        close(fd[<span class="number">1</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从管道中读取</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> len = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>((len = read(fd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf)<span class="number">-1</span>)) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="comment">// 过滤数据并输出  过滤功能还没写          </span></span><br><span class="line">        	<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf); </span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="comment">// 子进程</span></span><br><span class="line">        <span class="comment">// 关闭读端</span></span><br><span class="line">        close(fd[<span class="number">0</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 文件描述符的重定向 stdout_fileno -&gt; fd[1]</span></span><br><span class="line">        dup2(fd[<span class="number">1</span>], STDOUT_FILENO);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 执行 ps aux</span></span><br><span class="line">        execlp(<span class="string">&quot;ps&quot;</span>, <span class="string">&quot;ps&quot;</span>, <span class="string">&quot;aux&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        perror(<span class="string">&quot;execlp&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   	<span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<h4 id="管道读写特点和非阻塞的设置"><a href="#管道读写特点和非阻塞的设置" class="headerlink" title="管道读写特点和非阻塞的设置"></a>管道读写特点和非阻塞的设置</h4><p><strong>读写特点（阻塞I&#x2F;O下）</strong></p>
<ol>
<li>如果所有的指向 管道写端 的文件描述符都关闭了<code>（写端引用计数为0）</code>，有进程从管道的读端读数据，<code>那么管道中剩余的数据被读取以后，再次read会返回 0</code>，就像读到文件末尾一样。</li>
<li>如果有指向 管道写端 的文件描述符没有关闭<code>（写端引用计数大于0）</code>，而持有管道写端的进程也<code>没有往管道中写数据</code>，这时有进程从管道的读端读数据，<code>那么管道中剩余的数据被读取以后，再次read会阻塞</code>，直到管道中有数据可以读了才读取数据并返回。</li>
<li>如果所有的指向 管道读端 的文件描述符都关闭了<code>（读端引用计数为0）</code>，这个时候向管道中写数据，那么该进程会收到一个信号 SIGPIPE ，通常会导致进程异常终止。</li>
<li>如果有指向 管道读端 的文件描述符没有关闭<code>（读端引用计数大于0）</code>，而持有管道读端的进程也<code>没有往管道中读数据</code>，这时有进程从管道的写端写数据，<code>那么管道被写满的时候，再次调用write会阻塞</code>，直到管道中有空位置才能再次写入数据并返回。</li>
</ol>
<blockquote>
<p><strong>总结：</strong></p>
<p>​	读管道：</p>
<p>​		管道中有数据，read读取数据，返回实际读到的字节数。</p>
<p>​		管道中无数据：</p>
<p>​			写端被全部关闭，read返回0（相当于读到文件的末尾）<br>​			写端没有完全关闭，read阻塞等待</p>
<p>​	</p>
<p>​	写管道：</p>
<p>​		管道读端全部被关闭，进程异常终止（进程收到 SIGPIPE 信号）</p>
<p>​		管道读端没有全部关闭：</p>
<p>​			管道已满，write阻塞<br>​			管道未满，write将数据写入，返回实际写入的字节数</p>
</blockquote>
<br>

<br>

<p><strong>非阻塞设置</strong></p>
<p>fcntl函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> flags = fcntl(fd[<span class="number">0</span>], F_GETFL); <span class="comment">// 获取原来的flag</span></span><br><span class="line">flags |= O_NONBLOCK;			 <span class="comment">// 修改flag</span></span><br><span class="line">fcntl(fd[<span class="number">0</span>], F_SETFL, flags)；	<span class="comment">// 设置新的flag</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<h3 id="2-6-3-有名管道"><a href="#2-6-3-有名管道" class="headerlink" title="2.6.3 有名管道"></a>2.6.3 有名管道</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><ul>
<li>匿名管道由于无名，只能用于亲缘关系的进程间通信。为了扩大应用，提出了 有名管道 （FIFO），也叫命名管道，FIFO文件。</li>
<li>有名管道（FIFO）不同于匿名管道之处，<u>在于它提供了一个路径名与之关联</u>，以FIFO的文件形式存在于文件系统中，并且打开方式与普通文件相同。只要可以访问该路径，就能彼此通过有名管道相互通信，使得不相关的进程也能通信。</li>
</ul>
<br>

<p><strong>与匿名管道的不同之处：</strong></p>
<ol>
<li>FIFO 在文件系统中作为一个特殊文件存在，但 FIFO 中的内容却存放在内核区的内存中。</li>
<li>当使用 FIFO 的进程推出后，FIFO 文件将保存在文件系统中以便以后调用。</li>
<li>FIFO 有名，不相关的进程可以通过打开有名管道进行通信。</li>
</ol>
<br>

<h4 id="有名管道的使用"><a href="#有名管道的使用" class="headerlink" title="有名管道的使用"></a>有名管道的使用</h4><ul>
<li><p>通过命令创建：<code>mkfifo name</code></p>
</li>
<li><p>通过函数创建</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys.types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys.stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- pathname：管道名称的路径</span></span><br><span class="line"><span class="comment">		- mode：文件权限，和 open 的 mode 一样。</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		成功 0，失败 -1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>一旦使用 mkfifo 创建了一个 FIFO ，就可以使用 open 打开，以及使用常见的 I&#x2F;O 函数，如：read，write，unlink，close…</p>
</li>
<li><p>FIFO 严格遵循先进先出，读操作 总是从开始处返回数据，写操作 则把数据添加到末尾。所以不支持 lseek()等文件定位操作。</p>
</li>
</ul>
<br>

<h4 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h4><p><strong>基本使用</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 向管道中写数据</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断文件是否存在</span></span><br><span class="line">    <span class="type">int</span> ret = access(<span class="string">&quot;test&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">// 管道还未创建</span></span><br><span class="line">        ret = mkfifo(<span class="string">&quot;test&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打开管道（只写方式）</span></span><br><span class="line">    <span class="type">int</span> fd = open)<span class="string">&quot;test&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 写数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(buf,<span class="string">&quot;hello %d\n&quot;</span>, i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;write data: %s\n&quot;</span>, buf);</span><br><span class="line">        write(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    close(fd);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从管道中读取数据</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main1</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打开管道文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;test&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="type">int</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取数据</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> len = read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 写端断开连接了</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv buf: %s\n&quot;</span>,buf);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    close(fd);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<blockquote>
<p>open 注意事项：</p>
<ol>
<li>一个为只读而打开一个管道的进程会阻塞，直到另外一个进程为只写打开管道</li>
<li>一个为只写而打开一个管道的进程会阻塞，直到另外一个进程为只读打开管道</li>
</ol>
</blockquote>
<blockquote>
<p><strong>读管道：</strong></p>
<p>​	管道中有数据，read发怒hi实际督导的字节数</p>
<p>​	管道中无数据：<br>​		管道写端被全部关闭，read返回0 （相当于读到文件末尾）<br>​		管道写端没有全部关闭，read阻塞等待</p>
<p><strong>写管道：</strong></p>
<p>​	管道读端被全部关闭，进程异常终止（收到 SIGPIPE 信号）</p>
<p>​	管道读端没有全部关闭：<br>​		管道已满，write会阻塞<br>​		管道未满，write写入数据，返回实际写入的字节数</p>
</blockquote>
<br>

<br>

<p><strong>有名管道实现简单聊天</strong></p>
<p>只能交替地接收和发送</p>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230206212504676-167596242752015.png" alt="image-20230206212504676"></p>
<br>

<p>进程A</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.判断有名管道文件是否存在</span></span><br><span class="line">    <span class="type">int</span> ret = access(<span class="string">&quot;fifo1&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">// 文件不存在则创建</span></span><br><span class="line">        ret = mkfifo(<span class="string">&quot;fifo1&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">    	<span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">			perror(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">	ret = access(<span class="string">&quot;fifo2&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">// 文件不存在则创建</span></span><br><span class="line">        ret = mkfifo(<span class="string">&quot;fifo2&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">    	<span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">			perror(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 以只写方式打开管道 fifo1</span></span><br><span class="line">    <span class="type">int</span> fdw = open(<span class="string">&quot;fifo1&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span>(fdw == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开管道fifo1成功，等待写入...\n&quot;</span>)；</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 以只读方式打开管道 fifo2</span></span><br><span class="line">    <span class="type">int</span> fdr = open(<span class="string">&quot;fifo2&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fdr == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开管道fifo2成功，等待读取...\n&quot;</span>)；</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 循环写读数据</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line">    	<span class="comment">// 获取标准输入的数据    </span></span><br><span class="line">        fgets(buf, <span class="number">128</span>, <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="comment">// 发送信息，写入数据</span></span><br><span class="line">        ret = write(fdw, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 接收信息，读取数据</span></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line">        ret = read(fdr, buf, <span class="number">128</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">           	<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;buf: %s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    close(fdr);</span><br><span class="line">    close(fdw);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<p>进程B </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.判断有名管道文件是否存在</span></span><br><span class="line">    <span class="type">int</span> ret = access(<span class="string">&quot;fifo1&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">// 文件不存在则创建</span></span><br><span class="line">        ret = mkfifo(<span class="string">&quot;fifo1&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">    	<span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">			perror(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">	ret = access(<span class="string">&quot;fifo2&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">// 文件不存在则创建</span></span><br><span class="line">        ret = mkfifo(<span class="string">&quot;fifo2&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">    	<span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">			perror(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 以只读方式打开管道 fifo1</span></span><br><span class="line">    <span class="type">int</span> fdw = open(<span class="string">&quot;fifo1&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fdw == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开管道fifo1成功，等待读取...\n&quot;</span>)；</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 以只写方式打开管道 fifo2</span></span><br><span class="line">    <span class="type">int</span> fdr = open(<span class="string">&quot;fifo2&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span>(fdr == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开管道fifo2成功，等待写入...\n&quot;</span>)；</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 循环读写数据</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 接收信息，读取数据</span></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line">        ret = read(fdr, buf, <span class="number">128</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">           	<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;buf: %s\n&quot;</span>, buf);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line">    	<span class="comment">// 获取标准输入的数据    </span></span><br><span class="line">        fgets(buf, <span class="number">128</span>, <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="comment">// 发送信息，写入数据</span></span><br><span class="line">        ret = write(fdw, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    close(fdr);</span><br><span class="line">    close(fdw);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="2-6-4-内存映射"><a href="#2-6-4-内存映射" class="headerlink" title="2.6.4 内存映射"></a>2.6.4 内存映射</h3><p>内存映射 Memory-mapped I&#x2F;O ,是将磁盘文件的数据映射到内存，用户通过修改内存就能修改磁盘文件。</p>
<p>映射的是进程的虚拟地址空间，映射位置是共享库的位置</p>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230207021339909-167596242752017.png" alt="image-20230207021339909"></p>
<br>

<p><strong>相关系统调用</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	将一个文件或设备的数据映射到内存当中</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- addr：传入NULL，由内核决定后续处理</span></span><br><span class="line"><span class="comment">		- length：要映射的数据长度，不能为0.建议使用文件的长度	（使用 stat 或 lseek 可以获取文件长度）</span></span><br><span class="line"><span class="comment">		- prot：对申请的内存映射区的操作权限（不能与打开的文件有权限冲突）</span></span><br><span class="line"><span class="comment">			PROT_NONE 无权限</span></span><br><span class="line"><span class="comment">			PROT_EXEC 可执行</span></span><br><span class="line"><span class="comment">			PROT_READ 可读</span></span><br><span class="line"><span class="comment">			PROT_WRITE 可写</span></span><br><span class="line"><span class="comment">			（要操作映射内存，必须有读权限）</span></span><br><span class="line"><span class="comment">		- flags：</span></span><br><span class="line"><span class="comment">			MAP_SHARED	映射区的数据会自动和磁盘文件进行同步，进程间通信，必须设置该选项</span></span><br><span class="line"><span class="comment">			MAP_PRIVATE	不同步，内存映射区的数据改变不会修改源文件，而会创建一个新的文件 （copy on write）</span></span><br><span class="line"><span class="comment">		- fd：需要映射的文件的文件描述符，通过 open 得到的。 注意：文件大小要大于0，且 open 指定的权限不能和 prot 冲突。</span></span><br><span class="line"><span class="comment">		- offset：偏移量，文件数据的起始位置偏移，一般不使用（必须是4k的整数倍，0表示不偏移）</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		成功，返回映射到的内存首地址（虚拟地址）</span></span><br><span class="line"><span class="comment">		失败，返回 MAP_FAILED 即（void *) -1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	释放内存映射</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- addr：要释放的内存的首地址</span></span><br><span class="line"><span class="comment">		- length：要释放的内存大小，要和mmap函数中的length参数值一致</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<p><strong>实现进程间通信</strong></p>
<p>父子进程之间</p>
<blockquote>
<ul>
<li>在还没有子进程的时候<ul>
<li>通过唯一的父进程，先创建内存映射区</li>
</ul>
</li>
<li>有了内存映射区后，创建子进程</li>
<li>父子进程共享创建的内存映射区</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打开一个文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;test.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取文件大小</span></span><br><span class="line">    <span class="type">int</span> size = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建内存映射区</span></span><br><span class="line">    <span class="type">void</span> *ptr = mmap(<span class="literal">NULL</span>, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ptr == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(buf, (<span class="type">char</span> *)ptr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read data:%s\n&quot;</span>, buf);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">strcpy</span>((<span class="type">char</span> *)ptr, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关闭内存映射区</span></span><br><span class="line">    munmap(ptr, size);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<p>无关系的进程之间</p>
<blockquote>
<ul>
<li>准备一个大小不是0的磁盘文件</li>
<li>进程1 通过磁盘文件创建内存映射区</li>
<li>得到一个操作这块内存的指针</li>
<li>进程2 通过磁盘文件创建内存映射区</li>
<li>到到一个操作这块内存的指针</li>
<li>使用内存映射区通信</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main1</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打开一个文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;test.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取文件大小</span></span><br><span class="line">    <span class="type">int</span> size = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建内存映射区</span></span><br><span class="line">    <span class="type">void</span> *ptr = mmap(<span class="literal">NULL</span>, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ptr == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过获取文件数据</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(buf, (<span class="type">char</span> *)ptr);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;read data:%s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭内存映射区</span></span><br><span class="line">    munmap(ptr, size);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main2</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打开一个文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;test.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取文件大小</span></span><br><span class="line">    <span class="type">int</span> size = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建内存映射区</span></span><br><span class="line">    <span class="type">void</span> *ptr = mmap(<span class="literal">NULL</span>, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ptr == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 写入内存，修改文件</span></span><br><span class="line">    <span class="built_in">strcpy</span>((<span class="type">char</span> *)ptr, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关闭内存映射区</span></span><br><span class="line">    munmap(ptr, size);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<p><strong>思考问题</strong></p>
<ol>
<li>如果对mmap的返回值 (ptr) 做++操作 (ptr++) ，munmap能否成功</li>
</ol>
<blockquote>
<p>可以 ptr++; 但 munmap 会失败，只能通过首地址释放（提前保存）</p>
</blockquote>
<ol start="2">
<li>如果 open 时 O_RDONLY ，mmap 时 prot 参数指定 PROT_READ | PROT_WRITE 会怎样</li>
</ol>
<blockquote>
<p>错误，会返回MAP_FAILED。</p>
<p>open 函数中的权限要满足 mmap，即 prot &lt;&#x3D; open 的权限参数</p>
</blockquote>
<ol start="3">
<li>如果文件偏移量为1000会怎样</li>
</ol>
<blockquote>
<p>偏移量必须是 4k 的整数倍，否则会返回 MAP_FAILED</p>
</blockquote>
<ol start="4">
<li>mmap什么情况下会调用失败</li>
</ol>
<blockquote>
<ul>
<li>第二个参数：length &#x3D; 0</li>
<li>第三个参数：prot</li>
<li>没有指定读权限</li>
<li>参数 fd 在 open 时的权限不满足当前 prot</li>
</ul>
</blockquote>
<ol start="5">
<li>可以oepn的时候O_CREAT一个新文件来创建映射区吗</li>
</ol>
<blockquote>
<p>可以，但是创建的文件大小如果为 0 ，则不行</p>
<p>可以对新的文件进行拓展</p>
<pre><code>- lseek()
- truncate()
</code></pre>
</blockquote>
<ol start="6">
<li>mmap后关闭文件描述符，对mmap映射有没有影响</li>
</ol>
<blockquote>
<p>​	int fd &#x3D; open(“xxx”);</p>
<p>​	mmap(…, fd, …);</p>
<p>​	close(fd);</p>
<p>映射区还存在，创建的映射区的fd被关闭，没有任何影响</p>
</blockquote>
<ol start="7">
<li>对ptr越界操作会怎样</li>
</ol>
<blockquote>
<p>​	void * ptr &#x3D; mmap(NULL, 100, …);</p>
<p>越界操作会引发段错误</p>
</blockquote>
<br>

<br>

<p>除了进程间通信，还可以用来实现 <strong>文件复制</strong></p>
<ol>
<li>对原始的文件进行内存映射</li>
<li>创建新文件（并拓展</li>
<li>把新文件的数据映射到内存中</li>
<li>通过内存拷贝将第一个文件的数据拷贝到新的文件内存中</li>
<li>释放资源</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mmap.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对原始的文件进行内存映射</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;ori.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取原始文件大小</span></span><br><span class="line">    <span class="type">int</span> len = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个新的文件</span></span><br><span class="line">	<span class="type">int</span> fd1 = open(<span class="string">&quot;cpy.txt&quot;</span>, O_RDWR | O_CREAT, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd1 == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对新创建的文件进行拓展</span></span><br><span class="line">    truncate(<span class="string">&quot;cpy.txt&quot;</span>, len);</span><br><span class="line">    write(fd1, <span class="string">&quot; &quot;</span>, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分别做内存映射</span></span><br><span class="line">    <span class="type">void</span> *ptr = mmap(<span class="literal">NULL</span>,len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="type">void</span> *ptr1 = mmap(<span class="literal">NULL</span>,len, PROT_READ | PROT_WRITE, MAP_SHARED, fd1, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ptr == MAP_FAILED || ptr1 == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 内存拷贝</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr1, ptr, len);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放资源	（习惯上，先打开的后释放）</span></span><br><span class="line">    munmap(ptr1, len);</span><br><span class="line">    munmap(ptr, len);    </span><br><span class="line">    </span><br><span class="line">    close(fd1);</span><br><span class="line">    close(fd);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<p><strong>匿名映射</strong>(用于通信)</p>
<p>不需要文件实体进行内存映射，只能用于有关系的进程之间。</p>
<p>mmap 需要打开 <code>MAP_ANONYMOUS</code> 选项</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mmap.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建匿名内存映射区</span></span><br><span class="line">    <span class="type">int</span> len = <span class="number">4096</span>;</span><br><span class="line">    <span class="type">void</span> *ptr = mmap(<span class="literal">NULL</span>, len, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS，<span class="number">-1</span>， <span class="number">0</span>)；</span><br><span class="line">    <span class="keyword">if</span>(ptr == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 父子进程通信</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">strcpy</span>((<span class="type">char</span> *)ptr, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, (<span class="type">char</span> *)ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="type">int</span> ret = munmap(ptr, len);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;munmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<blockquote>
<p>与直接修改文件相比，在内存修改速度更快 </p>
</blockquote>
<br>

<h3 id="2-6-5-信号"><a href="#2-6-5-信号" class="headerlink" title="2.6.5 信号"></a>2.6.5 信号</h3><h4 id="信号概述"><a href="#信号概述" class="headerlink" title="信号概述"></a>信号概述</h4><p>信号是 Linux 进程通信最古老的方式之一，是事件发生时对进程的通知机制，有时又称为 <code>软件中断</code> ，它是在软件层次上对中断机制的一种模拟，是一种 <code>异步</code> 通信的方式。</p>
<p>信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断，转而处理某一个突发事件。</p>
<br>

<p>发往进程的诸多信号，通常都是源于<code>内核</code>。引发内核为进程产生信号的各类事件如下：</p>
<ul>
<li>对于前台进程，用户可以通过输入特殊的终端字符来发送信号。比如 Ctrl+C 通常会给进程发送一个中断信号。</li>
<li>硬件发生异常，即硬件检测到一个错误条件并通知内核，随机再由内核发送相应信号给相关进程。比如执行一条异常的机器语言指令，如除以0，或者引用了无法访问的内存区域。</li>
<li>系统状态的变化，比如 alarm 定时器到期将引起 SIGALRM 信号、进程执行的CPU时间超限、或者该进程的某个子进程退出。</li>
<li>运行 kill 命令或调用 kill 函数。</li>
</ul>
<br>

<p><strong>使用信号的两个目的</strong></p>
<ul>
<li>让进程知道已经发生了一个特定的事情</li>
<li>强迫进程执行它自己代码中的信号处理程序</li>
</ul>
<br>

<p><strong>特点</strong>：</p>
<ul>
<li>简单</li>
<li>不能携带大量信息</li>
<li>满足某个特定条件才发送</li>
<li>优先级比较高</li>
</ul>
<br>

<p>查看系统定义的信号列表：<code>kill -l</code></p>
<blockquote>
<p>前31个信号为常规信号，其余为实时信号</p>
</blockquote>
<br>

<p>查看信号的详细信息：<code>man 7 signal</code></p>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230207074413475-167596242752016.png" alt="image-20230207074413475"></p>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230207074659817-167596242752019.png" alt="image-20230207074659817"></p>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230207074814071-167596242752018.png" alt="image-20230207074814071"></p>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230207074951533-167596242752020.png" alt="image-20230207074951533"></p>
<br>

<p>进程的5个<strong>默认处理动作</strong></p>
<ul>
<li><p>Term 终止进程</p>
</li>
<li><p>Ign 当前进程忽略掉这个信号</p>
</li>
<li><p>Core 终止进程，并生成一个Core文件（保存进程异常退出的错误信息）</p>
<blockquote>
<p>通过 unlimit -c xxx 设置 core 文件生成</p>
<p>通过 gdb 打开生成的 core 文件</p>
</blockquote>
</li>
<li><p>Stop 暂停当前进程</p>
</li>
<li><p>Cont 继续执行当前被暂停的进程</p>
</li>
</ul>
<br>

<p>信号的3种<strong>状态</strong>：产生、未决、递达</p>
<br>

<blockquote>
<p>SIGKILL 和 SIGSTOP 信号不能被捕捉、阻塞或者忽略，只能执行默认动作</p>
</blockquote>
<br>

<br>

<h4 id="kill、raise、abort-函数"><a href="#kill、raise、abort-函数" class="headerlink" title="kill、raise、abort 函数"></a>kill、raise、abort 函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	给某个进程pid，发送某个信号sig</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- pid ：目标进程的 id</span></span><br><span class="line"><span class="comment">			&gt; 0 : 将信号发送给指定进程</span></span><br><span class="line"><span class="comment">			= 0 : 将信号发送给当前进程的进程组</span></span><br><span class="line"><span class="comment">			= -1 : 将信号发生给每一个有权限接收这个信号的进程</span></span><br><span class="line"><span class="comment">			&lt; -1 : 这个pid=某个进程组的gid取反</span></span><br><span class="line"><span class="comment">		- sig ：需要发送的信号编号或宏值，0表示不发送任何信号</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">raise</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	给当前进程发送某个信号sig</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- sig ：需要发送的信号编号或宏值，0表示不发送任何信号</span></span><br><span class="line"><span class="comment">		返回值：成功 0 ，失败 非 0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">abort</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	发送 SIGABRT 信号给当前进程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<h4 id="alarm-函数"><a href="#alarm-函数" class="headerlink" title="alarm 函数"></a>alarm 函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(unsigner <span class="type">int</span> seconds)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	设置定时器（闹钟）。函数调用后开始倒计时，当计时为0时，函数会给当前进程发送一个 SIGALARM 信号。</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- seconds：倒计时的时常，单位秒。若为0，则定时器无效（可以用 alarm(0); 取消定时器）</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		- 之前没有定时器，返回0</span></span><br><span class="line"><span class="comment">		- 之前有定时器，返回定时器剩余的时间</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	SIGALARM ： 默认终止当前的进程。</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	每一个进程都有且只有唯一的一个定时器。</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<blockquote>
<p>程序运行的实际时间 &#x3D; 内核时间 + 用户时间 + 切换、文件IO等消耗的时间</p>
</blockquote>
<blockquote>
<p>定时器与进程的状态无关。（采用自然定时法，无论进程出于什么状态，alarm都会计时）</p>
</blockquote>
<br>

<h4 id="setitimer-定时器函数"><a href="#setitimer-定时器函数" class="headerlink" title="setitimer 定时器函数"></a>setitimer 定时器函数</h4><p>周期性的定时</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时器值结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">it_interval</span>;</span>	<span class="comment">// 每个间隔的时间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">it_value</span>;</span>	<span class="comment">// 延迟多长时间启动定时器</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 时间值结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">    <span class="type">time_t</span> tv_sec;		<span class="comment">// seconds s</span></span><br><span class="line">    <span class="type">suseconds_t</span> tv_usec;	<span class="comment">// microseconds us</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setitimer</span><span class="params">(<span class="type">int</span> which, <span class="type">const</span> <span class="keyword">struct</span> itimerval *new_val, <span class="keyword">struct</span> itimerval *old_value)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	设置定时器（闹钟），替代 alarm 函数。精度微妙us，周期性计时。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- which : 定时器以什么时间计时</span></span><br><span class="line"><span class="comment">			ITIMER_REAL : 真实时间，时间到则发送SIGALARM ，常用</span></span><br><span class="line"><span class="comment">			ITIMER_VIRTUAL : 用户时间，时间到则发送 SIGVTALRM</span></span><br><span class="line"><span class="comment">			ITIMER_PROF : 以该进程在用户态和内核态下所消耗的时间来计算，时间到则发送 SIGPROF</span></span><br><span class="line"><span class="comment">			</span></span><br><span class="line"><span class="comment">		- new_val : 设置定时器的属性</span></span><br><span class="line"><span class="comment">		- old_value : 记录上一次的定时的时间参数，一般不使用，指定 NULL</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		成功 0 ，失败 -1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<h4 id="signal-信号捕捉函数"><a href="#signal-信号捕捉函数" class="headerlink" title="signal 信号捕捉函数"></a>signal 信号捕捉函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	设置某个信号的捕捉行为</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- signum ： 要捕捉的信号</span></span><br><span class="line"><span class="comment">		- handler ： 捕捉到信号后的处理</span></span><br><span class="line"><span class="comment">			可以是：</span></span><br><span class="line"><span class="comment">			SIG_IGN : 忽略</span></span><br><span class="line"><span class="comment">			SIG_DEL : 使用信号默认的行为</span></span><br><span class="line"><span class="comment">			回调函数 ： 由内核调用，程序员负责实现其功能</span></span><br><span class="line"><span class="comment">		回调函数：</span></span><br><span class="line"><span class="comment">			- 由程序员实现，提前准备好的，函数的类型根据实际需求，和函数指针的定义</span></span><br><span class="line"><span class="comment">			- 不是程序员调用，而是当信号产生，由内核调用</span></span><br><span class="line"><span class="comment">			- 函数指针是实现回调的手段，函数实现之后，将函数名放到函数指针的位置即可</span></span><br><span class="line"><span class="comment">			</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		成功，返回上一次注册的信号处理函数的地址，若是第一次则返回 NULL</span></span><br><span class="line"><span class="comment">		失败，返回 SIG_ERR ，并设置errno</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<blockquote>
<p>SIGKILL 和 SIGSTOP 信号不能被捕捉、阻塞或者忽略，只能执行默认动作</p>
</blockquote>
<br>

<p><strong>案例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myalarm</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sss\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//延迟3秒后启动间隔为2秒的定时器,启动时也会发送信号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册信号捕捉</span></span><br><span class="line">    <span class="comment">// signal(SIGALARM, SIG_IGN);</span></span><br><span class="line">    <span class="comment">// signal(SIGALARM, SIG_DEL);</span></span><br><span class="line">    <span class="comment">// void (* sighandler_t)(int); 函数指针</span></span><br><span class="line">    <span class="type">sighandler_t</span> ret1 = signal(SIGALARM, myalarm);</span><br><span class="line">    <span class="keyword">if</span>(ret1 == SIG_ERR) &#123;</span><br><span class="line">        perror(<span class="string">&quot;signal&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>)；</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">new_val</span>;</span></span><br><span class="line">    <span class="comment">// 间隔时间</span></span><br><span class="line">    new_val.it_interval.tv_sec = <span class="number">2</span>;</span><br><span class="line">    new_val.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 延迟时间</span></span><br><span class="line">    new_val.it_value.tv_sec = <span class="number">3</span>;</span><br><span class="line">    new_val.it.value.tv_usec = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> ret2 = setitimer(ITIMER_REAL, &amp;new_value, <span class="literal">NULL</span>);		<span class="comment">// 非阻塞的</span></span><br><span class="line">    <span class="keyword">if</span>(ret2 == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;setitimer&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<h4 id="信号集及相关函数"><a href="#信号集及相关函数" class="headerlink" title="信号集及相关函数"></a>信号集及相关函数</h4><p><strong>信号集</strong></p>
<ul>
<li>许多信号相关的系统调用都需要能表示一组不同的信号，多个信号可使用一个称之为信号集的数据结构来表示，其系统数据类型为 sigset_t</li>
<li>在 PCB 中有两个非常重要的信号集。一个称之为“阻塞信号集”，另一个称之为“未决信号集”。这两个信号集都是内核使用位图机制来实现的，但操作系统不允许我们直接对这两个信号集进行位操作，而需自定义另外一个集合，借助信号集操作函数来对 PCB 中的两个信号集进行修改。</li>
<li>”未决“，是一种状态，指的是<u>从信号的产生到信号被处理前</u>的这一段时间。</li>
<li>”阻塞“，是一个开关动作，指的是阻止信号被处理，但不是阻止信号产生。  </li>
<li>信号的阻塞就是让系统暂时保留信号，留待以后发送。由于另外有办法让系统忽略信号，所以一般情况下信号的阻塞只是暂时的，只是为了防止信号打断敏感的操作。</li>
</ul>
<br>

<p><strong>默认</strong></p>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230207122515067-167596242752021.png" alt="image-20230207122515067"></p>
<br>

<p><strong>操作信号集的函数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">//以下信号集相关的函数都是对自定义的信号集（参数set）进行操作</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	清空信号集中的数据，将所有标志位置 0</span></span><br><span class="line"><span class="comment">	参数：	set 要操作的信号集</span></span><br><span class="line"><span class="comment">	返回值：成功0，失败-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	将信号集中的所有标志位置 1</span></span><br><span class="line"><span class="comment">	参数：	set 要操作的信号集</span></span><br><span class="line"><span class="comment">	返回值：成功0，失败-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	设置信号集中的某一个信号对应得标志位为 1 ，表示阻塞这个信号</span></span><br><span class="line"><span class="comment">	参数：	</span></span><br><span class="line"><span class="comment">		- set 要操作的信号集</span></span><br><span class="line"><span class="comment">		- signum 需要设置的信号</span></span><br><span class="line"><span class="comment">	返回值：成功0，失败-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigdelset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	设置信号集中的某一个信号对应得标志位为 0 ，表示不阻塞这个信号</span></span><br><span class="line"><span class="comment">	参数：	</span></span><br><span class="line"><span class="comment">		- set 要操作的信号集</span></span><br><span class="line"><span class="comment">		- signum 需要设置的信号</span></span><br><span class="line"><span class="comment">	返回值：成功0，失败-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	判断某个信号是否阻塞</span></span><br><span class="line"><span class="comment">	参数：	</span></span><br><span class="line"><span class="comment">		- set 要操作的信号集</span></span><br><span class="line"><span class="comment">		- signum 需要判断的信号</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		- 1 ，signum被阻塞</span></span><br><span class="line"><span class="comment">		- 0 ，signum不阻塞</span></span><br><span class="line"><span class="comment">		- -1，调用失败</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<h4 id="sigprocmask-函数"><a href="#sigprocmask-函数" class="headerlink" title="sigprocmask 函数"></a>sigprocmask 函数</h4><p>将自己设置好的信号集应用到内核信号集中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oldset)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	将自定义信号集中的数据设置到内核中（设置阻塞，解除阻塞，替换）</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- how  如何对内和阻塞信号集进行处理</span></span><br><span class="line"><span class="comment">			SIG_BLOCK：将用户设置的阻塞信号集添加到内核中，内核中原来的数据不变	（假设内核中默认的阻塞信号集是mask，则令 mask | set ）</span></span><br><span class="line"><span class="comment">			SIG_UNBLOCK：根据用户设置的数据，对内核中的数据进行解除阻塞  （ mask &amp;= ~set ）</span></span><br><span class="line"><span class="comment">			SIG_SETMASK: 覆盖内核中原来的值</span></span><br><span class="line"><span class="comment">		- set  已经初始化的用户自定义的信号集</span></span><br><span class="line"><span class="comment">		- oldset  保存设置之前的内核中的阻塞信号集的状态，可以是NULL</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		成功 0</span></span><br><span class="line"><span class="comment">		失败 -1</span></span><br><span class="line"><span class="comment">			设置错误号：EFAULT、EINVAL</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigpending</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	获取内核中的未决信号集</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	参数 : set  传出参数，保存的是内存中的未决信号集的信息</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	返回值：成功0，失败-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<h4 id="sigaction-信号捕捉函数"><a href="#sigaction-信号捕捉函数" class="headerlink" title="sigaction 信号捕捉函数"></a>sigaction 信号捕捉函数</h4><p>跟 signal 函数作用类似</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> (*sa_handler)(<span class="type">int</span>);	<span class="comment">// 函数指针，指向的函数就是回调函数</span></span><br><span class="line">    <span class="type">void</span> (*sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span> *, <span class="type">void</span> *);		<span class="comment">// 不常用，需要就看看查文档</span></span><br><span class="line">    <span class="type">sigset_t</span> sa_mask;	<span class="comment">// 临时阻塞信号集，在信号捕捉函数执行过程中，临时阻塞某些信号</span></span><br><span class="line">    <span class="type">int</span> sa_flags;	<span class="comment">// 决定使用哪一个信号处理函数（ 0 表示使用 sa_handler，SA_SIGINFO 表示使用sa_sigaction</span></span><br><span class="line">    <span class="type">void</span> (*sa_restorer)(<span class="type">void</span>);	<span class="comment">// 废弃</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction *act, <span class="keyword">struct</span> sigaction *oldact)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	检查或改变信号的处理。信号捕捉</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- signum  指定的信号（ 除了SIGKILL 和 SIGSTOP ）</span></span><br><span class="line"><span class="comment">		- act  捕捉到信号后相应的处理动作</span></span><br><span class="line"><span class="comment">		- oldact  上一次对信号捕捉设置的处理动作，一般不使用，传递 NULL</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		成功 0</span></span><br><span class="line"><span class="comment">		失败 -1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<blockquote>
<p>由于编程标准原因，尽量使用 sigaction</p>
</blockquote>
<br>

<p>如果在回调函数执行过程中又收到信号，则会阻塞回调函数优先处理信号（解决方案：设置临时阻塞信号集）</p>
<br>

<p><strong>内核实现信号捕捉的过程</strong></p>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230207223806887-167596242752026.png" alt="image-20230207223806887"></p>
<blockquote>
<p>内核态的 do_signal() 和 sys_sigreturn()</p>
</blockquote>
<br>

<br>

<h4 id="SIGCHLD-信号"><a href="#SIGCHLD-信号" class="headerlink" title="SIGCHLD 信号"></a>SIGCHLD 信号</h4><p>产生条件：</p>
<ul>
<li>子进程终止时</li>
<li>子进程接收到 SIGSTOP 信号并停止时</li>
<li>子进程处在停止态，接收到 SIGCONT 信号唤醒时</li>
</ul>
<p>以上情况会由内核给父进程发送 SIGCHLD 信号，父进程默认忽略。</p>
<br>

<p><strong>解决僵尸进程问题</strong></p>
<ul>
<li>利用子进程终止时发送 SIGCHLD 信号</li>
<li>创建子进程前，先阻塞 SIGCHLD ，等回调函数注册完之后再解除阻塞</li>
</ul>
<br>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子进程资源回收 回调函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">myFun</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;捕捉信号 %d\n&quot;</span>, num);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> ret = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG);</span><br><span class="line">        <span class="keyword">if</span>(ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child die %d\n&quot;</span>, ret);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 还有子进程存活</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="comment">// 没有子进程了，回收完毕</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打开阻塞</span></span><br><span class="line">    <span class="type">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>. SIGCHLD);</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;<span class="built_in">set</span>, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">        act.sa_flags = <span class="number">0</span>;</span><br><span class="line">        act.sa_handler = myFun;</span><br><span class="line">        sigemptyset(&amp;act.sa_mask);</span><br><span class="line">        sigaction(SIGCHLD, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 解除阻塞</span></span><br><span class="line">        sigprocmask(SIG_UNBLOCK, &amp;<span class="built_in">set</span>, <span class="literal">NULL</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child %d\n&quot;</span>, getpid());</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><br><br></p>
<h3 id="2-6-6-共享内存"><a href="#2-6-6-共享内存" class="headerlink" title="2.6.6 共享内存"></a>2.6.6 共享内存</h3><p>效率最高的进程间通信方式</p>
<p>（内存映射需要用到文件）</p>
<br>

<ul>
<li>共享内存允许两个或多个进程共享<code>物理内存</code>的同一块区域（通常称为 段 )。由于一个共享内存段会被称为一个进程用户空间的一部分，因此这种 IPC 机制无需内核介入（实际上还是会用到系统调用，但相对较少）。所有需要做的就是让一个进程将数据复制进共享内存中，并且这部分数据会对其他所有共享同一个段的进程可用。</li>
<li>与管道等要求 发送进程 将数据从用户空间的缓冲区复制进内核内存 和 接收进程 将数据从内核内存复制进用户空间的缓冲区 的做法相比，共享内存方式速度更快。</li>
</ul>
<br>

<p><strong>使用步骤</strong></p>
<ol>
<li>调用 shmget() 创建一个新共享内存段或区的一个既有共享内存段的标识符（即由其他进程创建的共享内存段）。这个调用将返回后续调用中需要用到的共享内存标识符。</li>
<li>使用 shmat() 来附上共享内存段，也就是使该段成为调用进程的虚拟内存的一部分。</li>
<li>此刻在程序中可以像对待其他可用内存那样对待这个共享内存段。为引用这块共享内存，程序需要使用由 shmat() 调用返回的 addr 值，它是一个指向进程的虚拟地址空间中该共享内存段的起点的指针</li>
<li>调用 shmdt() 来分离共享内存段。调用后，进程就无法再引用这块共享内存。（这一步是可选的，并且在进程终止时会自动完成）</li>
<li>调用 shmctl() 来删除共享内存段。只有当当前所有附加内存段的进程都与之分离之后内存段才会销毁。（只有一个进程需要执行这一步）</li>
</ol>
<p><br><br></p>
<p><strong>函数接口</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	创建一个新的共享内存段，或者获取一个既有的共享内存段的标识</span></span><br><span class="line"><span class="comment">	新创建的内存段中的数据都会被初始化为0</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- key	key_t时整型，通过这个参数找到或者创建一个共享内存。一般使用16进制表示，非0值</span></span><br><span class="line"><span class="comment">		- size	共享内存的大小（实际按页划分）</span></span><br><span class="line"><span class="comment">		- shmflg 属性</span></span><br><span class="line"><span class="comment">			- 访问权限</span></span><br><span class="line"><span class="comment">			- 附加属性：创建/判断共享内存是否存在</span></span><br><span class="line"><span class="comment">				- 创建：IPC_CREAT</span></span><br><span class="line"><span class="comment">				- 判断共享内存是否存在：IPC_EXCL，需要和IPC_CREAT一起使用</span></span><br><span class="line"><span class="comment">				如 IPC_CREAT | IPC_EXCL | 0664</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		失败 -1，设置错误号</span></span><br><span class="line"><span class="comment">		成功 &gt;0,返回共享内存的引用 ID ，后面操作共享内存即通过这个值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">shmat</span><span class="params">(<span class="type">int</span> shmid, consst <span class="type">void</span> *shmaddr, <span class="type">int</span> shmflg)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	和当前的进程进行关联</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- shmid：共享内存的标识id，由shmget返回值获取</span></span><br><span class="line"><span class="comment">		- shmaddr：申请的共享内存的起始地址，指定NULL，由内核决定</span></span><br><span class="line"><span class="comment">		- shmflg：对共享内存的操作</span></span><br><span class="line"><span class="comment">			读：SHM_RDONLY，必须要有读权限</span></span><br><span class="line"><span class="comment">			读写：0</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		成功 返回共享内存的首地址</span></span><br><span class="line"><span class="comment">		失败 （void*)-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *shmaddr)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	解除当前进程和共享内存的关联</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- shmaddr：共享内存的首地址</span></span><br><span class="line"><span class="comment">	返回值：成功0，失败-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmctl</span><span class="params">(<span class="type">int</span> shmid, <span class="type">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	对共享内存进行操作（共享内存需要删除才会消失，创建共享内存的进程被销毁了对共享内存是没有影响的）</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- shmid：共享内存id</span></span><br><span class="line"><span class="comment">		- cmd：要做的操作</span></span><br><span class="line"><span class="comment">			IPC_STAT 获取共享内存的当前状态</span></span><br><span class="line"><span class="comment">			IPC_SET 设置共享内存的状态</span></span><br><span class="line"><span class="comment">			IPC_RMID 标记共享内存被销毁</span></span><br><span class="line"><span class="comment">		- buf：需要设置或者获取的共享内存的属性信息</span></span><br><span class="line"><span class="comment">			IPC_STAT：buf存储数据，传出参数</span></span><br><span class="line"><span class="comment">			IPC_SET：buf中需要初始化数据，设置到内核中，传入参数</span></span><br><span class="line"><span class="comment">			IPC_RMID：没有用，NULL</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<blockquote>
<p>shmid_ds结构体</p>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230208120249528-167596242752025.png" alt="image-20230208120249528"></p>
</blockquote>
<br>

<p><strong>案例</strong></p>
<p>write.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个共享内存</span></span><br><span class="line">    <span class="type">int</span> shmid = shmget(<span class="number">100</span>, <span class="number">0</span>, IPC_CREAT);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 和当前进程进行关联</span></span><br><span class="line">    <span class="type">void</span> *ptr = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 写数据</span></span><br><span class="line">    <span class="type">char</span> *str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, str, <span class="built_in">strlen</span>(str)+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 暂停一下</span></span><br><span class="line">    getchar();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解除关联</span></span><br><span class="line">    shmdt(ptr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除共享内存</span></span><br><span class="line">    shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<p>read.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取一个共享内存</span></span><br><span class="line">    <span class="type">int</span> shmid = shmget(<span class="number">100</span>, <span class="number">4096</span>, IPC_CREAT | <span class="number">0664</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 和当前进程进行关联</span></span><br><span class="line">    <span class="type">void</span> *ptr = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,(<span class="type">char</span> *)ptr);</span><br><span class="line">    <span class="comment">// 暂停一下</span></span><br><span class="line">    getchar();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解除关联</span></span><br><span class="line">    shmdt(ptr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除共享内存</span></span><br><span class="line">    shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<blockquote>
<p><strong>删除机制</strong></p>
<p>shmctl(shmid, IPC_RMID, NULL);</p>
<p>当关联进程数 &gt;&#x3D; 1 时，调用上面的函数删除共享内存并不会直接删除，而是把 key 值置为0，标记删除；</p>
<p>当关联进程数 &#x3D; 0 时，共享内存才会真正删除。</p>
</blockquote>
<br>

<br>

<p><strong>ftok函数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">key_t</span> <span class="title function_">ftok</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> proj_id)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	根据指定的路径名和 int 值，生成一个共享内存的 key ，可以作为shmget函数的参数</span></span><br><span class="line"><span class="comment">    参数：</span></span><br><span class="line"><span class="comment">		- pathname：指定一个存在的路径</span></span><br><span class="line"><span class="comment">		- proj_id：int类型的值（4B），但这个系统调用指挥使用其中1个字节</span></span><br><span class="line"><span class="comment">				   范围：0~255，一般指定一个字符 &#x27;a&#x27;</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<br>

<p><strong>问题</strong></p>
<ol>
<li>系统如何知道一块共享内存被多少个进程关联？<ul>
<li>共享内存维护了一个 shmid_ds 结构体，该结构体的成员 shm_nattach 记录了关联进程数</li>
</ul>
</li>
<li>可不可以对共享内存进行多次删除<ul>
<li>可以，当还有关联进程的时候，共享内存只是标记删除。而直到没有关联进程才会被真正删除。</li>
<li>key 为 0 ：被标记删除，不再能被关联</li>
</ul>
</li>
<li>共享内存与内存映射的区别<ul>
<li>共享内存可以直接创建，内存映射需要磁盘文件（匿名映射除外）</li>
<li>共享内存效率更高</li>
<li><strong>内存：</strong><br>共享内存，所有进程操作的是同一块共享内存（物理）；<br>内存映射，每个进程再自己的虚拟地址空间中有一个独立的内存。</li>
<li><strong>数据安全：</strong><ul>
<li>进程突然退出<br>共享内存还存在，内存映射区消失。</li>
<li>电脑突然宕机<br>共享内存中的数据消失，内存映射区的数据在磁盘文件中仍存在。</li>
</ul>
</li>
<li><strong>生命周期：</strong><ul>
<li>共享内存：进程退出，共享内存仍存在，需要手动删除或关机（进程退出会自动取消关联）</li>
<li>内存映射区：进程退出，映射区销毁</li>
</ul>
</li>
</ul>
</li>
</ol>
<br>

<p><strong>一些操作命令</strong>（System V）</p>
<p><code>ipcs</code></p>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230208122145744-167596242752022.png" alt="image-20230208122145744"></p>
<p><code>ipcrm</code></p>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230208122153825-167596242752023.png" alt="image-20230208122153825"></p>
<p><br><br></p>
<h3 id="补充：2-6-7-消息队列"><a href="#补充：2-6-7-消息队列" class="headerlink" title="补充：2.6.7 消息队列"></a>补充：2.6.7 消息队列</h3><p><br><br><br></p>
<h2 id="2-7-守护进程"><a href="#2-7-守护进程" class="headerlink" title="2.7 守护进程"></a>2.7 守护进程</h2><h3 id="终端、进程组、会话"><a href="#终端、进程组、会话" class="headerlink" title="终端、进程组、会话"></a>终端、进程组、会话</h3><p><strong>终端</strong></p>
<ul>
<li>在 UNIX 系统中，用户通过 终端 登陆到系统后得到一个 shell 进程，这个终端进程为 shell 进程的 控制终端 （Controlling Termianl) ，进程中，控制终端是保存在 PCB 中的信息，而 fork() 会复制 PCB 中的信息，因此由 shell 进程启动的其他进程的控制终端也是这个终端。</li>
<li>默认情况下（没有重定向），每个进程的标准输入、标准输出和标准错误输出（文件描述符）都指向控制终端，进程从标准输入读也就是读用户的键盘输入，进程往标准输出或标准错误输出写也就是输出到显示器上。</li>
<li>在控制终端输入一些特殊的控制键可以给前台进程发送信号，例如 Ctrl+C 会产生 SIGINT 信号，Ctrl+\ 会产生 SIGQUIT 信号。</li>
</ul>
<br>

<p><strong>进程组</strong></p>
<ul>
<li>进程组和会话在进程之间形成了一种两级层次关系：进程组是一组相关进程的集合，会话是一组相关进程组的集合。</li>
<li>进程组和会话是为支持 <u>shell作业控制</u> 而定义的抽象概念，用户通过 shell 能够交互式地在前台或后台运行命令。</li>
</ul>
<br>

<ul>
<li>进程组由一个或多个共享同一进程组标识符（PGID）的进程组成。一个进程组拥有一个 进程组首进程 （组长），该进程是创建该组的进程，<u>其进程 ID 为该进程组的 ID</u> ，新进程会继承父进程所属的进程组 ID 。</li>
<li>进程组有一个生命周期，起开始时间为首进程创建组的时刻，结束时间为最后一个成员进程退出的时刻。一个进程可能会因为终止而退出进程组，也可能会因为加入另一个进程组而退出进程组。进程组首进程无需是最后一个离开的成员。</li>
</ul>
<br>



<p><strong>会话</strong></p>
<ul>
<li>会话是一组进程组的集合。会话首进程是创建该新会话的进程，其进程ID会成为会话ID。新进程会继承其父进程的会话ID。</li>
<li>一个会话中的所有进程共享单个控制终端。控制终端会在会话首进程首次打开一个终端设备时被建立。一个终端最多可能成为一个会话的控制终端。</li>
<li>在任意时刻，会话中的其中一个进程组会成为终端的前台进程组，其他进程会成为后台进程组。只有前台进程组中的进程才能从控制终端中读取输入。当用户在控制终端中输入终端字符生成信号后，该信号会被发送到前台进程组中的所有成员。</li>
<li>当控制终端的连接建立起来之后，会话首进程会成为该终端的控制进程。</li>
</ul>
<br>

<p><strong>三者关系图</strong></p>
<p>指令 </p>
<p><code>fing / 2 &gt; /dev/null | wc -l &amp;</code>( &amp; 后台运行指令 )</p>
<p><code>sort &lt; longlist | uniq -c</code></p>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230208194637948-167596242752024.png" alt="image-20230208194637948"></p>
<blockquote>
<p>来自评论区：</p>
<p>为什么两条命令产生了两个新的进程组，并且不同于bach进程组:</p>
<p>关于find和wc为什么父进程是bash(400)，但是进程组ID确是658，而不是复制父进程的组ID。其实fork函数产生的子进程才是复制父进程的组ID。那通过这种命令产生的子进程，组ID是怎么确立的？在《Linux&#x2F;UNIX系统编程手册》2.13 中提到，“shell执行的每个程序都会在一个新进程内发起”，这句话解释了为什么find、wc、sort、uniq这四个都是一个单独的进程。“除了Bourne shell以外，几乎所有主流shell都提供了一种交互式特性，名为任务控制。该特性允许用户同时执行并操纵多条命令或管道。在支持任务控制的shell中，会将管道内所有进程置于一个新进程组或任务中。如果情况很简单，shell命令行只包含一条命令，那么就会创建一个只包含单个进程的新进程组。进程组中每个进程都具有相同的进程组标识符，其实就是进程组组长的ID”，这段话可以解释为什么两条命令产生了两个新的进程组，并且不同于bach进程组。这种shell命令创建子进程一定要和fork函数区分开来。</p>
</blockquote>
<br>

<br>

<p><strong>相关函数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取当前进程的进程组</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgrp</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// 获取指定进程的进程组</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br><span class="line"><span class="comment">// 设置指定进程的组id</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setpgid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">pid_t</span> pgid)</span>;</span><br><span class="line"><span class="comment">// 获取指定进程的会话id</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getsid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br><span class="line"><span class="comment">// 设置当前进程的会话id</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">setsid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><br><br></p>
<h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><p>守护进程( Daemon Process )，也就是通常说的 Daemon 进程（精灵进程），是Linux中的后台服务进程。其生存周期较长，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生地事件。进程名一般以 d 结尾。</p>
<br>

<p><strong>特征</strong></p>
<ul>
<li>生命周期长，守护进程会在系统启动的时候被创建并一直运行直至系统被关闭。</li>
<li>在后台运行并且不拥有控制终端。没有控制终端确保了内核永远不会为守护进程自动生成任何控制信号以及终端相关的信号（如 SIGINT、SIGQUIT）</li>
</ul>
<br>

<blockquote>
<p>Linux的大多数服务器就是用守护进程实现的，比如，Internet服务器 inetd ，Web服务器 httpd 等</p>
</blockquote>
<br>

<p><strong>创建步骤</strong></p>
<ul>
<li>*执行 fork()，然后父进程退出，子进程继续执行<ul>
<li>假设从命令行启动进程，父进程在退出后会使终端出现shell提示符；提前退出就不会出现了</li>
<li>子进程能确保自己不是进程组的首进程</li>
</ul>
</li>
<li>*子进程调用 setsid() 开启一个新会话（<ul>
<li>用setsid新建会话的首进程不能是进程组的首进程，否则导致组id重复</li>
<li>新建会话是为了控制终端，setsid() 新建的会话在终端连接建立之前默认无控制终端</li>
</ul>
</li>
<li>（非必须）清除进程的 umask 以确保当守护进程创建文件和目录时拥有所需的权限</li>
<li>（非必须）修改进程的当前工作目录，通常改为根目录（ &#x2F; ）</li>
<li>关闭守护进程从其父进程继承而来的所有打开着的文件描述符<ul>
<li>守护进程脱离了控制终端，但是没有脱离终端</li>
<li>避免守护进程通过标准输出等到终端读写数据</li>
<li>以及关闭其他继承过来的文件描述符，解除文件占用</li>
</ul>
</li>
<li>在关闭了文件描述符0、1、2之后，守护进程通常会打开 &#x2F;dev&#x2F;null 并使用 dup2() 使所有这些描述符指向这个设备<ul>
<li>某些系统调用会使用到0、1、2文件描述符，所以不能关闭</li>
<li>重定向后相当于丢弃掉数据</li>
</ul>
</li>
<li>*核心业务逻辑</li>
</ul>
<br>

<p><strong>案例</strong></p>
<p>写一个守护进程，每个2s获取一次系统时间，并将时间写入到磁盘文件中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">work</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="comment">// 捕捉到信号之后，获取系统时间并写入磁盘</span></span><br><span class="line">    <span class="type">time_t</span> ret = time(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> * <span class="title">loc</span> =</span> localtime(&amp;ret);</span><br><span class="line">    <span class="comment">// 转换格式</span></span><br><span class="line">    <span class="comment">// char buf[1024];</span></span><br><span class="line">    <span class="comment">// sprintf(buf, &quot;%d:%d:%d\n&quot;,loc-&gt;tm_hour,loc-&gt;tm_min,loc-&gt;tm_sec);</span></span><br><span class="line">    <span class="comment">// printf(&quot;%s\n&quot;,buf);</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *str = asctime(loc);</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;time.txt&quot;</span>, O_RDWR | O_CREAT | O_APPEND, <span class="number">0664</span>);</span><br><span class="line">    write(fd, str, <span class="built_in">strlen</span>(str));</span><br><span class="line">    write(fd, <span class="string">&quot;\n&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;\n&quot;</span>));    </span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建子进程，退出父进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子进程重新创建一个会话</span></span><br><span class="line">    setsid();</span><br><span class="line">    <span class="comment">// 设置掩码</span></span><br><span class="line">    umask(<span class="number">022</span>);</span><br><span class="line">    <span class="comment">// 更改工作目录</span></span><br><span class="line">    chdir(<span class="string">&quot;/root/user&quot;</span>);</span><br><span class="line">    <span class="comment">// 关闭、重定向文件描述符</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/dev/null&quot;</span>,O_RDWR);</span><br><span class="line">    dup2(fd,STDIN_FILENO);</span><br><span class="line">    dup2(fd,STDOUT_FILENO);</span><br><span class="line">    dup2(fd,STDERR_FILENO);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 业务逻辑</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册信号捕捉</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    act.sa_handler = work;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    sigaction(SIGALRM, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建定时器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">val</span>;</span></span><br><span class="line">    val.it_value.tv_sec = <span class="number">2</span>;</span><br><span class="line">    val.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">    val.it_interval.tv_sec = <span class="number">2</span>;</span><br><span class="line">    val.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    setitimer(ITIMER_REAL, &amp;val, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<br>

<p>第二章完结！</p>
]]></content>
      <categories>
        <category>C++开发</category>
        <category>高性能服务器项目</category>
      </categories>
      <tags>
        <tag>多进程</tag>
      </tags>
  </entry>
  <entry>
    <title>邮件服务实现思路</title>
    <url>/2024/01/05/%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<h2 id="Mail-Server"><a href="#Mail-Server" class="headerlink" title="Mail Server"></a>Mail Server</h2><ul>
<li>管理玩家的邮箱数据，包括从数据库（数据库代理服务器）加载、修改并保存到数据库<ul>
<li>与数据库代理的交互，会有监控机制监控操作是否成功，若不成功则会进行重试</li>
<li>重试次数会有上限，或者限流，防止压垮数据库</li>
</ul>
</li>
<li>向GS请求验证玩家是否满足接受邮件的条件</li>
<li>向GS请求验证玩家是否满足领取附件的条件</li>
<li>向GS通知玩家领取附件</li>
<li>与客户端直接进行交互（由GS转发）<ul>
<li>客户端视角：<ul>
<li>获取所有邮件</li>
<li>设置已读</li>
<li>删除邮件</li>
<li>领取附件</li>
</ul>
</li>
<li>Mail Server 视角：<ul>
<li>同步邮箱</li>
<li>同步新邮件</li>
<li>数据增删查改</li>
<li>邮件过期通知</li>
</ul>
</li>
</ul>
</li>
</ul>
<span id="more"></span>

<h2 id="Game-Server"><a href="#Game-Server" class="headerlink" title="Game Server"></a>Game Server</h2><ul>
<li>注册到 Mail Server 后，Mail Server 同步过来该服（所在group）的所有邮件</li>
<li>验证玩家是否符合接收邮件的条件，并将符合的邮件及其对应的玩家告知 Mail Server，Mail Server更新邮件数据</li>
<li>验证玩家是否符合接受附件的条件，符合则在GS这边更新玩家的附件内容，并告知 Mail Server 附件条件符合的玩家情况，Mail Server 更新玩家邮件附件领取状态</li>
<li>GS发送广播邮件过程<ul>
<li>GS 先向 Mail Server 通知要发送广播邮件</li>
<li>Mail Server 更新 GS 的广播邮件数据，并发给 GS 验证广播邮件的请求</li>
<li>GS 分帧验证符合接收邮件条件的在线玩家，并将符合情况发给 Mail Server</li>
<li>Mail Server 更新各个在线玩家的邮件数据，并给对应的在线玩家发送该广播邮件（由GS转发）</li>
</ul>
</li>
<li>GS发送单播邮件过程<ul>
<li>GS 先向 Mail Server 通知要发送单播邮件给某个玩家</li>
<li>Mail Server 更新玩家数据，并给对应玩家发送该广播邮件（由GS转发）</li>
</ul>
</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="GS广播邮件时不在线的玩家，在其上线后如何收到邮件"><a href="#GS广播邮件时不在线的玩家，在其上线后如何收到邮件" class="headerlink" title="GS广播邮件时不在线的玩家，在其上线后如何收到邮件"></a>GS广播邮件时不在线的玩家，在其上线后如何收到邮件</h3><ul>
<li>首先，Mail Server 记录有每个玩家已接收的最新邮件序号，记录有 GS（所在group）上的所有邮件</li>
<li>可以推测，每当 Mail Server 向 GS 请求验证完玩家收取邮件的条件后，若玩家能够接收邮件，Mail Server 会更新其收到的最新邮件序号</li>
<li>于是，不在线的玩家的最新邮件序号可能是过时的，当玩家登陆时，Mail Server 要向GS请求验证该玩家的邮件接收</li>
<li>GS 的做法是，从玩家的最新邮件序号开始，遍历自己同步到的邮件列表，验证每一个序号大于玩家当前最新邮件序号的邮件，并将符合的邮件的序号加入到回包中，发回给 Mail Server</li>
<li>Mail Server 根据验证情况，更新玩家的邮件数据和最新邮件序号</li>
</ul>
<h3 id="客户端的视角"><a href="#客户端的视角" class="headerlink" title="客户端的视角"></a>客户端的视角</h3><ul>
<li>客户端登陆后，Mail Server 会收到玩家上线通知，并加载玩家的邮箱数据</li>
<li>Mail Server 加载完成后，通知客户端加载完成（但不立即同步邮箱数据）</li>
<li>客户端通过 UI 交互触发同步邮箱数据请求，Mail Server 发送邮箱同步数据</li>
<li>客户端之后可以通过检查邮箱数据请求，与 Mail Server 校对邮箱数据是否是最新的（通过最新邮件序号）<ul>
<li>不是最新的的话，Mail Server 需要发送同步数据给客户都</li>
</ul>
</li>
<li>客户端可以进行邮件的读取、删除、领取附件的请求</li>
<li>客户端在线时，若有新的邮件，Mail Server 会发送单个邮件同步数据过来</li>
</ul>
<h3 id="Mail-Server-的性能考虑"><a href="#Mail-Server-的性能考虑" class="headerlink" title="Mail Server 的性能考虑"></a>Mail Server 的性能考虑</h3><ul>
<li>数据结构：邮件数据以有序的形式组织</li>
<li>用户量：只有当玩家上线或者需要给玩家发送邮件时，才从数据库中加载玩家的邮箱数据</li>
<li>过期处理：仅对在线玩家做实时的过期判断</li>
<li>每帧限制处理数量，防止卡帧丢帧</li>
</ul>
]]></content>
      <categories>
        <category>游戏开发</category>
        <category>服务端</category>
      </categories>
      <tags>
        <tag>邮件服务</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux网络编程</title>
    <url>/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<br>

<h1 id="第四章-Linux网络编程"><a href="#第四章-Linux网络编程" class="headerlink" title="第四章 Linux网络编程"></a>第四章 Linux网络编程</h1><hr>
<br>

<h2 id="4-1-计算机网络相关知识"><a href="#4-1-计算机网络相关知识" class="headerlink" title="4.1 计算机网络相关知识"></a>4.1 计算机网络相关知识</h2><br>

<h3 id="4-1-1-网络结构模式"><a href="#4-1-1-网络结构模式" class="headerlink" title="4.1.1 网络结构模式"></a>4.1.1 网络结构模式</h3><h4 id="C-x2F-S结构"><a href="#C-x2F-S结构" class="headerlink" title="C&#x2F;S结构"></a>C&#x2F;S结构</h4><span id="more"></span>

<p><strong>简介</strong></p>
<ul>
<li>服务器 - 客户机，即 Client - Server（C&#x2F;S）结构。<strong>C&#x2F;S 结构通常采取两层结构。服务器负责数据的管理，客户机负责完成与用户的交互任务。</strong>客户机是因特网上访问别人信息的机器，服务器则是提供信息供人访问的计算机。</li>
<li><strong>客户机通过局域网与服务器相连，接受用户的请求，并通过网络向服务器提出请求，对数据库进行操作。服务器接受客户机的请求，将数据提交给客户机，客户机将数据进行计算并将结果呈现给用户。</strong>服务器还要提供完善安全保护及对数据完整性的处理等操作，并允许多个客户机同时访问服务器，这就对服务器的硬件处理数据能力提出了很高的要求。</li>
<li>在C&#x2F;S结构中，<strong>应用程序分为两部分：服务器部分和客户机部分。</strong>服务器部分是多个用户共享的信息与功能，执行后台服务，如控制共享数据库的操作等；客户机部分为用户所专有，负责执行前台功能，在出错提示、在线帮助等方面都有强大的功能，并且可以在子程序间自由切换。</li>
</ul>
<br>

<p><strong>优点</strong></p>
<ol>
<li>能充分发挥客户端 PC 的处理能力，<strong>很多工作可以在客户端处理后再提交给服务器，</strong>所以 C&#x2F;S 结构<strong>客户端响应速度快</strong>；</li>
<li>操作界面漂亮、形式多样，可以充分满足客户自身的<strong>个性化</strong>要求；</li>
<li>C&#x2F;S 结构的<strong>管理信息系统具有较强的事务处理能力</strong>，能实现复杂的业务流程；</li>
<li><strong>安全性较高</strong>，C&#x2F;S 一般面向相对固定的用户群，<strong>程序更加注重流程</strong>，它可以<strong>对权限进行多层次校验</strong>，提供了更安全的存取模式，对信息安全的控制能力很强，一般<strong>高度机密</strong>的信息系统采用 C&#x2F;S 结构适宜。</li>
</ol>
<br>

<p><strong>缺点</strong></p>
<ol>
<li><strong>客户端需要安装专用的客户端软件</strong>。首先涉及到安装的工作量，其次任何一台电脑出问题，如病毒、硬件损坏，都需要进行安装或维护。系统软件升级时，每一台客户机需要重新安装，其维护和升级成本非常高；</li>
<li><strong>对客户端的操作系统一般也会有限制，不能够跨平台</strong></li>
</ol>
<br>

<br>

<h4 id="B-x2F-S-结构"><a href="#B-x2F-S-结构" class="headerlink" title="B&#x2F;S 结构"></a>B&#x2F;S 结构</h4><p><strong>简介</strong></p>
<ul>
<li>B&#x2F;S 结构（Browser&#x2F;Server，浏览器&#x2F;服务器模式），<strong>是WEB兴起后的一种网络结构模式，WEB浏览器是客户端最主要的应用软件。</strong>这种模式<strong>统一了客户端</strong>，将系统功能实现的<strong>核心部分集中到服务器上</strong>，简化了系统的开发、维护和使用。客户机上只要安装一个浏览器，如 Firefox 或 InternetExplorer，服务器安装 SQL Server、Oracle、MySQL 等数据库。浏览器通过 Web Server 同数据库进行数据交互</li>
</ul>
<br>

<p><strong>优点</strong></p>
<ul>
<li>B&#x2F;S 架构最大的优点是总体拥有<strong>成本低、维护方便、 分布性强、开发简单</strong>，可以不用安装任何专门的软件就能实现在任何地方进行操作，客户端零维护，系统的扩展非常容易，只要有一台能上网的电脑就能使用。</li>
</ul>
<br>

<p><strong>缺点</strong></p>
<ol>
<li><strong>通信开销大、系统和数据的安全性较难保障;</strong></li>
<li>个性特点明显降低，无法实现具有个性化的功能要求；</li>
<li>协议一般是<strong>固定</strong>的：<strong>http&#x2F;https</strong>（无法输出大数据）</li>
<li>客户端服务器端的交互是<strong>请求-响应模式</strong>，通常<strong>动态刷新</strong>页面，<strong>响应速度明显降低</strong>。</li>
</ol>
<br>

<br>

<br>

<h3 id="4-1-2-MAC、IP、端口"><a href="#4-1-2-MAC、IP、端口" class="headerlink" title="4.1.2 MAC、IP、端口"></a>4.1.2 MAC、IP、端口</h3><h4 id="网卡"><a href="#网卡" class="headerlink" title="网卡"></a>网卡</h4><p>（网卡分为 以太网卡 和 无线网卡 ）</p>
<ul>
<li>网卡是一块被设计用来允许计算机在计算机网络上进行通讯的计算机硬件，又称为 <strong>网络适配器</strong> 或 <strong>网络接口卡NIC</strong> 。</li>
<li>其<strong>拥有 MAC 地址</strong>，属于 OSI 模型的<strong>第 2 层</strong>，它使得用户可以通过电缆或无线相互连接。</li>
<li>每一个网卡都有一个被称为 MAC 地址的独一无二的 <strong>48 位</strong>串行号。</li>
<li>网卡的主要功能：<ul>
<li>数据的封装与解封装</li>
<li>链路管理</li>
<li>数据编码与译码</li>
</ul>
</li>
</ul>
<br>

<h4 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h4><ul>
<li>Media Access Control Address</li>
<li>直译为 <strong>媒体存取控制位址</strong> ，也称为 <strong>局域网地址</strong>、<strong>以太网地址</strong>、<strong>物理地址</strong> 或 <strong>硬件地址</strong> ，它是一个用来确认网络设备位置的位址，由网络设备制造商生产时烧录在网卡中</li>
<li>在 OSI 模型中，<strong>第三层网络层负责IP地址，第二层数据链路层则负责MAC位址</strong> </li>
<li>MAC 地址用于在网络中<strong>唯一标识一个网卡</strong>。一台设备若有一或多个网卡，则每个网卡都需要并会有一个唯一的 MAC 地址。</li>
<li>MAC 地址的长度为 <strong>48 位（6个字节）</strong>，通常表示为 12 个 16 进制数，如：00-16-EA-AE-3C-40 就是一个MAC 地址。<ul>
<li>其中前 3 个字节，16 进制数 00-16-EA 代表网络硬件制造商的编号，它由IEEE（电气与电子工程师协会）分配</li>
<li>而后 3 个字节，16进制数 AE-3C-40 代表该制造商所制造的某个网络产品（如网卡）的系列号。</li>
<li>只要不更改自己的 MAC 地址，MAC 地址在世界是唯一的。形象地说，MAC 地址就如同身份证上的身份证号码，具有唯性。</li>
</ul>
</li>
</ul>
<br>

<h4 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h4><p><strong>简介</strong></p>
<p>​	IP（Internet Protocol）协议是为计算机网络相互连接进行通信而设计的协议。在 <strong>因特网</strong> 中，它是能使连接到网上的所有计算机网络实现相互通信的一套规则，规定了计算机在因特网上进行通信时应当遵守的规则。任何厂家生产的计算机系统，只要遵守IP协议就可以与因特网互连互通。</p>
<p>​	各个厂家生产的网络系统和设备，如以太网、分组交换网等，它们相互之间不能互通，不能互通的主要原因是因为它们所传送数据的基本单元（技术上称之为“帧”）的格式不同。IP 协议实际上是一套由软件程序组成的协议软件，它把各种不同“<strong>帧</strong>”统一转换成“<strong>IP 数据报</strong>”格式，这种转换是因特网的一个最重要的特点，使所有各种计算机都能在因特网上实现互通，即具有“开放性”的特点。正是因为有了 IP 协议，因特网才得以迅速发展成为世界上最大的、开放的计算机通信网络。因此，IP 协议也可以叫做“<strong>因特网协议</strong>”。</p>
<br>

<ul>
<li><p><strong>IP地址</strong>（Internet Protocol Address）是指<strong>互联网协议地址</strong>，又译为<strong>网际协议地址</strong>。IP 地址是IP协议提供的一种统一的地址格式，<strong>它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异</strong></p>
</li>
<li><p>IP 地址是一个 <strong>32 位的二进制数</strong>，通常被分割为 <strong>4 个“ 8 位二进制数”</strong>（也就是 4 个字节）。</p>
</li>
</ul>
<br>

<p><strong>IP地址类型</strong></p>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230210225815319.png" alt="image-20230210225815319"></p>
<p>补充：</p>
<ul>
<li>D类IP地址：D 类 IP 地址在历史上被叫做多播地址（multicast address），即组播地址。在以太网中，多播地址命名了一组应该在这个网络中应用接收到一个分组的站点。多播地址的最高位必须是 “1110”，范围从224.0.0.0 - 239.255.255.255。</li>
<li><strong>特殊的网址</strong>（E类）：<ul>
<li>每一个字节都为 0 的地址（ “0.0.0.0” ）对应于当前主机；</li>
<li>IP 地址中的每一个字节都为 1 的 IP 地址（ “255.255.255.255” ）是当前子网的广播地址；</li>
<li>IP 地址中凡是以 “11110” 开头的 E 类 IP 地址都保留用于将来和实验使用。</li>
<li>IP地址中不能以十进制 “127” 作为开头，该类地址中数字 127.0.0.1 到 127.255.255.255 用于回路测试，如：127.0.0.1可以代表本机IP地址</li>
</ul>
</li>
</ul>
<br>

<p><strong>子网掩码</strong></p>
<ul>
<li>子网掩码（subnet mask）又叫网络掩码、地址掩码、子网络遮罩，它是一种用来指明一个 IP 地址的哪些位标识的是主机所在的子网，以及哪些位标识的是主机的位掩码。子网掩码不能单独存在，它必须结合 IP 地址一起用。子网掩码只有一个作用，就是<strong>将某个 IP 地址划分成 网络地址 和 主机地址 两部分</strong>。</li>
<li>子网掩码是一个 32 位地址，用于屏蔽 IP 地址的一部分以区别网络标识和主机标识，并说明该 IP地址是在局域网上，还是在广域网上。</li>
<li>子网掩码是在 IPv4 地址资源紧缺的背景下为了解决 IP 地址分配而产生的虚拟 IP 技术，通过子网掩码将A、B、C 三类地址划分为若干子网，从而显著提高了 IP 地址的分配效率，有效解决了 IP 地址资源紧张的局面。另一方面，在企业内网中为了更好地管理网络，网管人员也利用子网掩码的作用，人为地将一个较大的企业内部网络划分为更多个小规模的子网，再利用三层交换机的路由功能实现子网互联，从而有效解决了网络广播风暴和网络病毒等诸多网络管理方面的问题。</li>
</ul>
<br>

<br>

<h4 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h4><blockquote>
<p>端口 就是一块缓冲区，有 读缓冲 和 写缓冲 </p>
</blockquote>
<p><strong>简介</strong></p>
<ul>
<li>端口 是英文 port 的意译，可以认为是设备与外界通讯交流的出口。端口可分为 <strong>虚拟端口</strong> 和 <strong>物理端口</strong> ，<ul>
<li><strong>虚拟端口</strong> 指<strong>计算机内部或交换机路由器内的端口</strong>，<strong>不可见</strong>，是特指<strong>TCP&#x2F;IP协议中的端口</strong>，是<strong>逻辑意义上</strong>的端口。例如计算机中的 80 端口、21 端口、23 端口等。</li>
<li><strong>物理端口</strong> 又称为<strong>接口</strong>，<strong>是可见端口</strong>，计算机背板的 RJ45 网口，交换机路由器集线器等 RJ45 端口。电话使用 RJ11 插口也属于物理端口的范畴。</li>
</ul>
</li>
<li>如果把 IP 地址比作一间房子，端口就是出入这间房子的门。真正的房子只有几个门，但是一个 IP地址的端口可以有 <strong>65536</strong>（即：2^16）个之多！端口是通过端口号来标记的，端口号只有整数，范围是从 <strong>0 到 65535</strong>（2^16-1）。</li>
</ul>
<br>

<p><strong>端口类型</strong></p>
<ul>
<li><p><strong>周知端口</strong> Well Known Ports ：</p>
<ul>
<li>也叫知名端口、公认端口或者常用端口，范围从 <strong>0 到 1023</strong>，它们紧密绑定于一些特定的服务。</li>
<li>例如 <strong>80 端口分配给 WWW 服务，21 端口分配给 FTP 服务，23 端口分配给Telnet服务</strong>等等。</li>
<li>网络服务是可以使用其他端口号的，比如使用“8080” 作为 WWW服务的端口；但是有些系统协议使用固定的端口号，比如 139 端口专门用于 NetBIOS 与 TCP&#x2F;IP 之间的通信</li>
</ul>
</li>
<li><p><strong>注册端口</strong> Registered Ports ：</p>
<ul>
<li>端口号从 <strong>1024 到 49151</strong>，它们松散地绑定于一些服务，<strong>分配给用户进程或应用程序</strong>。</li>
<li>这些端口在没有被服务器资源占用的时候，可以给用户端动态选用为源端口。</li>
</ul>
</li>
<li><p><strong>动态端口</strong> &#x2F; <strong>私有端口</strong> Dynamic Ports&#x2F;Private Ports ：</p>
<ul>
<li>动态端口的范围是从 <strong>49152 到 65535</strong>。之所以称为动态端口，是因为它一般不固定分配某种服务，而是<strong>动态分配</strong>。</li>
</ul>
</li>
</ul>
<br>

<br>

<br>

<br>

<h3 id="4-1-3-网络模型"><a href="#4-1-3-网络模型" class="headerlink" title="4.1.3 网络模型"></a>4.1.3 网络模型</h3><h4 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h4><p>Open System Interconnection</p>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230210233638076.png" alt="image-20230210233638076"></p>
<p><strong>物理层</strong>：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输，到达目的地后再转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做比特。</p>
<br>

<p><strong>数据链路层</strong>：建立逻辑连接、进行硬件地址寻址、差错校验等功能。定义了如何让格式化数据以帧为单位进行传输，以及如何让控制对物理介质的访问。将比特组合成字节进而组合成帧，用MAC地址访问介质。</p>
<br>

<p><strong>网络层</strong>：进行逻辑地址寻址，在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。</p>
<br>

<p><strong>传输层</strong>：定义了一些传输数据的协议和端口号（ WWW 端口 80 等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与TCP 特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如 QQ 聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做段。</p>
<br>

<p><strong>会话层</strong>：通过传输层（端口号：传输端口与接收端口）建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求。</p>
<br>

<p><strong>表示层</strong>：<strong>数据的表示、安全、压缩。</strong>主要是进行对接收的数据进行解释、加密与解密、压缩与解压缩等（也就是把计算机能够识别的东西转换成人能够能识别的东西（如图片、声音等）。</p>
<br>

<p><strong>应用层</strong>：网络服务与最终用户的一个接口。这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务</p>
<br>

<br>

<h4 id="TCP-x2F-IP-四层模型"><a href="#TCP-x2F-IP-四层模型" class="headerlink" title="TCP&#x2F;IP 四层模型"></a>TCP&#x2F;IP 四层模型</h4><p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230210233916419.png" alt="image-20230210233916419"></p>
<p>现在 Internet（因特网）使用的<strong>主流协议族是 TCP&#x2F;IP 协议族</strong>，它是一个分层、多协议的通信体系。TCP&#x2F;IP协议族是一个四层协议系统，<strong>自底而上分别是数据链路层、网络层、传输层和应用层</strong>。</p>
<br>

<p><strong>简化OSI七层模型</strong></p>
<ol>
<li><strong>应用层、表示层、会话层</strong> 三个层次提供的服务相差不是很大，所以在 TCP&#x2F;IP 协议中，它们被合并为 <strong>应用层</strong> 一个层次。</li>
<li>由于 <strong>传输层、网络层</strong> 在网络协议中的地位十分重要，所以在 TCP&#x2F;IP 协议中它们被作为<strong>独立</strong>的两个层次。</li>
<li>因为 <strong>数据链路层、物理层</strong> 的内容相差不多，所以在 TCP&#x2F;IP 协议中它们被归并在 <strong>网络接口层</strong> 一个层次里。</li>
</ol>
<br>

<p><strong>四层介绍</strong></p>
<ul>
<li><strong>应用层</strong>：应用层是 TCP&#x2F;IP 协议的第一层，是直接为应用进程提供服务的。<ul>
<li>对不同种类的应用程序它们会根据自己的需要来使用应用层的不同协议，邮件传输应用使用了 SMTP 协议、万维网应用使用了 HTTP 协议、远程登录服务应用使用了有 TELNET 协议。</li>
<li>应用层还能<strong>加密、解密、格式化数据</strong>。</li>
<li>应用层可以<strong>建立或解除与其他节点的联系</strong>，这样可以充分节省网络资源。</li>
</ul>
</li>
<li><strong>传输层</strong>：作为 TCP&#x2F;IP 协议的第二层，运输层在整个 TCP&#x2F;IP 协议中起到了中流砥柱的作用。且在运输层中， <strong>TCP 和 UDP</strong> 也同样起到了中流砥柱的作用。</li>
<li><strong>网络层</strong>：网络层在 TCP&#x2F;IP 协议中的位于第三层。在 TCP&#x2F;IP 协议中网络层可以进行<strong>网络连接的建立和终止</strong>以及 <strong>IP 地址的寻找</strong>等功能。</li>
<li><strong>网络接口层</strong>：在 TCP&#x2F;IP 协议中，网络接口层位于第四层。由于网络接口层兼并了物理层和数据链路层所以，网络接口层既是<strong>传输数据的物理媒介</strong>，也可以为网络层<strong>提供一条准确无误的线路</strong>。</li>
</ul>
<br>

<br>

<p><strong>比较</strong></p>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230210235626139.png" alt="image-20230210235626139"></p>
<br>

<br>

<br>

<br>

<h3 id="4-1-4-协议"><a href="#4-1-4-协议" class="headerlink" title="4.1.4 协议"></a>4.1.4 协议</h3><p><strong>简介</strong></p>
<p>​	<strong>协议</strong>，网络协议的简称，网络协议是通信计算机双方必须共同遵从的一组约定。</p>
<ul>
<li>如怎么样建立连接、怎么样互相识别等。只有遵守这个约定，计算机之间才能相互通信交流。</li>
<li>它的三要素是：<strong>语法、语义、时序</strong>。</li>
<li>为了使数据在网络上从源到达目的，网络通信的参与方必须遵循相同的规则，这套规则称为协议（protocol），它最终体现为在网络上传输的<strong>数据包的格式</strong>。协议往往分成几个层次进行定义，<strong>分层定义</strong>是为了<u>使某一层协议的改变不影响其他层次的协议</u>。</li>
</ul>
<br>

<p><strong>常见协议</strong></p>
<ul>
<li><p>应用层：</p>
<ul>
<li>FTP协议（File Transfer Protocol 文件传输协议）</li>
<li>HTTP协议（Hyper Text Transfer Protocol 超文本传输协议）</li>
<li>NFS（Network File System 网络文件系统）。（SSH协议端口号是22）</li>
</ul>
</li>
<li><p>传输层：</p>
<ul>
<li>TCP协议（Transmission Control Protocol 传输控制协议）</li>
<li>UDP协议（User Datagram Protocol 用户数据报协议）。</li>
</ul>
</li>
<li><p>网络层：</p>
<ul>
<li>IP 协议（Internet Protocol 因特网互联协议）</li>
<li>ICMP 协议（Internet Control Message Protocol 因特网控制报文协议）</li>
<li>IGMP 协议（Internet Group Management Protocol 因特网组管理协议）。</li>
</ul>
</li>
<li><p>网络接口层：</p>
<ul>
<li>ARP协议（Address Resolution Protocol 地址解析协议）</li>
<li>RARP协议<br>（Reverse Address Resolution Protocol 反向地址解析协议）</li>
</ul>
</li>
</ul>
<br>

<br>

<h4 id="UDP报"><a href="#UDP报" class="headerlink" title="UDP报"></a>UDP报</h4><p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230211001006533.png" alt="image-20230211001006533"></p>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230211003426471.png" alt="image-20230211003426471"></p>
<br>

<h4 id="TCP报"><a href="#TCP报" class="headerlink" title="TCP报"></a>TCP报</h4><p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230211001202108.png" alt="image-20230211001202108"></p>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230211003839373.png" alt="image-20230211003839373"></p>
<p>flag：<br><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230211004511396.png" alt="image-20230211004511396"></p>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230211004527855.png" alt="image-20230211004527855"></p>
<br>

<h4 id="IP报"><a href="#IP报" class="headerlink" title="IP报"></a>IP报</h4><p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230211003610812.png" alt="image-20230211003610812"></p>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230211005238765.png" alt="image-20230211005238765"></p>
<br>

<h4 id="以太网帧"><a href="#以太网帧" class="headerlink" title="以太网帧"></a>以太网帧</h4><p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230211003524443.png" alt="image-20230211003524443"></p>
<p>类型：0x800 IP，0x806 ARP，0x835 RARP</p>
<br>

<h4 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h4><p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230211003731026.png" alt="image-20230211003731026"></p>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230211003742083.png" alt="image-20230211003742083"></p>
<br>

<br>

<h4 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程"></a>通信过程</h4><p><strong>封装</strong></p>
<p>​	应用程序数据在发送到物理网络上之前，将沿着协议栈从上往下依次传递。每层协议都将在上层数据的基础上加上自己的头部信息（有时还包括尾部信息），以实现该层的功能，这个过程就称为封装。</p>
<blockquote>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230211010042659.png" alt="封装"></p>
</blockquote>
<br>

<p><strong>分用</strong></p>
<p>​	当帧到达目的主机时，将沿着协议栈自底向上依次传递。各层协议依次处理帧中本层负责的头部数据，以获取所需的信息，并最终将处理后的帧交给目标应用程序。这个过程称为分用（demultiplexing）。分用是依靠头部信息中的类型字段实现的。</p>
<blockquote>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230211010337835.png" alt="分用"></p>
</blockquote>
<br>

<p><strong>封装与解封装案例</strong></p>
<p>（数据链路层还有 帧尾 的校验码）</p>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230211010845923.png" alt="封装与解封装"></p>
<br>

<br>

<h4 id="ARP协议的分析"><a href="#ARP协议的分析" class="headerlink" title="ARP协议的分析"></a>ARP协议的分析</h4><p>封装过程中，从网络层到数据链路层，需要添加的以太网帧头含有 <strong>目的mac地址</strong> 字段</p>
<p><strong>问题</strong>：目前知道 目的IP地址 ，要从何获取目的mac地址？ —— 利用ARP协议（通过 IP 获取 mac）</p>
<p>先查找本地 地址解析表 ，如果没有就如下：</p>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230211011936900.png" alt="arp"></p>
<ul>
<li>广播发送</li>
<li>单播应答</li>
</ul>
<br>

<p><strong>帧结构</strong></p>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230211020206256.png" alt="ARP报文"></p>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230211020650494.png" alt="加上帧头（请求包）"></p>
<blockquote>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230211003731026.png" alt="image-20230211003731026"></p>
</blockquote>
<br>

<br>

<h3 id="4-1-5-Socket套接字"><a href="#4-1-5-Socket套接字" class="headerlink" title="4.1.5 Socket套接字"></a>4.1.5 Socket套接字</h3><p><strong>socket</strong>（套接字），就是对 <strong>网络中不同主机上的应用进程之间</strong> 进行<strong>双向通信</strong>的<strong>端点</strong>的抽象。一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制。从所处的地位来讲，套接字上联应用进程，下联网络协议栈，是应用程序通过网络协议进行通信和交互的接口。</p>
<br>

<p>socket 可以看成是两个网络<strong>应用程序</strong>进行通信时，各自<strong>通信连接中的端点</strong>，这是一个<strong>逻辑上的概念</strong>。它是网络环境中进程间通信的 API，也是可以 <strong>被命名</strong> 和 <strong>寻址</strong> 的通信端点，使用中的每一个套接字都有其类型和一个与之相连进程。通信时其中一个网络应用程序将要传输的一段信息写入它所在主机的 socket 中，该 socket 通过与网络接口卡（NIC）相连的传输介质将这段信息送到另外一台主机的 socket 中，使对方能够接收到这段信息。socket 是由 <strong>IP</strong> 和 <strong>端口</strong> 结合的，提供<strong>向应用层进程传送数据包</strong>的机制。</p>
<br>

<p>socket 本身有“<strong>插座</strong>”的意思，在 Linux 环境下，用于表示进程间网络通信的特殊文件类型。本质为内核借助 <strong>缓冲区</strong> 形成的 <strong>伪文件</strong> 。既然是文件，那么理所当然的，我们可以使用 <strong>文件描述符</strong> 引用套接字。与管道类似的，<u>Linux 系统将其封装成文件的目的是为了统一接口</u>，使得读写套接字和读写文件的操作一致。<u>区别是管道主要应用于本地进程间通信，而套接字多应用于网络进程间数据的传递。</u></p>
<br>

<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230211023108406.png" alt="image-20230211023108406"></p>
<br>

<p>套接字通信分两部分：</p>
<ul>
<li><strong>服务器端</strong>：被动接受连接，一般不会主动发起连接</li>
<li><strong>客户端</strong>：主动向服务器发起连接</li>
</ul>
<blockquote>
<p>socket是一套通信的接口，Linux 和 Windows 都有，但是有一些细微的差别</p>
</blockquote>
<br>

<br>

<h3 id="4-1-6-字节序"><a href="#4-1-6-字节序" class="headerlink" title="4.1.6 字节序"></a>4.1.6 字节序</h3><blockquote>
<p>现代 CPU 的累加器一次都能装载（至少）4 字节（这里考虑 32 位机），即一个整数。</p>
<p>这 4 字节在内存中排列的顺序将影响它被累加器装载成的整数的值，这就是字节序问题。</p>
<p>通信双方交流的信息单元（比特、字节、字、双字等等）应该以什么样的顺序进行传送。</p>
</blockquote>
<br>

<p>字节序分为大端字节序（Big-Endian） 和小端字节序（Little-Endian）。</p>
<ul>
<li><p><strong>大端</strong> 字节序是指 一个整数 的 <strong>最高位字节</strong>（0x后面最左边的数字）存储在 <strong>内存</strong> 的 <strong>低地址</strong> 处 ，低位字节（0 ~ 7 bit）存储在内存的高地址处；<br><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230212223224461.png" alt="image-20230212223224461"></p>
</li>
<li><p><strong>小端</strong> 字节序则是指整数的高位字节存储在内存的高地址处，而低位字节则存储在内存的低地址处。</p>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230212223233439.png" alt="image-20230212223233439"></p>
</li>
</ul>
<br>

<p><strong>大部分计算机采用小端序</strong></p>
<br>

<h4 id="检测主机字节序"><a href="#检测主机字节序" class="headerlink" title="检测主机字节序"></a>检测主机字节序</h4><p>利用 union</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过代码检测当前主机的字节序</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 定义联合体</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">short</span> value;    <span class="comment">// 2字节</span></span><br><span class="line">        <span class="type">char</span> bytes[<span class="keyword">sizeof</span>(<span class="type">short</span>)];  <span class="comment">// char[2]</span></span><br><span class="line">    &#125; test;</span><br><span class="line"></span><br><span class="line">    test.value = <span class="number">0x0102</span>;</span><br><span class="line">    <span class="keyword">if</span>((test.bytes[<span class="number">0</span>] == <span class="number">1</span>) &amp;&amp; (test.bytes[<span class="number">1</span>] == <span class="number">2</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;大端字节序\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>((test.bytes[<span class="number">0</span>] == <span class="number">2</span>) &amp;&amp; (test.bytes[<span class="number">1</span>] == <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;小端字节序\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;未知\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<h4 id="字节序转换"><a href="#字节序转换" class="headerlink" title="字节序转换"></a>字节序转换</h4><p>当格式化的数据在两台使用不同字节序的主机之间直接传递时：</p>
<p><strong>发送端总是把要发送的数据转换成大端字节序数据后再发送，</strong>而接收端知道对方传送过来的数据总是采用大端字节序，所以接收端可以根据自身采用的字节序决定是否对接收到的数据进行转换。</p>
<br>

<p><strong>网络字节顺序</strong>：</p>
<p> TCP&#x2F;IP 中规定好的一种数据表示格式，它与具体的 CPU 类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释，<strong>网络字节顺序采用大端排序方式</strong>。</p>
<br>

<p>BSD Socket提供了封装好的转换接口，方便程序员使用。包括</p>
<ul>
<li><p>从主机字节序 到 网络字节序 的转换函数htons、htonl；</p>
</li>
<li><p>从网络字节序到主机字节序的转换函数：ntohs、ntohl。</p>
</li>
</ul>
<br>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	h - host 主机，主机字节序</span></span><br><span class="line"><span class="comment">	to - 转换成什么</span></span><br><span class="line"><span class="comment">	n - network 网络字节序</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	s - short unsigned short	，端口 </span></span><br><span class="line"><span class="comment">	l - long unsigned int	，IP</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 端口	short unsigned short</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">htons</span><span class="params">(<span class="type">uint16_t</span> hostshort)</span>; <span class="comment">// 主机字节序 - 网络字节序</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ntohs</span><span class="params">(<span class="type">uint16_t</span> netshort)</span>; <span class="comment">// 网络字节序 - 主机字节序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IP long unsigned int</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">htonl</span><span class="params">(<span class="type">uint32_t</span> hostlong)</span>; <span class="comment">// 主机字节序 - 网络字节序</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ntohl</span><span class="params">(<span class="type">uint32_t</span> netlong)</span>; <span class="comment">// 网络字节序 - 主机字节序</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><br><br></p>
<br>

<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// htons 转换端口</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> a = <span class="number">0x0102</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a : %x\n&quot;</span>, a);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> b = htons(a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b : %x\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;=======================\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// htonl  转换IP</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">4</span>] = &#123;<span class="number">192</span>, <span class="number">168</span>, <span class="number">1</span>, <span class="number">100</span>&#125;;</span><br><span class="line">    <span class="type">int</span> num = *(<span class="type">int</span> *)buf;  <span class="comment">// 先取数组地址，在对其进行int类型转换，再解引用</span></span><br><span class="line">    <span class="type">int</span> sum = htonl(num);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *p = (<span class="type">char</span> *)&amp;sum;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>, *p, *(p+<span class="number">1</span>), *(p+<span class="number">2</span>), *(p+<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;=======================\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ntohl</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buf1[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">168</span>, <span class="number">192</span>&#125;;</span><br><span class="line">    <span class="type">int</span> num1 = *(<span class="type">int</span> *)buf1;</span><br><span class="line">    <span class="type">int</span> sum1 = ntohl(num1);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *p1 = (<span class="type">unsigned</span> <span class="type">char</span> *)&amp;sum1;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>, *p1, *(p1+<span class="number">1</span>), *(p1+<span class="number">2</span>), *(p1+<span class="number">3</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ntohs</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> c = <span class="number">0x0201</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a : %x\n&quot;</span>, c);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> d = ntohs(c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b : %x\n&quot;</span>, d);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><br><br></p>
<br>

<h3 id="4-1-7-socket-地址"><a href="#4-1-7-socket-地址" class="headerlink" title="4.1.7 socket 地址"></a>4.1.7 socket 地址</h3><p>socket地址其实是一个结构体，封装端口号和IP等信息</p>
<h4 id="通用socket地址"><a href="#通用socket地址" class="headerlink" title="通用socket地址"></a>通用socket地址</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">	<span class="type">sa_family_t</span> sa_family;</span><br><span class="line">	<span class="type">char</span> sa_data[<span class="number">14</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="type">sa_family_t</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<br>

<p><strong>sa_family</strong> 成员是 地址族类型（sa_family_t）的变量。地址族类型通常与协议族类型对应。常见的协议族（protocol family，也称 domain）和对应的地址族入下所示：</p>
<table>
<thead>
<tr>
<th>协议族</th>
<th>地址族</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>PF_UNIX</td>
<td>AF_UNIX</td>
<td>UNIX本地域协议族</td>
</tr>
<tr>
<td>PF_INET</td>
<td>AF_INET</td>
<td>TCP&#x2F;IPv4协议族</td>
</tr>
<tr>
<td>PF_INET6</td>
<td>AF_INET6</td>
<td>TCP&#x2F;IPv6协议族</td>
</tr>
</tbody></table>
<blockquote>
<p>（宏 PF_* 和 AF_* 都定义在 bits&#x2F;socket.h 头文件中，且后者与前者有完全相同的值，所以二者通常混用）</p>
</blockquote>
<br>

<p><strong>sa_data</strong> 成员用于存放 <strong>socket 地址值</strong>。但是，不同的协议族的地址值具有不同的含义和长度，如下所示：</p>
<table>
<thead>
<tr>
<th align="left">协议族</th>
<th>地址值含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">PF_UNIX</td>
<td>文件的路径名，长度可达108字节</td>
</tr>
<tr>
<td align="left">PF_INET</td>
<td>16 bit 端口号 和 32 bit IPv4地址</td>
</tr>
<tr>
<td align="left">PF_INET6</td>
<td>16 bit 端口号，32 bit 流标识，128 bit IPv6 地址，32 bit 范围 ID  （共26字节）</td>
</tr>
</tbody></table>
<br>

<p>由上表可知，14 字节的 sa_data 根本无法容纳多数协议族的地址值。因此，Linux 定义了下面这个<strong>新的通用的 socket 地址结构体，这个结构体不仅提供了足够大的空间用于存放地址值，而且是内存对齐的</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">sa_family_t</span> sa_family;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> __ss_align;</span><br><span class="line">    <span class="comment">//	用来对其内存</span></span><br><span class="line">	<span class="type">char</span> __ss_padding[ <span class="number">128</span> - <span class="keyword">sizeof</span>(__ss_align) ];	<span class="comment">//	具体地址数据</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="type">sa_family_t</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<h4 id="专用socket地址"><a href="#专用socket地址" class="headerlink" title="专用socket地址"></a>专用socket地址</h4><p>很多网络编程函数诞生早于 IPv4 协议，那时候都使用的是 struct sockaddr 结构体，为了向前兼容，现sockaddr 退化成了（void *）的作用，传递一个地址给函数，至于是 sockaddr_in 还是sockaddr_in6，由地址族确定，然后函数内部再强制类型转化为所需的地址类型。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TCP/IP 协议族有 sockaddr_in 和 sockaddr_in6 两个专用的 socket 地址结构体，它们分别用于 IPv4 和 IPv6：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">sa_family_t</span> sin_family;	<span class="comment">// 地址族</span></span><br><span class="line">	<span class="type">in_port_t</span> sin_port; 	<span class="comment">// 端口</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">// IP</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">/* 对其内存用 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> sin_zero[<span class="keyword">sizeof</span> (<span class="keyword">struct</span> sockaddr) - __SOCKADDR_COMMON_SIZE - <span class="keyword">sizeof</span> (<span class="type">in_port_t</span>) - <span class="keyword">sizeof</span> (<span class="keyword">struct</span> in_addr)];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">in_addr_t</span> s_addr;	<span class="comment">//typedef uint32_t in_addr_t;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//	IPv6</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">sa_family_t</span> sin6_family;</span><br><span class="line">	<span class="type">in_port_t</span> sin6_port; <span class="comment">/* Transport layer port # */</span></span><br><span class="line">	<span class="type">uint32_t</span> sin6_flowinfo; <span class="comment">/* IPv6 flow information */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span> <span class="comment">/* IPv6 address */</span></span><br><span class="line">	<span class="type">uint32_t</span> sin6_scope_id; <span class="comment">/* IPv6 scope-id */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">uint16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">uint32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint16_t</span> <span class="type">in_port_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">in_addr_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SOCKADDR_COMMON_SIZE (sizeof (unsigned short int))</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230213070943568.png" alt="image-20230213070943568"></p>
<p><strong>所有专用 socket 地址（以及 sockaddr_storage）类型的变量在实际使用时都需要转化为通用 socket 地址类型 sockaddr（强制转化即可）</strong>，因为所有 socket 编程接口使用的地址参数类型都是 sockaddr</p>
<br>

<br>

<br>

<h3 id="4-1-8-IP地址转换"><a href="#4-1-8-IP地址转换" class="headerlink" title="4.1.8 IP地址转换"></a>4.1.8 IP地址转换</h3><p><strong>点分十进制字符串</strong> 表示的 <strong>IPv4</strong> 地址和用 <strong>网络字节序整数</strong> 表示的 <strong>IPv4</strong> 地址之间的转换：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 地址字符串 转 网络字节序整数</span></span><br><span class="line"><span class="type">in_addr_t</span> <span class="title function_">inet_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 地址字符串 转 网络字节序整数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_aton</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cp, <span class="keyword">struct</span> in_addr *inp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 网络字节序整数 转 地址字符串</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr in)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<p><strong>新版的函数接口</strong>：IPv4，IPv6</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// p:点分十进制的IP字符串，n:表示network，网络字节序的整数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 地址字符串 转 网络字节序整数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span>;</span><br><span class="line">af:地址族： AF_INET AF_INET6</span><br><span class="line">src:需要转换的点分十进制的IP字符串</span><br><span class="line">dst:转换后的结果保存在这个里面</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 网络字节序整数 转 地址字符串</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">char</span> *dst, <span class="type">socklen_t</span> size)</span>;</span><br><span class="line">af:地址族： AF_INET AF_INET6</span><br><span class="line">src: 要转换的ip的整数的地址</span><br><span class="line">dst: 转换成IP地址字符串保存的地方</span><br><span class="line">size：第三个参数的大小（数组的大小）</span><br><span class="line">返回值：返回转换后的数据的地址（字符串），和 dst 是一样的</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<p><strong>案例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个ip字符串,点分十进制的IP地址字符串</span></span><br><span class="line">    <span class="type">char</span> buf[] = <span class="string">&quot;192.168.1.4&quot;</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将点分十进制的IP字符串转换成网络字节序的整数</span></span><br><span class="line">    inet_pton(AF_INET, buf, &amp;num);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> * p = (<span class="type">unsigned</span> <span class="type">char</span> *)&amp;num;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>, *p, *(p+<span class="number">1</span>), *(p+<span class="number">2</span>), *(p+<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将网络字节序的IP整数转换成点分十进制的IP字符串</span></span><br><span class="line">    <span class="type">char</span> ip[<span class="number">16</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> * str =  inet_ntop(AF_INET, &amp;num, ip, <span class="number">16</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str : %s\n&quot;</span>, str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ip : %s\n&quot;</span>, ip);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ip == str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<p><br><br></p>
<br>

<h2 id="4-2-TCP通信"><a href="#4-2-TCP通信" class="headerlink" title="4.2 TCP通信"></a>4.2 TCP通信</h2><blockquote>
<p>UDP于TCP对比</p>
<hr>
<p><strong>UDP</strong>:<br>    <strong>用户数据报</strong> 协议，面向<strong>无连接</strong>，可以<strong>单播，多播，广播</strong>， 面向数据报，不可靠</p>
<p><strong>TCP</strong>:<br>    <strong>传输控制</strong> 协议，面向<strong>连接</strong>的，可靠的，基于<strong>字节流</strong>，仅支持<strong>单播</strong>传输</p>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th align="center">UDP</th>
<th align="center">TCP</th>
</tr>
</thead>
<tbody><tr>
<td>是否创建连接</td>
<td align="center">无连接</td>
<td align="center">面向连接</td>
</tr>
<tr>
<td>是否可靠</td>
<td align="center">不可靠</td>
<td align="center">可靠的</td>
</tr>
<tr>
<td>连接对象个数</td>
<td align="center">一对一、一对多、多对一、多对多</td>
<td align="center">一对一</td>
</tr>
<tr>
<td>传输的方式</td>
<td align="center">面向数据报</td>
<td align="center">面向字节流</td>
</tr>
<tr>
<td>首部开销</td>
<td align="center">8个字节</td>
<td align="center">最少20个字节</td>
</tr>
<tr>
<td>适用场景</td>
<td align="center">实时应用（视频会议，直播）</td>
<td align="center">可靠性高的应用（文件传输）</td>
</tr>
</tbody></table>
<br>

<br>

<h3 id="4-2-1-TCP通信流程"><a href="#4-2-1-TCP通信流程" class="headerlink" title="4.2.1 TCP通信流程"></a>4.2.1 TCP通信流程</h3><p><strong>服务器端</strong> （被动接受连接的角色）</p>
<ol>
<li>创建一个 <strong>用于监听</strong> 的套接字<ul>
<li>监听：监听有客户端的连接</li>
<li>套接字：这个套接字其实就是一个文件描述符</li>
</ul>
</li>
<li>将这个监听文件描述符和本地的IP和端口绑定（IP和端口就是服务器的地址信息）<ul>
<li>客户端连接服务器的时候使用的就是这个IP和端口</li>
</ul>
</li>
<li>设置监听，监听的fd开始工作</li>
<li>阻塞等待，当有客户端发起连接，解除阻塞，接受客户端的连接，会得到一个和客户端通信的套接字（fd）</li>
<li>通信<ul>
<li>接收数据</li>
<li>发送数据</li>
</ul>
</li>
<li>通信结束，断开连接</li>
</ol>
<br>

<p><strong>客户端</strong></p>
<ol>
<li>创建一个用于通信的套接字（fd）</li>
<li>连接服务器，需要指定连接的服务器的 IP 和 端口</li>
<li>连接成功了，客户端可以直接和服务器通信<ul>
<li>接收数据</li>
<li>发送数据</li>
</ul>
</li>
<li>通信结束，断开连接</li>
</ol>
<br>

<blockquote>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230213082358002.png" alt="image-20230213082358002"></p>
</blockquote>
<br>

<br>

<h3 id="4-2-2-Socket函数"><a href="#4-2-2-Socket函数" class="headerlink" title="4.2.2 Socket函数"></a>4.2.2 Socket函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span> <span class="comment">// 包含了这个头文件，上面两个就可以省略</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建套接字</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br><span class="line">	- 功能：创建一个套接字</span><br><span class="line">	- 参数：</span><br><span class="line">		- domain: 协议族</span><br><span class="line">			AF_INET : ipv4</span><br><span class="line">			AF_INET6 : ipv6</span><br><span class="line">			AF_UNIX, AF_LOCAL : 本地套接字通信（进程间通信）</span><br><span class="line">		- type: 通信过程中使用的协议类型</span><br><span class="line">			SOCK_STREAM : 流式协议 TCP</span><br><span class="line">			SOCK_DGRAM : 报式协议  UDP</span><br><span class="line">		- protocol : 具体的一个协议。一般写 <span class="number">0</span></span><br><span class="line">			- SOCK_STREAM : 流式协议默认使用 TCP</span><br><span class="line">			- SOCK_DGRAM : 报式协议默认使用 UDP</span><br><span class="line">	- 返回值：</span><br><span class="line">		- 成功：返回文件描述符，操作的就是内核缓冲区。</span><br><span class="line">		- 失败：<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将IP、端口绑定到套接字</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>; <span class="comment">// socket命名</span></span><br><span class="line">	- 功能：绑定，将 fd 和本地的IP + 端口进行绑定</span><br><span class="line">	- 参数：</span><br><span class="line">		- sockfd : 通过socket函数得到的文件描述符</span><br><span class="line">		- addr : 需要绑定的socket地址，这个地址封装了ip和端口号的信息</span><br><span class="line">		- addrlen : 第二个参数结构体占的内存大小</span><br><span class="line">            </span><br><span class="line"><span class="comment">// 套接字启动监听</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>; <span class="comment">// /proc/sys/net/core/somaxconn</span></span><br><span class="line">	- 功能：监听这个socket上的连接</span><br><span class="line">	- 参数：</span><br><span class="line">		- sockfd : 通过socket()函数得到的文件描述符</span><br><span class="line">		- backlog : 最大连接数， <span class="number">5</span>即可</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line"><span class="comment">// 接收连接，默认是阻塞的</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br><span class="line">	- 功能：接收客户端连接，默认是一个阻塞的函数，阻塞等待客户端连接</span><br><span class="line">	- 参数：</span><br><span class="line">		- sockfd : 用于监听的文件描述符</span><br><span class="line">		- addr : 传出参数，记录了连接成功后客户端的地址信息（ip，port）</span><br><span class="line">		- addrlen : 指定第二个参数的对应的内存大小</span><br><span class="line">	- 返回值：</span><br><span class="line">		- 成功 ：用于通信的文件描述符</span><br><span class="line">		- <span class="number">-1</span> ： 失败</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line"><span class="comment">// 客户端发起连接（参数有点像 bind ）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line">	- 功能： 客户端连接服务器</span><br><span class="line">	- 参数：</span><br><span class="line">		- sockfd : 用于通信的文件描述符</span><br><span class="line">		- addr : 客户端要连接的服务器的地址信息</span><br><span class="line">		- addrlen : 第二个参数的内存大小</span><br><span class="line">	- 返回值：成功 <span class="number">0</span>， 失败 <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>; <span class="comment">// 写数据</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>; <span class="comment">// 读数据</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<br>

<br>

<br>

<h3 id="4-2-3-三次握手"><a href="#4-2-3-三次握手" class="headerlink" title="4.2.3 三次握手"></a>4.2.3 三次握手</h3><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230214004936804.png" alt="image-20230214004936804" style="zoom:80%;">

<br>

<ul>
<li><p>TCP 是一种<strong>面向连接的单播协议</strong>，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的<strong>“连接”</strong>，其实是<strong>客户端和服务器的内存里保存的一份关于对方的信息</strong>，如 IP 地址、端口号等。</p>
</li>
<li><p>TCP 可以看成是一种<strong>字节流</strong>，它会处理 <strong>IP 层或以下的层</strong> 的 <strong>丢包、重复以及错误</strong> 问题。</p>
</li>
<li><p>在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在 TCP 头部。</p>
</li>
<li><p>TCP 提供了一种可靠、面向连接、字节流、传输层的服务，采用 三次握手建立一个连接 。采用 四次挥手来关闭一个连接 。 三次握手的目的是 <strong>保证双方互相之间建立了连接</strong> 。</p>
</li>
<li><p>三次握手发生在客户端连接的时候，当 <strong>调用connect()</strong> ，底层会通过TCP协议进行三次握手。</p>
</li>
</ul>
<br>

<p><strong>TCP 头</strong></p>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230214002211867.png" alt="image-20230214002211867"></p>
<br>

<ul>
<li><strong>16 位端口号</strong>（port number）：告知主机报文段是来自哪里（<strong>源端口</strong>）以及传给哪个上层协议或应用程序（<strong>目的端口</strong>）的。进行 TCP 通信时，客户端通常使用系统自动选择的临时端口号。</li>
<li><strong>32 位序号</strong>（sequence number）：一次 TCP 通信（从 TCP 连接建立到断开）过程中某一个传输方向上的字节流的每个字节的编号。假设主机 A 和主机 B 进行 TCP 通信，A 发送给 B 的第一个TCP 报文段中，序号值被系统初始化为某个随机值 ISN（Initial Sequence Number，初始序号值）。那么在该传输方向上（从 A 到 B），后续的 TCP 报文段中序号值将被系统设置成 ISN 加上该报文段所携带数据的第一个字节在整个字节流中的偏移。例如，某个 TCP 报文段传送的数据是字节流中的第 1025 ~ 2048 字节，那么该报文段的序号值就是 ISN + 1025。另外一个传输方向（从B 到 A）的 TCP 报文段的序号值也具有相同的含义。</li>
<li><strong>32 位确认号</strong>（acknowledgement number）：用作对另一方发送来的 TCP 报文段的响应。其值是收到的 TCP 报文段的序号值 + 标志位长度（SYN，FIN） + 数据长度 。假设主机 A 和主机 B 进行TCP 通信，那么 A 发送出的 TCP 报文段不仅携带自己的序号，而且包含对 B 发送来的 TCP 报文段的确认号。反之，B 发送出的 TCP 报文段也同样携带自己的序号和对 A 发送来的报文段的确认序</li>
<li><strong>4 位头部长度</strong>（head length）：标识该 TCP 头部有多少个 32 bit(4 字节)。因为 4 位最大能表示15，所以 TCP 头部最长是60 字节。</li>
<li><strong>6 位标志位</strong>包含如下几项：<ul>
<li>URG 标志，表示紧急指针（urgent pointer）是否有效。</li>
<li>ACK 标志，表示确认号是否有效。我们称携带 ACK 标志的 TCP 报文段为确认报文段。</li>
<li>PSH 标志，提示接收端应用程序应该立即从 TCP 接收缓冲区中读走数据，为接收后续数据腾出空间（如果应用程序不将接收到的数据读走，它们就会一直停留在 TCP 接收缓冲区中）。</li>
<li>RST 标志，表示要求对方重新建立连接。我们称携带 RST 标志的 TCP 报文段为 <strong>复位</strong> 报文段。</li>
<li>SYN 标志，表示请求建立一个连接。我们称携带 SYN 标志的 TCP 报文段为 <strong>同步</strong> 报文段。</li>
<li>FIN 标志，表示通知对方本端要关闭连接了。我们称携带 FIN 标志的 TCP 报文段为 <strong>结束</strong> 报文段。</li>
</ul>
</li>
<li><strong>16 位窗口大小</strong>（window size）：是 TCP 流量控制的一个手段。这里说的窗口，指的是 <strong>接收通告窗口</strong> （Receiver Window，RWND）。它告诉对方本端的 TCP 接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。</li>
<li><strong>16 位校验和</strong>（TCP checksum）：由发送端填充，接收端对 TCP 报文段执行 CRC 算法以校验TCP 报文段在传输过程中是否损坏。注意，这个校验不仅包括 TCP 头部，也包括数据部分。这也是 TCP 可靠传输的一个重要保障。</li>
<li><strong>16 位紧急指针</strong>（urgent pointer）：是一个正的偏移量。它和序号字段的值相加表示最后一个紧急数据的下一个字节的序号。因此，确切地说，这个字段是紧急指针相对当前序号的偏移，不妨称之为紧急偏移。TCP 的紧急指针是发送端向接收端发送紧急数据的方法。</li>
</ul>
<br>

<p><strong>三次握手</strong></p>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230214004856526.png" alt="image-20230214004856526"></p>
<p><strong>传输数据</strong></p>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230214004912780.png" alt="image-20230214004912780"></p>
<br>

<p><strong>小结</strong></p>
<p>第一次握手：<br>    1.客户端将SYN标志位置为1<br>    2.生成一个随机的32位的序号seq&#x3D;J ， 这个序号后边是可以携带数据（数据的大小）<br>第二次握手：<br>    1.服务器端接收客户端的连接： ACK&#x3D;1<br>    2.服务器会回发一个确认序号： ack &#x3D; 客户端的序号 + 数据长度 + SYN&#x2F;FIN(按一个字节算)<br>    3.服务器端会向客户端发起连接请求： SYN&#x3D;1<br>    4.服务器会生成一个随机序号：seq &#x3D; K<br>第三次握手：<br>    1.客户单应答服务器的连接请求：ACK&#x3D;1<br>    2.客户端回复收到了服务器端的数据：ack&#x3D;服务端的序号 + 数据长度 + SYN&#x2F;FIN(按一个字节算)</p>
<p><br><br></p>
<h3 id="4-2-4-滑动窗口"><a href="#4-2-4-滑动窗口" class="headerlink" title="4.2.4 滑动窗口"></a>4.2.4 滑动窗口</h3><p><strong>滑动窗口</strong>（Sliding window）是一种 <strong>流量控制</strong> 技术。</p>
<blockquote>
<p>早期的网络通信中，通信双方不会考虑网络的拥挤情况直接发送数据。由于大家不知道网络拥塞状况，同时发送数据，导致中间节点阻塞掉包，谁也发不了数据，所以就有了滑动窗口机制来解决此问题。</p>
</blockquote>
<p>滑动窗口协议是用来 <strong>改善吞吐量</strong> 的一种技术，即<strong>容许发送方在接收任何应答之前传送附加的包</strong> 。<strong>接收方告诉发送方在某一时刻能送多少包</strong>（称 <strong>窗口尺寸</strong>）。</p>
<p>TCP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。<strong>发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据</strong>。当滑动窗口为 0 时，发送方一般不能再发送数据报。</p>
<blockquote>
<p>滑动窗口是 TCP 中实现诸如 <strong>ACK 确认</strong>、<strong>流量控制</strong>、<strong>拥塞控制</strong> 的承载结构。</p>
</blockquote>
<br>

<ul>
<li>滑动窗口的大小会随着发送数据和接收数据而变化。</li>
<li>通信的双方都有发送缓冲区和接收数据的缓冲区</li>
</ul>
<br>

<p><strong>图例</strong></p>
<img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230214235843054.png" alt="image-20230214235843054" style="zoom:80%;">

<img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230214235856918.png" alt="image-20230214235856918" style="zoom:80%;">

<br>

<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230215000000336.png" alt="image-20230215000000336"></p>
<blockquote>
<p>mss: Maximum Segment Size(一条数据的最大的数据量)</p>
<p>win: 滑动窗口</p>
</blockquote>
<br>

<br>

<br>

<h3 id="4-2-5-四次挥手"><a href="#4-2-5-四次挥手" class="headerlink" title="4.2.5 四次挥手"></a>4.2.5 四次挥手</h3><ul>
<li>四次挥手发生在断开连接的时候，在程序中当调用了 close() 会使用TCP协议进行四次挥手。 </li>
<li>客户端和服务器端都可以主动发起断开连接，<strong>谁先调用 close() 谁就是发起</strong>。 </li>
<li>因为在TCP连接的时候，采用三次握手建立的的<strong>连接是双向</strong>的，在断开的时候需要<strong>双向断开</strong>。</li>
</ul>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230215010511553.png" alt="image-20230215010511553"></p>
<br>

<img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230215010632884.png" alt="image-20230215010632884" style="zoom:80%;">



<blockquote>
<p>ack &#x3D; 客户端的序号 + 数据长度 + SYN&#x2F;FIN(按一个字节算)</p>
</blockquote>
<br>

<br>

<br>

<br>

<h3 id="4-2-6-TCP状态转换"><a href="#4-2-6-TCP状态转换" class="headerlink" title="4.2.6 TCP状态转换"></a>4.2.6 TCP状态转换</h3><p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230215160143516.png" alt="image-20230215160143516"></p>
<br>

<br>

<p><strong>三次握手</strong></p>
<ul>
<li>客户端 SYN_SENT （发送 SYN ）</li>
<li>服务端 LISTEN -&gt; SYN_RCVD (接收并发送 SYN 和 ACK 回应)</li>
<li>客户端 ESTABLISHED （接收并发送 ACK ）</li>
<li>服务端 ESTABLISHED （接收）</li>
</ul>
<p><strong>数据传输</strong></p>
<ul>
<li>读写</li>
</ul>
<p><strong>四次握手</strong></p>
<ul>
<li>A: FIN_WAIT_1 （发送 FIN ）</li>
<li>B: CLOSE_WAIT （接收并发送 ACK ）</li>
<li>A: FIN_WAIT_2 （接收）</li>
<li>B: LAST_ACK   （发送 FIN ）</li>
<li>A: TIME_WAIT  （接收并发送ACK）</li>
<li>B: （接收）</li>
</ul>
<br>

<br>

<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230215161044162.png" alt="image-20230215161044162"></p>
<ul>
<li>红色当作客户端</li>
<li>绿色虚线当作服务端</li>
<li>黑色是异常</li>
</ul>
<blockquote>
<ul>
<li>四次握手中，前两次握手完成后，中间还可以继续通信一段时间，再去完成第三第四次握手。</li>
<li>TIME_WAIT：最后一次握手（主动方发送ACK）之后，无法立即确定对方是否收到ACK，所以要等待一段时间（<strong>两倍报文段寿命</strong>）来确定（如果对方收到了ACK就不会重发FIN）</li>
<li>2MSL 两倍报文段寿命：主动断开连接的一方, 最后进入一个 TIME_WAIT 状态, 这个状态会持续: 2msl。官方建议: 2分钟, 实际是30s</li>
</ul>
</blockquote>
<br>

<br>

<br>

<br>

<h2 id="4-3-并发服务器"><a href="#4-3-并发服务器" class="headerlink" title="4.3 并发服务器"></a>4.3 并发服务器</h2><h3 id="多进程实现"><a href="#多进程实现" class="headerlink" title="多进程实现"></a>多进程实现</h3><blockquote>
<p>要实现TCP通信服务器处理并发的任务，使用多线程或者多进程来解决。 </p>
<p>思路： </p>
<ol>
<li>一个父进程，多个子进程 </li>
<li>父进程负责等待并接受客户端的连接 </li>
<li>子进程：完成通信，接受一个客户端连接，就创建一个子进程用于通信。</li>
</ol>
</blockquote>
<br>

<h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><p>注意看注释</p>
<p><strong>子进程处理数据收发</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">// 不断循环等待客户端连接</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">        <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">        <span class="comment">// 接受连接</span></span><br><span class="line">        <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;len);</span><br><span class="line">        <span class="keyword">if</span>(cfd == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">==================================================================</span><br><span class="line">        <span class="comment">// 每一个连接进来，创建一个子进程跟客户端通信</span></span><br><span class="line">        <span class="type">pid_t</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 子进程</span></span><br><span class="line">            <span class="comment">// 获取客户端的信息</span></span><br><span class="line">            <span class="type">char</span> cliIp[<span class="number">16</span>];</span><br><span class="line">            inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, cliIp, <span class="keyword">sizeof</span>(cliIp));</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">short</span> cliPort = ntohs(cliaddr.sin_port);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client ip is : %s, prot is %d\n&quot;</span>, cliIp, cliPort);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 接收客户端发来的数据</span></span><br><span class="line">            <span class="type">char</span> recvBuf[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">int</span> len = read(cfd, &amp;recvBuf, <span class="keyword">sizeof</span>(recvBuf));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;recv client : %s\n&quot;</span>, recvBuf);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client closed....\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 回声服务器</span></span><br><span class="line">                write(cfd, recvBuf, <span class="built_in">strlen</span>(recvBuf) + <span class="number">1</span>);  <span class="comment">// 加1的目的是加上结束符</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            close(cfd);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);    <span class="comment">// 退出当前子进程</span></span><br><span class="line">        &#125;</span><br><span class="line">===================================================================</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<p><strong>利用信号来回收子进程资源</strong></p>
<p>注册信号 ( SIGCHLD )</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">   act.sa_flags = <span class="number">0</span>;</span><br><span class="line">   sigemptyset(&amp;act.sa_mask);</span><br><span class="line">   act.sa_handler = recyleChild;</span><br><span class="line">   <span class="comment">// 注册信号捕捉</span></span><br><span class="line">   sigaction(SIGCHLD, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<p>回调函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">recyleChild</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> ret = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="comment">// 所有的子进程都回收了</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 还有子进程活着</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 被回收了</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;子进程 %d 被回收了\n&quot;</span>, ret);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<br>

<br>

<p><strong>完整</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">recyleChild</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> ret = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="comment">// 所有的子进程都回收了</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 还有子进程活着</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 被回收了</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;子进程 %d 被回收了\n&quot;</span>, ret);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    act.sa_handler = recyleChild;</span><br><span class="line">    <span class="comment">// 注册信号捕捉</span></span><br><span class="line">    sigaction(SIGCHLD, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    <span class="type">int</span> ret = bind(lfd,(<span class="keyword">struct</span> sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不断循环等待客户端连接</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">        <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">        <span class="comment">// 接受连接</span></span><br><span class="line">        <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;len);</span><br><span class="line">        <span class="keyword">if</span>(cfd == <span class="number">-1</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;           <span class="comment">// 子进程的信号引发了软中断后，父进程中的accept会失败并设置错误号 EINTR，这时候不能让父进程（监听连接）退出</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每一个连接进来，创建一个子进程跟客户端通信</span></span><br><span class="line">        <span class="type">pid_t</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 子进程</span></span><br><span class="line">            <span class="comment">// 获取客户端的信息</span></span><br><span class="line">            <span class="type">char</span> cliIp[<span class="number">16</span>];</span><br><span class="line">            inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, cliIp, <span class="keyword">sizeof</span>(cliIp));</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">short</span> cliPort = ntohs(cliaddr.sin_port);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client ip is : %s, prot is %d\n&quot;</span>, cliIp, cliPort);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 接收客户端发来的数据</span></span><br><span class="line">            <span class="type">char</span> recvBuf[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">int</span> len = read(cfd, &amp;recvBuf, <span class="keyword">sizeof</span>(recvBuf));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;recv client : %s\n&quot;</span>, recvBuf);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client closed....\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                write(cfd, recvBuf, <span class="built_in">strlen</span>(recvBuf) + <span class="number">1</span>);  <span class="comment">// 加1的目的是加上结束符</span></span><br><span class="line">            &#125;</span><br><span class="line">            close(cfd);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);    <span class="comment">// 退出当前子进程</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<br>

<p><br><br></p>
<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TCP通信的客户端</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建套接字</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.连接服务器端</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span>;</span></span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;192.168.193.128&quot;</span>, &amp;serveraddr.sin_addr.s_addr);</span><br><span class="line">    serveraddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    <span class="type">int</span> ret = connect(fd, (<span class="keyword">struct</span> sockaddr *)&amp;serveraddr, <span class="keyword">sizeof</span>(serveraddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 通信</span></span><br><span class="line">    <span class="type">char</span> recvBuf[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">sprintf</span>(recvBuf, <span class="string">&quot;data : %d\n&quot;</span>, i++);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 给服务器端发送数据</span></span><br><span class="line">        write(fd, recvBuf, <span class="built_in">strlen</span>(recvBuf)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> len = read(fd, recvBuf, <span class="keyword">sizeof</span>(recvBuf));</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv server : %s\n&quot;</span>, recvBuf);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 表示服务器端断开连接</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;server closed...&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭连接</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<p><strong>注意</strong>：</p>
<p>如果客户端或者服务端进程提前终止，没有调用close(fd)，那么后续的数据传输会引发错误</p>
<p>比如</p>
<br>

<br>

<br>

<br>

<h3 id="多线程实现"><a href="#多线程实现" class="headerlink" title="多线程实现"></a>多线程实现</h3><p><strong>服务端</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockInfo</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> fd; <span class="comment">// 通信的文件描述符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;  <span class="comment">// 线程号</span></span><br><span class="line">    <span class="type">int</span> pos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockInfo</span> <span class="title">sockinfos</span>[128];</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">working</span><span class="params">(<span class="type">void</span> * arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 子线程和客户端通信   cfd 客户端的信息 线程号</span></span><br><span class="line">    <span class="comment">// 获取客户端的信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockInfo</span> * <span class="title">pinfo</span> =</span> (<span class="keyword">struct</span> sockInfo *)arg;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> cliIp[<span class="number">16</span>];</span><br><span class="line">    inet_ntop(AF_INET, &amp;pinfo-&gt;addr.sin_addr.s_addr, cliIp, <span class="keyword">sizeof</span>(cliIp));</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> cliPort = ntohs(pinfo-&gt;addr.sin_port);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client ip is : %s, prot is %d\n&quot;</span>, cliIp, cliPort);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收客户端发来的数据</span></span><br><span class="line">    <span class="type">char</span> recvBuf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> len = read(pinfo-&gt;fd, &amp;recvBuf, <span class="keyword">sizeof</span>(recvBuf));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv client : %s\n&quot;</span>, recvBuf);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client closed....\n&quot;</span>);</span><br><span class="line">            sockinfos[pinfo-&gt;pos].fd = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        write(pinfo-&gt;fd, recvBuf, <span class="built_in">strlen</span>(recvBuf) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(pinfo-&gt;fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    <span class="type">int</span> ret = bind(lfd,(<span class="keyword">struct</span> sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化数据</span></span><br><span class="line">    <span class="type">int</span> max = <span class="keyword">sizeof</span>(sockinfos) / <span class="keyword">sizeof</span>(sockinfos[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">        bzero(&amp;sockinfos[i], <span class="keyword">sizeof</span>(sockinfos[i]));</span><br><span class="line">        sockinfos[i].fd = <span class="number">-1</span>;</span><br><span class="line">        sockinfos[i].tid = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环等待客户端连接，一旦一个客户端连接进来，就创建一个子线程进行通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">        <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">        <span class="comment">// 接受连接</span></span><br><span class="line">        <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;len);</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockInfo</span> * <span class="title">pinfo</span>;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">            <span class="comment">// 从这个数组中找到一个可以用的sockInfo元素</span></span><br><span class="line">            <span class="keyword">if</span>(sockinfos[i].fd == <span class="number">-1</span>) &#123;</span><br><span class="line">                pinfo = &amp;sockinfos[i];</span><br><span class="line">                pinfo-&gt;pos = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i == max - <span class="number">1</span>) &#123;</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">                i = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pinfo-&gt;fd = cfd;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;pinfo-&gt;addr, &amp;cliaddr, len);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建子线程</span></span><br><span class="line">        pthread_create(&amp;pinfo-&gt;tid, <span class="literal">NULL</span>, working, pinfo);</span><br><span class="line"></span><br><span class="line">        pthread_detach(pinfo-&gt;tid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<br>

<p><br><br></p>
<br>

<br>

<p><br><br></p>
<br>

<br>

<h2 id="4-4-复用"><a href="#4-4-复用" class="headerlink" title="4.4 复用"></a>4.4 复用</h2><h3 id="4-4-1-半关闭、端口复用、IO多路复用"><a href="#4-4-1-半关闭、端口复用、IO多路复用" class="headerlink" title="4.4.1 半关闭、端口复用、IO多路复用"></a>4.4.1 半关闭、端口复用、IO多路复用</h3><h4 id="半关闭"><a href="#半关闭" class="headerlink" title="半关闭"></a>半关闭</h4><ul>
<li><strong>主动关闭方</strong> 从发送 FIN 并收到 ACK 后，到收到对方的 FIN 之前，处于 <strong>半关闭</strong> 状态。</li>
<li>此时还可以接收对方发送的数据，但不能够再向对方发送数据。</li>
</ul>
<br>

<p>半关闭不使用 close 实现，而是使用 shutdown ：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shutdown</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> how)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//	sockfd: 需要关闭的socket的描述符</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//	how: 允许为shutdown操作选择以下几种方式:</span></span><br><span class="line"><span class="comment">//		- SHUT_RD(0): 关闭sockfd上的 读 功能，此选项将不允许sockfd进行读操作。该套接字不再接收数据，任何当前在套接字接受缓冲区的数据将被无声的丢弃掉。</span></span><br><span class="line"><span class="comment">//		- SHUT_WR(1): 关闭sockfd的 写 功能，此选项将不允许sockfd进行写操作。进程不能对此套接字发出写操作。</span></span><br><span class="line"><span class="comment">//		- SHUT_RDWR(2): 关闭sockfd的读写功能。相当于调用shutdown两次：首先是以SHUT_RD,然后以SHUT_WR。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>close 中止一个连接，但它只是<strong>减少描述符的引用计数</strong>，并不直接关闭连接，只有<strong>当描述符的引用计数为 0 时才关闭连接</strong>。</li>
<li>shutdown 不考虑描述符的引用计数，<strong>直接关闭描述符</strong>。也<strong>可选择中止一个方向的连接</strong>，只中止读或只中止写。</li>
</ul>
<blockquote>
<p><strong>注意:</strong></p>
<ul>
<li>如果有多个进程共享一个套接字，close 每被调用一次，计数减 1 ，直到计数为 0 时，也就是所用进程都调用了 close，套接字将被释放。</li>
<li>在多进程中如果一个进程调用了 shutdown(sfd, SHUT_RDWR) 后，其它的进程将无法进行通信。<u>但如果一个进程 close(sfd) 将不会影响到其它进程。</u></li>
</ul>
</blockquote>
<br>

<br>

<h4 id="端口复用"><a href="#端口复用" class="headerlink" title="端口复用"></a>端口复用</h4><p>最常用的用途:</p>
<ul>
<li>防止服务器重启时之前绑定的端口还未释放</li>
<li>程序突然退出而系统没有释放端口</li>
</ul>
<blockquote>
<p>常看网络相关信息的命令:<code>netstat</code><br>参数：<br>    -a 所有的socket<br>    -p 显示正在使用socket的程序的名称<br>    -n 直接使用IP地址，而不通过域名服务器</p>
<p>​	…</p>
</blockquote>
<br>

<p><strong>setsockopt函数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置套接字的属性（不仅仅能设置端口复用）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">const</span> <span class="type">void</span> *optval, <span class="type">socklen_t</span> optlen)</span>;</span><br><span class="line">	参数（在UNP（Unix网络编程）书籍中使用）：</span><br><span class="line">		- sockfd : 要操作的文件描述符</span><br><span class="line">		- level : 级别 SOL_SOCKET (使用端口复用的级别)</span><br><span class="line">		- optname : 选项的名称</span><br><span class="line">			- SO_REUSEADDR	IP重用</span><br><span class="line">			- SO_REUSEPORT	端口复用</span><br><span class="line">		- optval : 端口复用的值（整型）</span><br><span class="line">			- <span class="number">1</span> : 可以复用</span><br><span class="line">			- <span class="number">0</span> : 不可以复用</span><br><span class="line">		- optlen : optval参数的大小</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line"><span class="comment">// 端口复用，设置的时机是在服务器绑定端口之前</span></span><br><span class="line">	setsockopt();</span><br><span class="line"></span><br><span class="line">	bind();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<br>

<h4 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h4><p>又称 <strong>IO多路转接</strong></p>
<ul>
<li>不是传统意义上的文件IO，而是对套接字读写缓冲区的IO管理</li>
<li>I&#x2F;O 多路复用使得程序能 <strong>同时监听多个文件描述符</strong> ，能够提高程序的性能，Linux 下实现 I&#x2F;O 多路复用的系统调用主要有 <strong>select、poll 和 epoll</strong>。</li>
</ul>
<br>

<p><strong>等待模型</strong></p>
<ol>
<li><strong>阻塞等待</strong>（阻塞IO模型即 <strong>BIO模型</strong> ）</li>
</ol>
<p>优点：不占用CPU宝贵的时间片</p>
<p>缺点：<br>    同一时刻只能处理一个操作，效率低（单进程&#x2F;单线程）<br>    线程或进程的创建消耗系统资源，调度消耗CPU资源（多线程&#x2F;多进程）</p>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230215175146862.png" alt="image-20230215175146862"></p>
<br>

<ol start="2">
<li><strong>非阻塞</strong>，<strong>忙轮询</strong>（非阻塞模型即 <strong>NIO模型</strong> ）</li>
</ol>
<p>优点：提高了程序的执行效率</p>
<p>缺点：占有更多的CPU和系统资源</p>
<p>使用 <strong>IO多路复用</strong>（select，poll，epoll） 来解决这里的缺点,</p>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230215175852729.png" alt="image-20230215175852729"></p>
<br>

<br>

<ul>
<li>第一种IO多路复用技术（select&#x2F;poll）<br><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230215180146018.png" alt="image-20230215180146018"></li>
<li>第二种IO多路复用技术（epoll）<br><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230215180630626.png" alt="image-20230215180630626"></li>
</ul>
<br>

<br>

<br>

<h3 id="4-4-2-Select"><a href="#4-4-2-Select" class="headerlink" title="4.4.2 Select"></a>4.4.2 Select</h3><p><strong>主要思路：</strong></p>
<ol>
<li>首先要构造一个<strong>关于文件描述符的列表</strong>，将要监听的文件描述符添加到该列表中。</li>
<li>调用一个系统函数（即select），<strong>监听该列表中的文件描述符</strong>，<u>直到这些描述符中的一个或者多个进行I&#x2F;O操作时，该函数才返回</u>。<ul>
<li>这个函数是<strong>阻塞的</strong></li>
<li>函数对文件描述符的检测的操作是由<strong>内核完成的</strong></li>
</ul>
</li>
<li>在返回时，它会告诉进程<strong>有多少（哪些）描述符</strong>要进行I&#x2F;O操作。</li>
</ol>
<br>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">fd_set 就是文件描述符的 位集，用 位 来表示各个描述符的状态</span><br><span class="line"><span class="comment">// sizeof(fd_set) = 128个字节 1024位</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 委托内核监听列表中的文件描述符</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span>;</span><br><span class="line">	- 参数：</span><br><span class="line">		- nfds : 委托内核检测的最大文件描述符的值 + <span class="number">1</span></span><br><span class="line">		- readfds : 要检测的文件描述符的读的集合，委托内核检测哪些文件描述符的读的属性</span><br><span class="line">			- 一般检测读操作</span><br><span class="line">			- 对应的是对方发送过来的数据，因为读是被动的接收数据，检测的就是读缓冲区</span><br><span class="line">            - 是一个 传入传出参数</span><br><span class="line">		- writefds : 要检测的文件描述符的写的集合，委托内核检测哪些文件描述符的写的属性</span><br><span class="line">			- 委托内核检测写缓冲区是不是还可以写数据（不满的就可以写）</span><br><span class="line">		- exceptfds : 检测发生异常的文件描述符的集合</span><br><span class="line">		- timeout : 设置的超时时间</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">				<span class="type">long</span> tv_sec; <span class="comment">/* seconds */</span></span><br><span class="line">				<span class="type">long</span> tv_usec; <span class="comment">/* microseconds */</span></span><br><span class="line">			&#125;;</span><br><span class="line">			- <span class="literal">NULL</span> : 永久阻塞，直到检测到了文件描述符有变化</span><br><span class="line">			- tv_sec = <span class="number">0</span> tv_usec = <span class="number">0</span>， 不阻塞</span><br><span class="line">			- tv_sec &gt; <span class="number">0</span> tv_usec &gt; <span class="number">0</span>， 阻塞对应的时间</span><br><span class="line">	- 返回值 :</span><br><span class="line">		- <span class="number">-1</span> : 失败</span><br><span class="line">		- &gt;<span class="number">0</span>(n) : 检测的集合中有n个文件描述符发生了变化</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">对位集合的操作         </span><br><span class="line"><span class="comment">// 将参数文件描述符fd对应的标志位设置为0（clear）</span></span><br><span class="line"><span class="type">void</span> FD_CLR(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将参数文件描述符fd 对应的标志位，设置为1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fd_set一共有1024 bit, 全部初始化为0</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断fd对应的标志位是0还是1， 返回值 ： fd对应的标志位的值，如果是0返回0， 是1返回1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<br>

<br>

<p><strong>Select 工作流程</strong></p>
<img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230215204459693.png" alt="image-20230215204459693" style="zoom: 67%;">



<img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230215204514747.png" alt="image-20230215204514747" style="zoom: 67%;">

<img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230215220639318.png" alt="image-20230215220639318" style="zoom:80%;">

<br>

<p><strong>服务端</strong></p>
<ul>
<li>accept之前先设置好fdset并调用select</li>
<li>如果select检测出数据变动：<ul>
<li>如果是服务端的socketfd有变动，则表示有客户端连接可进行accept</li>
<li>然后再for循环文件描述符列表进行读写处理（如果需要的话）</li>
</ul>
</li>
<li>fdset用到两个，一个用来给select调用，一个用来维护文件描述符列表</li>
<li>注意需要维护一个最大文件描述符</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    bind(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    listen(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个fd_set的集合，存放的是需要检测的文件描述符</span></span><br><span class="line">    fd_set rdset, tmp;	<span class="comment">// tmp用来给内核检测，rdset用来维护存在的文件描述符</span></span><br><span class="line">    FD_ZERO(&amp;rdset);</span><br><span class="line">    FD_SET(lfd, &amp;rdset);  <span class="comment">// select调用前rdset的某位fd为1表示我们希望内核帮我们检测该fd对应的接收缓存。select调用后rdset对应的fd为1表示该接收缓存接收到数据了，为0表示没接收到数据</span></span><br><span class="line">    <span class="type">int</span> maxfd = lfd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        tmp = rdset;  <span class="comment">// 这里要记得</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用select系统函数，让内核帮检测哪些文件描述符有数据</span></span><br><span class="line">        <span class="type">int</span> ret = select(maxfd + <span class="number">1</span>, &amp;tmp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;select&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 说明检测到了有文件描述符的对应的缓冲区的数据发生了改变</span></span><br><span class="line">            <span class="keyword">if</span>(FD_ISSET(lfd, &amp;tmp)) &#123;</span><br><span class="line">                <span class="comment">// 表示有新的客户端连接进来了</span></span><br><span class="line">                <span class="keyword">struct</span> sockaddr_in cliaddr;</span><br><span class="line">                <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">                <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;cliaddr, &amp;len);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将新的文件描述符加入到集合中</span></span><br><span class="line">                FD_SET(cfd, &amp;rdset);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 更新最大的文件描述符</span></span><br><span class="line">                maxfd = maxfd &gt; cfd ? maxfd : cfd;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = lfd + <span class="number">1</span>; i &lt;= maxfd; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(FD_ISSET(i, &amp;tmp)) &#123;</span><br><span class="line">                    <span class="comment">// 说明这个文件描述符对应的客户端发来了数据</span></span><br><span class="line">                    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                    <span class="type">int</span> len = read(i, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                    <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">                        perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;client closed...\n&quot;</span>);</span><br><span class="line">                        close(i);</span><br><span class="line">                        FD_CLR(i, &amp;rdset);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, buf);</span><br><span class="line">                        write(i, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<p><strong>客户端</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> fd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">seraddr</span>;</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;seraddr.sin_addr.s_addr);</span><br><span class="line">    seraddr.sin_family = AF_INET;</span><br><span class="line">    seraddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接服务器</span></span><br><span class="line">    <span class="type">int</span> ret = connect(fd, (<span class="keyword">struct</span> sockaddr *)&amp;seraddr, <span class="keyword">sizeof</span>(seraddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">char</span> sendBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">sprintf</span>(sendBuf, <span class="string">&quot;send data %d&quot;</span>, num++);</span><br><span class="line">        write(fd, sendBuf, <span class="built_in">strlen</span>(sendBuf) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收</span></span><br><span class="line">        <span class="type">int</span> len = read(fd, sendBuf, <span class="keyword">sizeof</span>(sendBuf));</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, sendBuf);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;服务器已经断开连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// sleep(1);</span></span><br><span class="line">        usleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<br>

<br>

<p><strong>Select 的缺点</strong></p>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230215221709493.png" alt="image-20230215221709493"></p>
<br>

<br>

<br>

<h3 id="4-4-3-poll"><a href="#4-4-3-poll" class="headerlink" title="4.4.3 poll"></a>4.4.3 poll</h3><p>select的改进版</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> fd; <span class="comment">/* 委托内核检测的文件描述符 */</span></span><br><span class="line">	<span class="type">short</span> events; <span class="comment">/* 委托内核检测文件描述符的什么事件 */</span></span><br><span class="line">	<span class="type">short</span> revents; <span class="comment">/* 文件描述符实际发生的事件 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">myfd</span>;</span></span><br><span class="line">	myfd.fd = <span class="number">5</span>;</span><br><span class="line">    myfd.events = POLLIN | POLLOUT;  同时委托内核进行读写操作</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span>;</span><br><span class="line">	- 参数：</span><br><span class="line">		- fds : 是一个<span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> 结构体数组，这是一个需要检测的文件描述符的集合</span></span><br><span class="line"><span class="class">		- <span class="title">nfds</span> :</span> 这个是第一个参数数组中最后一个有效元素的下标 + <span class="number">1</span></span><br><span class="line">		- timeout : 阻塞时长</span><br><span class="line">			<span class="number">0</span> : 不阻塞</span><br><span class="line">			<span class="number">-1</span> : 阻塞，当检测到需要检测的文件描述符有变化，解除阻塞</span><br><span class="line">			&gt;<span class="number">0</span> : 阻塞的时长</span><br><span class="line">	- 返回值：</span><br><span class="line">		<span class="number">-1</span> : 失败</span><br><span class="line">		&gt;<span class="number">0</span>（n） : 成功，n表示检测到集合中有n个文件描述符发生变化</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<p>short类型，表示发生事件</p>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230215224613996.png" alt="image-20230215224613996"></p>
<br>

<p><strong>服务端</strong></p>
<ul>
<li><p>在到客户端连接时，在accept之后要在pollfd数组中找一个靠前的位置来记录；</p>
</li>
<li><p>其他的跟select类似。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    bind(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    listen(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化检测的文件描述符数组</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>[1024];</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++) &#123;</span><br><span class="line">        fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">        fds[i].events = POLLIN;</span><br><span class="line">    &#125;</span><br><span class="line">    fds[<span class="number">0</span>].fd = lfd;</span><br><span class="line">    <span class="type">int</span> nfds = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用poll系统函数，让内核帮检测哪些文件描述符有数据</span></span><br><span class="line">        <span class="type">int</span> ret = poll(fds, nfds + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;poll&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 说明检测到了有文件描述符的对应的缓冲区的数据发生了改变</span></span><br><span class="line">            <span class="keyword">if</span>(fds[<span class="number">0</span>].revents &amp; POLLIN) &#123;</span><br><span class="line">                <span class="comment">// 表示有新的客户端连接进来了</span></span><br><span class="line">                <span class="keyword">struct</span> sockaddr_in cliaddr;</span><br><span class="line">                <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">                <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;cliaddr, &amp;len);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将新的文件描述符加入到集合中</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1024</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(fds[i].fd == <span class="number">-1</span>) &#123;</span><br><span class="line">                        fds[i].fd = cfd;</span><br><span class="line">                        fds[i].events = POLLIN;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 更新最大的文件描述符的索引</span></span><br><span class="line">                nfds = nfds &gt; cfd ? nfds : cfd;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">			<span class="comment">// 最大的文件描述符 一定 大于等于它在数组中的下标。</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= nfds; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(fds[i].revents &amp; POLLIN) &#123;</span><br><span class="line">                    <span class="comment">// 说明这个文件描述符对应的客户端发来了数据</span></span><br><span class="line">                    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                    <span class="type">int</span> len = read(fds[i].fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                    <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">                        perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;client closed...\n&quot;</span>);</span><br><span class="line">                        close(fds[i].fd);</span><br><span class="line">                        fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, buf);</span><br><span class="line">                        write(fds[i].fd, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>





<br>

<br>

<br>

<h3 id="4-4-4-epoll"><a href="#4-4-4-epoll" class="headerlink" title="4.4.4 epoll"></a>4.4.4 epoll</h3><p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230215225908336.png" alt="image-20230215225908336"></p>
<ol>
<li>不用从用户态拷贝数据到内核，直接在内核中进行实例化和数据处理</li>
<li>采用了更高效的数据结构<ul>
<li>红黑树：存储所有fd，用来遍历检测哪些发生数据改变</li>
<li>双向链表：存放发生数据改变的fd的就绪列表</li>
</ul>
</li>
</ol>
<br>

<br>

<br>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新的epoll实例。在内核中创建了一个数据，这个数据中有两个比较重要的数据，一个是需要检测的文件描述符的信息（红黑树），还有一个是就绪列表，存放检测到数据发送改变的文件描述符信息（双向链表）。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br><span class="line">	- 参数：</span><br><span class="line">		size : 目前没有意义了。随便写一个数，必须大于<span class="number">0</span></span><br><span class="line">	- 返回值：</span><br><span class="line">		<span class="number">-1</span> : 失败</span><br><span class="line">		&gt; <span class="number">0</span> : 文件描述符，操作epoll实例的fd</span><br><span class="line">         </span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">	<span class="type">uint32_t</span> events; <span class="comment">/* Epoll events */</span></span><br><span class="line">	<span class="type">epoll_data_t</span> data; <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br><span class="line">常见的Epoll检测事件：</span><br><span class="line">	- EPOLLIN</span><br><span class="line">	- EPOLLOUT</span><br><span class="line">	- EPOLLERR</span><br><span class="line">	- EPOLLET  <span class="comment">// 边沿触发</span></span><br><span class="line">  	- ...</span><br><span class="line">    	</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span>	<span class="comment">// 是一个union</span></span><br><span class="line">	<span class="type">void</span> *ptr;</span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	<span class="type">uint32_t</span> u32;</span><br><span class="line">	<span class="type">uint64_t</span> u64;</span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 对epoll实例进行管理：添加文件描述符信息，删除信息，修改信息</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>;</span><br><span class="line">	- 参数：</span><br><span class="line">		- epfd : epoll实例对应的文件描述符</span><br><span class="line">		- op : 要进行什么操作</span><br><span class="line">			EPOLL_CTL_ADD: 添加</span><br><span class="line">			EPOLL_CTL_MOD: 修改</span><br><span class="line">			EPOLL_CTL_DEL: 删除</span><br><span class="line">		- fd : 要检测的文件描述符</span><br><span class="line">		- event : 检测文件描述符什么事情</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line"><span class="comment">// 检测函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br><span class="line">	- 参数：</span><br><span class="line">		- epfd : epoll实例对应的文件描述符</span><br><span class="line">		- events : 传出参数，一个epoll_event数组，保存了发生了变化的文件描述符</span><br><span class="line">		- maxevents : 第二个参数结构体数组的大小</span><br><span class="line">		- timeout : 阻塞时间</span><br><span class="line">			- <span class="number">0</span> : 不阻塞</span><br><span class="line">			- <span class="number">-1</span> : 阻塞，直到检测到fd数据发生变化，解除阻塞</span><br><span class="line">			- &gt; <span class="number">0</span> : 阻塞的时长（毫秒）</span><br><span class="line">	- 返回值：</span><br><span class="line">		- 成功，返回发送变化的文件描述符的个数 &gt; <span class="number">0</span></span><br><span class="line">		- 失败 <span class="number">-1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<br>

<p><strong>服务端</strong></p>
<p>根据监听读还是写事件来编写对应的处理</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    bind(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    listen(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用epoll_create()创建一个epoll实例</span></span><br><span class="line">    <span class="type">int</span> epfd = epoll_create(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将监听的文件描述符相关的检测信息添加到epoll实例中</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epev</span>;</span></span><br><span class="line">    epev.events = EPOLLIN;</span><br><span class="line">    epev.data.fd = lfd;</span><br><span class="line">    epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;epev);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epevs</span>[1024];</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ret = epoll_wait(epfd, epevs, <span class="number">1024</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>, ret);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; ret; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> curfd = epevs[i].data.fd;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(curfd == lfd) &#123;</span><br><span class="line">                <span class="comment">// 监听的文件描述符有数据达到，有客户端连接</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">                <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">                <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;cliaddr, &amp;len);</span><br><span class="line">				</span><br><span class="line">                <span class="comment">// 将客户端文件描述符相关的检测信息添加到epoll实例中</span></span><br><span class="line">                epev.events = EPOLLIN;</span><br><span class="line">                epev.data.fd = cfd;</span><br><span class="line">                epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;epev);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(epevs[i].events &amp; EPOLLOUT) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;   </span><br><span class="line">                <span class="comment">// 有数据到达，需要通信</span></span><br><span class="line">                <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="type">int</span> len = read(curfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client closed...\n&quot;</span>);</span><br><span class="line">                    epoll_ctl(epfd, EPOLL_CTL_DEL, curfd, <span class="literal">NULL</span>);</span><br><span class="line">                    close(curfd);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, buf);</span><br><span class="line">                    write(curfd, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(lfd);</span><br><span class="line">    close(epfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<br>

<h4 id="epoll-两种工作模式"><a href="#epoll-两种工作模式" class="headerlink" title="epoll 两种工作模式"></a>epoll 两种工作模式</h4><br>

<ul>
<li><strong>LT</strong> 模式（<strong>水平触发</strong>）<ul>
<li>假设委托内核检测读事件 -&gt; 检测fd的读缓冲区</li>
<li>读缓冲区有数据 -&gt; epoll检测到了会给用户通知<ul>
<li>用户不读数据，数据会一直在缓冲区，epoll会一直通知</li>
<li>用户只读了一部分数据，epoll会通知</li>
<li>用户读完数据，epoll不通知</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>能否一次读完得看缓冲区大小和每次读取的数量</p>
<blockquote>
<p>LT（level - triggered）是缺省（即默认）的工作方式，并且同时支持 <strong>block 和 no-block socket</strong>。在这种做法中，<strong>内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的 fd 进行 IO 操作</strong>。如果你不作任何操作，<strong>内核还是会继续通知你的</strong>。</p>
</blockquote>
<br>

<ul>
<li><strong>ET</strong> 模式（<strong>边缘触发</strong>）<ul>
<li>假设委托内核检测读事件 -&gt; 检测fd的读缓冲区</li>
<li>读缓冲区有数据 -&gt; epoll 检测到了会给用户通知<ul>
<li>用户不读数据，数据一致在缓冲区中，epoll下次检测时不通知</li>
<li>用户只读了一部分数据，epoll不通知</li>
<li>用户读完数据，epoll不通知</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li><p>ET（edge - triggered）是高速工作方式，<strong>只支持 no-block socket</strong>。</p>
</li>
<li><p>在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，<strong>直到你做了某些操作导致那个文件描述符不再为就绪状态了</strong>。但是请注意，如果一直不对这个 fd 作 IO 操作（从而导致它再次变成未就绪），内核不会发送更多的通知（only once）。</p>
</li>
<li><p>ET 模式在很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。</p>
</li>
<li><p>epoll工作在 ET 模式的时候，必须使用<strong>非阻塞</strong>套接口，<strong>以避免由于一个文件句柄的阻塞读&#x2F;阻塞写操作把处理多个文件描述符的任务饿死。</strong></p>
</li>
</ul>
</blockquote>
<br>

<br>

<p><strong>客户端</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> fd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">seraddr</span>;</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;seraddr.sin_addr.s_addr);</span><br><span class="line">    seraddr.sin_family = AF_INET;</span><br><span class="line">    seraddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接服务器</span></span><br><span class="line">    <span class="type">int</span> ret = connect(fd, (<span class="keyword">struct</span> sockaddr *)&amp;seraddr, <span class="keyword">sizeof</span>(seraddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">char</span> sendBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">// sprintf(sendBuf, &quot;send data %d&quot;, num++);</span></span><br><span class="line">        fgets(sendBuf, <span class="keyword">sizeof</span>(sendBuf), <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">        write(fd, sendBuf, <span class="built_in">strlen</span>(sendBuf) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收</span></span><br><span class="line">        <span class="type">int</span> len = read(fd, sendBuf, <span class="keyword">sizeof</span>(sendBuf));</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, sendBuf);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;服务器已经断开连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<br>

<p><strong>LT 服务端</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    bind(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    listen(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用epoll_create()创建一个epoll实例</span></span><br><span class="line">    <span class="type">int</span> epfd = epoll_create(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将监听的文件描述符相关的检测信息添加到epoll实例中</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epev</span>;</span></span><br><span class="line">    epev.events = EPOLLIN;</span><br><span class="line">    epev.data.fd = lfd;</span><br><span class="line">    epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;epev);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epevs</span>[1024];</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ret = epoll_wait(epfd, epevs, <span class="number">1024</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>, ret);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; ret; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> curfd = epevs[i].data.fd;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(curfd == lfd) &#123;</span><br><span class="line">                <span class="comment">// 监听的文件描述符有数据达到，有客户端连接</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">                <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">                <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;cliaddr, &amp;len);</span><br><span class="line"></span><br><span class="line">                epev.events = EPOLLIN;</span><br><span class="line">                epev.data.fd = cfd;</span><br><span class="line">                epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;epev);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(epevs[i].events &amp; EPOLLOUT) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;   </span><br><span class="line">                <span class="comment">// 有数据到达，需要通信</span></span><br><span class="line">                <span class="type">char</span> buf[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="type">int</span> len = read(curfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client closed...\n&quot;</span>);</span><br><span class="line">                    epoll_ctl(epfd, EPOLL_CTL_DEL, curfd, <span class="literal">NULL</span>);</span><br><span class="line">                    close(curfd);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, buf);</span><br><span class="line">                    write(curfd, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(lfd);</span><br><span class="line">    close(epfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<br>

<br>

<br>

<p><strong>ET 服务端</strong></p>
<ul>
<li>用fctnl设置连接客户端的文件描述符为非阻塞</li>
<li>设置客户端fd的epoll_event为边缘触发模式</li>
<li>读数据的时候用循环来读完</li>
<li>数据读完之后，在非阻塞的条件下，再去read对应的fd会引发<strong>EAGAIN</strong>，需要用条件判断避开</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    bind(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    listen(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用epoll_create()创建一个epoll实例</span></span><br><span class="line">    <span class="type">int</span> epfd = epoll_create(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将监听的文件描述符相关的检测信息添加到epoll实例中</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epev</span>;</span></span><br><span class="line">    epev.events = EPOLLIN;</span><br><span class="line">    epev.data.fd = lfd;</span><br><span class="line">    epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;epev);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epevs</span>[1024];</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ret = epoll_wait(epfd, epevs, <span class="number">1024</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>, ret);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; ret; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> curfd = epevs[i].data.fd;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(curfd == lfd) &#123;</span><br><span class="line">                <span class="comment">// 监听的文件描述符有数据达到，有客户端连接</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">                <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">                <span class="type">int</span> cfd = accept(lf d, (<span class="keyword">struct</span> sockaddr *)&amp;cliaddr, &amp;len);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 设置cfd属性非阻塞</span></span><br><span class="line">                <span class="type">int</span> flag = fcntl(cfd, F_GETFL);</span><br><span class="line">                flag |= O_NONBLOCK;</span><br><span class="line">                fcntl(cfd, F_SETFL, flag);</span><br><span class="line"></span><br><span class="line">                epev.events = EPOLLIN | EPOLLET;    <span class="comment">// 设置边沿触发</span></span><br><span class="line">                epev.data.fd = cfd;</span><br><span class="line">                epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;epev);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(epevs[i].events &amp; EPOLLOUT) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;  </span><br><span class="line"></span><br><span class="line">                <span class="comment">// 循环读取出所有数据</span></span><br><span class="line">                <span class="type">char</span> buf[<span class="number">5</span>];</span><br><span class="line">                <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>( (len = read(curfd, buf, <span class="keyword">sizeof</span>(buf))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 打印数据</span></span><br><span class="line">                    <span class="comment">// printf(&quot;recv data : %s\n&quot;, buf);</span></span><br><span class="line">                    write(STDOUT_FILENO, buf, len);</span><br><span class="line">                    write(curfd, buf, len);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client closed....&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(errno == EAGAIN) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;data over.....&quot;</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(lfd);</span><br><span class="line">    close(epfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<br>

<br>

<br>

<h2 id="4-5-UDP通信"><a href="#4-5-UDP通信" class="headerlink" title="4.5 UDP通信"></a>4.5 UDP通信</h2><h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230216011718092.png" alt="image-20230216011718092"></p>
<p><strong>服务端</strong></p>
<ul>
<li>创建socket</li>
<li>绑定ip端口</li>
<li>通信</li>
<li>关闭socket</li>
</ul>
<p><strong>客户端</strong></p>
<ul>
<li>创建socket</li>
<li>通信</li>
<li>关闭socket</li>
</ul>
<br>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line">or</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *dest_addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line">	- 参数：</span><br><span class="line">		- sockfd : 通信的fd</span><br><span class="line">		- buf : 要发送的数据</span><br><span class="line">		- len : 发送数据的长度</span><br><span class="line">		- flags : <span class="number">0</span></span><br><span class="line">		- dest_addr : 传出参数，指定通信的另外一端的地址信息</span><br><span class="line">		- addrlen : 地址的内存大小</span><br><span class="line">           </span><br><span class="line">            </span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags, <span class="keyword">struct</span> sockaddr *src_addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br><span class="line">	- 参数：</span><br><span class="line">		- sockfd : 通信的fd</span><br><span class="line">		- buf : 接收数据的数组</span><br><span class="line">		- len : 数组的大小</span><br><span class="line">    	- flags : <span class="number">0</span></span><br><span class="line">		- src_addr : 传入参数，用来保存另外一端的地址信息，不需要可以指定为<span class="literal">NULL</span></span><br><span class="line">		- addrlen : 地址的内存大小</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<br>

<p><strong>服务端</strong></p>
<p>bind 绑定后不需要监听 listen</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建一个通信的socket</span></span><br><span class="line">    <span class="type">int</span> fd = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.绑定</span></span><br><span class="line">    <span class="type">int</span> ret = bind(fd, (<span class="keyword">struct</span> sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">char</span> recvbuf[<span class="number">128</span>];</span><br><span class="line">        <span class="type">char</span> ipbuf[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">        <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="type">int</span> num = recvfrom(fd, recvbuf, <span class="keyword">sizeof</span>(recvbuf), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;cliaddr, &amp;len);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client IP : %s, Port : %d\n&quot;</span>, </span><br><span class="line">            inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, ipbuf, <span class="keyword">sizeof</span>(ipbuf)),</span><br><span class="line">            ntohs(cliaddr.sin_port));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client say : %s\n&quot;</span>, recvbuf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        sendto(fd, recvbuf, <span class="built_in">strlen</span>(recvbuf) + <span class="number">1</span>, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;cliaddr, <span class="keyword">sizeof</span>(cliaddr));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<br>

<p><strong>客户端</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建一个通信的socket</span></span><br><span class="line">    <span class="type">int</span> fd = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务器的地址信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;saddr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 3.通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        <span class="type">char</span> sendBuf[<span class="number">128</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(sendBuf, <span class="string">&quot;hello , i am client %d \n&quot;</span>, num++);</span><br><span class="line">        sendto(fd, sendBuf, <span class="built_in">strlen</span>(sendBuf) + <span class="number">1</span>, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="type">int</span> num = recvfrom(fd, sendBuf, <span class="keyword">sizeof</span>(sendBuf), <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server say : %s\n&quot;</span>, sendBuf);</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<br>

<br>

<br>

<h3 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h3><p>向 <strong>子网</strong> 中多台计算机发送消息，并且子网中所有的计算机都可以接收到发送方发送的消息，每个广播消息都包含一个特殊的IP地址（<strong>广播地址</strong>），除了子网ip外的主机部分的二进制位都为1。</p>
<ul>
<li>只能在<strong>局域网</strong>中使用。</li>
<li><strong>客户端</strong>需要绑定<strong>服务器广播使用的端口</strong>，才可以接收到广播消息。</li>
</ul>
<br>

<p><strong>服务端</strong></p>
<ul>
<li>用setsockopt设置sockfd的广播属性</li>
<li>然后使用广播地址作为sendto的地址</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.设置广播属性</span></span><br><span class="line"><span class="type">int</span> op = <span class="number">1</span>;</span><br><span class="line">setsockopt(fd, SOL_SOCKET, SO_BROADCAST, &amp;op, <span class="keyword">sizeof</span>(op));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.创建一个广播的地址</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">cliaddr.sin_family = AF_INET;</span><br><span class="line">cliaddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">inet_pton(AF_INET, <span class="string">&quot;192.168.193.255&quot;</span>, &amp;cliaddr.sin_addr.s_addr);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<p><strong>客户端</strong></p>
<ul>
<li>sockfd 需要用 bind 绑定 本地IP和广播的端口</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.客户端绑定本地的IP和端口</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">addr.sin_family = AF_INET;</span><br><span class="line">addr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ret = bind(fd, (<span class="keyword">struct</span> sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<br>

<br>

<br>

<br>

<h3 id="组播-多播"><a href="#组播-多播" class="headerlink" title="组播(多播)"></a>组播(多播)</h3><ul>
<li>单播地址标识单个 IP 接口，广播地址标识某个子网的所有 IP 接口，多播地址标识一组 IP 接口。</li>
<li>单播和广播是寻址方案的两个极端（要么单个要么全部），多播则意在两者之间提供一种折中方案。</li>
<li>多播数据报只应该由对它感兴趣的接口接收，也就是说由<strong>运行相应多播会话应用系统的主机上的接口</strong>接收。</li>
<li>另外，<strong>广播一般局限于局域网内</strong>使用，而多播则既可以用于局域网，也可以跨广域网使用。<ul>
<li><strong>组播</strong>既可以用于<strong>局域网</strong>，也可以用于<strong>广域网</strong></li>
<li><strong>客户端</strong>需要加入<strong>多播组</strong>，才能接收到多播的数据</li>
</ul>
</li>
</ul>
<br>

<br>

<p><strong>组播地址</strong></p>
<p>IP 多播通信必须依赖于 IP 多播地址，在 IPv4 中它的范围从 <strong>224.0.0.0 到 239.255.255.255</strong> ，并被划分为 <strong>局部链接多播地址</strong>、 <strong>预留多播地址</strong> 和 <strong>管理权限多播地址</strong> 三类:</p>
<table>
<thead>
<tr>
<th align="center">IP地址</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">224.0.0.0~224.0.0.255</td>
<td align="center">局部链接多播地址：为路由协议和其他用途保留的地址，路由器并不转发属于此范围的IP包</td>
</tr>
<tr>
<td align="center">224.0.1.0~224.0.1.255</td>
<td align="center">预留多播地址：公用组播地址，可用于Internet；使用前需要申请</td>
</tr>
<tr>
<td align="center">224.0.2.0~238.255.255.255</td>
<td align="center">预留多播地址：用户可用组播地址（临时），全网范围有效</td>
</tr>
<tr>
<td align="center">239.0.0.0~239.255.255.255</td>
<td align="center">本地管理组播地址，可供组织内部使用，类似于私有IP地址，不能用于Internet，可限制多播范围</td>
</tr>
</tbody></table>
<br>

<br>

<p><strong>设置</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname,<span class="type">const</span> <span class="type">void</span> *optval, <span class="type">socklen_t</span> optlen)</span>;</span><br><span class="line">	<span class="comment">// 服务器设置多播的信息，外出接口</span></span><br><span class="line">	- level : IPPROTO_IP</span><br><span class="line">	- optname : IP_MULTICAST_IF</span><br><span class="line">	- optval : <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">	// 客户端加入到多播组：</span></span><br><span class="line"><span class="class">	- <span class="title">level</span> :</span> IPPROTO_IP</span><br><span class="line">	- optname : IP_ADD_MEMBERSHIP</span><br><span class="line">	- optval : <span class="class"><span class="keyword">struct</span> <span class="title">ip_mreq</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">        </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_mreq</span> &#123;</span></span><br><span class="line">	<span class="comment">/* IP multicast address of group. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">imr_multiaddr</span>;</span> <span class="comment">// 组播的IP地址</span></span><br><span class="line">	<span class="comment">/* Local IP address of interface. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">imr_interface</span>;</span> <span class="comment">// 本地的IP地址</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">	<span class="type">in_addr_t</span> s_addr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">in_addr_t</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<p><strong>服务端</strong></p>
<ul>
<li>setsockopt 设置 IPPROTO_IP 级别的 IP_MULTICAST_IF，传入组播的外出接口</li>
<li>将外出接口作为客户端地址信息，作为 sendto 指定的地址</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 2.设置多播的属性，设置外出接口</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">imr_multiaddr</span>;</span></span><br><span class="line"><span class="comment">// 初始化多播地址</span></span><br><span class="line">inet_pton(AF_INET, <span class="string">&quot;239.0.0.10&quot;</span>, &amp;imr_multiaddr.s_addr);</span><br><span class="line">setsockopt(fd, IPPROTO_IP, IP_MULTICAST_IF, &amp;imr_multiaddr, <span class="keyword">sizeof</span>(imr_multiaddr));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.初始化客户端的地址信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">cliaddr.sin_family = AF_INET;</span><br><span class="line">cliaddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">inet_pton(AF_INET, <span class="string">&quot;239.0.0.10&quot;</span>, &amp;cliaddr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通信</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<br>

<p><strong>客户端</strong></p>
<ul>
<li>bind 绑定端口</li>
<li>指定ip_mreq结构体中的本地地址和组播地址</li>
<li>setsockopt设置 IPPROTO_IP 级别的 IP_ADD_MEMBERSHIP ，传入上面（指定地址）的结构体</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">// 2.客户端绑定本地的IP和端口</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">   addr.sin_family = AF_INET;</span><br><span class="line">   addr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">   addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> ret = bind(fd, (<span class="keyword">struct</span> sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">   <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">       perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">       <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加入到多播组</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">ip_mreq</span> <span class="title">op</span>;</span></span><br><span class="line">   inet_pton(AF_INET, <span class="string">&quot;239.0.0.10&quot;</span>, &amp;op.imr_multiaddr.s_addr);</span><br><span class="line">   op.imr_interface.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">   setsockopt(fd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;op, <span class="keyword">sizeof</span>(op));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 3.通信</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<br>

<br>

<p><br><br></p>
<h2 id="4-6-本地套接字通信"><a href="#4-6-本地套接字通信" class="headerlink" title="4.6 本地套接字通信"></a>4.6 本地套接字通信</h2><p>本地套接字的作用：<strong>本地的进程间通信</strong></p>
<p>（本地套接字实现流程和网络套接字类似，一般采用 <strong>TCP 的通信流程</strong>）</p>
<ul>
<li><strong>有关系</strong>的进程间的通信</li>
<li><strong>没有关系</strong>的进程间的通信</li>
</ul>
<br>

<br>

<p><strong>struct sockaddr_un</strong></p>
<img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230216033138989.png" alt="image-20230216033138989" style="zoom:67%;">

<h3 id="通信流程"><a href="#通信流程" class="headerlink" title="通信流程"></a>通信流程</h3><p>本地套接字通信的流程 - tcp</p>
<img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230216033448663.png" alt="image-20230216033448663" style="zoom:80%;">

<p><strong>服务器端</strong></p>
<ol>
<li>创建监听的套接字</li>
</ol>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> lfd = socket(AF_UNIX/AF_LOCAL, SOCK_STREAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>监听的套接字 绑定 <strong>本地的套接字文件</strong> -&gt; server端</li>
</ol>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">addr</span>;</span></span><br><span class="line"><span class="comment">// 绑定成功之后，指定的sun_path中的套接字文件会自动生成。</span></span><br><span class="line"></span><br><span class="line">bind(lfd, addr, len);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>监听</li>
</ol>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">listen(lfd, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>等待并接受连接请求</li>
</ol>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">cliaddr</span>;</span></span><br><span class="line"><span class="type">int</span> cfd = accept(lfd, &amp;cliaddr, len);</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>通信<br> 接收数据：read&#x2F;recv<br> 发送数据：write&#x2F;send</p>
</li>
<li><p>关闭连接<br>close();</p>
</li>
</ol>
<br>

<p><strong>客户端</strong></p>
<ol>
<li>创建通信的套接字</li>
</ol>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> fd = socket(AF_UNIX/AF_LOCAL, SOCK_STREAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>监听的套接字绑定本地的IP,端口</li>
</ol>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">addr</span>;</span></span><br><span class="line"><span class="comment">// 绑定成功之后，指定的sun_path中的套接字文件会自动生成。</span></span><br><span class="line"></span><br><span class="line">bind(lfd, addr, len);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>连接服务器</li>
</ol>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">serveraddr</span>;</span></span><br><span class="line"></span><br><span class="line">connect(fd, &amp;serveraddr, <span class="keyword">sizeof</span>(serveraddr));</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>通信<br> 接收数据：read&#x2F;recv<br> 发送数据：write&#x2F;send</p>
</li>
<li><p>关闭连接<br>close();</p>
</li>
</ol>
<br>

<br>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 头文件: sys/un.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNIX_PATH_MAX 108</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> &#123;</span></span><br><span class="line">	<span class="type">sa_family_t</span> sun_family; <span class="comment">// 地址族协议 af_local</span></span><br><span class="line">	<span class="type">char</span> sun_path[UNIX_PATH_MAX]; <span class="comment">// 套接字文件的路径, 这是一个伪文件, 大小永远=0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>

<br>

<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>注意使用 <strong>strcpy</strong> 来设置 sockaddr_un 结构体中的 <strong>sun_path</strong> 的内容</p>
<p><strong>服务端</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    unlink(<span class="string">&quot;server.sock&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建监听的套接字</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_LOCAL, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.绑定本地套接字文件</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sun_family = AF_LOCAL;</span><br><span class="line">    <span class="built_in">strcpy</span>(addr.sun_path, <span class="string">&quot;server.sock&quot;</span>);</span><br><span class="line">    <span class="type">int</span> ret = bind(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.等待客户端连接</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;cliaddr, &amp;len);</span><br><span class="line">    <span class="keyword">if</span>(cfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client socket filename: %s\n&quot;</span>, cliaddr.sun_path);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">        <span class="type">int</span> len = recv(cfd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client closed....\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client say : %s\n&quot;</span>, buf);</span><br><span class="line">            send(cfd, buf, len, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(cfd);</span><br><span class="line">    close(lfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<br>

<br>

<p><strong>客户端</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    unlink(<span class="string">&quot;client.sock&quot;</span>);	</span><br><span class="line">    <span class="comment">// 删除参数pathname 指定的文件. </span></span><br><span class="line">    <span class="comment">// 如果该文件名为最后连接点, 但有其他进程打开了此文件, 则在所有关于此文件的文件描述词皆关闭后才会删除. </span></span><br><span class="line">    <span class="comment">// 如果参数pathname 为一符号连接, 则此连接会被删除。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建套接字</span></span><br><span class="line">    <span class="type">int</span> cfd = socket(AF_LOCAL, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(cfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.绑定本地套接字文件</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sun_family = AF_LOCAL;</span><br><span class="line">    <span class="built_in">strcpy</span>(addr.sun_path, <span class="string">&quot;client.sock&quot;</span>);</span><br><span class="line">    <span class="type">int</span> ret = bind(cfd, (<span class="keyword">struct</span> sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.连接服务器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">seraddr</span>;</span></span><br><span class="line">    seraddr.sun_family = AF_LOCAL;</span><br><span class="line">    <span class="built_in">strcpy</span>(seraddr.sun_path, <span class="string">&quot;server.sock&quot;</span>);</span><br><span class="line">    ret = connect(cfd, (<span class="keyword">struct</span> sockaddr *)&amp;seraddr, <span class="keyword">sizeof</span>(seraddr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.通信</span></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;hello, i am client %d\n&quot;</span>, num++);</span><br><span class="line">        send(cfd, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client say : %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="type">int</span> len = recv(cfd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;server closed....\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;server say : %s\n&quot;</span>, buf);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(cfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<br>

<br>

]]></content>
      <categories>
        <category>C++开发</category>
        <category>高性能服务器项目</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
</search>
