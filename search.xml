<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>test</title>
    <url>/2023/02/10/test/</url>
    <content><![CDATA[<p>Test</p>
<p><img src="/?utm_source=gold_browser_extension/2023/02/10/test/image-20230210000157021.png" alt="213"></p>
<img src="/?utm_source=gold_browser_extension/2023/02/10/test/02/10/test/image-20230210000157021.png" class title="test">
]]></content>
  </entry>
  <entry>
    <title>用不同电脑写hexo博客</title>
    <url>/2022/07/11/%E4%B8%8D%E5%90%8C%E7%94%B5%E8%84%91%E5%86%99hexo%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="基于GitHub双分支方法"><a href="#基于GitHub双分支方法" class="headerlink" title="基于GitHub双分支方法"></a>基于GitHub双分支方法</h1><h2 id="1-在每次编辑之前"><a href="#1-在每次编辑之前" class="headerlink" title="1. 在每次编辑之前"></a>1. 在每次编辑之前</h2><hr>
<p>需要先 <code>git pull</code> 拉取hexo分支的内容到本地，即同步更新，然后再进行上述操作。</p>
<hr>
<p><br><br><br><br><br><br></p>
<h2 id="2-修改本地文件和编辑博客内容"><a href="#2-修改本地文件和编辑博客内容" class="headerlink" title="2. 修改本地文件和编辑博客内容"></a>2. 修改本地文件和编辑博客内容</h2><hr>
<p>Windows下用 git bash 打开本地文件夹</p>
<p>然后就是 <code>hexo new [layout] &lt;title&gt;</code> 创建新文件</p>
<img src="/?utm_source=gold_browser_extension/2022/07/11/%E4%B8%8D%E5%90%8C%E7%94%B5%E8%84%91%E5%86%99hexo%E5%8D%9A%E5%AE%A2/07/11/%E4%B8%8D%E5%90%8C%E7%94%B5%E8%84%91%E5%86%99hexo%E5%8D%9A%E5%AE%A2/1.png" class>

<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/156915260">相关hexo操作</a></p>
</blockquote>
<blockquote>
<p><a href="https://markdown.com.cn/basic-syntax/">markdown语法</a></p>
</blockquote>
<blockquote>
<p>图片插入格式 <code>&#123;% asset_img example.jpg This is an example image %&#125;</code></p>
</blockquote>
<hr>
<p><br><br><br><br><br><br></p>
<h2 id="3-编辑和修改完成之后"><a href="#3-编辑和修改完成之后" class="headerlink" title="3. 编辑和修改完成之后"></a>3. 编辑和修改完成之后</h2><hr>
<p>先归并到hexo分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;xxx&quot;&#x27;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<p>再用</p>
<p> <code>hexo d -g</code></p>
<p> 部署到master分支中的网页上。</p>
<hr>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>暑期算法学习day1</title>
    <url>/2022/07/31/%E6%9A%91%E6%9C%9F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0day1/</url>
    <content><![CDATA[<h1 id="暑假算法学习day1"><a href="#暑假算法学习day1" class="headerlink" title="暑假算法学习day1"></a>暑假算法学习day1</h1><br>

<h2 id="day1——核心框架汇总"><a href="#day1——核心框架汇总" class="headerlink" title="day1——核心框架汇总"></a>day1——核心框架汇总</h2><h3 id="1-框架思维"><a href="#1-框架思维" class="headerlink" title="1-框架思维"></a>1-框架思维</h3><h4 id="基本数据结构及其操作"><a href="#基本数据结构及其操作" class="headerlink" title="基本数据结构及其操作"></a>基本数据结构及其操作</h4><p>数据结构的存储方式只有两种：<strong>数组（顺序存储）和链表（链式存储）</strong></p>
<p>在此之上可以构成：<strong>散列表、栈、队列、堆、树、图等等各种数据结构</strong></p>
<p>基本操作：无非就是<strong>遍历 + 访问</strong>，再具体一点就是：<strong>增删查改</strong>。</p>
<p>数据结构种类很多，但它们存在的目的都是在不同的应用场景，尽可能高效地增删查改。</p>
<hr>
<h4 id="算法的框架思维"><a href="#算法的框架思维" class="headerlink" title="算法的框架思维"></a>算法的框架思维</h4><p>数组遍历框架</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">voidtraverse</span>(<span class="type">int</span>[]arr)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i &lt;arr.length; i++)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 迭代访问 arr[i]</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<p>链表遍历框架，兼具迭代和递归结构：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 基本的单链表节点 */</span></span><br><span class="line"></span><br><span class="line">classListNode&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">voidtraverse</span>(ListNodehead)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(ListNode p = head; p != null; p =p.next)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 迭代访问 p.val</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">voidtraverse</span>(ListNodehead)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归访问 head.val</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">traverse</span>(head.next);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<p>二叉树遍历框架，典型的非线性递归遍历结构：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 基本的二叉树节点 */</span></span><br><span class="line"></span><br><span class="line">classTreeNode&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">    TreeNode left, right;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">voidtraverse</span>(TreeNoderoot)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">traverse</span>(root.left);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">traverse</span>(root.right);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<p>N 叉树的遍历框架：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 基本的 N 叉树节点 */</span></span><br><span class="line"></span><br><span class="line">classTreeNode&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">    TreeNode[] children;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">voidtraverse</span>(TreeNoderoot)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(TreeNode child :root.children)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">traverse</span>(child);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>1、先学习像数组、链表这种基本数据结构的常用算法</strong></p>
<p><strong>2、学会基础算法之后，不要急着上来就刷回溯算法、动态规划这类笔试常考题，而应该先刷二叉树</strong></p>
<hr>
<br>

<h3 id="2-刷题心得"><a href="#2-刷题心得" class="headerlink" title="2-刷题心得"></a>2-刷题心得</h3><h4 id="数组-x2F-单链表系列算法"><a href="#数组-x2F-单链表系列算法" class="headerlink" title="数组&#x2F;单链表系列算法"></a>数组&#x2F;单链表系列算法</h4><blockquote>
<p>-<strong>单链表常考的技巧就是双指针</strong></p>
</blockquote>
<blockquote>
<p>-<strong>数组常用的技巧有很大一部分还是双指针相关的技巧，说白了是教你如何聪明地进行穷举</strong></p>
</blockquote>
<blockquote>
<p>-<strong>滑动窗口算法技巧，典型的快慢双指针，快慢指针中间就是滑动的「窗口」，主要用于解决子串问题。</strong></p>
</blockquote>
<blockquote>
<p>-**最后说说 <a href="https://labuladong.github.io/algo/2/20/24/">前缀和技巧</a> 和 <a href="https://labuladong.github.io/algo/2/20/25/">差分数组技巧</a>**。</p>
</blockquote>
<blockquote>
<blockquote>
<p>如果频繁地让你计算子数组的和，每次用 for 循环去遍历肯定没问题，但前缀和技巧预计算一个 <code>preSum</code> 数组，就可以避免循环。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>类似的，如果频繁地让你对子数组进行增减操作，也可以每次用 for 循环去操作，但差分数组技巧维护一个 <code>diff</code> 数组，也可以避免循环。</p>
</blockquote>
</blockquote>
<br>

<h4 id="二叉树系列算法"><a href="#二叉树系列算法" class="headerlink" title="二叉树系列算法"></a>二叉树系列算法</h4><p>二叉树题目的递归解法可以分两类思路，第一类是遍历一遍二叉树得出答案，第二类是通过分解问题计算出答案，这两类思路分别对应着 <a href="https://labuladong.github.io/algo/4/31/105/">回溯算法核心框架</a> 和 <a href="https://labuladong.github.io/algo/3/25/69/">动态规划核心框架</a>。</p>
<p>更进一步，图论相关的算法也是二叉树算法的延续。</p>
<p>比如 <a href="https://labuladong.github.io/algo/2/22/50/">图论基础</a>， <a href="https://labuladong.github.io/algo/2/22/51/">环判断和拓扑排序</a> 和 <a href="https://labuladong.github.io/algo/2/22/52/">二分图判定算法</a> 就用到了 DFS 算法；再比如 <a href="https://labuladong.github.io/algo/2/22/56/">Dijkstra 算法模板</a>，就是改造版 BFS 算法加上一个类似 dp table 的数组。</p>
<p>这些算法的本质都是穷举二（多）叉树，有机会的话通过剪枝或者备忘录的方式减少冗余计算，提高效率，就这么点事儿。</p>
<hr>
<br>

<h3 id="3-双指针（七道链表题）"><a href="#3-双指针（七道链表题）" class="headerlink" title="3-双指针（七道链表题）"></a>3-双指针（七道链表题）</h3><br>

<h4 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h4><p>用到了3个指针：指向原链表的p1、p2，连接链表的p</p>
<p>注意要新建一个空的链表头</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">ListNodemergeTwoLists</span>(ListNodel1,ListNodel2)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 虚拟头结点</span></span><br><span class="line"></span><br><span class="line">    ListNode dummy =<span class="built_in">newListNode</span>(<span class="number">-1</span>), p = dummy;</span><br><span class="line"></span><br><span class="line">    ListNode p1 = l1, p2 = l2;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p1 != null &amp;&amp; p2 != null)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较 p1 和 p2 两个指针</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将值较小的的节点接到 p 指针</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(p1.val&gt;p2.val)&#123;</span><br><span class="line"></span><br><span class="line">            p.next= p2;</span><br><span class="line"></span><br><span class="line">            p2 =p2.next;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">            p.next= p1;</span><br><span class="line"></span><br><span class="line">            p1 =p1.next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// p 指针不断前进</span></span><br><span class="line"></span><br><span class="line">        p =p.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p1 != null)&#123;</span><br><span class="line"></span><br><span class="line">        p.next= p1;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p2 != null)&#123;</span><br><span class="line"></span><br><span class="line">        p.next= p2;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    returndummy.next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<h4 id="链表的分解"><a href="#链表的分解" class="headerlink" title="链表的分解"></a>链表的分解</h4><p><img src="https://labuladong.github.io/algo/images/%e9%93%be%e8%a1%a8%e6%8a%80%e5%b7%a7/title4.jpg" alt="img"></p>
<br>

<h4 id="合并k个有序链表"><a href="#合并k个有序链表" class="headerlink" title="合并k个有序链表"></a>合并k个有序链表</h4><p>利用优先级队列（堆）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">ListNodemergeKLists</span>(ListNode[]lists)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(lists.length==<span class="number">0</span>)<span class="keyword">return</span> null;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 虚拟头结点</span></span><br><span class="line"></span><br><span class="line">    ListNode dummy =<span class="built_in">newListNode</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    ListNode p = dummy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优先级队列，最小堆</span></span><br><span class="line"></span><br><span class="line">    PriorityQueue&lt;ListNode&gt; pq =newPriorityQueue&lt;&gt;(</span><br><span class="line"></span><br><span class="line">        lists.length,(a, b)-&gt;(a.val-b.val));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 k 个链表的头结点加入最小堆</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(ListNode head : lists)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(head != null)</span><br><span class="line"></span><br><span class="line">            pq.<span class="built_in">add</span>(head);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!pq.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取最小节点，接到结果链表中</span></span><br><span class="line"></span><br><span class="line">        ListNode node =pq.<span class="built_in">poll</span>();</span><br><span class="line"></span><br><span class="line">        p.next= node;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node.next!= null)&#123;</span><br><span class="line"></span><br><span class="line">            pq.<span class="built_in">add</span>(node.next);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// p 指针不断前进</span></span><br><span class="line"></span><br><span class="line">        p =p.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    returndummy.next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>优先队列 <code>pq</code> 中的元素个数最多是 <code>k</code>，所以一次 <code>poll</code> 或者 <code>add</code> 方法的时间复杂度是 <code>O(logk)</code>；所有的链表节点都会被加入和弹出 <code>pq</code>，<strong>所以算法整体的时间复杂度是 <code>O(Nlogk)</code>，其中 <code>k</code> 是链表的条数，<code>N</code> 是这些链表的节点总数</strong>。</p>
<br>

<h4 id="寻找单链表的倒数第k个节点"><a href="#寻找单链表的倒数第k个节点" class="headerlink" title="寻找单链表的倒数第k个节点"></a>寻找单链表的倒数第k个节点</h4><p>不告诉链表长度；</p>
<p>只遍历一次链表的解法：用p1走k步后，p2再出发</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 返回链表的倒数第 k 个节点</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">ListNodefindFromEnd</span>(ListNodehead,intk)&#123;</span><br><span class="line"></span><br><span class="line">    ListNode p1 = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// p1 先走 k 步</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line"></span><br><span class="line">        p1 =p1.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode p2 = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// p1 和 p2 同时走 n - k 步</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p1 != null)&#123;</span><br><span class="line"></span><br><span class="line">        p2 =p2.next;</span><br><span class="line"></span><br><span class="line">        p1 =p1.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// p2 现在指向第 n - k + 1 个节点，即倒数第 k 个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p2;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<h4 id="寻找单链表的中点"><a href="#寻找单链表的中点" class="headerlink" title="寻找单链表的中点"></a>寻找单链表的中点</h4><p>利用快慢指针：快指针走两步，慢指针走一步</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">ListNodemiddleNode</span>(ListNodehead)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快慢指针初始化指向 head</span></span><br><span class="line"></span><br><span class="line">    ListNode slow = head, fast = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快指针走到末尾时停止</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(fast != null &amp;&amp;fast.next!= null)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 慢指针走一步，快指针走两步</span></span><br><span class="line"></span><br><span class="line">        slow =slow.next;</span><br><span class="line"></span><br><span class="line">        fast =fast.next.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 慢指针指向中点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>需要注意的是，如果链表长度为偶数，也就是说中点有两个的时候，我们这个解法返回的节点是靠后的那个节点。</p>
<br>

<h4 id="判断单链表是否包含环并找出环起点"><a href="#判断单链表是否包含环并找出环起点" class="headerlink" title="判断单链表是否包含环并找出环起点"></a>判断单链表是否包含环并找出环起点</h4><p>判断是否含环：快慢指针，如果最终快指针赶上慢指针说明有环。否则快指针遍历直到空指针。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">booleanhasCycle</span>(ListNodehead)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快慢指针初始化指向 head</span></span><br><span class="line"></span><br><span class="line">    ListNode slow = head, fast = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快指针走到末尾时停止</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(fast != null &amp;&amp;fast.next!= null)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 慢指针走一步，快指针走两步</span></span><br><span class="line"></span><br><span class="line">        slow =slow.next;</span><br><span class="line"></span><br><span class="line">        fast =fast.next.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 快慢指针相遇，说明含有环</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(slow == fast)&#123;</span><br><span class="line"></span><br><span class="line">            returntrue;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不包含环</span></span><br><span class="line"></span><br><span class="line">    returnfalse;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>若有环，如何判断环的起点</p>
<blockquote>
<p>当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">ListNodedetectCycle</span>(ListNodehead)&#123;</span><br><span class="line"></span><br><span class="line">    ListNode fast, slow;</span><br><span class="line"></span><br><span class="line">    fast = slow = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(fast != null &amp;&amp;fast.next!= null)&#123;</span><br><span class="line"></span><br><span class="line">        fast =fast.next.next;</span><br><span class="line"></span><br><span class="line">        slow =slow.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(fast == slow)<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上面的代码类似 hasCycle 函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fast == null ||fast.next== null)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// fast 遇到空指针说明没有环</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> null;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新指向头结点</span></span><br><span class="line"></span><br><span class="line">    slow = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快慢指针同步前进，相交点就是环起点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line"></span><br><span class="line">        fast =fast.next;</span><br><span class="line"></span><br><span class="line">        slow =slow.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<h4 id="判断两个单链表是否相交并找出交点"><a href="#判断两个单链表是否相交并找出交点" class="headerlink" title="判断两个单链表是否相交并找出交点"></a>判断两个单链表是否相交并找出交点</h4><p>不使用Hashmap的实现，即仅使用两个指针</p>
<blockquote>
<p>我们可以让 <code>p1</code> 遍历完链表 <code>A</code> 之后开始遍历链表 <code>B</code>，让 <code>p2</code> 遍历完链表 <code>B</code> 之后开始遍历链表 <code>A</code>，这样相当于「逻辑上」两条链表接在了一起。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">ListNodegetIntersectionNode</span>(ListNodeheadA,ListNodeheadB)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// p1 指向 A 链表头结点，p2 指向 B 链表头结点</span></span><br><span class="line"></span><br><span class="line">    ListNode p1 = headA, p2 = headB;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p1 != p2)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// p1 走一步，如果走到 A 链表末尾，转到 B 链表</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(p1 == null) p1 = headB;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>            p1 =p1.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// p2 走一步，如果走到 B 链表末尾，转到 A 链表</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(p2 == null) p2 = headA;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>            p2 =p2.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>或者通过预先求出两个链表的长度，来使p1、p2同时到达相交节点</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> lenA =<span class="number">0</span>, lenB =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算两条链表的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(ListNode p1 = headA; p1 != null; p1 =p1.next)&#123;</span><br><span class="line"></span><br><span class="line">        lenA++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(ListNode p2 = headB; p2 != null; p2 =p2.next)&#123;</span><br><span class="line"></span><br><span class="line">        lenB++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让 p1 和 p2 到达尾部的距离相同</span></span><br><span class="line"></span><br><span class="line">    ListNode p1 = headA, p2 = headB;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(lenA &gt; lenB)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i &lt; lenA - lenB; i++)&#123;</span><br><span class="line"></span><br><span class="line">            p1 =p1.next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i &lt; lenB - lenA; i++)&#123;</span><br><span class="line"></span><br><span class="line">            p2 =p2.next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 看两个指针是否会相同，p1 == p2 时有两种情况：</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、要么是两条链表不相交，他俩同时走到尾部空指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、要么是两条链表相交，他俩走到两条链表的相交点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p1 != p2)&#123;</span><br><span class="line"></span><br><span class="line">        p1 =p1.next;</span><br><span class="line"></span><br><span class="line">        p2 =p2.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<br>

<h3 id="4-双指针（七道数组题）"><a href="#4-双指针（七道数组题）" class="headerlink" title="4-双指针（七道数组题）"></a>4-双指针（七道数组题）</h3><blockquote>
<p>链表和数组题中的双指针有两种</p>
</blockquote>
<blockquote>
<p>-<strong>左右指针</strong>，就是两个指针相向而行或者相背而行；</p>
</blockquote>
<blockquote>
<p>-<strong>快慢指针</strong>，就是两个指针同向而行，一快一慢。</p>
</blockquote>
<br>

<h4 id="快慢指针技巧"><a href="#快慢指针技巧" class="headerlink" title="快慢指针技巧"></a>快慢指针技巧</h4><blockquote>
<p>原地修改数组</p>
</blockquote>
<h5 id="删除有序数组中的重复项"><a href="#删除有序数组中的重复项" class="headerlink" title="删除有序数组中的重复项"></a>删除有序数组中的重复项</h5><p>在不新开数组的情况下的解法</p>
<p><img src="https://labuladong.github.io/algo/images/%e6%95%b0%e7%bb%84%e5%8e%bb%e9%87%8d/1.gif" alt="img"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">intremoveDuplicates</span>(<span class="type">int</span>[]nums)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(nums.length==<span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">        return0;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> slow =<span class="number">0</span>, fast =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(fast &lt;nums.length)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums[fast]!=nums[slow])&#123;</span><br><span class="line"></span><br><span class="line">            slow++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 维护 nums[0..slow] 无重复</span></span><br><span class="line"></span><br><span class="line">            nums[slow]=nums[fast];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fast++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组长度为索引 + 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slow +<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于删除有序链表中的重复项呢？</p>
<p><img src="https://labuladong.github.io/algo/images/%e6%95%b0%e7%bb%84%e5%8e%bb%e9%87%8d/2.gif" alt="img"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">ListNodedeleteDuplicates</span>(ListNodehead)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(head == null)<span class="keyword">return</span> null;</span><br><span class="line"></span><br><span class="line">    ListNode slow = head, fast = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(fast != null)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(fast.val!=slow.val)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// nums[slow] = nums[fast];</span></span><br><span class="line"></span><br><span class="line">            slow.next= fast;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// slow++;</span></span><br><span class="line"></span><br><span class="line">            slow =slow.next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// fast++</span></span><br><span class="line"></span><br><span class="line">        fast =fast.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 断开与后面重复元素的连接</span></span><br><span class="line"></span><br><span class="line">    slow.next= null;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<h5 id="删除无序数组中的某个元素"><a href="#删除无序数组中的某个元素" class="headerlink" title="删除无序数组中的某个元素"></a>删除无序数组中的某个元素</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">intremoveElement</span>(<span class="type">int</span>[]nums,intval)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fast =<span class="number">0</span>, slow =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(fast &lt;nums.length)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums[fast]!= val)&#123;</span><br><span class="line"></span><br><span class="line">            nums[slow]=nums[fast];</span><br><span class="line"></span><br><span class="line">            slow++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fast++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里是先给 <code>nums[slow]</code> 赋值然后再给 slow++</p>
<br>

<h5 id="移动0"><a href="#移动0" class="headerlink" title="移动0"></a>移动0</h5><blockquote>
<p>比如说给你输入 <code>nums = [0,1,4,0,2]</code>，你的算法没有返回值，但是会把 <code>nums</code> 数组原地修改成 <code>[1,4,2,0,0]</code>。</p>
</blockquote>
<blockquote>
<p>其实就相当于移除 <code>nums</code> 中的所有 0，然后再把后面的元素都赋值为 0 即可。</p>
</blockquote>
<p>可以复用上一题的 <code>removeElement</code> 函数</p>
<br>

<h4 id="滑动窗口类型（快慢指针）"><a href="#滑动窗口类型（快慢指针）" class="headerlink" title="滑动窗口类型（快慢指针）"></a>滑动窗口类型（快慢指针）</h4><p>代码框架</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 滑动窗口算法框架 */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">voidslidingWindow</span>(strings,stringt)&#123;</span><br><span class="line"></span><br><span class="line">    unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; need, window;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c : t)need[c]++;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left =<span class="number">0</span>, right =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> valid =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(right &lt;s.<span class="built_in">size</span>())&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> c =s[right];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右移（增大）窗口</span></span><br><span class="line"></span><br><span class="line">        right++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(window needs shrink)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">char</span> d =s[left];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 左移（缩小）窗口</span></span><br><span class="line"></span><br><span class="line">            left++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>left</code> 指针在后，<code>right</code> 指针在前，两个指针中间的部分就是「窗口」，算法通过扩大和缩小「窗口」来解决某些问题。</p>
<hr>
<br>

<h4 id="左右指针技巧"><a href="#左右指针技巧" class="headerlink" title="左右指针技巧"></a>左右指针技巧</h4><h5 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h5><p>简单框架</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">intbinarySearch</span>(<span class="type">int</span>[]nums,inttarget)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一左一右两个指针相向而行</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left =<span class="number">0</span>, right =nums.length<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> mid =(right + left)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums[mid]== target)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">elseif</span>(nums[mid]&lt; target)</span><br><span class="line"></span><br><span class="line">            left = mid +<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">elseif</span>(nums[mid]&gt; target)</span><br><span class="line"></span><br><span class="line">            right = mid <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span><span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<h5 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h5><p>返回的下标是从1算起的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span>[] <span class="built_in">twoSum</span>(<span class="type">int</span>[] nums,<span class="type">int</span> target)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一左一右两个指针相向而行</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left =<span class="number">0</span>, right =nums.length<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> sum =nums[left]+nums[right];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 题目要求的索引是从 1 开始的</span></span><br><span class="line"></span><br><span class="line">            returnnewint[]&#123;left +<span class="number">1</span>, right +<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="built_in">elseif</span>(sum &lt; target)&#123;</span><br><span class="line"></span><br><span class="line">            left++; <span class="comment">// 让 sum 大一点 *</span></span><br><span class="line"></span><br><span class="line">        &#125;<span class="built_in">elseif</span>(sum &gt; target)&#123;</span><br><span class="line"></span><br><span class="line">            right--; <span class="comment">// 让 sum 小一点 *</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    returnnewint[]&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<h5 id="反转数组"><a href="#反转数组" class="headerlink" title="反转数组"></a>反转数组</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">voidreverseString</span>(<span class="type">char</span>[]s)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一左一右两个指针相向而行</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left =<span class="number">0</span>, right =s.length<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 交换 s[left] 和 s[right]</span></span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> temp =s[left];</span><br><span class="line"></span><br><span class="line">        s[left]=s[right];</span><br><span class="line"></span><br><span class="line">        s[right]= temp;</span><br><span class="line"></span><br><span class="line">        left++;</span><br><span class="line"></span><br><span class="line">        right--;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<h5 id="回文串匹配"><a href="#回文串匹配" class="headerlink" title="回文串匹配"></a>回文串匹配</h5><p>简单匹配</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">booleanisPalindrome</span>(Strings)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一左一右两个指针相向而行</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left =<span class="number">0</span>, right =s.<span class="built_in">length</span>()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">charAt</span>(left)!=s.<span class="built_in">charAt</span>(right))&#123;</span><br><span class="line"></span><br><span class="line">            returnfalse;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        left++;</span><br><span class="line"></span><br><span class="line">        right--;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    returntrue;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<p><strong>最长回文子串</strong></p>
<blockquote>
<p>左右指针从中间往两边延申</p>
</blockquote>
<blockquote>
<p>如果回文串的长度为奇数，参数 r &#x3D; l</p>
</blockquote>
<blockquote>
<p>如果回文串的长度为偶数，参数 r &#x3D; l+1</p>
</blockquote>
<blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 s 中寻找以 s[l] 和 s[r] 为中心的最长回文串</span></span><br><span class="line"><span class="built_in">Stringpalindrome</span>(Strings,intl,intr)&#123;</span><br><span class="line"><span class="comment">// 防止索引越界</span></span><br><span class="line"><span class="keyword">while</span>(l &gt;=<span class="number">0</span>&amp;&amp; r &lt;s.<span class="built_in">length</span>()</span><br><span class="line">&amp;&amp;s.<span class="built_in">charAt</span>(l)==s.<span class="built_in">charAt</span>(r))&#123;</span><br><span class="line"><span class="comment">// 双指针，向两边展开</span></span><br><span class="line">l--; r++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回以 s[l] 和 s[r] 为中心的最长回文串</span></span><br><span class="line">returns.<span class="built_in">substring</span>(l +<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">StringlongestPalindrome</span>(Strings)&#123;</span><br><span class="line"></span><br><span class="line">    String res =<span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i &lt;s.<span class="built_in">length</span>(); i++)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以 s[i] 为中心的最长回文子串</span></span><br><span class="line"></span><br><span class="line">        String s1 =<span class="built_in">palindrome</span>(s, i, i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以 s[i] 和 s[i+1] 为中心的最长回文子串</span></span><br><span class="line"></span><br><span class="line">        String s2 =<span class="built_in">palindrome</span>(s, i, i +<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// res = longest(res, s1, s2)</span></span><br><span class="line"></span><br><span class="line">        res =res.<span class="built_in">length</span>()&gt;s1.<span class="built_in">length</span>()? res : s1;</span><br><span class="line"></span><br><span class="line">        res =res.<span class="built_in">length</span>()&gt;s2.<span class="built_in">length</span>()? res : s2;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux多进程</title>
    <url>/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="2-Linux多进程开发"><a href="#2-Linux多进程开发" class="headerlink" title="2.Linux多进程开发"></a>2.Linux多进程开发</h1><hr>
<h2 id="2-1-进程概述"><a href="#2-1-进程概述" class="headerlink" title="2.1 进程概述"></a>2.1 进程概述</h2><p><strong>程序和进程</strong></p>
<blockquote>
<p><strong>程序</strong></p>
<p>程序是包含一系列信息的文件，这些文件描述了如何在运行时创建一个进程。</p>
<p>包含内容：</p>
<ul>
<li>二进制格式标识：每个程序文件都包含用于描述可执行文件格式的元信息。内核利用此信息来解释文件中的其他信息。（ELF可执行链接格式）</li>
<li>机器语言指令：对程序算法进行编码。</li>
<li>程序入口地址：标识程序开始执行时的起始指令位置。</li>
<li>数据：程序文件包含的变量初始值和程序使用的字面量值（如字符串）。</li>
<li>符号表及重定位表：描述程序中函数和变量的位置及名称。这些表格有多重用途，其中包括调试和运行时的符号解析（动态链接）。</li>
<li>共享库和动态链接信息：程序文件所包含的一些字段，列出了程序运行时需要使用的共享库，以及加载共享库的动态链接器的路径名。</li>
<li>其他信息：程序文件还包含其他信息，用来描述如何创建进程。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>进程</strong></p>
<ul>
<li>进程是正在运行的程序的实例。<ul>
<li>是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。</li>
<li>是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。</li>
</ul>
</li>
<li>可以用一个程序来创建多个进程，进程是由内核定义的抽象实体，并为该实体分配用以执行程序的各项系统资源。<ul>
<li>从内核的角度看，进程由用户内存空间和一些列的内核数据结构组成，其中用户内存空间包含了程序代码及代码所使用的变量，而内核数据结构则用于维护进程状态信息。</li>
<li>记录在内核数据结构中的信息包括许多与进程相关的标识号（IDs）、虚拟内存表、打开文件的描述符表，信号传递及处理的有关信息、进程资源使用及限制、当前工作目录和大量的其他信息。</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>单道、多道程序设计</strong></p>
<p>单道程序：在计算机内存中只允许一个的程序运行。</p>
<p>多道程序：计算机内存中同时存放多道相互独立的程序使它们在管理程序控制下，相互穿插运行，两个或两个以上程序在计算机系统中处于开始到结束之间的状态，这些车程序共享计算机资源。（提高CPU的利用率）</p>
<ul>
<li>对于单CPU系统而言，宏观上可以使多个程序像是同时运行，实际上任意时刻CPU上运行的程序只有一个。</li>
<li>在多道程序设计模型中，多个程序轮流使用CPU。</li>
</ul>
<p><strong>时间片</strong></p>
<p>时间片 timeslice 又称为“量子 quantum”或“处理器片processor slice”，是操作系统分配给每个正在运行的进程微观上的一段CPU时间。</p>
<p>时间片由操作系统内核的调度程序分配给每个进程。</p>
<p><strong>并行和并发</strong></p>
<p>并行（parallel）：指在同一时刻，有多条指令在多个处理器上同时执行。</p>
<p>并发（concurrency）：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。</p>
<p><img src="/?utm_source=gold_browser_extension/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230204223514971.png" alt="image-20230204223514971"></p>
<p><img src="/?utm_source=gold_browser_extension/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/Users\86191\Desktop\myblog\mang959595.github.io\source_posts\第二章Linux多进程\image-20230204223803946.png" alt="image-20230204223803946"></p>
 <img src="/?utm_source=gold_browser_extension/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230204223514971.png" class title="example">

<p><strong>进程控制块 PCB</strong></p>
<p>内核为每个进程分配以一个 PCB 进程控制块，维护进程相关的信息，Linux内核的进程控制块是 task_struct 结构体。</p>
<p>在 &#x2F;usr&#x2F;src&#x2F;linux-headers-xxx&#x2F;include&#x2F;linux&#x2F;sched.h 文件中可以查看 struct task_struct 结构体定义，其部分内部成员如下：</p>
<ul>
<li>进程id：系统中每个进程有唯一的 id ，用 pid_t 类型表示，是一个非负整数</li>
<li>进程的状态：就绪、运行、挂起、停止等状态</li>
<li>进程切换时需要保存和恢复的一些CPU寄存器信息</li>
<li>描述虚拟地址空间的信息</li>
<li>描述控制终端的信息</li>
<li>当前工作目录</li>
<li>umask掩码</li>
<li>文件描述符表，包含很多执行file结构体的指针</li>
<li>和信号相关的信息</li>
<li>用户id和组id</li>
<li>会话（session）和进程组</li>
<li>进程可以使用的资源上限（可用ulimit指令查看系统内核资源上限）</li>
</ul>
<h2 id="2-2-进程状态转换"><a href="#2-2-进程状态转换" class="headerlink" title="2.2 进程状态转换"></a>2.2 进程状态转换</h2><h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><p>进程状态反映进程执行过程的变化。</p>
<p><code>三态模型</code>中，进程状态分为三个基本状态 —— 就绪态、运行态、阻塞态。</p>
<blockquote>
<p><strong>运行态</strong>：进程占有处理器正在运行。</p>
<p><strong>就绪态</strong>：进程具备运行条件，等待系统分配处理器以便运行。当进程分配到除CPU外的所有必要资源后，只要再获得CPU，便可立即执行。多个就绪进程排成队列，称为就绪队列。</p>
<p><strong>阻塞态</strong>：又称为 等待态(wait) 或 睡眠态(sleep)，指进程不具备运行条件，正在等待某个事件的完成。</p>
</blockquote>
<p><img src="/?utm_source=gold_browser_extension/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/Users\86191\Desktop\myblog\mang959595.github.io\source_posts\第二章Linux多进程\image-20230204225943684.png" alt="image-20230204225943684"></p>
<p><code>五态模型</code>中，进程状态分为 ——  新建态、就绪态、运行态、阻塞态、终止态。</p>
<blockquote>
<p><strong>新建态</strong>：进程刚被创建时的状态，尚未进入就绪队列</p>
<p><strong>终止态</strong>：进程完成任务达到正常结束点，或出现无法克服的错误而异常终止，或被操作系统及有终止权的进程所终止时所处的状态。进入终止态的进程不再执行，但依然保留再操作系统中等待善后。一旦其他进程完成了对终止态进程的信息抽取之后，操作系统将删除该进程。</p>
</blockquote>
<p><img src="/?utm_source=gold_browser_extension/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/Users\86191\Desktop\myblog\mang959595.github.io\source_posts\第二章Linux多进程\image-20230204230502376.png" alt="image-20230204230502376"></p>
<h3 id="进程相关指令"><a href="#进程相关指令" class="headerlink" title="进程相关指令"></a>进程相关指令</h3><p><strong>查看进程</strong></p>
<p><code>ps aux/ajx</code></p>
<p>a：显示终端上的所有进程，包括其他用户的进程</p>
<p>u：显示进程的详细信息</p>
<p>x：显示没有控制终端的进程</p>
<p>j：列出与作业控制相关的进程</p>
<blockquote>
<p>stat标识</p>
<p><img src="/?utm_source=gold_browser_extension/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/Users\86191\Desktop\myblog\mang959595.github.io\source_posts\第二章Linux多进程\image-20230204232608821.png" alt="image-20230204232608821"></p>
</blockquote>
<p><strong>实时显示进程状态</strong></p>
<p><code>top</code></p>
<p>可以在 top 命令后加 -d 来指定显示信息更新的时间间隔</p>
<p>在 top 命令执行后，可以按一下按键对显示结果进行排序</p>
<ul>
<li>M 根据内存使用量</li>
<li>P 根据CPU占有率</li>
<li>T 根据进程运行时间长短</li>
<li>U 根据用户名筛选</li>
<li>K 输入指定的 PID 杀死进程</li>
</ul>
<p><strong>杀死进程</strong></p>
<p><code>kill [-signal] pid</code></p>
<p><code>kill -l</code>列出所有signal信号(信号宏)</p>
<p>比如：</p>
<ul>
<li><p><code>kill -SIGKILL 进程ID</code></p>
</li>
<li><p><code>kill -9 进程ID</code> </p>
</li>
<li><p><code>killall name</code> 根据进程名杀死进程</p>
</li>
</ul>
<p><strong>进程号和相关函数</strong></p>
<ul>
<li><p>每个进程都由<strong>进程号</strong>来表示，其类型为 pid_t（整型），进程号范围：0~32767。</p>
</li>
<li><p>任何进程（除init进程）都是由另一个进程创建，即父进程， PPID 为父进程号</p>
</li>
<li><p><strong>进程组</strong>是一个或多个进程的集合。他们相互关联，进程组可以接收同一终端的各种信号，关联的进程有一个进程组号 PGID 。默认情况下，当前的进程号会当做当前的进程组号。</p>
</li>
</ul>
<p>相关函数：</p>
<ul>
<li><code>pid_t getpid(void);</code></li>
<li><code>pid_t getppid(void);</code></li>
<li><code>pid_t getpgid(pid_t pid);</code></li>
</ul>
<h2 id="2-3-进程创建与调试"><a href="#2-3-进程创建与调试" class="headerlink" title="2.3 进程创建与调试"></a>2.3 进程创建与调试</h2><p>系统允许一个进程创建新进程，即紫禁城，子进程还可以创建新的子进程，形成树结构模型。</p>
<h3 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a>fork函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建子进程</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		- 成功：子进程中返回0，父进程中返回子进程 ID </span></span><br><span class="line"><span class="comment">		- 失败：子进程不被创建，父进程中返回-1，并设置errno</span></span><br><span class="line"><span class="comment">		失败的两个主要原因：</span></span><br><span class="line"><span class="comment">		1. 当前系统的进程数已经达到了系统规定的上限，这时 errno 的值被设置为 EAGAIN</span></span><br><span class="line"><span class="comment">		2. 系统内存不足，这是 errno 的值被设置为 ENOMEM</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<p>用法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//父进程要执行的内容</span></span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//子进程要执行的内容</span></span><br><span class="line">    	...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//都会执行的内容</span></span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="父、子进程虚拟地址空间情况"><a href="#父、子进程虚拟地址空间情况" class="headerlink" title="父、子进程虚拟地址空间情况"></a>父、子进程虚拟地址空间情况</h3><p><img src="/?utm_source=gold_browser_extension/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/Users\86191\Desktop\myblog\mang959595.github.io\source_posts\第二章Linux多进程\image-20230205003125065.png" alt="image-20230205003125065"></p>
<p>进程的实际pid在内核空间</p>
<p>变量pid的值在栈空间</p>
<blockquote>
<p>fork() 是通过 写时拷贝（copy-on-write） 实现。</p>
<p>写时拷贝时一钟可以推迟甚至避免拷贝数据的技术。内核此时并不复制整个进程的地址空间，而是让父子进程共享一个地址空间。</p>
<p>只有在需要写入的时候才会复制地址空间，从而使得各个进程拥有各自的地址空间，在此之前只有以只读方式共享。</p>
<p>注意：fork后父子进程共享文件</p>
<p><img src="/?utm_source=gold_browser_extension/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/Users\86191\Desktop\myblog\mang959595.github.io\source_posts\第二章Linux多进程\image-20230205011611597.png" alt="image-20230205011611597"></p>
<p><img src="/?utm_source=gold_browser_extension/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/Users\86191\Desktop\myblog\mang959595.github.io\source_posts\第二章Linux多进程\image-20230205011543783.png" alt="image-20230205011543783"></p>
</blockquote>
<blockquote>
<p>不同的进程访问同样的逻辑地址（虚拟地址）而对应的物理地址不同，是由于各自页表的不同。</p>
<p>linux系统下每个进程都拥有自己的页表，父进程fork出新的子进程时，子进程拷贝一份父进程的页表，且父子进程将页表状态修改为写保护。当父进程或子进程发生写操作时将会发生缺页异常，缺页异常处理函数将会为子进程分配新的物理地址。</p>
</blockquote>
<h3 id="父子进程关系"><a href="#父子进程关系" class="headerlink" title="父子进程关系"></a>父子进程关系</h3><p><strong>不同点</strong></p>
<ol>
<li>fork()函数的返回值不同<ul>
<li>父进程中：&gt;0 返回子进程的ID</li>
<li>子进程中：&#x3D;0</li>
</ul>
</li>
<li>PCB中的一些数据<ul>
<li>当前进程的id pid</li>
<li>当前进程的父进程id ppid</li>
<li>信号集</li>
</ul>
</li>
</ol>
<p><strong>共同点</strong></p>
<p>某些状态下：子进程刚被创建出来，还没有执行任何的写数据的操作</p>
<pre><code>- 用户区的数据
- 文件描述符表
</code></pre>
<p>父子进程对变量是不是共享的？</p>
<ul>
<li>刚开始是共享的，如果数据发生修改则不共享</li>
<li>读时共享，写时拷贝</li>
</ul>
<h3 id="GDB多进程调试"><a href="#GDB多进程调试" class="headerlink" title="GDB多进程调试"></a>GDB多进程调试</h3><p>GDB默认只能跟踪一个进程，可以在fork函数调用前，通过指令设置 GDB 调试工具跟踪父进程或者是子进程，默认跟踪父进程。</p>
<ul>
<li>设置调试父进程或子进程：</li>
</ul>
<p><code>set follow-fork-mod [parent(default) | child]</code></p>
<ul>
<li>设置调试模式：</li>
</ul>
<p><code>set detach-on-fork [on(default) | off]</code></p>
<p>​	on：调试当前进程时，其他进程继续运行</p>
<p>​	off：调试当前进程时，其他进程被 GDB 挂起</p>
<ul>
<li>查看调试的进程：</li>
</ul>
<p><code>info inferiors</code></p>
<ul>
<li>切换当前调试的进程：</li>
</ul>
<p><code>inferior 编号</code>（若切换的进程被挂起，切换后先 c ）</p>
<ul>
<li>使进程脱离 GDB 调试：</li>
</ul>
<p><code>detach inferiors id</code></p>
<h2 id="2-4-exec函数族"><a href="#2-4-exec函数族" class="headerlink" title="2.4 exec函数族"></a>2.4 exec函数族</h2><p>c++有函数重载，c语言没有；</p>
<p>函数族即一系列功能相似的函数。</p>
<ul>
<li>exec 函数族的作用是根据指定文件名找到可执行文件，并用它来取代调用进程的内容，换句话说，就是在调用进程内部执行一个可执行文件。（实际应用时一般在子进程中执行 exec函数族）</li>
<li>exec 函数族的函数执行成功后不会返回，因为调用进程的实体，包括代码段、数据段和堆栈等都已经被新的内容取代，只留下进程ID等一些表面上的信息仍保持原样。只有调用失败了，才会返回－１，从原程序的调用点接着往下执行。</li>
</ul>
<p><img src="/?utm_source=gold_browser_extension/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/Users\86191\Desktop\myblog\mang959595.github.io\source_posts\第二章Linux多进程\image-20230205022237610.png" alt="image-20230205022237610"></p>
<p><strong>exec函数族</strong></p>
<blockquote>
<p>exec后的字母表示传参方式和搜索规则</p>
<ul>
<li><p>l(list)	参数地址列表，以空指针结尾</p>
</li>
<li><p>v(vector)  存有个参数地址的指针数组的地址</p>
</li>
<li><p>p(path)	按 PATH 环境变量指定的目录搜索可执行文件</p>
</li>
<li><p>e(environment) 存有环境变量字符串地址的指针数组的地址</p>
</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ...<span class="comment">/* (char *) NULL */</span>)</span>；</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- path：需要指定的执行文件的路径或名称（相对路径或绝对路径）（推荐使用绝对路径）</span></span><br><span class="line"><span class="comment">		- arg：可执行文件的参数列表（第一个参数一般没什么作用，为了方便，一般写的是执行程序的名称，从第二个参数开始往后，就是程序执行所需的参数列表，并以 NULL 结尾（哨兵））</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		只有调用失败，才有返回值-1，并设置errno。</span></span><br><span class="line"><span class="comment">		调用成功没有返回值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg, ...<span class="comment">/* (char *) NULL */</span>)</span>；</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	会到环境变量中查找指定的可执行文件，如果找到了就执行，找不到就执行原程序</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- file：需要执行的可执行文件的文件名</span></span><br><span class="line"><span class="comment">		- arg：可执行文件的参数列表（第一个参数一般没什么作用，为了方便，一般写的是执行程序的名称，从第二个参数开始往后，就是程序执行所需的参数列表，并以 NULL 结尾（哨兵））</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		只有调用失败，才有返回值-1，并设置errno。</span></span><br><span class="line"><span class="comment">		调用成功没有返回值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ...<span class="comment">/*, (char *) NULL, char *const envp[] */</span>)</span>；</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *<span class="type">const</span> argv[])</span>；</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">用例：</span></span><br><span class="line"><span class="comment">	char * argv[] = &#123;&quot;ps&quot;, &quot;aux&quot;, NULL&#125;;</span></span><br><span class="line"><span class="comment">	execv(&quot;/bin/ps&quot;, arg);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[])</span>；</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">execvpe</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>；</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>；</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">用例：</span></span><br><span class="line"><span class="comment">	char * argv[] = &#123;&quot;ps&quot;, &quot;aux&quot;, NULL&#125;;</span></span><br><span class="line"><span class="comment">	char * envp[] = &#123;&quot;/home/nowcoder&quot;, &quot;/home/aaa&quot;, &quot;/home/bbb&quot;&#125;;</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	execve(&quot;ps&quot;, arg, envp);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="2-5-进程控制"><a href="#2-5-进程控制" class="headerlink" title="2.5 进程控制"></a>2.5 进程控制</h2><h3 id="进程退出"><a href="#进程退出" class="headerlink" title="进程退出"></a>进程退出</h3><p><strong>exit函数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#incldue <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> _exit(<span class="type">int</span> status);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- status：进程退出时的一个状态信息。父进程回收子进程资源的时候可以获取到。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	exit是标准C库的函数，比_exit多做了</span></span><br><span class="line"><span class="comment">	1.调用退出处理函数</span></span><br><span class="line"><span class="comment">	2.刷新I/O缓存</span></span><br><span class="line"><span class="comment">	3.关闭文件描述符</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/?utm_source=gold_browser_extension/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/Users\86191\Desktop\myblog\mang959595.github.io\source_posts\第二章Linux多进程\image-20230205024702546.png" alt="image-20230205024702546"></p>
<h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h3><p>父进程运行结束，但子进程还在运行，这样的子进程就成为孤儿进程（Orphan Process）</p>
<p>每当出现一个孤儿进程时，内核就把孤儿进程的父进程设置为init进程，而init进程会循环地 wait() 它的已经退出的子进程。（init进程会回收运行结束的孤儿进程）</p>
<p>没什么危害</p>
<h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><p>每个进程结束之后，会释放自己地址空间中的用户区数据，内核去的PCB则需要父进程去释放</p>
<p>子进程终止后，父进程尚未将其回收，子进程残留资源（PCB）存放于内核中，变成僵尸进程</p>
<ul>
<li>僵尸进程不能被 kill -9 杀死</li>
<li>如果父进程不调用 wait() 或 waitpid() ，那么保留的信息就不会释放，进程号会一直被占用</li>
<li>危害：系统的进程号有限，如果出现大量僵尸进程，会导致系统无法产生新的进程</li>
</ul>
<h3 id="进程回收"><a href="#进程回收" class="headerlink" title="进程回收"></a>进程回收</h3><p>在每个进程退出的时候，内核释放该进程所有的资源、包括打开的文件、占用的内存等。但是仍为其保留一定的信息，这些信息主要指 PCB 的信息（包括进程号、退出状态、运行时间等）</p>
<p>父进程可以通过 wait() 或 waitpid()得到子进程的退出状态，并彻底清除掉这个进程</p>
<ul>
<li>wait() 或 waitpid() 功能一样，区别在于： 	wait() 会阻塞；<br>waitpid() 可以设置不阻塞，且可以指定等待哪个子进程结束；</li>
<li>一次wait或waitpid调用只能清理一个子进程，清理多个子进程应该使用循环</li>
</ul>
<h4 id="wait函数"><a href="#wait函数" class="headerlink" title="wait函数"></a>wait函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *wstatus)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	功能：等待任意一个子进程结束，如果任意一个子进程结束了，此函数会回收子进程的资源。</span></span><br><span class="line"><span class="comment">	参数：int *wstatus</span></span><br><span class="line"><span class="comment">		进程退出时的状态信息，传入的是一个int指针，是一个传出参数</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		成功：返回被回收的子进程的id</span></span><br><span class="line"><span class="comment">		失败：返回-1（所有的子进程都结束了，调用函数失败）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	调用wait函数的进程会被挂起（阻塞），知道它的一个子进程退出或者收到一个不能被忽略的信号时才被唤醒（相当于继续往下执行）</span></span><br><span class="line"><span class="comment">	如果没有子进程了/子进程都结束了，函数立刻返回，返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>退出信息相关宏函数</strong></p>
<ul>
<li><p>​	函数					返回值</p>
<hr>
</li>
<li><p>WIFEXITED(status)	非0，进程正常退出</p>
</li>
<li><p>WEXITSTATUS(status)  如果上宏为真，获取进程退出的状态（exit的参数）</p>
</li>
<li><p>WIFSIGNALED(status)  非0，进程异常终止</p>
</li>
<li><p>WTERMSIG(status)     如果上宏为真，获取使进程终止的信号编号</p>
</li>
<li><p>WIFSTOPPED(status)   非0，进程处于暂停状态</p>
</li>
<li><p>WSTOPSIG(status)     如果上宏为真，获取使进程暂停的信号编号</p>
</li>
<li><p>WIFCONTINUED(status) 非0，进程暂停后已经继续运行</p>
</li>
</ul>
<h4 id="waitpid函数"><a href="#waitpid函数" class="headerlink" title="waitpid函数"></a>waitpid函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *wstatus, <span class="type">int</span> options)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	功能：回收指定进程号的子进程；可以设置是否阻塞。</span></span><br><span class="line"><span class="comment">	wait(&amp;wstatus); 等价于 waitpid(-1, &amp;wstatus, 0);</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- pid：指定子进程的id</span></span><br><span class="line"><span class="comment">			&gt; 0  ：某个子进程的id</span></span><br><span class="line"><span class="comment">			  0  ：回收当前进程组的所有子进程</span></span><br><span class="line"><span class="comment">			  -1 ：回收所有的子进程	（最常用）</span></span><br><span class="line"><span class="comment">			&lt; -1 ：某个进程组组id的绝对值，回收指定进程组中的子进程</span></span><br><span class="line"><span class="comment">		- wstatus：进程退出时的状态信息，传入的是一个int指针，是一个传出参数</span></span><br><span class="line"><span class="comment">		- options：设置阻塞或非阻塞</span></span><br><span class="line"><span class="comment">			0    ：阻塞</span></span><br><span class="line"><span class="comment">			宏值  ：WNOHANG 非阻塞（没有子进程退出的话立即返回）</span></span><br><span class="line"><span class="comment">				   WUNTRACED</span></span><br><span class="line"><span class="comment">				   WCONTINUED</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		&gt; 0 ：返回被回收的子进程的id</span></span><br><span class="line"><span class="comment">		= 0 ：options=WNOHANG时，表示还有子进程没有退出</span></span><br><span class="line"><span class="comment">		= -1：错误，或者没有子进程了</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	调用wait函数的进程会被挂起（阻塞），知道它的一个子进程退出或者收到一个不能被忽略的信号时才被唤醒（相当于继续往下执行）</span></span><br><span class="line"><span class="comment">	如果没有子进程了/子进程都结束了，函数立刻返回，返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h2 id="2-6-进程间通信"><a href="#2-6-进程间通信" class="headerlink" title="2.6 进程间通信"></a>2.6 进程间通信</h2><h3 id="2-6-1-进程间通信简介"><a href="#2-6-1-进程间通信简介" class="headerlink" title="2.6.1 进程间通信简介"></a>2.6.1 进程间通信简介</h3><p>不同的进程需要进行信息的交互和状态的传递等，因此需要进程间通信（IPC：Inter Processes Communication</p>
<p><strong>进程通信目的：</strong></p>
<ul>
<li>数据传输：一个进程需要将它的数据发送给另一个进程</li>
<li>通知事件：一个进程需要向另一个或一组进程发送信息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）</li>
<li>资源共享：多个进程之间共享同样的资源。（需要用到内核提供的互斥和同步机制）</li>
<li>进程控制：有些进程希望完全控制另一个进程的运行（如 Debug 进程gdb），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道其状态改变</li>
</ul>
<p><strong>Linux进程间通信的方式：</strong></p>
<p><img src="/?utm_source=gold_browser_extension/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/Users\86191\Desktop\myblog\mang959595.github.io\source_posts\第二章Linux多进程\image-20230205232903586.png" alt="image-20230205232903586"></p>
<h3 id="2-6-2-匿名管道"><a href="#2-6-2-匿名管道" class="headerlink" title="2.6.2 匿名管道"></a>2.6.2 匿名管道</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>管道 也叫匿名管道。是 UNIX 系统 IPC 的最古老形式，所有的 UNIX 系统都支持这种通信机制。</p>
<p><strong>案例解析：</strong></p>
<p>​	统计一个目录中文件的数目命令：<code>ls | wc -l</code>	（管道符 | ）</p>
<p>为了执行该命令，shell 创建了两个进程分别执行 ls 和 wc</p>
<p><img src="/?utm_source=gold_browser_extension/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/Users\86191\Desktop\myblog\mang959595.github.io\source_posts\第二章Linux多进程\image-20230205233552602.png" alt="image-20230205233552602"></p>
<p>ls进程的标准输出 stdout 指向管道写入端</p>
<p>wc进程的标准输入 stdin 指向管道读取端</p>
<p><strong>特点</strong></p>
<ul>
<li>管道 其实是一个在<code>内核内存中</code>维护的缓冲器，这个缓冲器的存储能力是有限的，不同操作系统中可能不同</li>
<li>管道拥有文件的特质：读操作、写操作，<u>匿名管道没有文件实体，有名管道有文件实体，但不存储数据。</u>可以按照操作文件的方式操作管道</li>
<li>一个管道是一个<code>字节流</code>，使用管道时不存在消息或者消息边界的概念，从管道读取数据的进程可以读取任意大小的数据块，而不管写入进程写入管道的数据库的大小是多少</li>
<li>通过管道传递的数据是顺序的</li>
<li>在管道中的数据的传递方向是单向的，一端写入，一端读取，是半双工的（有两个传递方向，同一时刻内只能通一个方向）</li>
<li>从管道读取数据是一次性操作，数据一旦被读走，就从管道中被抛弃，释放空间以便写更多的数据，在管道中无法使用lseek()来随机访问数据</li>
<li>匿名管道只能在具有公共祖先的进程之间使用（父子进程共享文件描述符表，有相同的管道）</li>
</ul>
<p><img src="/?utm_source=gold_browser_extension/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/Users\86191\Desktop\myblog\mang959595.github.io\source_posts\第二章Linux多进程\image-20230206013639551.png" alt="image-20230206013639551"></p>
<p><strong>管道的数据结构</strong></p>
<p>环形队列（重复利用节点空间）</p>
<p><img src="/?utm_source=gold_browser_extension/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/Users\86191\Desktop\myblog\mang959595.github.io\source_posts\第二章Linux多进程\image-20230206014318131.png" alt="image-20230206014318131"></p>
<h4 id="管道的使用"><a href="#管道的使用" class="headerlink" title="管道的使用"></a>管道的使用</h4><ul>
<li><p>创建匿名管道</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	创建一个匿名管道，用于进程间通信</span></span><br><span class="line"><span class="comment">	参数： int pipefd[2]：传出参数</span></span><br><span class="line"><span class="comment">			pipefd[0] 管道的读端</span></span><br><span class="line"><span class="comment">			pipefd[1] 管道的写端</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		成功 0</span></span><br><span class="line"><span class="comment">		失败 -1</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	管道默认是阻塞的：</span></span><br><span class="line"><span class="comment">		如果管道中没有数据，read阻塞；</span></span><br><span class="line"><span class="comment">		如果管道满了，write阻塞；</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	注意：匿名管道只能用于具有关系的进程之间的通信（父子进程，兄弟进程...）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现：子进程发送数据给父进程，父进程读取到数据输出</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在fork之前创建管道</span></span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> ret = pipe(pipefd);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="comment">// 从管道的读取端读取数据</span></span><br><span class="line">        close(pipefd[<span class="number">1</span>]);</span><br><span class="line">        </span><br><span class="line">    	<span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> len = read(pipefd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent recv : %s, pid: %d\n&quot;</span>, buf, getpid());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        close(pipefd[<span class="number">0</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="type">char</span> *str = <span class="string">&quot;hello, i am child&quot;</span>;</span><br><span class="line">        write(pipefd[<span class="number">1</span>], str, <span class="built_in">strlen</span>(str));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看管道缓冲大小命令:<code>ulimit -a</code></p>
</li>
<li><p>查看管道缓冲大小函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">fpathconf</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> name)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	获取文件的配置信息值</span></span><br><span class="line"><span class="comment">	参数 name：宏值，表明要查看的内容</span></span><br><span class="line"><span class="comment">		_PC_PIPE_BUF</span></span><br><span class="line"><span class="comment">		更多参数参考文档</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>规定：</p>
<ul>
<li>使用匿名管道实际开发时，父子进程不相互收发数据，而是规定好一个进程读一个进程写</li>
<li>读的进程关闭写端；写的进程关闭读端；</li>
</ul>
<p><img src="/?utm_source=gold_browser_extension/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/Users\86191\Desktop\myblog\mang959595.github.io\source_posts\第二章Linux多进程\image-20230206022417540.png" alt="image-20230206022417540"></p>
</blockquote>
<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>实现<code>ps aux | grep xxx</code></p>
<p>父子进程间通信</p>
<ul>
<li><p>子进程：ps aux，结束后将数据发送给父进程</p>
</li>
<li><p>父进程：获取数据，并过滤</p>
<p>pipe()</p>
<p>execlp()</p>
<p>dup2() 子进程将标准输出 stdout_fileno 重定向到管道的写端</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建管道</span></span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> ret = pipe(fd);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="comment">// 关闭写端</span></span><br><span class="line">        close(fd[<span class="number">1</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从管道中读取</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> len = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>((len = read(fd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf)<span class="number">-1</span>)) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="comment">// 过滤数据并输出  过滤功能还没写          </span></span><br><span class="line">        	<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf); </span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="comment">// 子进程</span></span><br><span class="line">        <span class="comment">// 关闭读端</span></span><br><span class="line">        close(fd[<span class="number">0</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 文件描述符的重定向 stdout_fileno -&gt; fd[1]</span></span><br><span class="line">        dup2(fd[<span class="number">1</span>], STDOUT_FILENO);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 执行 ps aux</span></span><br><span class="line">        execlp(<span class="string">&quot;ps&quot;</span>, <span class="string">&quot;ps&quot;</span>, <span class="string">&quot;aux&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        perror(<span class="string">&quot;execlp&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   	<span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h4 id="管道读写特点和非阻塞的设置"><a href="#管道读写特点和非阻塞的设置" class="headerlink" title="管道读写特点和非阻塞的设置"></a>管道读写特点和非阻塞的设置</h4><p><strong>读写特点（阻塞I&#x2F;O下）</strong></p>
<ol>
<li>如果所有的指向 管道写端 的文件描述符都关闭了<code>（写端引用计数为0）</code>，有进程从管道的读端读数据，<code>那么管道中剩余的数据被读取以后，再次read会返回 0</code>，就像读到文件末尾一样。</li>
<li>如果有指向 管道写端 的文件描述符没有关闭<code>（写端引用计数大于0）</code>，而持有管道写端的进程也<code>没有往管道中写数据</code>，这时有进程从管道的读端读数据，<code>那么管道中剩余的数据被读取以后，再次read会阻塞</code>，直到管道中有数据可以读了才读取数据并返回。</li>
<li>如果所有的指向 管道读端 的文件描述符都关闭了<code>（读端引用计数为0）</code>，这个时候向管道中写数据，那么该进程会收到一个信号 SIGPIPE ，通常会导致进程异常终止。</li>
<li>如果有指向 管道读端 的文件描述符没有关闭<code>（读端引用计数大于0）</code>，而持有管道读端的进程也<code>没有往管道中读数据</code>，这时有进程从管道的写端写数据，<code>那么管道被写满的时候，再次调用write会阻塞</code>，直到管道中有空位置才能再次写入数据并返回。</li>
</ol>
<blockquote>
<p><strong>总结：</strong></p>
<p>​	读管道：</p>
<p>​		管道中有数据，read读取数据，返回实际读到的字节数。</p>
<p>​		管道中无数据：</p>
<p>​			写端被全部关闭，read返回0（相当于读到文件的末尾）<br>​			写端没有完全关闭，read阻塞等待</p>
<p>​	</p>
<p>​	写管道：</p>
<p>​		管道读端全部被关闭，进程异常终止（进程收到 SIGPIPE 信号）</p>
<p>​		管道读端没有全部关闭：</p>
<p>​			管道已满，write阻塞<br>​			管道未满，write将数据写入，返回实际写入的字节数</p>
</blockquote>
<p><strong>非阻塞设置</strong></p>
<p>fcntl函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> flags = fcntl(fd[<span class="number">0</span>], F_GETFL); <span class="comment">// 获取原来的flag</span></span><br><span class="line">flags |= O_NONBLOCK;			 <span class="comment">// 修改flag</span></span><br><span class="line">fcntl(fd[<span class="number">0</span>], F_SETFL, flags)；	<span class="comment">// 设置新的flag</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="2-6-3-有名管道"><a href="#2-6-3-有名管道" class="headerlink" title="2.6.3 有名管道"></a>2.6.3 有名管道</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><ul>
<li>匿名管道由于无名，只能用于亲缘关系的进程间通信。为了扩大应用，提出了 有名管道 （FIFO），也叫命名管道，FIFO文件。</li>
<li>有名管道（FIFO）不同于匿名管道之处，<u>在于它提供了一个路径名与之关联</u>，以FIFO的文件形式存在于文件系统中，并且打开方式与普通文件相同。只要可以访问该路径，就能彼此通过有名管道相互通信，使得不相关的进程也能通信。</li>
</ul>
<p><strong>与匿名管道的不同之处：</strong></p>
<ol>
<li>FIFO 在文件系统中作为一个特殊文件存在，但 FIFO 中的内容却存放在内核区的内存中。</li>
<li>当使用 FIFO 的进程推出后，FIFO 文件将保存在文件系统中以便以后调用。</li>
<li>FIFO 有名，不相关的进程可以通过打开有名管道进行通信。</li>
</ol>
<h4 id="有名管道的使用"><a href="#有名管道的使用" class="headerlink" title="有名管道的使用"></a>有名管道的使用</h4><ul>
<li><p>通过命令创建：<code>mkfifo name</code></p>
</li>
<li><p>通过函数创建</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys.types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys.stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- pathname：管道名称的路径</span></span><br><span class="line"><span class="comment">		- mode：文件权限，和 open 的 mode 一样。</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		成功 0，失败 -1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>一旦使用 mkfifo 创建了一个 FIFO ，就可以使用 open 打开，以及使用常见的 I&#x2F;O 函数，如：read，write，unlink，close…</p>
</li>
<li><p>FIFO 严格遵循先进先出，读操作 总是从开始处返回数据，写操作 则把数据添加到末尾。所以不支持 lseek()等文件定位操作。</p>
</li>
</ul>
<h4 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h4><p><strong>基本使用</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 向管道中写数据</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断文件是否存在</span></span><br><span class="line">    <span class="type">int</span> ret = access(<span class="string">&quot;test&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">// 管道还未创建</span></span><br><span class="line">        ret = mkfifo(<span class="string">&quot;test&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打开管道（只写方式）</span></span><br><span class="line">    <span class="type">int</span> fd = open)<span class="string">&quot;test&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 写数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(buf,<span class="string">&quot;hello %d\n&quot;</span>, i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;write data: %s\n&quot;</span>, buf);</span><br><span class="line">        write(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    close(fd);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从管道中读取数据</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main1</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打开管道文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;test&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="type">int</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取数据</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> len = read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 写端断开连接了</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv buf: %s\n&quot;</span>,buf);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    close(fd);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>open 注意事项：</p>
<ol>
<li>一个为只读而打开一个管道的进程会阻塞，直到另外一个进程为只写打开管道</li>
<li>一个为只写而打开一个管道的进程会阻塞，直到另外一个进程为只读打开管道</li>
</ol>
</blockquote>
<blockquote>
<p><strong>读管道：</strong></p>
<p>​	管道中有数据，read发怒hi实际督导的字节数</p>
<p>​	管道中无数据：<br>​		管道写端被全部关闭，read返回0 （相当于读到文件末尾）<br>​		管道写端没有全部关闭，read阻塞等待</p>
<p><strong>写管道：</strong></p>
<p>​	管道读端被全部关闭，进程异常终止（收到 SIGPIPE 信号）</p>
<p>​	管道读端没有全部关闭：<br>​		管道已满，write会阻塞<br>​		管道未满，write写入数据，返回实际写入的字节数</p>
</blockquote>
<p><strong>有名管道实现简单聊天</strong></p>
<p>只能交替地接收和发送</p>
<p><img src="/?utm_source=gold_browser_extension/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/Users\86191\Desktop\myblog\mang959595.github.io\source_posts\第二章Linux多进程\image-20230206212504676.png" alt="image-20230206212504676"></p>
<p>进程A</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.判断有名管道文件是否存在</span></span><br><span class="line">    <span class="type">int</span> ret = access(<span class="string">&quot;fifo1&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">// 文件不存在则创建</span></span><br><span class="line">        ret = mkfifo(<span class="string">&quot;fifo1&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">    	<span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">			perror(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">	ret = access(<span class="string">&quot;fifo2&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">// 文件不存在则创建</span></span><br><span class="line">        ret = mkfifo(<span class="string">&quot;fifo2&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">    	<span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">			perror(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 以只写方式打开管道 fifo1</span></span><br><span class="line">    <span class="type">int</span> fdw = open(<span class="string">&quot;fifo1&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span>(fdw == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开管道fifo1成功，等待写入...\n&quot;</span>)；</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 以只读方式打开管道 fifo2</span></span><br><span class="line">    <span class="type">int</span> fdr = open(<span class="string">&quot;fifo2&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fdr == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开管道fifo2成功，等待读取...\n&quot;</span>)；</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 循环写读数据</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line">    	<span class="comment">// 获取标准输入的数据    </span></span><br><span class="line">        fgets(buf, <span class="number">128</span>, <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="comment">// 发送信息，写入数据</span></span><br><span class="line">        ret = write(fdw, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 接收信息，读取数据</span></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line">        ret = read(fdr, buf, <span class="number">128</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">           	<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;buf: %s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    close(fdr);</span><br><span class="line">    close(fdw);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>进程B </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.判断有名管道文件是否存在</span></span><br><span class="line">    <span class="type">int</span> ret = access(<span class="string">&quot;fifo1&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">// 文件不存在则创建</span></span><br><span class="line">        ret = mkfifo(<span class="string">&quot;fifo1&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">    	<span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">			perror(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">	ret = access(<span class="string">&quot;fifo2&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">// 文件不存在则创建</span></span><br><span class="line">        ret = mkfifo(<span class="string">&quot;fifo2&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">    	<span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">			perror(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 以只读方式打开管道 fifo1</span></span><br><span class="line">    <span class="type">int</span> fdw = open(<span class="string">&quot;fifo1&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fdw == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开管道fifo1成功，等待读取...\n&quot;</span>)；</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 以只写方式打开管道 fifo2</span></span><br><span class="line">    <span class="type">int</span> fdr = open(<span class="string">&quot;fifo2&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span>(fdr == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开管道fifo2成功，等待写入...\n&quot;</span>)；</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 循环读写数据</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 接收信息，读取数据</span></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line">        ret = read(fdr, buf, <span class="number">128</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">           	<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;buf: %s\n&quot;</span>, buf);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line">    	<span class="comment">// 获取标准输入的数据    </span></span><br><span class="line">        fgets(buf, <span class="number">128</span>, <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="comment">// 发送信息，写入数据</span></span><br><span class="line">        ret = write(fdw, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    close(fdr);</span><br><span class="line">    close(fdw);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-6-4-内存映射"><a href="#2-6-4-内存映射" class="headerlink" title="2.6.4 内存映射"></a>2.6.4 内存映射</h3><p>内存映射 Memory-mapped I&#x2F;O ,是将磁盘文件的数据映射到内存，用户通过修改内存就能修改磁盘文件。</p>
<p>映射的是进程的虚拟地址空间，映射位置是共享库的位置</p>
<p><img src="/?utm_source=gold_browser_extension/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/Users\86191\Desktop\myblog\mang959595.github.io\source_posts\第二章Linux多进程\image-20230207021339909.png" alt="image-20230207021339909"></p>
<p><strong>相关系统调用</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	将一个文件或设备的数据映射到内存当中</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- addr：传入NULL，由内核决定后续处理</span></span><br><span class="line"><span class="comment">		- length：要映射的数据长度，不能为0.建议使用文件的长度	（使用 stat 或 lseek 可以获取文件长度）</span></span><br><span class="line"><span class="comment">		- prot：对申请的内存映射区的操作权限（不能与打开的文件有权限冲突）</span></span><br><span class="line"><span class="comment">			PROT_NONE 无权限</span></span><br><span class="line"><span class="comment">			PROT_EXEC 可执行</span></span><br><span class="line"><span class="comment">			PROT_READ 可读</span></span><br><span class="line"><span class="comment">			PROT_WRITE 可写</span></span><br><span class="line"><span class="comment">			（要操作映射内存，必须有读权限）</span></span><br><span class="line"><span class="comment">		- flags：</span></span><br><span class="line"><span class="comment">			MAP_SHARED	映射区的数据会自动和磁盘文件进行同步，进程间通信，必须设置该选项</span></span><br><span class="line"><span class="comment">			MAP_PRIVATE	不同步，内存映射区的数据改变不会修改源文件，而会创建一个新的文件 （copy on write）</span></span><br><span class="line"><span class="comment">		- fd：需要映射的文件的文件描述符，通过 open 得到的。 注意：文件大小要大于0，且 open 指定的权限不能和 prot 冲突。</span></span><br><span class="line"><span class="comment">		- offset：偏移量，文件数据的起始位置偏移，一般不使用（必须是4k的整数倍，0表示不偏移）</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		成功，返回映射到的内存首地址（虚拟地址）</span></span><br><span class="line"><span class="comment">		失败，返回 MAP_FAILED 即（void *) -1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	释放内存映射</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- addr：要释放的内存的首地址</span></span><br><span class="line"><span class="comment">		- length：要释放的内存大小，要和mmap函数中的length参数值一致</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>实现进程间通信</strong></p>
<p>父子进程之间</p>
<blockquote>
<ul>
<li>在还没有子进程的时候<ul>
<li>通过唯一的父进程，先创建内存映射区</li>
</ul>
</li>
<li>有了内存映射区后，创建子进程</li>
<li>父子进程共享创建的内存映射区</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打开一个文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;test.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取文件大小</span></span><br><span class="line">    <span class="type">int</span> size = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建内存映射区</span></span><br><span class="line">    <span class="type">void</span> *ptr = mmap(<span class="literal">NULL</span>, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ptr == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(buf, (<span class="type">char</span> *)ptr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read data:%s\n&quot;</span>, buf);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">strcpy</span>((<span class="type">char</span> *)ptr, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关闭内存映射区</span></span><br><span class="line">    munmap(ptr, size);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>无关系的进程之间</p>
<blockquote>
<ul>
<li>准备一个大小不是0的磁盘文件</li>
<li>进程1 通过磁盘文件创建内存映射区</li>
<li>得到一个操作这块内存的指针</li>
<li>进程2 通过磁盘文件创建内存映射区</li>
<li>到到一个操作这块内存的指针</li>
<li>使用内存映射区通信</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main1</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打开一个文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;test.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取文件大小</span></span><br><span class="line">    <span class="type">int</span> size = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建内存映射区</span></span><br><span class="line">    <span class="type">void</span> *ptr = mmap(<span class="literal">NULL</span>, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ptr == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过获取文件数据</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(buf, (<span class="type">char</span> *)ptr);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;read data:%s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭内存映射区</span></span><br><span class="line">    munmap(ptr, size);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main2</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打开一个文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;test.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取文件大小</span></span><br><span class="line">    <span class="type">int</span> size = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建内存映射区</span></span><br><span class="line">    <span class="type">void</span> *ptr = mmap(<span class="literal">NULL</span>, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ptr == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 写入内存，修改文件</span></span><br><span class="line">    <span class="built_in">strcpy</span>((<span class="type">char</span> *)ptr, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关闭内存映射区</span></span><br><span class="line">    munmap(ptr, size);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p><strong>思考问题</strong></p>
<ol>
<li>如果对mmap的返回值 (ptr) 做++操作 (ptr++) ，munmap能否成功</li>
</ol>
<blockquote>
<p>可以 ptr++; 但 munmap 会失败，只能通过首地址释放（提前保存）</p>
</blockquote>
<ol start="2">
<li>如果 open 时 O_RDONLY ，mmap 时 prot 参数指定 PROT_READ | PROT_WRITE 会怎样</li>
</ol>
<blockquote>
<p>错误，会返回MAP_FAILED。</p>
<p>open 函数中的权限要满足 mmap，即 prot &lt;&#x3D; open 的权限参数</p>
</blockquote>
<ol start="3">
<li>如果文件偏移量为1000会怎样</li>
</ol>
<blockquote>
<p>偏移量必须是 4k 的整数倍，否则会返回 MAP_FAILED</p>
</blockquote>
<ol start="4">
<li>mmap什么情况下会调用失败</li>
</ol>
<blockquote>
<ul>
<li>第二个参数：length &#x3D; 0</li>
<li>第三个参数：prot</li>
<li>没有指定读权限</li>
<li>参数 fd 在 open 时的权限不满足当前 prot</li>
</ul>
</blockquote>
<ol start="5">
<li>可以oepn的时候O_CREAT一个新文件来创建映射区吗</li>
</ol>
<blockquote>
<p>可以，但是创建的文件大小如果为 0 ，则不行</p>
<p>可以对新的文件进行拓展</p>
<pre><code>- lseek()
- truncate()
</code></pre>
</blockquote>
<ol start="6">
<li>mmap后关闭文件描述符，对mmap映射有没有影响</li>
</ol>
<blockquote>
<p>​	int fd &#x3D; open(“xxx”);</p>
<p>​	mmap(…, fd, …);</p>
<p>​	close(fd);</p>
<p>映射区还存在，创建的映射区的fd被关闭，没有任何影响</p>
</blockquote>
<ol start="7">
<li>对ptr越界操作会怎样</li>
</ol>
<blockquote>
<p>​	void * ptr &#x3D; mmap(NULL, 100, …);</p>
<p>越界操作会引发段错误</p>
</blockquote>
<p>除了进程间通信，还可以用来实现 <strong>文件复制</strong></p>
<ol>
<li>对原始的文件进行内存映射</li>
<li>创建新文件（并拓展</li>
<li>把新文件的数据映射到内存中</li>
<li>通过内存拷贝将第一个文件的数据拷贝到新的文件内存中</li>
<li>释放资源</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mmap.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对原始的文件进行内存映射</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;ori.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取原始文件大小</span></span><br><span class="line">    <span class="type">int</span> len = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个新的文件</span></span><br><span class="line">	<span class="type">int</span> fd1 = open(<span class="string">&quot;cpy.txt&quot;</span>, O_RDWR | O_CREAT, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd1 == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对新创建的文件进行拓展</span></span><br><span class="line">    truncate(<span class="string">&quot;cpy.txt&quot;</span>, len);</span><br><span class="line">    write(fd1, <span class="string">&quot; &quot;</span>, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分别做内存映射</span></span><br><span class="line">    <span class="type">void</span> *ptr = mmap(<span class="literal">NULL</span>,len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="type">void</span> *ptr1 = mmap(<span class="literal">NULL</span>,len, PROT_READ | PROT_WRITE, MAP_SHARED, fd1, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ptr == MAP_FAILED || ptr1 == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 内存拷贝</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr1, ptr, len);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放资源	（习惯上，先打开的后释放）</span></span><br><span class="line">    munmap(ptr1, len);</span><br><span class="line">    munmap(ptr, len);    </span><br><span class="line">    </span><br><span class="line">    close(fd1);</span><br><span class="line">    close(fd);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p><strong>匿名映射</strong>(用于通信)</p>
<p>不需要文件实体进行内存映射，只能用于有关系的进程之间。</p>
<p>mmap 需要打开 <code>MAP_ANONYMOUS</code> 选项</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mmap.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建匿名内存映射区</span></span><br><span class="line">    <span class="type">int</span> len = <span class="number">4096</span>;</span><br><span class="line">    <span class="type">void</span> *ptr = mmap(<span class="literal">NULL</span>, len, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS，<span class="number">-1</span>， <span class="number">0</span>)；</span><br><span class="line">    <span class="keyword">if</span>(ptr == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 父子进程通信</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">strcpy</span>((<span class="type">char</span> *)ptr, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, (<span class="type">char</span> *)ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="type">int</span> ret = munmap(ptr, len);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;munmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<blockquote>
<p>与直接修改文件相比，在内存修改速度更快 </p>
</blockquote>
<h3 id="2-6-5-信号"><a href="#2-6-5-信号" class="headerlink" title="2.6.5 信号"></a>2.6.5 信号</h3><h4 id="信号概述"><a href="#信号概述" class="headerlink" title="信号概述"></a>信号概述</h4><p>信号是 Linux 进程通信最古老的方式之一，是事件发生时对进程的通知机制，有时又称为 <code>软件中断</code> ，它是在软件层次上对中断机制的一种模拟，是一种 <code>异步</code> 通信的方式。</p>
<p>信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断，转而处理某一个突发事件。</p>
<p>发往进程的诸多信号，通常都是源于<code>内核</code>。引发内核为进程产生信号的各类事件如下：</p>
<ul>
<li>对于前台进程，用户可以通过输入特殊的终端字符来发送信号。比如 Ctrl+C 通常会给进程发送一个中断信号。</li>
<li>硬件发生异常，即硬件检测到一个错误条件并通知内核，随机再由内核发送相应信号给相关进程。比如执行一条异常的机器语言指令，如除以0，或者引用了无法访问的内存区域。</li>
<li>系统状态的变化，比如 alarm 定时器到期将引起 SIGALRM 信号、进程执行的CPU时间超限、或者该进程的某个子进程退出。</li>
<li>运行 kill 命令或调用 kill 函数。</li>
</ul>
<p><strong>使用信号的两个目的</strong></p>
<ul>
<li>让进程知道已经发生了一个特定的事情</li>
<li>强迫进程执行它自己代码中的信号处理程序</li>
</ul>
<p><strong>特点</strong>：</p>
<ul>
<li>简单</li>
<li>不能携带大量信息</li>
<li>满足某个特定条件才发送</li>
<li>优先级比较高</li>
</ul>
<p>查看系统定义的信号列表：<code>kill -l</code></p>
<blockquote>
<p>前31个信号为常规信号，其余为实时信号</p>
</blockquote>
<p>查看信号的详细信息：<code>man 7 signal</code></p>
<p><img src="/?utm_source=gold_browser_extension/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/Users\86191\Desktop\myblog\mang959595.github.io\source_posts\第二章Linux多进程\image-20230207074413475.png" alt="image-20230207074413475"></p>
<p><img src="/?utm_source=gold_browser_extension/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/Users\86191\Desktop\myblog\mang959595.github.io\source_posts\第二章Linux多进程\image-20230207074659817.png" alt="image-20230207074659817"></p>
<p><img src="/?utm_source=gold_browser_extension/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/Users\86191\Desktop\myblog\mang959595.github.io\source_posts\第二章Linux多进程\image-20230207074814071.png" alt="image-20230207074814071"></p>
<p><img src="/?utm_source=gold_browser_extension/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/Users\86191\Desktop\myblog\mang959595.github.io\source_posts\第二章Linux多进程\image-20230207074951533.png" alt="image-20230207074951533"></p>
<p>进程的5个<strong>默认处理动作</strong></p>
<ul>
<li><p>Term 终止进程</p>
</li>
<li><p>Ign 当前进程忽略掉这个信号</p>
</li>
<li><p>Core 终止进程，并生成一个Core文件（保存进程异常退出的错误信息）</p>
<blockquote>
<p>通过 unlimit -c xxx 设置 core 文件生成</p>
<p>通过 gdb 打开生成的 core 文件</p>
</blockquote>
</li>
<li><p>Stop 暂停当前进程</p>
</li>
<li><p>Cont 继续执行当前被暂停的进程</p>
</li>
</ul>
<p>信号的3种<strong>状态</strong>：产生、未决、递达</p>
<blockquote>
<p>SIGKILL 和 SIGSTOP 信号不能被捕捉、阻塞或者忽略，只能执行默认动作</p>
</blockquote>
<h4 id="kill、raise、abort-函数"><a href="#kill、raise、abort-函数" class="headerlink" title="kill、raise、abort 函数"></a>kill、raise、abort 函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	给某个进程pid，发送某个信号sig</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- pid ：目标进程的 id</span></span><br><span class="line"><span class="comment">			&gt; 0 : 将信号发送给指定进程</span></span><br><span class="line"><span class="comment">			= 0 : 将信号发送给当前进程的进程组</span></span><br><span class="line"><span class="comment">			= -1 : 将信号发生给每一个有权限接收这个信号的进程</span></span><br><span class="line"><span class="comment">			&lt; -1 : 这个pid=某个进程组的gid取反</span></span><br><span class="line"><span class="comment">		- sig ：需要发送的信号编号或宏值，0表示不发送任何信号</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">raise</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	给当前进程发送某个信号sig</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- sig ：需要发送的信号编号或宏值，0表示不发送任何信号</span></span><br><span class="line"><span class="comment">		返回值：成功 0 ，失败 非 0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">abort</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	发送 SIGABRT 信号给当前进程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="alarm-函数"><a href="#alarm-函数" class="headerlink" title="alarm 函数"></a>alarm 函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(unsigner <span class="type">int</span> seconds)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	设置定时器（闹钟）。函数调用后开始倒计时，当计时为0时，函数会给当前进程发送一个 SIGALARM 信号。</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- seconds：倒计时的时常，单位秒。若为0，则定时器无效（可以用 alarm(0); 取消定时器）</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		- 之前没有定时器，返回0</span></span><br><span class="line"><span class="comment">		- 之前有定时器，返回定时器剩余的时间</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	SIGALARM ： 默认终止当前的进程。</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	每一个进程都有且只有唯一的一个定时器。</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<blockquote>
<p>程序运行的实际时间 &#x3D; 内核时间 + 用户时间 + 切换、文件IO等消耗的时间</p>
</blockquote>
<blockquote>
<p>定时器与进程的状态无关。（采用自然定时法，无论进程出于什么状态，alarm都会计时）</p>
</blockquote>
<h4 id="setitimer-定时器函数"><a href="#setitimer-定时器函数" class="headerlink" title="setitimer 定时器函数"></a>setitimer 定时器函数</h4><p>周期性的定时</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时器值结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">it_interval</span>;</span>	<span class="comment">// 每个间隔的时间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">it_value</span>;</span>	<span class="comment">// 延迟多长时间启动定时器</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 时间值结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">    <span class="type">time_t</span> tv_sec;		<span class="comment">// seconds s</span></span><br><span class="line">    <span class="type">suseconds_t</span> tv_usec;	<span class="comment">// microseconds us</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setitimer</span><span class="params">(<span class="type">int</span> which, <span class="type">const</span> <span class="keyword">struct</span> itimerval *new_val, <span class="keyword">struct</span> itimerval *old_value)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	设置定时器（闹钟），替代 alarm 函数。精度微妙us，周期性计时。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- which : 定时器以什么时间计时</span></span><br><span class="line"><span class="comment">			ITIMER_REAL : 真实时间，时间到则发送SIGALARM ，常用</span></span><br><span class="line"><span class="comment">			ITIMER_VIRTUAL : 用户时间，时间到则发送 SIGVTALRM</span></span><br><span class="line"><span class="comment">			ITIMER_PROF : 以该进程在用户态和内核态下所消耗的时间来计算，时间到则发送 SIGPROF</span></span><br><span class="line"><span class="comment">			</span></span><br><span class="line"><span class="comment">		- new_val : 设置定时器的属性</span></span><br><span class="line"><span class="comment">		- old_value : 记录上一次的定时的时间参数，一般不使用，指定 NULL</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		成功 0 ，失败 -1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="signal-信号捕捉函数"><a href="#signal-信号捕捉函数" class="headerlink" title="signal 信号捕捉函数"></a>signal 信号捕捉函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	设置某个信号的捕捉行为</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- signum ： 要捕捉的信号</span></span><br><span class="line"><span class="comment">		- handler ： 捕捉到信号后的处理</span></span><br><span class="line"><span class="comment">			可以是：</span></span><br><span class="line"><span class="comment">			SIG_IGN : 忽略</span></span><br><span class="line"><span class="comment">			SIG_DEL : 使用信号默认的行为</span></span><br><span class="line"><span class="comment">			回调函数 ： 由内核调用，程序员负责实现其功能</span></span><br><span class="line"><span class="comment">		回调函数：</span></span><br><span class="line"><span class="comment">			- 由程序员实现，提前准备好的，函数的类型根据实际需求，和函数指针的定义</span></span><br><span class="line"><span class="comment">			- 不是程序员调用，而是当信号产生，由内核调用</span></span><br><span class="line"><span class="comment">			- 函数指针是实现回调的手段，函数实现之后，将函数名放到函数指针的位置即可</span></span><br><span class="line"><span class="comment">			</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		成功，返回上一次注册的信号处理函数的地址，若是第一次则返回 NULL</span></span><br><span class="line"><span class="comment">		失败，返回 SIG_ERR ，并设置errno</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<blockquote>
<p>SIGKILL 和 SIGSTOP 信号不能被捕捉、阻塞或者忽略，只能执行默认动作</p>
</blockquote>
<p><strong>案例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myalarm</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sss\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//延迟3秒后启动间隔为2秒的定时器,启动时也会发送信号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册信号捕捉</span></span><br><span class="line">    <span class="comment">// signal(SIGALARM, SIG_IGN);</span></span><br><span class="line">    <span class="comment">// signal(SIGALARM, SIG_DEL);</span></span><br><span class="line">    <span class="comment">// void (* sighandler_t)(int); 函数指针</span></span><br><span class="line">    <span class="type">sighandler_t</span> ret1 = signal(SIGALARM, myalarm);</span><br><span class="line">    <span class="keyword">if</span>(ret1 == SIG_ERR) &#123;</span><br><span class="line">        perror(<span class="string">&quot;signal&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>)；</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">new_val</span>;</span></span><br><span class="line">    <span class="comment">// 间隔时间</span></span><br><span class="line">    new_val.it_interval.tv_sec = <span class="number">2</span>;</span><br><span class="line">    new_val.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 延迟时间</span></span><br><span class="line">    new_val.it_value.tv_sec = <span class="number">3</span>;</span><br><span class="line">    new_val.it.value.tv_usec = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> ret2 = setitimer(ITIMER_REAL, &amp;new_value, <span class="literal">NULL</span>);		<span class="comment">// 非阻塞的</span></span><br><span class="line">    <span class="keyword">if</span>(ret2 == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;setitimer&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="信号集及相关函数"><a href="#信号集及相关函数" class="headerlink" title="信号集及相关函数"></a>信号集及相关函数</h4><p><strong>信号集</strong></p>
<ul>
<li>许多信号相关的系统调用都需要能表示一组不同的信号，多个信号可使用一个称之为信号集的数据结构来表示，其系统数据类型为 sigset_t</li>
<li>在 PCB 中有两个非常重要的信号集。一个称之为“阻塞信号集”，另一个称之为“未决信号集”。这两个信号集都是内核使用位图机制来实现的，但操作系统不允许我们直接对这两个信号集进行位操作，而需自定义另外一个集合，借助信号集操作函数来对 PCB 中的两个信号集进行修改。</li>
<li>”未决“，是一种状态，指的是<u>从信号的产生到信号被处理前</u>的这一段时间。</li>
<li>”阻塞“，是一个开关动作，指的是阻止信号被处理，但不是阻止信号产生。  </li>
<li>信号的阻塞就是让系统暂时保留信号，留待以后发送。由于另外有办法让系统忽略信号，所以一般情况下信号的阻塞只是暂时的，只是为了防止信号打断敏感的操作。</li>
</ul>
<p><strong>默认</strong></p>
<p><img src="/?utm_source=gold_browser_extension/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/Users\86191\Desktop\myblog\mang959595.github.io\source_posts\第二章Linux多进程\image-20230207122515067.png" alt="image-20230207122515067"></p>
<p><strong>操作信号集的函数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">//以下信号集相关的函数都是对自定义的信号集（参数set）进行操作</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	清空信号集中的数据，将所有标志位置 0</span></span><br><span class="line"><span class="comment">	参数：	set 要操作的信号集</span></span><br><span class="line"><span class="comment">	返回值：成功0，失败-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	将信号集中的所有标志位置 1</span></span><br><span class="line"><span class="comment">	参数：	set 要操作的信号集</span></span><br><span class="line"><span class="comment">	返回值：成功0，失败-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	设置信号集中的某一个信号对应得标志位为 1 ，表示阻塞这个信号</span></span><br><span class="line"><span class="comment">	参数：	</span></span><br><span class="line"><span class="comment">		- set 要操作的信号集</span></span><br><span class="line"><span class="comment">		- signum 需要设置的信号</span></span><br><span class="line"><span class="comment">	返回值：成功0，失败-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigdelset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	设置信号集中的某一个信号对应得标志位为 0 ，表示不阻塞这个信号</span></span><br><span class="line"><span class="comment">	参数：	</span></span><br><span class="line"><span class="comment">		- set 要操作的信号集</span></span><br><span class="line"><span class="comment">		- signum 需要设置的信号</span></span><br><span class="line"><span class="comment">	返回值：成功0，失败-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	判断某个信号是否阻塞</span></span><br><span class="line"><span class="comment">	参数：	</span></span><br><span class="line"><span class="comment">		- set 要操作的信号集</span></span><br><span class="line"><span class="comment">		- signum 需要判断的信号</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		- 1 ，signum被阻塞</span></span><br><span class="line"><span class="comment">		- 0 ，signum不阻塞</span></span><br><span class="line"><span class="comment">		- -1，调用失败</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="sigprocmask-函数"><a href="#sigprocmask-函数" class="headerlink" title="sigprocmask 函数"></a>sigprocmask 函数</h4><p>将自己设置好的信号集应用到内核信号集中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oldset)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	将自定义信号集中的数据设置到内核中（设置阻塞，解除阻塞，替换）</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- how  如何对内和阻塞信号集进行处理</span></span><br><span class="line"><span class="comment">			SIG_BLOCK：将用户设置的阻塞信号集添加到内核中，内核中原来的数据不变	（假设内核中默认的阻塞信号集是mask，则令 mask | set ）</span></span><br><span class="line"><span class="comment">			SIG_UNBLOCK：根据用户设置的数据，对内核中的数据进行解除阻塞  （ mask &amp;= ~set ）</span></span><br><span class="line"><span class="comment">			SIG_SETMASK: 覆盖内核中原来的值</span></span><br><span class="line"><span class="comment">		- set  已经初始化的用户自定义的信号集</span></span><br><span class="line"><span class="comment">		- oldset  保存设置之前的内核中的阻塞信号集的状态，可以是NULL</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		成功 0</span></span><br><span class="line"><span class="comment">		失败 -1</span></span><br><span class="line"><span class="comment">			设置错误号：EFAULT、EINVAL</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigpending</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	获取内核中的未决信号集</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	参数 : set  传出参数，保存的是内存中的未决信号集的信息</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	返回值：成功0，失败-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="sigaction-信号捕捉函数"><a href="#sigaction-信号捕捉函数" class="headerlink" title="sigaction 信号捕捉函数"></a>sigaction 信号捕捉函数</h4><p>跟 signal 函数作用类似</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> (*sa_handler)(<span class="type">int</span>);	<span class="comment">// 函数指针，指向的函数就是回调函数</span></span><br><span class="line">    <span class="type">void</span> (*sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span> *, <span class="type">void</span> *);		<span class="comment">// 不常用，需要就看看查文档</span></span><br><span class="line">    <span class="type">sigset_t</span> sa_mask;	<span class="comment">// 临时阻塞信号集，在信号捕捉函数执行过程中，临时阻塞某些信号</span></span><br><span class="line">    <span class="type">int</span> sa_flags;	<span class="comment">// 决定使用哪一个信号处理函数（ 0 表示使用 sa_handler，SA_SIGINFO 表示使用sa_sigaction</span></span><br><span class="line">    <span class="type">void</span> (*sa_restorer)(<span class="type">void</span>);	<span class="comment">// 废弃</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction *act, <span class="keyword">struct</span> sigaction *oldact)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	检查或改变信号的处理。信号捕捉</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- signum  指定的信号（ 除了SIGKILL 和 SIGSTOP ）</span></span><br><span class="line"><span class="comment">		- act  捕捉到信号后相应的处理动作</span></span><br><span class="line"><span class="comment">		- oldact  上一次对信号捕捉设置的处理动作，一般不使用，传递 NULL</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		成功 0</span></span><br><span class="line"><span class="comment">		失败 -1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<blockquote>
<p>由于编程标准原因，尽量使用 sigaction</p>
</blockquote>
<p>如果在回调函数执行过程中又收到信号，则会阻塞回调函数优先处理信号（解决方案：设置临时阻塞信号集）</p>
<p><strong>内核实现信号捕捉的过程</strong></p>
<p><img src="/?utm_source=gold_browser_extension/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/Users\86191\Desktop\myblog\mang959595.github.io\source_posts\第二章Linux多进程\image-20230207223806887.png" alt="image-20230207223806887"></p>
<blockquote>
<p>内核态的 do_signal() 和 sys_sigreturn()</p>
</blockquote>
<h4 id="SIGCHLD-信号"><a href="#SIGCHLD-信号" class="headerlink" title="SIGCHLD 信号"></a>SIGCHLD 信号</h4><p>产生条件：</p>
<ul>
<li>子进程终止时</li>
<li>子进程接收到 SIGSTOP 信号并停止时</li>
<li>子进程处在停止态，接收到 SIGCONT 信号唤醒时</li>
</ul>
<p>以上情况会由内核给父进程发送 SIGCHLD 信号，父进程默认忽略。</p>
<p><strong>解决僵尸进程问题</strong></p>
<ul>
<li>利用子进程终止时发送 SIGCHLD 信号</li>
<li>创建子进程前，先阻塞 SIGCHLD ，等回调函数注册完之后再解除阻塞</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子进程资源回收 回调函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">myFun</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;捕捉信号 %d\n&quot;</span>, num);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> ret = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG);</span><br><span class="line">        <span class="keyword">if</span>(ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child die %d\n&quot;</span>, ret);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 还有子进程存活</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="comment">// 没有子进程了，回收完毕</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打开阻塞</span></span><br><span class="line">    <span class="type">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>. SIGCHLD);</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;<span class="built_in">set</span>, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">        act.sa_flags = <span class="number">0</span>;</span><br><span class="line">        act.sa_handler = myFun;</span><br><span class="line">        sigemptyset(&amp;act.sa_mask);</span><br><span class="line">        sigaction(SIGCHLD, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 解除阻塞</span></span><br><span class="line">        sigprocmask(SIG_UNBLOCK, &amp;<span class="built_in">set</span>, <span class="literal">NULL</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child %d\n&quot;</span>, getpid());</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="2-6-6-共享内存"><a href="#2-6-6-共享内存" class="headerlink" title="2.6.6 共享内存"></a>2.6.6 共享内存</h3><p>效率最高的进程间通信方式</p>
<p>（内存映射需要用到文件）</p>
<ul>
<li>共享内存允许两个或多个进程共享<code>物理内存</code>的同一块区域（通常称为 段 )。由于一个共享内存段会被称为一个进程用户空间的一部分，因此这种 IPC 机制无需内核介入（实际上还是会用到系统调用，但相对较少）。所有需要做的就是让一个进程将数据复制进共享内存中，并且这部分数据会对其他所有共享同一个段的进程可用。</li>
<li>与管道等要求 发送进程 将数据从用户空间的缓冲区复制进内核内存 和 接收进程 将数据从内核内存复制进用户空间的缓冲区 的做法相比，共享内存方式速度更快。</li>
</ul>
<p><strong>使用步骤</strong></p>
<ol>
<li>调用 shmget() 创建一个新共享内存段或区的一个既有共享内存段的标识符（即由其他进程创建的共享内存段）。这个调用将返回后续调用中需要用到的共享内存标识符。</li>
<li>使用 shmat() 来附上共享内存段，也就是使该段成为调用进程的虚拟内存的一部分。</li>
<li>此刻在程序中可以像对待其他可用内存那样对待这个共享内存段。为引用这块共享内存，程序需要使用由 shmat() 调用返回的 addr 值，它是一个指向进程的虚拟地址空间中该共享内存段的起点的指针</li>
<li>调用 shmdt() 来分离共享内存段。调用后，进程就无法再引用这块共享内存。（这一步是可选的，并且在进程终止时会自动完成）</li>
<li>调用 shmctl() 来删除共享内存段。只有当当前所有附加内存段的进程都与之分离之后内存段才会销毁。（只有一个进程需要执行这一步）</li>
</ol>
<p><strong>函数接口</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	创建一个新的共享内存段，或者获取一个既有的共享内存段的标识</span></span><br><span class="line"><span class="comment">	新创建的内存段中的数据都会被初始化为0</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- key	key_t时整型，通过这个参数找到或者创建一个共享内存。一般使用16进制表示，非0值</span></span><br><span class="line"><span class="comment">		- size	共享内存的大小（实际按页划分）</span></span><br><span class="line"><span class="comment">		- shmflg 属性</span></span><br><span class="line"><span class="comment">			- 访问权限</span></span><br><span class="line"><span class="comment">			- 附加属性：创建/判断共享内存是否存在</span></span><br><span class="line"><span class="comment">				- 创建：IPC_CREAT</span></span><br><span class="line"><span class="comment">				- 判断共享内存是否存在：IPC_EXCL，需要和IPC_CREAT一起使用</span></span><br><span class="line"><span class="comment">				如 IPC_CREAT | IPC_EXCL | 0664</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		失败 -1，设置错误号</span></span><br><span class="line"><span class="comment">		成功 &gt;0,返回共享内存的引用 ID ，后面操作共享内存即通过这个值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">shmat</span><span class="params">(<span class="type">int</span> shmid, consst <span class="type">void</span> *shmaddr, <span class="type">int</span> shmflg)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	和当前的进程进行关联</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- shmid：共享内存的标识id，由shmget返回值获取</span></span><br><span class="line"><span class="comment">		- shmaddr：申请的共享内存的起始地址，指定NULL，由内核决定</span></span><br><span class="line"><span class="comment">		- shmflg：对共享内存的操作</span></span><br><span class="line"><span class="comment">			读：SHM_RDONLY，必须要有读权限</span></span><br><span class="line"><span class="comment">			读写：0</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		成功 返回共享内存的首地址</span></span><br><span class="line"><span class="comment">		失败 （void*)-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *shmaddr)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	解除当前进程和共享内存的关联</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- shmaddr：共享内存的首地址</span></span><br><span class="line"><span class="comment">	返回值：成功0，失败-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmctl</span><span class="params">(<span class="type">int</span> shmid, <span class="type">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	对共享内存进行操作（共享内存需要删除才会消失，创建共享内存的进程被销毁了对共享内存是没有影响的）</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- shmid：共享内存id</span></span><br><span class="line"><span class="comment">		- cmd：要做的操作</span></span><br><span class="line"><span class="comment">			IPC_STAT 获取共享内存的当前状态</span></span><br><span class="line"><span class="comment">			IPC_SET 设置共享内存的状态</span></span><br><span class="line"><span class="comment">			IPC_RMID 标记共享内存被销毁</span></span><br><span class="line"><span class="comment">		- buf：需要设置或者获取的共享内存的属性信息</span></span><br><span class="line"><span class="comment">			IPC_STAT：buf存储数据，传出参数</span></span><br><span class="line"><span class="comment">			IPC_SET：buf中需要初始化数据，设置到内核中，传入参数</span></span><br><span class="line"><span class="comment">			IPC_RMID：没有用，NULL</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<blockquote>
<p>shmid_ds结构体</p>
<p><img src="/?utm_source=gold_browser_extension/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/Users\86191\Desktop\myblog\mang959595.github.io\source_posts\第二章Linux多进程\image-20230208120249528.png" alt="image-20230208120249528"></p>
</blockquote>
<p><strong>案例</strong></p>
<p>write.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个共享内存</span></span><br><span class="line">    <span class="type">int</span> shmid = shmget(<span class="number">100</span>, <span class="number">0</span>, IPC_CREAT);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 和当前进程进行关联</span></span><br><span class="line">    <span class="type">void</span> *ptr = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 写数据</span></span><br><span class="line">    <span class="type">char</span> *str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, str, <span class="built_in">strlen</span>(str)+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 暂停一下</span></span><br><span class="line">    getchar();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解除关联</span></span><br><span class="line">    shmdt(ptr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除共享内存</span></span><br><span class="line">    shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>read.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取一个共享内存</span></span><br><span class="line">    <span class="type">int</span> shmid = shmget(<span class="number">100</span>, <span class="number">4096</span>, IPC_CREAT | <span class="number">0664</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 和当前进程进行关联</span></span><br><span class="line">    <span class="type">void</span> *ptr = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,(<span class="type">char</span> *)ptr);</span><br><span class="line">    <span class="comment">// 暂停一下</span></span><br><span class="line">    getchar();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解除关联</span></span><br><span class="line">    shmdt(ptr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除共享内存</span></span><br><span class="line">    shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<blockquote>
<p><strong>删除机制</strong></p>
<p>shmctl(shmid, IPC_RMID, NULL);</p>
<p>当关联进程数 &gt;&#x3D; 1 时，调用上面的函数删除共享内存并不会直接删除，而是把 key 值置为0，标记删除；</p>
<p>当关联进程数 &#x3D; 0 时，共享内存才会真正删除。</p>
</blockquote>
<p><strong>ftok函数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">key_t</span> <span class="title function_">ftok</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> proj_id)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	根据指定的路径名和 int 值，生成一个共享内存的 key ，可以作为shmget函数的参数</span></span><br><span class="line"><span class="comment">    参数：</span></span><br><span class="line"><span class="comment">		- pathname：指定一个存在的路径</span></span><br><span class="line"><span class="comment">		- proj_id：int类型的值（4B），但这个系统调用指挥使用其中1个字节</span></span><br><span class="line"><span class="comment">				   范围：0~255，一般指定一个字符 &#x27;a&#x27;</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<p><strong>问题</strong></p>
<ol>
<li>系统如何知道一块共享内存被多少个进程关联？<ul>
<li>共享内存维护了一个 shmid_ds 结构体，该结构体的成员 shm_nattach 记录了关联进程数</li>
</ul>
</li>
<li>可不可以对共享内存进行多次删除<ul>
<li>可以，当还有关联进程的时候，共享内存只是标记删除。而直到没有关联进程才会被真正删除。</li>
<li>key 为 0 ：被标记删除，不再能被关联</li>
</ul>
</li>
<li>共享内存与内存映射的区别<ul>
<li>共享内存可以直接创建，内存映射需要磁盘文件（匿名映射除外）</li>
<li>共享内存效率更高</li>
<li><strong>内存：</strong><br>共享内存，所有进程操作的是同一块共享内存（物理）；<br>内存映射，每个进程再自己的虚拟地址空间中有一个独立的内存。</li>
<li><strong>数据安全：</strong><ul>
<li>进程突然退出<br>共享内存还存在，内存映射区消失。</li>
<li>电脑突然宕机<br>共享内存中的数据消失，内存映射区的数据在磁盘文件中仍存在。</li>
</ul>
</li>
<li><strong>生命周期：</strong><ul>
<li>共享内存：进程退出，共享内存仍存在，需要手动删除或关机（进程退出会自动取消关联）</li>
<li>内存映射区：进程退出，映射区销毁</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>一些操作命令</strong>（System V）</p>
<p><code>ipcs</code></p>
<p><img src="/?utm_source=gold_browser_extension/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/Users\86191\Desktop\myblog\mang959595.github.io\source_posts\第二章Linux多进程\image-20230208122145744.png" alt="image-20230208122145744"></p>
<p><code>ipcrm</code></p>
<p><img src="/?utm_source=gold_browser_extension/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/Users\86191\Desktop\myblog\mang959595.github.io\source_posts\第二章Linux多进程\image-20230208122153825.png" alt="image-20230208122153825"></p>
<h3 id="补充：2-6-7-消息队列"><a href="#补充：2-6-7-消息队列" class="headerlink" title="补充：2.6.7 消息队列"></a>补充：2.6.7 消息队列</h3><h2 id="2-7-守护进程"><a href="#2-7-守护进程" class="headerlink" title="2.7 守护进程"></a>2.7 守护进程</h2><h3 id="终端、进程组、会话"><a href="#终端、进程组、会话" class="headerlink" title="终端、进程组、会话"></a>终端、进程组、会话</h3><p><strong>终端</strong></p>
<ul>
<li>在 UNIX 系统中，用户通过 终端 登陆到系统后得到一个 shell 进程，这个终端进程为 shell 进程的 控制终端 （Controlling Termianl) ，进程中，控制终端是保存在 PCB 中的信息，而 fork() 会复制 PCB 中的信息，因此由 shell 进程启动的其他进程的控制终端也是这个终端。</li>
<li>默认情况下（没有重定向），每个进程的标准输入、标准输出和标准错误输出（文件描述符）都指向控制终端，进程从标准输入读也就是读用户的键盘输入，进程往标准输出或标准错误输出写也就是输出到显示器上。</li>
<li>在控制终端输入一些特殊的控制键可以给前台进程发送信号，例如 Ctrl+C 会产生 SIGINT 信号，Ctrl+\ 会产生 SIGQUIT 信号。</li>
</ul>
<p><strong>进程组</strong></p>
<ul>
<li><p>进程组和会话在进程之间形成了一种两级层次关系：进程组是一组相关进程的集合，会话是一组相关进程组的集合。</p>
</li>
<li><p>进程组和会话是为支持 <u>shell作业控制</u> 而定义的抽象概念，用户通过 shell 能够交互式地在前台或后台运行命令。</p>
</li>
<li><p>进程组由一个或多个共享同一进程组标识符（PGID）的进程组成。一个进程组拥有一个 进程组首进程 （组长），该进程是创建该组的进程，<u>其进程 ID 为该进程组的 ID</u> ，新进程会继承父进程所属的进程组 ID 。</p>
</li>
<li><p>进程组有一个生命周期，起开始时间为首进程创建组的时刻，结束时间为最后一个成员进程退出的时刻。一个进程可能会因为终止而退出进程组，也可能会因为加入另一个进程组而退出进程组。进程组首进程无需是最后一个离开的成员。</p>
</li>
</ul>
<p><strong>会话</strong></p>
<ul>
<li>会话是一组进程组的集合。会话首进程是创建该新会话的进程，其进程ID会成为会话ID。新进程会继承其父进程的会话ID。</li>
<li>一个会话中的所有进程共享单个控制终端。控制终端会在会话首进程首次打开一个终端设备时被建立。一个终端最多可能成为一个会话的控制终端。</li>
<li>在任意时刻，会话中的其中一个进程组会成为终端的前台进程组，其他进程会成为后台进程组。只有前台进程组中的进程才能从控制终端中读取输入。当用户在控制终端中输入终端字符生成信号后，该信号会被发送到前台进程组中的所有成员。</li>
<li>当控制终端的连接建立起来之后，会话首进程会成为该终端的控制进程。</li>
</ul>
<p><strong>三者关系图</strong></p>
<p>指令 </p>
<p><code>fing / 2 &gt; /dev/null | wc -l &amp;</code>( &amp; 后台运行指令 )</p>
<p><code>sort &lt; longlist | uniq -c</code></p>
<p><img src="/?utm_source=gold_browser_extension/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/Users\86191\Desktop\myblog\mang959595.github.io\source_posts\第二章Linux多进程\image-20230208194637948.png" alt="image-20230208194637948"></p>
<blockquote>
<p>来自评论区：</p>
<p>为什么两条命令产生了两个新的进程组，并且不同于bach进程组:</p>
<p>关于find和wc为什么父进程是bash(400)，但是进程组ID确是658，而不是复制父进程的组ID。其实fork函数产生的子进程才是复制父进程的组ID。那通过这种命令产生的子进程，组ID是怎么确立的？在《Linux&#x2F;UNIX系统编程手册》2.13 中提到，“shell执行的每个程序都会在一个新进程内发起”，这句话解释了为什么find、wc、sort、uniq这四个都是一个单独的进程。“除了Bourne shell以外，几乎所有主流shell都提供了一种交互式特性，名为任务控制。该特性允许用户同时执行并操纵多条命令或管道。在支持任务控制的shell中，会将管道内所有进程置于一个新进程组或任务中。如果情况很简单，shell命令行只包含一条命令，那么就会创建一个只包含单个进程的新进程组。进程组中每个进程都具有相同的进程组标识符，其实就是进程组组长的ID”，这段话可以解释为什么两条命令产生了两个新的进程组，并且不同于bach进程组。这种shell命令创建子进程一定要和fork函数区分开来。</p>
</blockquote>
<p><strong>相关函数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取当前进程的进程组</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgrp</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// 获取指定进程的进程组</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br><span class="line"><span class="comment">// 设置指定进程的组id</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setpgid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">pid_t</span> pgid)</span>;</span><br><span class="line"><span class="comment">// 获取指定进程的会话id</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getsid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br><span class="line"><span class="comment">// 设置当前进程的会话id</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">setsid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><p>守护进程( Daemon Process )，也就是通常说的 Daemon 进程（精灵进程），是Linux中的后台服务进程。其生存周期较长，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生地事件。进程名一般以 d 结尾。</p>
<p><strong>特征</strong></p>
<ul>
<li>生命周期长，守护进程会在系统启动的时候被创建并一直运行直至系统被关闭。</li>
<li>在后台运行并且不拥有控制终端。没有控制终端确保了内核永远不会为守护进程自动生成任何控制信号以及终端相关的信号（如 SIGINT、SIGQUIT）</li>
</ul>
<blockquote>
<p>Linux的大多数服务器就是用守护进程实现的，比如，Internet服务器 inetd ，Web服务器 httpd 等</p>
</blockquote>
<p><strong>创建步骤</strong></p>
<ul>
<li>*执行 fork()，然后父进程退出，子进程继续执行<ul>
<li>假设从命令行启动进程，父进程在退出后会使终端出现shell提示符；提前退出就不会出现了</li>
<li>子进程能确保自己不是进程组的首进程</li>
</ul>
</li>
<li>*子进程调用 setsid() 开启一个新会话（<ul>
<li>用setsid新建会话的首进程不能是进程组的首进程，否则导致组id重复</li>
<li>新建会话是为了控制终端，setsid() 新建的会话在终端连接建立之前默认无控制终端</li>
</ul>
</li>
<li>（非必须）清除进程的 umask 以确保当守护进程创建文件和目录时拥有所需的权限</li>
<li>（非必须）修改进程的当前工作目录，通常改为根目录（ &#x2F; ）</li>
<li>关闭守护进程从其父进程继承而来的所有打开着的文件描述符<ul>
<li>守护进程脱离了控制终端，但是没有脱离终端</li>
<li>避免守护进程通过标准输出等到终端读写数据</li>
<li>以及关闭其他继承过来的文件描述符，解除文件占用</li>
</ul>
</li>
<li>在关闭了文件描述符0、1、2之后，守护进程通常会打开 &#x2F;dev&#x2F;null 并使用 dup2() 使所有这些描述符指向这个设备<ul>
<li>某些系统调用会使用到0、1、2文件描述符，所以不能关闭</li>
<li>重定向后相当于丢弃掉数据</li>
</ul>
</li>
<li>*核心业务逻辑</li>
</ul>
<p><strong>案例</strong></p>
<p>写一个守护进程，每个2s获取一次系统时间，并将时间写入到磁盘文件中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">work</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="comment">// 捕捉到信号之后，获取系统时间并写入磁盘</span></span><br><span class="line">    <span class="type">time_t</span> ret = time(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> * <span class="title">loc</span> =</span> localtime(&amp;ret);</span><br><span class="line">    <span class="comment">// 转换格式</span></span><br><span class="line">    <span class="comment">// char buf[1024];</span></span><br><span class="line">    <span class="comment">// sprintf(buf, &quot;%d:%d:%d\n&quot;,loc-&gt;tm_hour,loc-&gt;tm_min,loc-&gt;tm_sec);</span></span><br><span class="line">    <span class="comment">// printf(&quot;%s\n&quot;,buf);</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *str = asctime(loc);</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;time.txt&quot;</span>, O_RDWR | O_CREAT | O_APPEND, <span class="number">0664</span>);</span><br><span class="line">    write(fd, str, <span class="built_in">strlen</span>(str));</span><br><span class="line">    write(fd, <span class="string">&quot;\n&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;\n&quot;</span>));    </span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建子进程，退出父进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子进程重新创建一个会话</span></span><br><span class="line">    setsid();</span><br><span class="line">    <span class="comment">// 设置掩码</span></span><br><span class="line">    umask(<span class="number">022</span>);</span><br><span class="line">    <span class="comment">// 更改工作目录</span></span><br><span class="line">    chdir(<span class="string">&quot;/root/user&quot;</span>);</span><br><span class="line">    <span class="comment">// 关闭、重定向文件描述符</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/dev/null&quot;</span>,O_RDWR);</span><br><span class="line">    dup2(fd,STDIN_FILENO);</span><br><span class="line">    dup2(fd,STDOUT_FILENO);</span><br><span class="line">    dup2(fd,STDERR_FILENO);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 业务逻辑</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册信号捕捉</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    act.sa_handler = work;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    sigaction(SIGALRM, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建定时器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">val</span>;</span></span><br><span class="line">    val.it_value.tv_sec = <span class="number">2</span>;</span><br><span class="line">    val.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">    val.it_interval.tv_sec = <span class="number">2</span>;</span><br><span class="line">    val.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    setitimer(ITIMER_REAL, &amp;val, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<p>第二章完结！</p>
]]></content>
      <tags>
        <tag>多进程</tag>
      </tags>
  </entry>
</search>
