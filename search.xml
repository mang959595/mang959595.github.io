<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2024开年大吉</title>
    <url>/2024/01/01/2024%E5%BC%80%E5%B9%B4%E5%A4%A7%E5%90%89/</url>
    <content><![CDATA[<p>哈哈，没想到距离上一次反思已经快过去一年了，上次反思还是在 2023.2.12 寒假那会儿。</p>
<p>这一次，主要是回顾2023年，展望2024年。</p>
<br>

<p>2023这一年囊括了大三下和大四上这两个学期，按理来说应该是本科找工作的最关键的时期。目前呢，我还是无offer人士，本来现在还0offer的话应该是很焦虑的，但我感觉还好，因为现在还在西山居实习。这会儿实习也来到第三个月了，后面或许有机会拿到项目组的offer。不过拿不到也没事，毕竟这段时候还是有所收获的</p>
<span id="more"></span>

<br>

<br>

<p><br>首先是回顾一下2023年的情况吧。</p>
<h2 id="2023时间线："><a href="#2023时间线：" class="headerlink" title="2023时间线："></a>2023时间线：</h2><h3 id="1月"><a href="#1月" class="headerlink" title="1月"></a>1月</h3><ul>
<li>一月份的话我可能还在打游戏，那会儿玩夜猫永恒玩疯了。</li>
<li>大概是到了1月底，也就是大年初七左右，我突然感受到了一股压力，开始慌慌张张地复习了起来。复习是看牛客的webserver项目视频，内容大概就是把游双的《Linux高性能服务器编程》提炼了出来，稍微复习到了一些操作系统的概念和Linux的API，以及计网的东西。</li>
</ul>
<h3 id="2月"><a href="#2月" class="headerlink" title="2月"></a>2月</h3><ul>
<li>记得那会儿是2月20多号才补上个学期的期末考试，而我是等到2.17回学校之后才开始期末复习，这段时间里面就没法看别的了。</li>
<li>在前面半个月的时间里，应该是在看牛客的视频，然后就是在刷牛客101题。</li>
</ul>
<h3 id="3月"><a href="#3月" class="headerlink" title="3月"></a>3月</h3><ul>
<li><p>三月份充了一年力扣的会员，开始逐步转移到这边刷题，然后还挑了力扣里面的一些八股总结来看。</p>
</li>
<li><p>另外就是开始写webserver的代码，因为牛客视频里的那个比较简单，所以我又去找了经典的TinyWebserver来写。与其说是写，不如说是抄吧，基本就是跟着别人的博客还有代码过了一遍，不少地方还有点知其然而不知其所以然。</p>
</li>
<li><p>还有就是把之前操作系统课设写的那个协程给捋了捋，也给当作一个项目来用了。</p>
<p><img src="/2024/01/01/2024%E5%BC%80%E5%B9%B4%E5%A4%A7%E5%90%89/image-20240101024131237.png" alt="刷题热点图"></p>
</li>
</ul>
<h3 id="4月"><a href="#4月" class="headerlink" title="4月"></a>4月</h3><ul>
<li>四月份开始一边高强度刷题看八股，一边投简历了。</li>
<li>从下图可以看到，投的公司不多，但都来自各行各业。</li>
<li>这个月的主要战绩是把华为的笔试过了。</li>
</ul>
<p><img src="/2024/01/01/2024%E5%BC%80%E5%B9%B4%E5%A4%A7%E5%90%89/image-20240101024258966.png" alt="image-20240101024258966"></p>
<h3 id="5月"><a href="#5月" class="headerlink" title="5月"></a>5月</h3><ul>
<li>五月份一开始，就葬送了去华为的可能。因为五一出去玩了，没有复习八股和项目，导致面华为约面的时候被打了个措手不及。不过究其原因还是自己对基础知识的理解不够深刻，以及对项目的认识也不够深刻。</li>
<li>华为一面G了之后，备受打击，好在这个时候收到了西山居技术训练营的面试。面试特别简单，一面十几分钟，二面就是跟hr聊天和oc了。</li>
<li>大概隔了两个星期之后，西山居发了训练营的offer，然后我也接了。这期间，过了阿里灵犀的一面，一面问了大概1小时10分的八股，从C++，到操作系统，到计算机网络，到数据结构和算法，很多都是常问的面试题，但是每一题都会挖得很深，问到不会为止。通过这次面试也发现自己对基础知识的理解还是不够深入的，没有构建起一个互联的体系。</li>
<li>在收到西山居训练营的offer之后，我把阿里这边的二面拒了。二面按理来说应该是会问项目，我知道自己对项目的理解不够深。其实如果好好再去准备一下也是可以面一面的，面了不管过没过都能有所收获。但是！但是我把二面拒了，现在想想，好想打屎我这个懒B。此外我也把CVTE的笔试给丢了。</li>
<li>在拿了offer之后，我决定往游戏行业靠了，毕竟我也是一个臭打游戏的。我开始入门Unity，还花钱买了麦扣的 3D RPG项目，跟着做了一遍。按后面来看，其实没必要买，免费的部分就足够入门了。而且这个教程也就那样，顶多就是能帮助新手熟悉一下Unity的各个部分，往深了就没了，代码什么的其实写的一般。</li>
</ul>
<h3 id="6月"><a href="#6月" class="headerlink" title="6月"></a>6月</h3><ul>
<li>继续学了一点Unity，可惜后来没有按我当时的计划清单里写的，再做一个带有网络对战的 Unity Demo。</li>
<li>6月中间是生了场病，病了两个星期，直接把这个月给搞砸了。</li>
<li>病好了之后我就又开始狂打游戏了，这个月回头一看几乎是一片空白，毫无收获。</li>
</ul>
<h3 id="7月"><a href="#7月" class="headerlink" title="7月"></a>7月</h3><ul>
<li>六月底七月初有期末考，我那会儿应该是在复习吧。</li>
<li>7月18号开始训练营，去之前那段时间我应该就多看了一点Unity，别的也来不及看了。</li>
<li>然后就是训练营的前2周，是在上课和做作业，客户端、服务端、渲染都讲了些，也都实践了一下，详细内容懒得码字了，简历、实习总结里有。</li>
</ul>
<h3 id="8月"><a href="#8月" class="headerlink" title="8月"></a>8月</h3><ul>
<li>训练营的后半部分是进行更多的实践，根据策划文档完成作业。文档内容分了单机和联网两部分，联网的内容可以自己拓展，服务端除了完成文档上的内容，我和我那个给力的队友还加了房间管理和多人游戏同步的内容。</li>
<li>8月18号训练营就结束了，虽说顺利拿到了继续实习offer，但是这次还是发现了自己的一些不足，之前在学校动手实践实在太少了。</li>
<li>这次训练营让我了解游戏开发大概是怎样的一个情况，提升了我的编码和调试能力（但此时还是很渣）。</li>
<li>回去学校之后，先是给自己放空了一个星期。本来打算九月就回去珠海继续实习，但是因为后面9月和10月要校内实习，我就得看导师放不放我远程实习。</li>
</ul>
<h3 id="9月"><a href="#9月" class="headerlink" title="9月"></a>9月</h3><ul>
<li>问了导师，导师的回答比较模糊，然后我又去问辅导员和教务员，都没能得到我想要的回答。又因为我对图形学和渲染一直有点爱慕之情，就打算干脆先在学校待两个月再去珠海，这段时间先学一学图形学和 Unity Shader，说不定以后还有机会做做TA啥的。哈哈，因为小时候玩游戏总是很关注画质，所以自己对这方面是有一点天然的兴趣的。可惜了解得太晚了，等到快大四才知道这个方向，现在转这个方向估计是找不了工作的。</li>
<li>八月底和九月初其实还行，把GAMES101过了一遍，然后把Unity Shader精要也看了一般。可惜，我还是太懒了，全都是浅看辄止，没有动手实践。</li>
<li>后面就开始完蛋了。因为校内实习的事情把我搞得有点烦，然后当时还误以为导师很高冷，我就没有再和导师沟通，校内实习直接啥也没干。现在来看真的很蠢，导师人可好了，有什么事情直接问就行了，不回的话可能是人家比较忙，再多Call一下就行了，实在不行直接上办公室敲门算了。然后我还把EVA剧场版看了，看完就更EMO了，开始天天打游戏，不思进取，秋招直接简历0投递，0准备。</li>
</ul>
<h3 id="10月"><a href="#10月" class="headerlink" title="10月"></a>10月</h3><ul>
<li>到了十月，本来我是想10月9号就偷跑回珠海的，但是申请晚了，只能10月18号回。</li>
<li>十月第一周，国庆假期，不用想，啥也没干。第二周，也学不了啥了，索性当作最后的疯狂游戏时光。</li>
<li>然后就是回来实习了，第一周只有两天半，大概把文档过了一下，环境搭了一下，还把go语言的语法过了一遍，可惜后来完全用不到go。</li>
<li>实习第二周，开始过之前项目的代码，但是只是从命名、语法规范等的角度来重构。</li>
</ul>
<h3 id="11月"><a href="#11月" class="headerlink" title="11月"></a>11月</h3><ul>
<li>实习第三周，说是要看libuv源码，但是实际看的是别人的博客。然后用自己乱搞的测试客户端来测试项目，出现了一些奇怪的问题，后面就围绕这个问题开始看代码和调试。</li>
<li>实习第四周，这次真看了libuv源码，然后调试，找到问题并解决。按师傅和导师的要求，整理了一份文档，内容包括对libuv源码层面的介绍和我的问题解决过程。</li>
<li>实习第五周，开始接服务了。接服务就是把这边的游戏服务端通用微服务框架里的各个服务应用到Demo项目里，主要是先看协议和文档了解业务逻辑，然后敲代码，敲完就在客户端画点UI测一下。这周先把客户端网络处理部分的代码重构了，然后接了登录服务。</li>
<li>实习第六周，继续接服务，包括在线服务，邮件服务，名字服务。</li>
<li>实习第七周，继续接服务，包括聊天服务，好友服务，总计花了三周。</li>
</ul>
<h3 id="12月"><a href="#12月" class="headerlink" title="12月"></a>12月</h3><ul>
<li><p>实习第八周，接完服务不知道干嘛了，看了一周《Lua程序设计》，但没有实践，效率低下。另外把整个项目里面打日志的代码封装了一下。</p>
</li>
<li><p>实习第九周，和导师过了一遍接完服务后的代码，重新规范了一下代码，然后从模块设计的层面重构了一下，补充完善了很多功能，主要是针对网络连接的。</p>
</li>
<li><p>实习第十周，本来这周是要接中心服务和测试的，然后第一天确实接了，把正常情况下的协议测了一遍。后面请假了，回去填校内实习的坑。</p>
</li>
<li><p>实习第十一周，把Lua嵌入C++的方式整合完毕了，又把连接管理几乎重写了，后面可以顺畅地重写其他逻辑了。</p>
</li>
</ul>
<br>

<br>

<p>实习的这两个月，写了应该快1万行代码了，我的动手能力是实打实的锻炼到了。然后就是，对于后端接触的这些东西有了一个清晰一点的概念映像了，对一些业务逻辑，对项目里的实际要求，也有了更多的认识。</p>
<br>

<br>

<p>好了，下面就来到2024了。</p>
<br>

<br>

<h2 id="2024规划："><a href="#2024规划：" class="headerlink" title="2024规划："></a>2024规划：</h2><br>

<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>回顾完了2023，给自己一句简短的总结，大概就是“努力过了，但又没完全努力”。</p>
<p>相比起我在朋友圈看到的，比如有些同学已经顺利保研，或者是收获了腾讯、美团、网易等大厂的offer，我的收获就不值一提了。</p>
<p>但是，别人也不是一蹴而就，每个人总会有一段压力巨大的时期，如果扛过去了，并且稳扎稳打逐步爬升，总能有好结果的。</p>
<p>而我呢，也算是在逐步前进吧，但是三天打鱼两天晒网的现象还是比较严重，也就导致了最终跟别人比起来有些相形见绌。</p>
<p>说实话，看到同班的同学拿到大厂offer，还是挺眼红的。总有一种感觉在说，凭什么别人可以，你就不可以了。也希望者能够成为2024年的一些动力吧，毕竟，我的大学生涯比较失败的原因有很大的部分在于没有明确的目标和源源不断的动力。</p>
<br>

<br>

<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ul>
<li>上半年：<ul>
<li>顺利毕业</li>
<li>找到合心的工作</li>
</ul>
</li>
<li>下半年：<ul>
<li>迅速融入工作环境</li>
<li>争取找到新的目标</li>
</ul>
</li>
</ul>
<br>

<h3 id="眼下："><a href="#眼下：" class="headerlink" title="眼下："></a>眼下：</h3><p>眼前需要应付的事情有：实习，毕业设计，春招。</p>
<p>实习：</p>
<ul>
<li>现在已经进入收尾阶段了，目前需要用Lua把之前的东西再过一遍。然后可以多看一些测试的东西，多了解框架里面一些服务。</li>
</ul>
<p>毕设：</p>
<ul>
<li>估计还是得等实习结束才抽的出时间和精力来搞。</li>
</ul>
<p>春招准备：</p>
<ul>
<li>八股，项目，算法这三个过一遍就行了。</li>
<li>另外要加强一下自己的沟通和表达，以及多注意其他非技术的因素。</li>
</ul>
<br>

<br>

<p><img src="/2024/01/01/2024%E5%BC%80%E5%B9%B4%E5%A4%A7%E5%90%89/image-20240101192141010.png" alt="image-20240101192141010"></p>
<br>

<p>再之后的事情再看吧，希望2024的开头能顺顺利利，给后续铺垫基础。</p>
<br>

<br>
]]></content>
      <categories>
        <category>反思录</category>
      </categories>
      <tags>
        <tag>时间</tag>
      </tags>
  </entry>
  <entry>
    <title>3D RPG Demo回顾</title>
    <url>/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/</url>
    <content><![CDATA[<h1 id="3D-RPG-Demo回顾"><a href="#3D-RPG-Demo回顾" class="headerlink" title="3D RPG Demo回顾"></a>3D RPG Demo回顾</h1><h2 id="1-创建项目"><a href="#1-创建项目" class="headerlink" title="1.创建项目"></a>1.创建项目</h2><p>包含 <strong>项目创建，渲染管线设置，资源导入，资源材质渲染升级</strong></p>
<span id="more"></span>

<ul>
<li>新建3D项目</li>
<li>Window-&gt;PackageManager(Packages&#x2F; Unity Registry)中下载和导入 <strong>Universal RP</strong> 通用渲染管线</li>
<li>在Assets目录中创建 Pipeline Asseet<ul>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602103502206.png" alt="image-20230602103502206" style="zoom:67%;"></li>
</ul>
</li>
<li>导入PackageManager(Packages&#x2F; My Assets)中的资源包</li>
<li>升级资源项目的材质Material到URP<ul>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602104131868.png" alt="image-20230602104131868" style="zoom: 67%;"></li>
<li>Window-&gt;Rendering-&gt;Render Pipeline Converter</li>
</ul>
</li>
</ul>
<h2 id="2-场景搭建"><a href="#2-场景搭建" class="headerlink" title="2.场景搭建"></a>2.场景搭建</h2><p>包括 <strong>天空盒，阴影，光照，场景搭建</strong></p>
<ul>
<li><p>天空盒设置</p>
<ul>
<li>Window-&gt;renderinh-&gt;lighting-&gt;Environment</li>
</ul>
</li>
<li><p>阴影设置</p>
<ul>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602104716284.png" alt="image-20230602104716284"></li>
<li>在<strong>渲染管线配置文件</strong>中设置Shadow字段的参数</li>
</ul>
</li>
<li><p>光照设置</p>
<ul>
<li><p>Window-&gt;renderinh-&gt;lighting-&gt;Scene</p>
</li>
<li><p>通过设置 Lighting Settings 文件，配置光照参数</p>
</li>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602105125399.png" alt="image-20230602105125399" style="zoom:80%;">

<p>设置是否在生成场景时自动渲染光照</p>
</li>
<li><p>光源：在Environment中设置光源 Environment Lighting&#x2F;Source</p>
</li>
</ul>
</li>
<li><p>场景物体摆放</p>
<ul>
<li><p>shift+F 抓取顶点</p>
</li>
<li><p>ctrl+shift+F 快速设置transform</p>
</li>
<li><p>利用空Object分割 Hierarchy 中的各类型对象</p>
</li>
<li><p>Polybrush插件</p>
<ul>
<li><p>安装：</p>
<ul>
<li>Window-&gt;PackageManager(Packages&#x2F; Unity Registry)</li>
<li>导入样例Shader<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602105808946.png" alt="image-20230602105808946" style="zoom:80%;"></li>
</ul>
</li>
<li><p>使用：Tools菜单&#x2F;Polybrush Window <img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602110016714.png" alt="image-20230602110016714" style="zoom:80%;"></p>
</li>
<li><p>使用Polybrush自带的ShaderGraph来创建材质<br><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602110307916.png" alt="image-20230602110307916"></p>
<p>使用了该材质的物体可以使用Polybrush的颜色刷子</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>场景模型创建 —— ProBuilder</p>
<ul>
<li><p>安装：跟PolyBrush差不多</p>
<p><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602110912896.png" alt="image-20230602110912896"></p>
</li>
<li><p><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602111158996.png" alt="image-20230602111158996"></p>
</li>
<li><p>新版本的参数名称有不同<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602111249173.png" alt="image-20230602111249173"></p>
</li>
</ul>
</li>
<li><p>启用Preview Package：ProGrids</p>
<ul>
<li><p>Edit&#x2F;Project Setting</p>
</li>
<li><p><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602111434848.png" alt="image-20230602111434848"></p>
</li>
<li><p>Tools&#x2F;ProGrids</p>
</li>
</ul>
</li>
</ul>
<h2 id="3-地图导航烘焙"><a href="#3-地图导航烘焙" class="headerlink" title="3.地图导航烘焙"></a>3.地图导航烘焙</h2><h3 id="Navigation"><a href="#Navigation" class="headerlink" title="Navigation"></a>Navigation</h3><ul>
<li>开启：Window-&gt;AI-&gt;Navigation</li>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602112337244.png" alt="image-20230602112337244" style="zoom:80%;">
- Agent 表示的是 移动物
- 可以设置坡度、Agent模型体积等参数</li>
<li>设置物体为导航路面<ul>
<li>Static：Navigation static<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602112516103.png" alt="image-20230602112516103" style="zoom:80%;"></li>
<li>设置是否 Walkable<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602112459426.png" alt="image-20230602112459426" style="zoom:80%;"></li>
</ul>
</li>
<li>为人物添加导航组件<ul>
<li>Nav Mesh Agent：导航网格人物代理组件<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602113028687.png" alt="image-20230602113028687" style="zoom:80%;"><ul>
<li>相关参数：<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602113243270.png" alt="image-20230602113243270" style="zoom:80%;"></li>
</ul>
</li>
</ul>
</li>
<li>为障碍物添加导航组件<ul>
<li>Nav Mesh Obstacle</li>
<li>carve：可以实时切割导航路面<br><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602113445563.png" alt="image-20230602113445563"></li>
</ul>
</li>
<li>跳跃设置：没有用到</li>
</ul>
<h2 id="4-鼠标控制和人物移动控制"><a href="#4-鼠标控制和人物移动控制" class="headerlink" title="4.鼠标控制和人物移动控制"></a>4.鼠标控制和人物移动控制</h2><h3 id="MouseManager脚本"><a href="#MouseManager脚本" class="headerlink" title="MouseManager脚本"></a>MouseManager脚本</h3><ul>
<li><p>挂载在空物体 Mouse Manager</p>
</li>
<li><p>设置鼠标点击事件的处理</p>
<ul>
<li>UnityEngine.Event<ul>
<li>[System.Serializable] 序列化处理非MonoBehaviour子类，使得Unity界面中能够查看和设置该属性<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/../../../游戏开发/3D RPG/3D RPG 回顾/image-20230602115927683.png" alt="image-20230602115927683" style="zoom:80%;">
<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602120050100.png" alt="image-20230602120050100" style="zoom:80%;"></li>
<li>设置事件处理<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602120216706.png" alt="image-20230602120216706" style="zoom:80%;">
- 将事件设置为NavMeshAgent自带的Destination，表示导航位置。</li>
</ul>
</li>
</ul>
</li>
<li><p>获取鼠标点击位置：利用射线和collider发生碰撞</p>
<ul>
<li><p>API：</p>
<ul>
<li>Camera.ScreenPointToRay(Vector3 position) 从屏幕发射到position的射线</li>
<li>Physics.Raycast(Ray ray, out RaycastHit hitInfo) 检测射线的碰撞</li>
</ul>
</li>
<li><p>相关参数：</p>
<ul>
<li>RaycastHit hitInfo 作为Physics.Raycast的传出参数，保存有射线的碰撞信息</li>
</ul>
</li>
<li><p>代码：</p>
<ul>
<li><p>射线发射，判断射线碰撞物体，根据物体标签设置鼠标贴图</p>
<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602121109491.png" alt="image-20230602121109491" style="zoom:80%;">
</li>
<li><p>点击鼠标，触发事件处理 OnMouseClicked.Invoke(hitInfo.point) 就是 前面设置的 NavMeshAgent.Destination</p>
<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602121411322.png" alt="image-20230602121411322" style="zoom:80%;">
<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/../../../游戏开发/3D RPG/3D RPG 回顾/image-20230602121305501.png" alt="image-20230602121305501" style="zoom:80%;"></li>
</ul>
</li>
</ul>
</li>
<li><p>移动控制小细节：NavMeshAgent组件 的参数</p>
<ul>
<li>Stopping Distance 的大小设置可以跟攻击距离有关联</li>
<li>速度，角速度，加速度</li>
<li>自动制动 Auto Braking：提前减速，否则就是匀速到达并停止</li>
</ul>
</li>
<li><p>指针贴图设置</p>
<ul>
<li>导入PNG格式的鼠标贴图，并设置相关参数</li>
<li>脚本代码中，用 Texture2D 类型的变量保存贴图内容</li>
<li>控制代码<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602124442960.png" alt="image-20230602124442960" style="zoom: 67%;"></li>
<li>注意鼠标点击的原始位置是在 鼠标贴图的左上角顶点 ，通过 SetCursor() 的第二个参数来设置偏移使得鼠标点击位置位于贴图中央</li>
</ul>
</li>
</ul>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>写法</p>
 <img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602122814252.png" alt="image-20230602122814252" style="zoom: 80%;">
<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/../../../游戏开发/3D RPG/3D RPG 回顾/image-20230602122801102.png" alt="image-20230602122801102" style="zoom:67%;">

<p><strong>只需</strong>保证Mouse Manager的实例<strong>有且仅有一份</strong>就行了，不关心实例是否保持为最早创建的实例。</p>
<h3 id="PlayerController"><a href="#PlayerController" class="headerlink" title="PlayerController"></a>PlayerController</h3><ul>
<li>鼠标移动事件：弃用上面的 UnityEngine.Events&#x2F;EventVector3，改用 System&#x2F;event Action&lt;xxx&gt; ,xxx为参数<ul>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602123546809.png" alt="image-20230602123546809" style="zoom:80%;"></li>
<li>工作原理：<ul>
<li>创建事件 OnMouseClicked</li>
<li>将事件处理函数注册到该事件 OnMouseClicked +&#x3D; xxx;</li>
<li>事件发生时，调用 OnMouseClicked.Invoke(arg) 会唤起所有注册了的事件处理函数</li>
</ul>
</li>
<li>代码：<ul>
<li>事件处理以及注册（PlayerController中），涉及NavMeshAgent组件<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602123936237.png" alt="image-20230602123936237" style="zoom:80%;"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="5-相机设置"><a href="#5-相机设置" class="headerlink" title="5.相机设置"></a>5.相机设置</h2><h3 id="相机跟踪"><a href="#相机跟踪" class="headerlink" title="相机跟踪"></a>相机跟踪</h3><ul>
<li><p>安装 Cinemashine 工具</p>
</li>
<li><p>创建虚拟相机 virtual Cinemashine，设置 MainCamera的brain</p>
</li>
<li><p>设置虚拟相机的参数</p>
<ul>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602150704716.png" alt="image-20230602150704716"></li>
<li>Aim参数-do nothing</li>
<li>follow参数-playerObjcet<ul>
<li>可以给人物加一个lookAtPoint来作为相机跟随对象</li>
</ul>
</li>
<li>虚拟相机的位置可以通过Ctrl+Shift+F调整</li>
</ul>
</li>
</ul>
<h3 id="视图后处理"><a href="#视图后处理" class="headerlink" title="视图后处理"></a>视图后处理</h3><h4 id="设置迷雾"><a href="#设置迷雾" class="headerlink" title="设置迷雾"></a>设置迷雾</h4><ul>
<li>Window-&gt;Rendering-&gt;lighting-&gt;environment-&gt;fog<ul>
<li>能见度</li>
<li>颜色</li>
</ul>
</li>
<li>Scene内也要开启fog</li>
</ul>
<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602151605304.png" alt="image-20230602151605304" style="zoom:80%;">

<h4 id="Post-Processing"><a href="#Post-Processing" class="headerlink" title="Post Processing"></a>Post Processing</h4><ul>
<li><p>Main Camera中启动PostProcessing</p>
<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602151731551.png" alt="image-20230602151731551" style="zoom:80%;">
</li>
<li><p>创建 Global Volume 对象</p>
<ul>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602151427826.png" alt="image-20230602151427826" style="zoom:80%;"></li>
<li>创建 Profile ，添加并设置各种效果 Add Override<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602151630478.png" alt="image-20230602151630478" style="zoom:80%;">
- Bloom 泛光
- Color Adjustment 曝光、对比度、饱和等
- ToneMapping 色调
- Depth Of Field 景深
- Chromatic Aberration 畸变、鱼眼效果
- ...</li>
</ul>
</li>
</ul>
<h3 id="Cinemashine之-FreeLook-Camera"><a href="#Cinemashine之-FreeLook-Camera" class="headerlink" title="Cinemashine之 FreeLook Camera"></a>Cinemashine之 FreeLook Camera</h3><ul>
<li>设置 Follow 和 Look At</li>
<li>相机移动控制：<ul>
<li>Axis Control <ul>
<li>Input Axis Name：<br>可以在Project Setting-InputManager里查看<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230606161237318.png" alt="image-20230606161237318" style="zoom:80%;"></li>
</ul>
</li>
<li>Orbits 移动范围<ul>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230606161432763.png" alt="image-20230606161432763" style="zoom:80%;"></li>
<li>Binding Mode 设置移动跟随 <img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230606161858979.png" alt="image-20230606161858979" style="zoom:80%;"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="6-动画控制"><a href="#6-动画控制" class="headerlink" title="6.动画控制"></a>6.动画控制</h2><ul>
<li><p>添加 Animator 组件</p>
</li>
<li><p>创建 Animator Controller 动画控制器，并设置到Animator组件中</p>
<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602152928218.png" alt="image-20230602152928218" style="zoom:80%;">

<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602153026204.png" alt="image-20230602153026204" style="zoom:80%;">
</li>
<li><p>打开动画控制器</p>
<ul>
<li>在 Base Layer 创建 Blend Tree，控制基本的移动动作<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602153228523.png" alt="image-20230602153228523" style="zoom:67%;"></li>
<li>在 Blend Tree 中添加参数：Speed(float)</li>
<li>在 Blend Tree 中添加 Motion Field，并设置相应动画以及数值控制<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602153717925.png" alt="image-20230602153717925" style="zoom:80%;"></li>
</ul>
</li>
<li><p>代码：</p>
<ul>
<li>先获取 Animator 组件给anim变量</li>
<li>设置 Speed 的值<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602154108267.png" alt="image-20230602154108267" style="zoom:80%;">
- agent.velocity获取速度
- sqrMagnitude将Vector3的速度数值转为float</li>
</ul>
</li>
</ul>
<h2 id="7-利用ShaderGraph实现剔除遮挡的效果"><a href="#7-利用ShaderGraph实现剔除遮挡的效果" class="headerlink" title="7.利用ShaderGraph实现剔除遮挡的效果"></a>7.利用ShaderGraph实现剔除遮挡的效果</h2><p>ShaderGraph提供了可视化编辑渲染管线的功能</p>
<ul>
<li><p>创建 Unlit Shader Graph</p>
<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602155500819.png" alt="image-20230602155500819" style="zoom:80%;">
</li>
<li><p>基于该 Shader，创建一个 Material 供后续使用</p>
</li>
<li><p>打开 Shader Graph 窗口</p>
<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602162619599.png" alt="image-20230602162619599" style="zoom:80%;">
</li>
<li><p>菲涅尔效果</p>
<ul>
<li>创建 Fresnel Effect 的Node结点<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602162733920.png" alt="image-20230602162733920" style="zoom:80%;"></li>
<li>创建 Color 变量，并与菲尼尔效果节点相乘，输出给 Fragment 的 Base Color<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602163708773.png" alt="image-20230602163708773" style="zoom:80%;"></li>
</ul>
</li>
<li><p>噪点效果：</p>
<ul>
<li>创建 Dither node，并输出到 Fragment 的 Alpha</li>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602170950278.png" alt="image-20230602170950278" style="zoom:80%;"></li>
</ul>
</li>
<li><p>Alpha阈值设置</p>
<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602171106967.png" alt="image-20230602171106967" style="zoom:80%;"></li>
<li><p>在 Pipeline Setting 中应用该Shader</p>
<ul>
<li>打开的是另一个 URPRenderPipelineAsset 文件，带_Render后缀<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602171331027.png" alt="image-20230602171331027" style="zoom:80%;"></li>
<li>添加两个 Render Object<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602171358318.png" alt="image-20230602171358318" style="zoom:80%;">
- 一个是被遮挡的渲染模式
  - 首先取消勾选 Write Depth
    <img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602171804718.png" alt="image-20230602171804718" style="zoom: 67%;">
  - 将 Depth Test 设为 Greater
  - 设置 Layer Mask 为 Player图层
    <img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230602171948351.png" alt="image-20230602171948351" style="zoom:67%;">
- 一个是不被遮挡的渲染模式
  设置 Layer Mask 为Player图层即可，其他的为默认</li>
</ul>
</li>
</ul>
<p>附加Tip：</p>
<p>如何使得场景中的树木不遮挡鼠标射线?</p>
<ul>
<li>方法一：将树木的 Layer 设为 Ignore Raycast</li>
<li>方法二：关闭树木的 Collider 组件</li>
</ul>
<h2 id="8-敌人"><a href="#8-敌人" class="headerlink" title="8.敌人"></a>8.敌人</h2><h3 id="属性和状态"><a href="#属性和状态" class="headerlink" title="属性和状态"></a>属性和状态</h3><ul>
<li><p>在脚本代码中自动添加组件 </p>
<ul>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230606153916500.png" alt="image-20230606153916500" style="zoom:80%;"></li>
</ul>
</li>
<li><p>状态机构思：</p>
<ul>
<li>站桩 or 巡逻</li>
<li>追击</li>
<li>死亡</li>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230606154305351.png" alt="image-20230606154305351" style="zoom:80%;"></li>
</ul>
</li>
<li><p>其他细节：</p>
<ul>
<li>Layer 增加一层Enemy，用于在PipelineSetting里的Layer Mask加上实现遮挡剔除</li>
<li>Tag 也加上Enemy，用来设置鼠标贴图</li>
</ul>
</li>
</ul>
<h4 id="追击状态"><a href="#追击状态" class="headerlink" title="追击状态"></a>追击状态</h4><p><strong>范围内发现Player</strong></p>
<ul>
<li>视野变量，表示视野范围</li>
<li>Physics API<ul>
<li>OverlapSphere(position, Radius)  返回范围内的一组collider<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230606162604976.png" alt="image-20230606162604976" style="zoom:80%;"></li>
</ul>
</li>
</ul>
<p><strong>敌人动画控制</strong></p>
<p>思路</p>
<ul>
<li>追击</li>
<li>脱战，回到站桩或巡逻</li>
<li>攻击范围内攻击</li>
</ul>
<p>动画控制器Layer：</p>
<ul>
<li>基本移动<ul>
<li>idolNormal作为初始动画</li>
<li>WalkFWD行走动画，并用bool变量做条件</li>
<li>RunFWD跑动动画</li>
</ul>
</li>
<li>攻击<ul>
<li>权值设置，覆盖&#x2F;叠加前面Layer的动画<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230606163720456.png" alt="image-20230606163720456" style="zoom:80%;"></li>
<li>如何从其他Layer的动画状态切换过来 —— 创建空state，代表之前的任何一个Layer，并连接到Entry<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230606164123342.png" alt="image-20230606164123342" style="zoom:80%;"></li>
<li>战斗状态动画控制，两个bool<ul>
<li>追击 Chase —— 其他动画&lt; - &gt;攻击动画</li>
<li>跟踪 Follow —— 攻击动画&lt; - &gt;跑动动画</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>代码</p>
<ul>
<li>更新动画变量<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230606164427284.png" alt="image-20230606164427284" style="zoom:80%;"></li>
<li>更新脚本变量<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230606164742822.png" alt="image-20230606164742822" style="zoom:80%;"></li>
</ul>
<h4 id="巡逻状态"><a href="#巡逻状态" class="headerlink" title="巡逻状态"></a>巡逻状态</h4><p><strong>随即巡逻点</strong></p>
<ul>
<li>辅助线API <img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230606165110165.png" alt="image-20230606165110165" style="zoom:80%;"></li>
<li>随机获取范围内的某个点<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230606165758352.png" alt="image-20230606165758352" style="zoom:80%;">
- 获取当前位置范围内的随机点，也可更改为获取固定范围内的随机点
- 可能出现的问题是获取到的点位置不可达</li>
<li>问题解决：<ul>
<li>导航API：<br>SamplePosition() 在指定范围内，找到导航网格上最近的指定Area的点<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230606170502168.png" alt="image-20230606170502168" style="zoom:80%;">
<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/../../../游戏开发/3D RPG/3D RPG 回顾/image-20230606171016841.png" alt="image-20230606171016841" style="zoom:80%;">
- NavMesh.AllAreas：
  <img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230606170616067.png" alt="image-20230606170616067" style="zoom:80%;"></li>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230606170308989.png" alt="image-20230606170308989" style="zoom:80%;"></li>
</ul>
</li>
</ul>
<p><strong>状态控制代码</strong></p>
<ul>
<li>动画变量设置，移动速度设置</li>
<li>若到达目标位置内，获取新的目标点</li>
<li>若未到达目标位置，则继续移动</li>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230606165433686.png" alt="image-20230606165433686" style="zoom:80%;"></li>
</ul>
<p><strong>在巡逻点停留</strong></p>
<ul>
<li>LookAtTime 和 RemainLookAtTime 变量</li>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230606171222823.png" alt="image-20230606171222823" style="zoom:80%;"></li>
<li>在获取随机点后更新 RemainLookAtTime</li>
</ul>
<p><strong>脱战后回到巡逻状态</strong></p>
 <img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230606171443224.png" alt="image-20230606171443224" style="zoom:80%;">





<h4 id="守卫状态"><a href="#守卫状态" class="headerlink" title="守卫状态"></a>守卫状态</h4><ul>
<li>定点站桩</li>
<li>若不在站桩点，则走回站桩点站桩</li>
<li>走动、站桩的动画控制（bool动画变量）<ul>
<li>回到站桩点时，利用插值计算，平滑地使对象转向原来的方向</li>
</ul>
</li>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608105415137.png" alt="image-20230608105415137" style="zoom:80%;"></li>
</ul>
<h4 id="死亡状态"><a href="#死亡状态" class="headerlink" title="死亡状态"></a>死亡状态</h4><ul>
<li><p><strong>动画管理</strong></p>
<ul>
<li>创建新的Layer，Death，并设置覆盖指数为1</li>
<li>创建一个空的动画State，表示上一个动画状态<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608105557358.png" alt="image-20230608105557358"></li>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608105819149.png" alt="image-20230608105819149" style="zoom: 67%;">
- 受攻击：Trigger变量，Hit，被攻击（暴击）时触发
  - 在动画事件里面判断和设置 
    <img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608110608686.png" alt="image-20230608110608686" style="zoom:80%;">
- 死亡：bool变量。Death，血量为0
  - 取消勾选，取消自循环播放
    <img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608105857413.png" alt="image-20230608105857413" style="zoom:80%;"></li>
</ul>
</li>
<li><p>主角的受伤和死亡的动画管理类似</p>
</li>
<li><p><strong>脚本管理</strong></p>
<ul>
<li>用一个bool表示是否死亡，并且同步States状态<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608110206112.png" alt="image-20230608110206112" style="zoom:80%;"></li>
<li>状态机状态处理<ul>
<li>关闭导航Agent，Collider等组件</li>
<li>延迟销毁 gameObject 对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="主角攻击（移动与动画）"><a href="#主角攻击（移动与动画）" class="headerlink" title="主角攻击（移动与动画）"></a>主角攻击（移动与动画）</h3><ul>
<li><p>类似OnMouseClicked事件，在Mouse Manager中增加一个OnEnemyClicked事件</p>
<ul>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230606155002407.png" alt="image-20230606155002407" style="zoom:80%;"></li>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230606154924557.png" alt="image-20230606154924557" style="zoom:80%;"></li>
</ul>
</li>
<li><p>还要在PlayerController中注册这个事件的回调函数EvntAttack</p>
<ul>
<li>利用 协程 + while循环 控制移动 MoveToAttcakTarge<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230606155634741.png" alt="image-20230606155634741" style="zoom:80%;"></li>
<li>还要考虑到 <strong>攻击CD，攻击范围，暴击</strong> 等</li>
<li>可以在普通的移动中加上一步终止协程，否则攻击触发之后无法改变状态直至执行完这次攻击。</li>
</ul>
</li>
<li><p>动画</p>
<ul>
<li>直接拖动画文件到动画编辑窗口内，然后添加动画关联变换，设置变换条件<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230606155918381.png" alt="image-20230606155918381" style="zoom:80%;"></li>
</ul>
</li>
</ul>
<h3 id="敌人攻击"><a href="#敌人攻击" class="headerlink" title="敌人攻击"></a>敌人攻击</h3><ul>
<li>攻击动作处于状态机的 Chase 状态</li>
<li>根据相对位置和攻击距离，管理对象的动作状态（isFollow, isStopped)</li>
<li>攻击CD控制</li>
<li>暴击控制，bool动画变量</li>
<li>动画控制<ul>
<li>在攻击动画和idol动画之间切换</li>
<li>使用 Trigger 动画变量</li>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608101757617.png" alt="image-20230608101757617" style="zoom:80%;"></li>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608101741123.png" alt="image-20230608101741123" style="zoom:80%;"></li>
</ul>
</li>
</ul>
<h2 id="9-人物属性和数值"><a href="#9-人物属性和数值" class="headerlink" title="9.人物属性和数值"></a>9.人物属性和数值</h2><p>使用 <strong>ScriptableObject</strong> 脚本帮助生成 Asset 文件，可以制作数值模板、设置模板</p>
<p>比如<br><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230607230044721.png" alt="image-20230607230044721" style="zoom:80%;"></p>
<h3 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h3><p><strong>ScriptableObject脚本</strong></p>
<ul>
<li>脚本继承自<ul>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230607230259807.png" alt="image-20230607230259807"></li>
</ul>
</li>
<li>在create菜单中添加选项<ul>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230607230344849.png" alt="image-20230607230344849"></li>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230607230426920.png" alt="image-20230607230426920" style="zoom:80%;"></li>
</ul>
</li>
<li>为Asset文件设置字段名称和属性变量<ul>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230607230629919.png" alt="image-20230607230629919" style="zoom:80%;"></li>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230607230604591.png" alt="image-20230607230604591" style="zoom:80%;"></li>
</ul>
</li>
</ul>
<p><strong>Mono Behaviour脚本</strong></p>
<ul>
<li>管理 Asset 中的数值</li>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230607230808777.png" alt="image-20230607230808777" style="zoom:80%;"></li>
<li>将 Asset 中的数值读取到 Stats 脚本文件中。简化后续的数值访问（不用 Stats.Data.xxx ）。<ul>
<li>利用C# properties 属性 的语法</li>
<li>例如：MaxHealth<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230607231157397.png" alt="image-20230607231157397" style="zoom:80%;"></li>
</ul>
</li>
<li>#region xxx，#endregion 管理代码块</li>
</ul>
<h3 id="攻击属性"><a href="#攻击属性" class="headerlink" title="攻击属性"></a>攻击属性</h3><ul>
<li>数值模板：同样先创建Scriptable object脚本文件管理所创建的Asset文件的数值内容</li>
<li>数值控制：再使用Mono脚本作为组件管理数值（在脚本内获取Asset数值文件资源）</li>
</ul>
<h3 id="伤害数值计算"><a href="#伤害数值计算" class="headerlink" title="伤害数值计算"></a>伤害数值计算</h3><ul>
<li>在数值控制脚本内声明和定义攻击伤害计算方法</li>
<li>伤害处理方法以两个数值控制脚本对象作参数（attacker，defender）</li>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608103721171.png" alt="image-20230608103721171" style="zoom:80%;"></li>
</ul>
<h3 id="伤害生效处理（动画事件）"><a href="#伤害生效处理（动画事件）" class="headerlink" title="伤害生效处理（动画事件）"></a>伤害生效处理（动画事件）</h3><p>简单的处理：采用动画事件，而非使用物理方法判断攻击是否生效。</p>
<ul>
<li>Animation窗口<ul>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608103949432.png" alt="image-20230608103949432" style="zoom:80%;"></li>
</ul>
</li>
<li>攻击事件函数&#x2F;方法<ul>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608104342103.png" alt="image-20230608104342103" style="zoom:80%;"></li>
</ul>
</li>
<li>关键帧+动画事件<ul>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608104431072.png" alt="image-20230608104431072" style="zoom:80%;"></li>
</ul>
</li>
</ul>
<h2 id="10-泛型单例模式-与-Game-Manager"><a href="#10-泛型单例模式-与-Game-Manager" class="headerlink" title="10.泛型单例模式 与 Game Manager"></a>10.泛型单例模式 与 Game Manager</h2><h3 id="GameManager"><a href="#GameManager" class="headerlink" title="GameManager"></a>GameManager</h3><ul>
<li><p>在主角死亡时，可以用Game Manager广播主角死亡的消息</p>
</li>
<li><p>特殊图标的Script文件，用 空object 挂载</p>
<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608111154847.png" alt="image-20230608111154847" style="zoom:80%;"></li>
<li><p>Game Manager存有PlayerStats数据脚本，游戏中其他的对象要访问Player的数据时，通过Game Manager访问</p>
<ul>
<li>Game Manager 如何获取Player的数据脚本？<ul>
<li>采用 观察者 模式，反向注册，当Player生成的时候，向Game Manager注册</li>
<li>Game Manager提供注册接口<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608111649709.png" alt="image-20230608111649709" style="zoom:80%;"></li>
<li>Player注册<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608113646462.png" alt="image-20230608113646462" style="zoom:80%;"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="泛型单例模式"><a href="#泛型单例模式" class="headerlink" title="泛型单例模式"></a>泛型单例模式</h3><ul>
<li>语法<ul>
<li>泛型单例脚本<br><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608111837904.png" alt="image-20230608111837904"></li>
<li>泛型&lt;T&gt;，并且约束T为继承自 Singleton&lt;T&gt; 的类</li>
<li>不约束T能放任何类，比如Singleton&lt;Animator&gt;，约束后只能放继承自Singleton&lt;T&gt;的类，比如Singleton&lt;MouseManager&gt;</li>
<li>具体类型单例脚本<br><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608113122412.png" alt="image-20230608113122412"></li>
</ul>
</li>
<li>生成实例（严格上说是饿汉）<ul>
<li>场景生成时，Awake创建了新的Manager<ul>
<li>若原来的实例没被销毁，则销毁新生成的泛型单例对象</li>
<li>若原来的实例被销毁了，更新实例为当前泛型单例对象</li>
</ul>
</li>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608112618150.png" alt="image-20230608112618150" style="zoom:80%;"></li>
</ul>
</li>
<li>获取实例（私有变量，公开属性）<ul>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608112252141.png" alt="image-20230608112252141" style="zoom:80%;"></li>
</ul>
</li>
<li>析构<ul>
<li>当实例对象就是当前单例对象时，销毁单例对象的同时也将实例对象销毁。<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608112953207.png" alt="image-20230608112953207" style="zoom:80%;"></li>
</ul>
</li>
<li>具体类型脚本继承单例类型脚本后<ul>
<li>重写Awake，DontDestroyOnLoad(this)使得切换场景时不析构该脚本对象。<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608113523815.png" alt="image-20230608113523815" style="zoom:80%;"></li>
</ul>
</li>
</ul>
<h2 id="11-接口-与-观察者模式：订阅和广播"><a href="#11-接口-与-观察者模式：订阅和广播" class="headerlink" title="11.接口 与 观察者模式：订阅和广播"></a>11.接口 与 观察者模式：订阅和广播</h2><p>主要广播的是Player死亡的消息</p>
<h3 id="EndGameObserver-接口"><a href="#EndGameObserver-接口" class="headerlink" title="EndGameObserver 接口"></a>EndGameObserver 接口</h3><p>如名称所示，该接口意为 游戏结束的观测者 ，其接口方法则是 游戏结束时的处理方法 。</p>
<ul>
<li>接口的脚本文件以I开头<ul>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608121427054.png" alt="image-20230608121427054" style="zoom:80%;"></li>
</ul>
</li>
<li>接口声明<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608121512905.png" alt="image-20230608121512905" style="zoom:80%;"></li>
<li>接口方法，使用（继承）了接口的脚本都要实现接口方法<ul>
<li>EndNotify</li>
</ul>
</li>
<li>继承接口和实现接口方法<ul>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608121727677.png" alt="image-20230608121727677" style="zoom:80%;"></li>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608121813288.png" alt="image-20230608121813288" style="zoom:80%;"></li>
</ul>
</li>
</ul>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>Game Manager 记录所有实现了接口的对象，并在事件发生时广播消息给这些对象。</p>
<p>游戏对象作为观察者，并在Game Manager中注册，以在适当的时候接收广播消息。</p>
<ul>
<li><p>Game Manager</p>
<ul>
<li>提供注册函数和注销函数<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608122127201.png" alt="image-20230608122127201" style="zoom:80%;"></li>
<li>广播消息<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608122509030.png" alt="image-20230608122509030" style="zoom:80%;"></li>
</ul>
</li>
<li><p>在游戏对象的Controller脚本中进行注册和注销（启用和关闭时）</p>
<ul>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608122257093.png" alt="image-20230608122257093" style="zoom:80%;"></li>
</ul>
</li>
<li><p>在Player死亡时，由PlayerController启动Game Manager的广播</p>
<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608122732454.png" alt="image-20230608122732454" style="zoom:80%;"></li>
</ul>
<h3 id="接口方法的具体实现"><a href="#接口方法的具体实现" class="headerlink" title="接口方法的具体实现"></a>接口方法的具体实现</h3><ul>
<li>胜利动画<ul>
<li>单独建一个Layer，启用覆盖，并用一个bool值控制，可以从任何动画状态切换进入<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608123619992.png" alt="image-20230608123619992" style="zoom:80%;"></li>
<li>并且取消勾选 Cant Transition To Self</li>
</ul>
</li>
<li>停止其他动画状态</li>
<li>攻击目标置空</li>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608123512271.png" alt="image-20230608123512271" style="zoom:80%;"></li>
</ul>
<h2 id="12-更多敌人"><a href="#12-更多敌人" class="headerlink" title="12.更多敌人"></a>12.更多敌人</h2><h3 id="独享数据文件"><a href="#独享数据文件" class="headerlink" title="独享数据文件"></a>独享数据文件</h3><ul>
<li>将 源Scriptable Object文件 作为模板，初始化一份独有的Scriptable Object文件来实际管理数值。<ul>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608124419519.png" alt="image-20230608124419519" style="zoom:80%;"></li>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608124607913.png" alt="image-20230608124607913" style="zoom:80%;"></li>
</ul>
</li>
</ul>
<h3 id="制作已有类型敌人（史莱姆和乌龟）"><a href="#制作已有类型敌人（史莱姆和乌龟）" class="headerlink" title="制作已有类型敌人（史莱姆和乌龟）"></a>制作已有类型敌人（史莱姆和乌龟）</h3><ul>
<li>相同的Controller脚本，附带相同的组件</li>
<li>自建Asset数据模板文件，并填写基础数值</li>
<li>动画：制作Animator Controller，可以用 Animator Override Controller 快速利用原有的其他Animator Controller。<ul>
<li>只能替换动画<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608134433661.png" alt="image-20230608134433661" style="zoom:80%;"></li>
<li>对有Override关系的动画控制器进行修改的话，会相互影响</li>
</ul>
</li>
<li>保存prefab</li>
</ul>
<h3 id="制作新类型敌人（兽人和石头人）"><a href="#制作新类型敌人（兽人和石头人）" class="headerlink" title="制作新类型敌人（兽人和石头人）"></a>制作新类型敌人（兽人和石头人）</h3><h4 id="兽人"><a href="#兽人" class="headerlink" title="兽人"></a>兽人</h4><ul>
<li>动画：新建Animator Controller，可以通过复制得到后进行修改，不会影响原来的动画控制器。<ul>
<li>更换动画文件</li>
<li>暴击攻击换成技能攻击，修改动画变量和切换条件</li>
</ul>
</li>
<li>脚本：主要多实现了技能攻击<ul>
<li>继承通用Controller</li>
<li>实现 KickOff 动画事件（击退效果）<ul>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608140925727.png" alt="image-20230608140925727" style="zoom:80%;"></li>
<li>采用NavMeshAgent的velocity方法施加力<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608164531038.png" alt="image-20230608164531038" style="zoom:80%;"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="其他内容"><a href="#其他内容" class="headerlink" title="其他内容"></a>其他内容</h4><h5 id="动画状态机"><a href="#动画状态机" class="headerlink" title="动画状态机"></a>动画状态机</h5><p><strong>角色被攻击后，设置眩晕或受击时无法移动</strong></p>
<ul>
<li>为动画状态添加Behaviour脚本<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608165206326.png" alt="image-20230608165206326" style="zoom:80%;"></li>
<li>Unity内置的状态机脚本<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608165455352.png" alt="image-20230608165455352" style="zoom:80%;">
- 分别设定 进入动画、动画执行、退出动画...时的执行内容
- 注意NavMeshAgent组件在角色死亡时会先销毁，而动画执行未结束，导致这里报错。可以将死亡时的处理代码改为将NavMeshAgent组件的Radius置0，达到死亡后对导航不挡路的效果。</li>
</ul>
<h5 id="拓展方法"><a href="#拓展方法" class="headerlink" title="拓展方法"></a>拓展方法</h5><p>给一个类加一个自己写的方法，这里是给 Transform 类添加内容</p>
<ul>
<li>语法要求：public static 类，无继承<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608185319267.png" alt="image-20230608185319267" style="zoom:80%;"></li>
<li>添加的是攻击扇形范围的角度，以及判断攻击目标是否处于角度范围内的方法<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608191039779.png" alt="image-20230608191039779" style="zoom:80%;">
- this Transform xxx 指定要添加内容的类
- Transform target 是方法的参数</li>
<li>使用：直接用transform组件调用自定义方法<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608191241671.png" alt="image-20230608191241671" style="zoom:80%;"></li>
</ul>
<h4 id="石头人"><a href="#石头人" class="headerlink" title="石头人"></a>石头人</h4><ul>
<li>动画：override 兽人的动画控制器</li>
<li>脚本：继承同样Controller</li>
<li>普通攻击带击退 ，远程攻击扔石头+击退</li>
<li>设计数值（基本数值，攻击距离，冷却，力度 …)</li>
</ul>
<p><strong>扔石头</strong></p>
<ul>
<li>对于石头<ul>
<li>为石头prefab添加控制脚本、刚体、碰撞体等组件</li>
<li>石头在生成时就飞向攻击目标（抛射），生成位置为举手抛出时的position（利用手部模型子对象的Transform）</li>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608203209013.png" alt="image-20230608203209013"></li>
</ul>
</li>
<li>对于石头人<ul>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608202826309.png" alt="image-20230608202826309" style="zoom:80%;"></li>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608203244331.png" alt="image-20230608203244331" style="zoom:80%;"></li>
</ul>
</li>
</ul>
<p><strong>玩家击回石头</strong></p>
<ul>
<li><p>石头的三个状态</p>
<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608213629690.png" alt="image-20230608213629690" style="zoom:80%;">
</li>
<li><p>Hit Player</p>
<ul>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608214016997.png" alt="image-20230608214016997" style="zoom:80%;"></li>
<li>击退 + 造成伤害</li>
<li>切换状态为 Hit Nothing</li>
<li>在数据控制脚本中重载伤害计算方法<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608214217045.png" alt="image-20230608214217045" style="zoom:80%;"></li>
</ul>
</li>
<li><p>Hit Enemy</p>
<ul>
<li>伤害造成（对石头人），并销毁自身<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608214824954.png" alt="image-20230608214824954" style="zoom:80%;"></li>
<li>玩家击打石头<ul>
<li>设置石头的标签为 attackable</li>
<li>Mouse Manager添加对该标签物体的鼠标指针管理（OnEnemyClicked信号触发）<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608215320548.png" alt="image-20230608215320548" style="zoom:80%;"></li>
<li>在Player Controller里对 Hit动画事件 做文章，若攻击对象是石头，则造成击飞效果<br><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608220000170.png" alt="image-20230608220000170"><ul>
<li>要在打击后，设置石头的初速度</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Hit Nothing</p>
<ul>
<li><p>一种是击中玩家后，切换为 Hit Nothing 状态</p>
</li>
<li><p>另一种情况是，未击中玩家，当速度下降接近0时，切换为 Hit Nothing 状态</p>
<ul>
<li>在 FixedUpdate 中读写物理相关的数据</li>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608215906297.png" alt="image-20230608215906297" style="zoom:80%;"></li>
</ul>
</li>
</ul>
</li>
<li><p>另外要给小狗加上刚体组件，防止跟石头穿模。并且要勾选 is Kinematic 。</p>
</li>
</ul>
<p><strong>粒子效果：石头碎裂</strong></p>
<ul>
<li><p>在Hierarchy中创建碎石效果</p>
<ul>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608220428244.png" alt="image-20230608220428244" style="zoom:80%;"></li>
</ul>
</li>
<li><p>设置各种各样的参数</p>
<ul>
<li>Gravity Modifier 重力下落效果</li>
<li>Collision 与其他物体产生碰撞<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608220903263.png" alt="image-20230608220903263" style="zoom:80%;"></li>
<li>Start Lifetime 生命周期</li>
<li>Start Size 设为随机尺寸<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608221203967.png" alt="image-20230608221203967" style="zoom: 67%;"></li>
<li>Renderer<ul>
<li>Render mode 改为 Mesh</li>
<li>Mesh文件采用石头的Mesh</li>
<li>设置材质</li>
</ul>
</li>
<li>角度变化<ul>
<li>Rotation By Speed</li>
<li>Rotation over Lifetime</li>
</ul>
</li>
</ul>
</li>
<li><p>保存为prefab</p>
</li>
<li><p>脚本获取效果并触发效果</p>
<ul>
<li>用gameObject变量获取</li>
<li>在石头的HitEnemy状态处理代码中生成效果<br><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608221624698.png" alt="image-20230608221624698"></li>
</ul>
</li>
</ul>
<h2 id="13-简单UI"><a href="#13-简单UI" class="headerlink" title="13.简单UI"></a>13.简单UI</h2><h3 id="血条"><a href="#血条" class="headerlink" title="血条"></a>血条</h3><ul>
<li>创建画布 Canvas<ul>
<li>Render Mode 采用 World Space</li>
<li>Event Camera 设为 Main Camera</li>
</ul>
</li>
<li>创建画布的子物体：<ul>
<li>创建 Image 来作为血条</li>
<li>两条长方 square ，一红一绿，通过覆盖和改变长度来表现血条</li>
</ul>
</li>
<li>创建脚本控制UI的生成 : HealthBarUI.cs 每个有血条的角色都要挂载<ul>
<li>在每一个角色头上生成、展示血条</li>
<li>提前给每个角色prefab加一个空的子物体表示血条位置，或者也可以自己在代码中计算位置</li>
<li>脚本需要的数据成员<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608235352306.png" alt="image-20230608235352306" style="zoom:80%;">
- 相机Transform组件用于使血条平面始终平行于相机画面</li>
<li>更新血量事件。参数为当前血量和最大血量。<br><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608235059330.png" alt="image-20230608235059330"><ul>
<li>在每次攻击发生时进行触发事件（TakeDamage伤害计算函数，在数据控制脚本中）<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230608235233226.png" alt="image-20230608235233226" style="zoom:80%;"></li>
<li>注册事件处理函数<ul>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230609000013087.png" alt="image-20230609000013087" style="zoom: 80%;"></li>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230609000127215.png" alt="image-20230609000127215"></li>
</ul>
</li>
</ul>
</li>
<li>血条位置更新<ul>
<li>LateUpdate的执行时机实在本帧完成后。也可用于相机跟随之类的功能。</li>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230609000412130.png" alt="image-20230609000412130" style="zoom:80%;"></li>
</ul>
</li>
<li>若血条设置不是永久显示，需要更新显示计时<ul>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230609000711625.png" alt="image-20230609000711625" style="zoom:80%;"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="经验值与升级"><a href="#经验值与升级" class="headerlink" title="经验值与升级"></a>经验值与升级</h3><h4 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h4><p><strong>玩家数据脚本</strong></p>
<ul>
<li><p>在玩家的 Scriptable Object 文件中</p>
<ul>
<li>添加跟等级有关的数据字段<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230610011457529.png" alt="image-20230610011457529" style="zoom:80%;"></li>
<li>添加经验更新方法<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230610011612004.png" alt="image-20230610011612004" style="zoom:80%;"></li>
<li>升级处理方法<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230610011829408.png" alt="image-20230610011829408" style="zoom:80%;"></li>
</ul>
</li>
<li><p>在外部的攻击活动中调用经验更新（击杀时）</p>
<ul>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230610012111972.png" alt="image-20230610012111972" style="zoom:80%;"></li>
</ul>
</li>
</ul>
<p><strong>UI控制脚本</strong></p>
<ul>
<li>获取UI物件<ul>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230610015511118.png" alt="image-20230610015511118" style="zoom:80%;"></li>
</ul>
</li>
<li>更新UI物件：生命值、经验值、文字<ul>
<li><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230610015632242.png" alt="image-20230610015632242"></li>
<li>不建议在Update中更新<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230610015742815.png" alt="image-20230610015742815" style="zoom:80%;"></li>
</ul>
</li>
</ul>
<h4 id="UI处理"><a href="#UI处理" class="headerlink" title="UI处理"></a>UI处理</h4><p>创建画布 Canvas</p>
<ul>
<li>Render Mode: Screen Space-Overlay </li>
<li>Canvas Scaler 的 Scale Mode 设为 <img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/../../../游戏开发/3D RPG/3D RPG 回顾/image-20230610015100042.png" alt="image-20230610015100042" style="zoom: 67%;">
<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230610015131065.png" alt="image-20230610015131065" style="zoom:67%;"></li>
</ul>
<p><strong>玩家血条</strong></p>
<ul>
<li>在画布下创建 Image<ul>
<li>调整布局位置，按住 alt+shift 选择左上角<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230610014416713.png" alt="image-20230610014416713" style="zoom:80%;"></li>
<li>调整大小，具体位置，颜色</li>
<li>还需要一个子 Image 覆盖实现血条滑动效果<ul>
<li>应该是绿色，然后调整Image Type相关参数<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230610014624384.png" alt="image-20230610014624384" style="zoom:80%;"></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>经验条</strong></p>
<ul>
<li>复制上面的血条，调整一下外观即可</li>
</ul>
<p><strong>等级</strong></p>
<ul>
<li>创建一个 Text 然后同上调整位置和外观</li>
</ul>
<h2 id="14-场景切换"><a href="#14-场景切换" class="headerlink" title="14.场景切换"></a>14.场景切换</h2><h3 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a>传送门</h3><ul>
<li>创建 Lit Shader Graph<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230610123834553.png" alt="image-20230610123834553" style="zoom:80%;"></li>
<li>打开 shader graph <ul>
<li>设定显示模式<br><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230610123948606.png" alt="image-20230610123948606"></li>
<li>创建基本节点：Twirl<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230610124147731.png" alt="image-20230610124147731" style="zoom: 67%;"></li>
<li>与 Voronol 叠加<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230610124217404.png" alt="image-20230610124217404" style="zoom:80%;"></li>
<li>将时间和一个float变量相乘，作为offset控制旋转速度，并用另一个float设置强度strength<br><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230610124503197.png" alt="image-20230610124503197"><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/../../../游戏开发/3D RPG/3D RPG 回顾/image-20230610124605348.png" alt="image-20230610124605348" style="zoom: 67%;"></li>
<li>设置2D纹理，建立 Sample Texture 2D节点，并用一个 Texture 2D 变量指定纹理图片<br><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230610124906224.png" alt="image-20230610124906224"></li>
<li>加上颜色，输出到片段着色器的 Emission<br><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230610124956317.png" alt="image-20230610124956317"></li>
<li>再加上透明通道<br><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230610125033851.png" alt="image-20230610125033851"><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/../../../游戏开发/3D RPG/3D RPG 回顾/image-20230610125112548.png" alt="image-20230610125112548" style="zoom:80%;"></li>
<li>双向显示，在Graph Inspector中勾选Two Sided</li>
</ul>
</li>
<li>利用做好的 Shader 创建 Material<br><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230610125227192.png" alt="image-20230610125227192"></li>
<li>创建一个 Quad 物体并把材质附上，在Mesh Renderer关闭阴影，勾选 Always Refresh 查看效果<br><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230610125333402.png" alt="image-20230610125333402"></li>
<li>Shader中的颜色节点勾选HDR，可以调整效果更亮&#x2F;更暗</li>
<li>使用Power节点可以再增强效果<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230610125649902.png" alt="image-20230610125649902" style="zoom: 67%;"></li>
</ul>
<p><strong>传送</strong></p>
<p>每个传送门表示了 自身地点 和 传送目的地 。</p>
<ul>
<li><p>给每个传送门创建一个空子物体，作为其传送点</p>
<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230610125932333.png" alt="image-20230610125932333" style="zoom:80%;">
<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/../../../游戏开发/3D RPG/3D RPG 回顾/image-20230610125853188.png" alt="image-20230610125853188" style="zoom:80%;">
</li>
<li><p>两个脚本管理传送</p>
<ul>
<li>TransitionPoint.cs 管理传送门标签，作为传送门的组件<br><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230610130600330.png" alt="image-20230610130600330"><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230610130615401.png" alt="image-20230610130615401" style="zoom:80%;"></li>
<li>TransitionDestination.cs 管理传送目的地<br><img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230610130539683.png" alt="image-20230610130539683"></li>
</ul>
</li>
<li><p>传送门 碰撞检测触发传送</p>
<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230610130857682.png" alt="image-20230610130857682" style="zoom:80%;">
![image-20230610130813083](3D-RPG-Demo回顾/image-20230610130813083.png)

<p>在Update里检测按键传送</p>
</li>
</ul>
<h3 id="传送"><a href="#传送" class="headerlink" title="传送"></a>传送</h3><p>用脚本控制场景切换：SceneController.cs</p>
<p>利用协程异步加载场景和切换角色位置</p>
<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230626201210879.png" alt="image-20230626201210879" style="zoom:80%;">

<h4 id="同场景传送"><a href="#同场景传送" class="headerlink" title="同场景传送"></a>同场景传送</h4><p>传送过程：  </p>
<ul>
<li>获取游戏主角的object，及其agent</li>
<li>全局查找到目标传送点对象</li>
<li>停用Player对象的Agent，切换Player对象的位置角度到传送点，再启用Agent</li>
</ul>
<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230626191336726.png" alt="image-20230626191336726" style="zoom:80%;">





<h4 id="跨场景传送"><a href="#跨场景传送" class="headerlink" title="跨场景传送"></a>跨场景传送</h4><p>传送过程：  </p>
<ul>
<li>异步加载场景</li>
<li>重新初始化主角的prefab，位于传送门位置</li>
<li>停用Player对象的Agent，切换Player对象的位置角度到传送点，再启用Agent</li>
</ul>
<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230626201615795.png" alt="image-20230626201615795" style="zoom:80%;">

<ul>
<li>对各种Manager，最好启用DontDestroyOnLoad<img src="/2023/06/06/3D-RPG-Demo%E5%9B%9E%E9%A1%BE/image-20230626201816138.png" alt="image-20230626201816138" style="zoom:80%;"></li>
</ul>
<h2 id="15-数据保存"><a href="#15-数据保存" class="headerlink" title="15.数据保存"></a>15.数据保存</h2><h2 id="16-主菜单"><a href="#16-主菜单" class="headerlink" title="16.主菜单"></a>16.主菜单</h2><h3 id="主菜单"><a href="#主菜单" class="headerlink" title="主菜单"></a>主菜单</h3><h3 id="场景切换淡入淡出"><a href="#场景切换淡入淡出" class="headerlink" title="场景切换淡入淡出"></a>场景切换淡入淡出</h3><h2 id="17-打包程序"><a href="#17-打包程序" class="headerlink" title="17.打包程序"></a>17.打包程序</h2>]]></content>
      <categories>
        <category>游戏开发</category>
        <category>客户端</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>LearnOpenGL摘要（入门一）</title>
    <url>/2024/03/30/LearnOpenGL%E6%91%98%E8%A6%81/</url>
    <content><![CDATA[<h1 id="基本概念，环境搭建，画三角形"><a href="#基本概念，环境搭建，画三角形" class="headerlink" title="基本概念，环境搭建，画三角形"></a>基本概念，环境搭建，画三角形</h1><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><blockquote>
<p>OpenGL规范严格规定了每个函数该如何执行，以及它们的输出值。至于内部具体每个函数是如何实现(Implement)的，将由OpenGL库的开发者自行决定（译注：这里开发者是指编写OpenGL库的人）。</p>
</blockquote>
<ul>
<li><a href="https://registry.khronos.org/OpenGL/specs/gl/glspec33.core.pdf">OpenGL规范</a></li>
</ul>
<span id="more"></span>

<h2 id><a href="#" class="headerlink" title></a></h2><h3 id="核心渲染"><a href="#核心渲染" class="headerlink" title="核心渲染"></a>核心渲染</h3><ul>
<li><p>Core-profile mode</p>
</li>
<li><p>库函数更加现代，有更高的灵活性和效率。</p>
</li>
<li><p>现代函数要求使用者真正理解OpenGL和图形编程。</p>
</li>
</ul>
<h3 id="立即渲染"><a href="#立即渲染" class="headerlink" title="立即渲染"></a>立即渲染</h3><ul>
<li>Immediate mode，也就是固定渲染管线</li>
<li>从OpenGL实际运作中抽象掉了很多细节，因此它在易于学习的同时，也很难让人去把握OpenGL具体是如何运作的。</li>
</ul>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><ul>
<li>不必等待一个新的OpenGL规范面世，就可以使用这些新的渲染特性</li>
<li>只需要简单地检查一下显卡是否支持此扩展</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(GL_ARB_extension_name)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 使用硬件支持的全新的现代特性</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 不支持此扩展: 用旧的方式去做</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h3><ul>
<li>OpenGL自身是一个巨大的状态机</li>
<li>OpenGL的状态通常被称为OpenGL上下文(Context)，由一系列的变量描述OpenGL此刻应当如何运行</li>
<li>更改OpenGL状态的途径：设置选项，操作缓冲</li>
<li>两类函数<ul>
<li>状态设置函数(State-changing Function)：改变上下文</li>
<li>状态使用函数(State-using Function)：根据当前OpenGL的状态执行一些操作</li>
</ul>
</li>
</ul>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><ul>
<li>为c语言结构体引入的一层抽象：对象Object</li>
<li>OpenGL对象：指一些选项的集合，它代表OpenGL状态的一个子集</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类似的： </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">object_name</span> &#123;</span></span><br><span class="line">    <span class="type">float</span>  option1;</span><br><span class="line">    <span class="type">int</span>    option2;</span><br><span class="line">    <span class="type">char</span>[] name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用的方式类似下方：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// OpenGL的状态</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OpenGL_Context</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    object* object_Window_Target;</span><br><span class="line">    ...     </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> objectId = <span class="number">0</span>;</span><br><span class="line">glGenObject(<span class="number">1</span>, &amp;objectId);</span><br><span class="line"><span class="comment">// 绑定对象至上下文</span></span><br><span class="line">glBindObject(GL_WINDOW_TARGET, objectId);</span><br><span class="line"><span class="comment">// 设置当前绑定到 GL_WINDOW_TARGET 的对象的一些选项</span></span><br><span class="line">glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_WIDTH, <span class="number">800</span>);</span><br><span class="line">glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_HEIGHT, <span class="number">600</span>);</span><br><span class="line"><span class="comment">// 将上下文对象设回默认</span></span><br><span class="line">glBindObject(GL_WINDOW_TARGET, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用对象的一个好处是在程序中，我们不止可以定义一个对象，并设置它们的选项，每个对象都可以是不同的设置。在我们执行一个使用OpenGL状态的操作的时候，只需要绑定含有需要的设置的对象即可</p>
</li>
</ul>
<h2 id="二、实操"><a href="#二、实操" class="headerlink" title="二、实操"></a>二、实操</h2><ul>
<li>OpenGL编程实操：首先需要一个OpenGL上下文和一个输出显示窗口，以及处理用户输入。</li>
<li>有一些库已经封装好了上一步提到的内容，而不需要我们自己进行系统编程。最流行的几个库有GLUT，SDL，SFML和GLFW。</li>
<li>教程中使用GLFW。</li>
</ul>
<h3 id="GLFW"><a href="#GLFW" class="headerlink" title="GLFW"></a>GLFW</h3><ul>
<li>不直接使用编译好的库：从源代码编译库可以保证生成的库完全适合你的操作系统和CPU的，而预编译的二进制文件则并非总是适用于您的系统。</li>
<li>自己编译带来的问题：并不是每个人都用相同的IDE或者构建系统来搞开发，因而提供的项目&#x2F;解决方案文件可能和一些人的IDE不兼容。</li>
</ul>
<h4 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h4><ul>
<li>工程文件生成工具</li>
<li>用户可以使用预定义好的CMake脚本，根据自己的选择（像是Visual Studio, Code::Blocks, Eclipse）生成不同IDE的工程文件</li>
</ul>
<blockquote>
<p>tip：貌似CMake配置VS2017的只能编译32位版本的glfw3.lib，如果自己的项目是64位的，会出现链接错误。</p>
<p>快速的解决方法是直接用官方编译好的库文件。</p>
</blockquote>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol>
<li>使用CMake配置和生成所选IDE的项目配置和构建信息</li>
<li>用IDE打开项目后进行编译和构建</li>
<li>生成之后就可以使用了。在我们自己的项目中，配置好头文件和库的位置即可。</li>
<li>可以把需要用到的库文件和头文件放到单独的一个地方管理，在其他项目中加入这个地方的路径来引入对应内容即可。</li>
</ol>
<h3 id="GLAD"><a href="#GLAD" class="headerlink" title="GLAD"></a>GLAD</h3><ul>
<li><p>由于OpenGL驱动版本众多，它大多数函数的位置都无法在编译时确定下来，需要在运行时查询。开发者需要在运行时获取函数地址并将其保存在一个函数指针中供以后使用。</p>
</li>
<li><p>取得地址的方法因平台而异，在Windows上会是类似这样：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义函数原型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*GL_GENBUFFERS)</span> <span class="params">(GLsizei, GLuint*)</span>;</span><br><span class="line"><span class="comment">// 找到正确的函数并赋值给函数指针</span></span><br><span class="line">GL_GENBUFFERS glGenBuffers  = (GL_GENBUFFERS)wglGetProcAddress(<span class="string">&quot;glGenBuffers&quot;</span>);</span><br><span class="line"><span class="comment">// 现在函数可以被正常调用了</span></span><br><span class="line">GLuint buffer;</span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;buffer);</span><br></pre></td></tr></table></figure>
</li>
<li><p>幸运的是，有些库能简化此过程，其中<strong>GLAD</strong>是目前最新，也是最流行的库。</p>
</li>
</ul>
<blockquote>
<p>打开GLAD的<a href="http://glad.dav1d.de/">在线服务</a>，将语言(Language)设置为<strong>C&#x2F;C++<strong>，在API选项中，选择</strong>3.3</strong>以上的OpenGL(gl)版本（我们的教程中将使用3.3版本，但更新的版本也能用）。之后将模式(Profile)设置为<strong>Core</strong>，并且保证选中了<strong>生成加载器</strong>(Generate a loader)选项。现在可以先（暂时）忽略扩展(Extensions)中的内容。都选择完之后，点击<strong>生成</strong>(Generate)按钮来生成库文件。</p>
</blockquote>
<h3 id="创建窗口"><a href="#创建窗口" class="headerlink" title="创建窗口"></a>创建窗口</h3><ul>
<li>代码一：初始化</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化glfw窗口</span></span><br><span class="line">    glfwInit();</span><br><span class="line">    <span class="comment">// 告知glfw要使用的opengl版本</span></span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">    <span class="comment">// 告知glfw要使用的opengl渲染模式</span></span><br><span class="line">    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//mac os x系统需要用到   </span></span><br><span class="line">    <span class="comment">//glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>代码二：创建窗口，设置上下文</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GLFWwindow* window = glfwCreateWindow(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;LearnOpenGL&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    glfwTerminate();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">glfwMakeContextCurrent(window);</span><br></pre></td></tr></table></figure>

<ul>
<li>代码三：初始化GLAD</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在glfw初始化和创建窗口之后才能初始化glad</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>代码四：设置视口View Port</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前两个参数控制窗口左下角的位置。第三个和第四个参数控制渲染窗口的宽度和高度（像素）</span></span><br><span class="line">glViewport(<span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">600</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置窗口大小变化时的回调函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span><br><span class="line">&#123;</span><br><span class="line">    glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);</span><br></pre></td></tr></table></figure>

<ul>
<li>代码五：释放资源</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">glfwTerminate();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>



<h3 id="渲染循环"><a href="#渲染循环" class="headerlink" title="渲染循环"></a>渲染循环</h3><p>让GLFW退出前一直保持运行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(!glfwWindowShouldClose(window))	<span class="comment">// 检查是否被要求退出窗口</span></span><br><span class="line">&#123;</span><br><span class="line">    glfwSwapBuffers(window);			<span class="comment">// 交换颜色缓冲，输出显示到屏幕</span></span><br><span class="line">    glfwPollEvents();    				<span class="comment">// 检查有没有触发什么事件（比如键盘输入、鼠标移动等）、更新窗口状态，并调用对应的回调函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>双缓冲：</p>
<ul>
<li>应用程序使用单缓冲绘图时可能会存在图像闪烁的问题。因为生成的图像不是一下子被绘制出来的，而是按照从左到右，由上而下逐像素地绘制而成的。</li>
<li>应用双缓冲渲染窗口应用程序。<strong>前</strong>缓冲保存着最终输出的图像，它会在屏幕上显示；而所有的的渲染指令都会在<strong>后</strong>缓冲上绘制。</li>
<li>当所有的渲染指令执行完毕后，我们<strong>交换</strong>(Swap)前缓冲和后缓冲，这样图像就立即呈显出来，之前提到的不真实感就消除了。</li>
</ul>
</blockquote>
<h3 id="输入控制"><a href="#输入控制" class="headerlink" title="输入控制"></a>输入控制</h3><p>案例为检测ESC是否按下，按下则关闭窗口</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// glfwGetKey函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">processInput</span><span class="params">(GLFWwindow *window)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)</span><br><span class="line">        glfwSetWindowShouldClose(window, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染循环中检测</span></span><br><span class="line"><span class="keyword">while</span> (!glfwWindowShouldClose(window))</span><br><span class="line">&#123;</span><br><span class="line">    processInput(window);</span><br><span class="line"></span><br><span class="line">    glfwSwapBuffers(window);</span><br><span class="line">    glfwPollEvents();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="渲染操作"><a href="#渲染操作" class="headerlink" title="渲染操作"></a>渲染操作</h3><p>在渲染循环中加入渲染指令</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 渲染循环</span></span><br><span class="line"><span class="keyword">while</span>(!glfwWindowShouldClose(window))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 输入</span></span><br><span class="line">    processInput(window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染指令</span></span><br><span class="line">    glClearColor(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">	glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查并调用事件，交换缓冲</span></span><br><span class="line">    glfwPollEvents();</span><br><span class="line">    glfwSwapBuffers(window);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>清空缓冲：</p>
<ul>
<li>glClear（Buffer Bit）<ul>
<li>GL_COLOR_BUFFER_BIT 颜色缓冲</li>
<li>GL_DEPTH_BUFFER_BIT 深度缓冲</li>
<li>GL_STENCIL_BUFFER_BIT 模板缓冲</li>
</ul>
</li>
</ul>
<blockquote>
<p>tip：glClearColor函数是一个<strong>状态设置</strong>函数，而glClear函数则是一个<strong>状态使用</strong>的函数</p>
</blockquote>
<h3 id="画三角形"><a href="#画三角形" class="headerlink" title="画三角形"></a>画三角形</h3><h4 id="三类OpenGL对象"><a href="#三类OpenGL对象" class="headerlink" title="三类OpenGL对象"></a>三类OpenGL对象</h4><ul>
<li>顶点数组对象：Vertex Array Object，VAO</li>
<li>顶点缓冲对象：Vertex Buffer Object，VBO</li>
<li>元素缓冲对象：Element Buffer Object，EBO 或 索引缓冲对象 Index Buffer Object，IBO</li>
</ul>
<h4 id="图形渲染管线"><a href="#图形渲染管线" class="headerlink" title="图形渲染管线"></a>图形渲染管线</h4><ul>
<li>接受一组3D坐标，然后把它们转变为你屏幕上的有色2D像素输出。</li>
<li>可以被划分为几个阶段，每个阶段将会把前一个阶段的输出作为输入。</li>
<li>所有这些阶段都是高度专门化的（它们都有一个特定的函数），并且很容易并行执行。</li>
</ul>
<p><strong>着色器</strong></p>
<ul>
<li>在GPU上为每一个（渲染管线）阶段运行各自的小程序。</li>
<li>部分着色器可由用户自行定义</li>
<li>OpenGL着色器是用OpenGL着色器语言(OpenGL Shading Language, GLSL)写成的，在下一节中我们再花更多时间研究它。</li>
</ul>
<p><img src="/2024/03/30/LearnOpenGL%E6%91%98%E8%A6%81/image-20240328171158977.png" alt="image-20240328171158977"></p>
<blockquote>
<p>图元 (Primitive)：</p>
<ul>
<li>OpenGL需要你去指定一组顶点数据所表示的渲染类型。我们是希望把这些数据渲染成一系列的点？一系列的三角形？还是仅仅是一个长长的线？</li>
<li>任何一个绘制指令的调用都将把图元传递给OpenGL。</li>
<li>这是其中的几个：GL_POINTS、GL_TRIANGLES、GL_LINE_STRIP。</li>
</ul>
</blockquote>
<h5 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h5><ul>
<li>输入：一个顶点的信息（位置，…）</li>
<li>过程：<ul>
<li>进行坐标变换</li>
<li>一些其他的处理</li>
</ul>
</li>
<li>输出：变换后的顶点信息</li>
</ul>
<h5 id="几何着色器"><a href="#几何着色器" class="headerlink" title="几何着色器"></a>几何着色器</h5><ul>
<li>输入：一组顶点着色器输出的顶点（选择性）</li>
<li>过程：<ul>
<li>将一组顶点表示为一个图元</li>
<li>根据原有顶点，生成新的顶点，以形成新的或其他的图元和形状</li>
</ul>
</li>
<li>输出：新的顶点信息</li>
</ul>
<h5 id="图元装配-Primitive-Assembly"><a href="#图元装配-Primitive-Assembly" class="headerlink" title="图元装配(Primitive Assembly)"></a>图元装配(Primitive Assembly)</h5><ul>
<li>输入：顶点着色器（或几何着色器）输出的所有顶点</li>
<li>过程：<ul>
<li>将所有的点装配成指定图元的形状</li>
</ul>
</li>
<li>输出：图元信息</li>
</ul>
<h5 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h5><ul>
<li>输入：图元信息</li>
<li>过程：把图元映射为最终屏幕上相应的像素，生成供片段着色器(Fragment Shader)使用的片段(Fragment)</li>
<li>输出：片段信息（OpenGL中的一个片段是OpenGL渲染一个像素所需的所有数据）</li>
</ul>
<h5 id="片段着色器"><a href="#片段着色器" class="headerlink" title="片段着色器"></a>片段着色器</h5><ul>
<li>输入：片段信息</li>
<li>过程：<ul>
<li>运行前，先进行裁切（clipping），丢弃viewport之外的片段</li>
<li>使用3D场景的数据（比如光照、阴影、光的颜色等等）计算最终像素的颜色</li>
</ul>
</li>
<li>输出：片段的像素颜色</li>
</ul>
<h5 id="测试与混合"><a href="#测试与混合" class="headerlink" title="测试与混合"></a>测试与混合</h5><ul>
<li>输入：片段信息</li>
<li>过程：（逐片段处理）<ul>
<li>透明度测试</li>
<li>模板测试</li>
<li>深度测试（遮挡）</li>
<li>混合</li>
</ul>
</li>
<li>输出：片段像素的最终颜色</li>
</ul>
<blockquote>
<p>在opengl中，需要自己实现 顶点着色器 和 片段着色器</p>
</blockquote>
<h4 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h4><h5 id="顶点输入，创建VBO缓冲"><a href="#顶点输入，创建VBO缓冲" class="headerlink" title="顶点输入，创建VBO缓冲"></a>顶点输入，创建VBO缓冲</h5><ul>
<li>opengl接受的顶点坐标是在标准化设备坐标下的，即坐标值（-1，1）之间</li>
<li>定义一组顶点</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>顶点着色器将顶点在3D世界坐标下的坐标，经过一系列变换，变换到标准化设备坐标。</li>
<li>标准化设备坐标通过glViewport函数进行视口变换变换到屏幕坐标。</li>
<li>片元的位置信息为其屏幕坐标。</li>
</ul>
<blockquote>
<p>VBO：</p>
<ul>
<li><p>通过顶点缓冲对象(Vertex Buffer Objects, VBO)管理GPU中存储顶点信息的内存（显存）。</p>
</li>
<li><p>使用这些缓冲对象的好处是我们可以一次性的发送一大批数据到显卡上，而不是每个顶点发送一次。</p>
</li>
<li><p>可以使用glGenBuffers函数和一个缓冲ID生成一个VBO对象，并绑定顶点缓冲</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> VBO;</span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);  </span><br><span class="line">      </span><br><span class="line"><span class="comment">// 把之前定义的顶点数据复制到缓冲的内存</span></span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"><span class="comment">// 第四个参数为显卡对数据的管理模式</span></span><br></pre></td></tr></table></figure>

<ul>
<li>GL_STATIC_DRAW ：数据不会或几乎不会改变。</li>
<li>GL_DYNAMIC_DRAW：数据会被改变很多。</li>
<li>GL_STREAM_DRAW ：数据每次绘制时都会改变。</li>
</ul>
</li>
</ul>
</blockquote>
<h5 id="顶点着色器-1"><a href="#顶点着色器-1" class="headerlink" title="顶点着色器"></a>顶点着色器</h5><ul>
<li><p>着色器语言，此处用GLSL</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core </span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(aPos.x, aPos.y, aPos.z, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>版本声明</li>
<li>声明输入顶点的所有属性(Input Vertex Attribute)，此处仅位置属性</li>
<li>设定输入变量的位置值(Location)</li>
<li>main：对输入数据什么都没有处理就把它传到着色器的输出了<ul>
<li>把位置数据赋值给预定义的gl_Position变量</li>
</ul>
</li>
<li>在真实的程序里，顶点着色器的输入数据通常都不是标准化设备坐标，所以我们首先必须先把它们转换至OpenGL的可视区域内。</li>
</ul>
</li>
<li><p>编译着色器</p>
<ul>
<li><p>方法一：使用c风格字符串表示着色器内容</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 着色器代码</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *vertexShaderSource = <span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line">    <span class="string">&quot;layout (location = 0) in vec3 aPos;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;void main()\n&quot;</span></span><br><span class="line">    <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n&quot;</span></span><br><span class="line">    <span class="string">&quot;&#125;\0&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 着色器对象</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> vertexShader;</span><br><span class="line">vertexShader = glCreateShader(GL_VERTEX_SHADER);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 附加着色器代码到着色器对象上，并编译</span></span><br><span class="line">glShaderSource(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">glCompileShader(vertexShader);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断编译是否成功的错误处理</span></span><br><span class="line"><span class="type">int</span>  success;	<span class="comment">// 成功与否标志</span></span><br><span class="line"><span class="type">char</span> infoLog[<span class="number">512</span>];	<span class="comment">// 错误信息容器</span></span><br><span class="line">glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);	<span class="comment">// 检查编译结果</span></span><br><span class="line"><span class="keyword">if</span>(!success)</span><br><span class="line">&#123;</span><br><span class="line">    glGetShaderInfoLog(vertexShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h5 id="片段着色器-1"><a href="#片段着色器-1" class="headerlink" title="片段着色器"></a>片段着色器</h5><p>片段着色器所做的是计算像素最后的颜色输出。</p>
<ul>
<li>输出黄色的着色器代码</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    FragColor = <span class="type">vec4</span>(<span class="number">1.0</span>f, <span class="number">0.5</span>f, <span class="number">0.2</span>f, <span class="number">1.0</span>f);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ul>
<li><p>编译方式同上，着色器类型为GL_FRAGMENT_SHADER</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> fragmentShader;</span><br><span class="line">fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);</span><br><span class="line">glShaderSource(fragmentShader, <span class="number">1</span>, &amp;fragmentShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">glCompileShader(fragmentShader);</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="着色器程序"><a href="#着色器程序" class="headerlink" title="着色器程序"></a>着色器程序</h5><p>着色器程序对象 (Shader Program Object)：多个着色器合并之后并最终链接完成的版本</p>
<ul>
<li>当链接着色器至一个程序的时候，它会把每个着色器的输出链接到下个着色器的输入。</li>
</ul>
<p>创建着色器程序对象与链接着色器</p>
<ul>
<li><p>&#96;&#96;&#96;c<br>&#x2F;&#x2F; 创建着色器程序对象<br>unsigned int shaderProgram;<br>shaderProgram &#x3D; glCreateProgram();</p>
<p>&#x2F;&#x2F; 链接着色器到着色器程序对象<br>glAttachShader(shaderProgram, vertexShader);<br>glAttachShader(shaderProgram, fragmentShader);</p>
<p>glLinkProgram(shaderProgram);</p>
<p>&#x2F;&#x2F; 链接结果检查<br>int  success;	<br>char infoLog[512];<br>glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success);<br>if(!success) {<br>glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog);<br>…<br>}</p>
<p>&#x2F;&#x2F; 激活着色器程序对象，修改opengl上下文<br>glUseProgram(shaderProgram);</p>
<p>&#x2F;&#x2F; 不再需要啊着色器对象（不是着色器程序对象）<br>glDeleteShader(vertexShader);<br>glDeleteShader(fragmentShader);</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">##### 链接顶点属性</span><br><span class="line"></span><br><span class="line">- 告知opengl如何解释内存中的顶点数据，以及如何将顶点数据链接到顶点着色器的属性上。</span><br><span class="line">- 手动指定输入数据的哪一个部分对应顶点着色器的哪一个顶点属性。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">目标格式：</span><br><span class="line"></span><br><span class="line">![image-20240328211847130](LearnOpenGL摘要/image-20240328211847130.png)</span><br><span class="line"></span><br><span class="line">内容</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">float vertices[] = &#123;</span><br><span class="line">    -0.5f, -0.5f, 0.0f,</span><br><span class="line">     0.5f, -0.5f, 0.0f,</span><br><span class="line">     0.0f,  0.5f, 0.0f</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>格式的主要特点</p>
<ul>
<li>位置数据被储存为32位（4字节）浮点值。</li>
<li>每个位置包含3个这样的值。</li>
<li>在这3个值之间没有空隙（或其他值）。这几个值在数组中紧密排列(Tightly Packed)。</li>
<li>数据中第一个值在缓冲开始的位置。</li>
</ul>
<p>对应的API : glVertexAttribPointer</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个参数指定我们要配置的顶点属性的位置值（location）</li>
<li>第二个参数指定顶点属性的大小</li>
<li>第三个参数指定数据的类型</li>
<li>第四个参数定义我们是否希望数据被标准化(Normalize)</li>
<li>第五个参数叫做步长(Stride)，它告诉我们在连续的顶点属性组之间的间隔</li>
<li>最后一个参数的类型是<code>void*</code>，所以需要我们进行这个奇怪的强制类型转换。它表示位置数据在缓冲中起始位置的偏移量(Offset)。</li>
</ul>
<p>没有VAO的使用方式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 0. 复制顶点数组到缓冲中供OpenGL使用</span></span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"><span class="comment">// 1. 设置顶点属性指针</span></span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 2. 当我们渲染一个物体时要使用着色器程序</span></span><br><span class="line">glUseProgram(shaderProgram);</span><br><span class="line"><span class="comment">// 3. 绘制物体</span></span><br><span class="line">someOpenGLFunctionThatDrawsOurTriangle();</span><br></pre></td></tr></table></figure>



<h5 id="顶点对象数组"><a href="#顶点对象数组" class="headerlink" title="顶点对象数组"></a>顶点对象数组</h5><p>顶点数组对象(Vertex Array Object, VAO)可以像顶点缓冲对象那样被绑定，任何随后的顶点属性调用都会储存在这个VAO中。</p>
<ul>
<li>即把顶点属性信息（顶点属性指针）存储在数组中</li>
<li>在不同顶点数据和属性配置之间切换变得非常简单，只需要绑定不同的VAO就行了</li>
</ul>
<p>一个顶点数组对象会储存以下这些内容：</p>
<ul>
<li><code>glEnableVertexAttribArray</code>和<code>glDisableVertexAttribArray</code>的调用。</li>
<li>通过<code>glVertexAttribPointer</code>设置的顶点属性配置。</li>
<li>通过<code>glVertexAttribPointer</code>调用与顶点属性关联的顶点缓冲对象。</li>
</ul>
<p><img src="/2024/03/30/LearnOpenGL%E6%91%98%E8%A6%81/image-20240328215033763.png" alt="image-20240328215033763"></p>
<p>创建和使用VAO：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建VAO</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> VAO;</span><br><span class="line">glGenVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ..:: 初始化代码（只运行一次 (除非你的物体频繁改变)） :: ..</span></span><br><span class="line"><span class="comment">// 1. 绑定VAO</span></span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line"><span class="comment">// 2. 把顶点数组复制到缓冲中供OpenGL使用</span></span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"><span class="comment">// 3. 设置顶点属性指针</span></span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line"><span class="comment">// ..:: 绘制代码（渲染循环中） :: ..</span></span><br><span class="line"><span class="comment">// 4. 绘制物体</span></span><br><span class="line">glUseProgram(shaderProgram);</span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">someOpenGLFunctionThatDrawsOurTriangle();</span><br></pre></td></tr></table></figure>

<ul>
<li>要想使用VAO，要做的只是使用glBindVertexArray绑定VAO。</li>
<li>从绑定之后起，我们应该绑定和配置对应的VBO和属性指针，之后解绑VAO供之后使用。</li>
<li>当我们打算绘制一个物体的时候，我们只要在绘制物体前简单地把VAO绑定到希望使用的设定上就行了。</li>
</ul>
<h5 id="绘制三角形"><a href="#绘制三角形" class="headerlink" title="绘制三角形"></a>绘制三角形</h5><ul>
<li>glDrawArrays函数 ：<code>glDrawArrays(GL_TRIANGLES, 0, 3);</code><ul>
<li>参数1：图元类型</li>
<li>参数2：顶点数组的起始索引</li>
<li>参数3：要绘制的顶点数</li>
</ul>
</li>
</ul>
<h5 id="元素缓冲对象-IBO-x2F-EBO"><a href="#元素缓冲对象-IBO-x2F-EBO" class="headerlink" title="元素缓冲对象 IBO&#x2F;EBO"></a>元素缓冲对象 IBO&#x2F;EBO</h5><p>元素缓冲对象(Element Buffer Object，EBO)，也叫索引缓冲对象(Index Buffer Object，IBO)</p>
<ul>
<li><p>解决的问题：绘制多个图型时，在存在一些重复的顶点情况下，如何减少开销。</p>
</li>
<li><p>比如：存在2个重复顶点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="comment">// 第一个三角形</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="comment">// 右上角</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// 右下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// 左上角</span></span><br><span class="line">    <span class="comment">// 第二个三角形</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// 右下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// 左下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>   <span class="comment">// 左上角</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>使用 IBO&#x2F;EBO ：</p>
<ul>
<li>有点像OBJ文件里的记录方式</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="comment">// 右上角</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// 右下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// 左下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>   <span class="comment">// 左上角</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> indices[] = &#123;</span><br><span class="line">    <span class="comment">// 注意索引从0开始! </span></span><br><span class="line">    <span class="comment">// 此例的索引(0,1,2,3)就是顶点数组vertices的下标，</span></span><br><span class="line">    <span class="comment">// 这样可以由下标代表顶点组合成矩形</span></span><br><span class="line"></span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="comment">// 第一个三角形</span></span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>  <span class="comment">// 第二个三角形</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建EBO</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> EBO;</span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;EBO);</span><br><span class="line"><span class="comment">// 绑定EBO</span></span><br><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class="keyword">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure>

<ul>
<li>绘制使用的函数改变：<code>glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);</code><ul>
<li>第一个参数：绘制的图元类型</li>
<li>第二个参数：绘制顶点的个数</li>
<li>第三个参数：索引的类型</li>
<li>最后一个参数：指定EBO中的偏移量</li>
</ul>
</li>
</ul>
<p>顶点缓冲属性绑定方式：</p>
<ul>
<li>VAO除了跟踪VBO的绑定，也会跟踪EBO的绑定</li>
<li>在绑定VAO后，最后一个绑定的EBO会被存储为该VAO的EBO<ul>
<li>当目标是GL_ELEMENT_ARRAY_BUFFER的时候，VAO会储存glBindBuffer的函数调用</li>
<li>解绑调用也会被跟踪，确保你没有在解绑VAO之前解绑索引数组缓冲，否则它就没有这个EBO配置了</li>
</ul>
</li>
</ul>
<p><img src="/2024/03/30/LearnOpenGL%E6%91%98%E8%A6%81/image-20240330223306708.png" alt="image-20240330223306708"></p>
<ul>
<li><p>代码组织 belike：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ..:: 初始化代码 :: ..</span></span><br><span class="line"><span class="comment">// 1. 绑定顶点数组对象</span></span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line"><span class="comment">// 2. 把我们的顶点数组复制到一个顶点缓冲中，供OpenGL使用</span></span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"><span class="comment">// 3. 复制我们的索引数组到一个索引缓冲中，供OpenGL使用</span></span><br><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class="keyword">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br><span class="line"><span class="comment">// 4. 设定顶点属性指针</span></span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line"><span class="comment">// ..:: 绘制代码（渲染循环中） :: ..</span></span><br><span class="line">glUseProgram(shaderProgram);</span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">glDrawElements(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line">glBindVertexArray(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>图形学</category>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>LearnOpenGL摘要（入门二）</title>
    <url>/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/</url>
    <content><![CDATA[<h1 id="着色器，纹理，变换，坐标系、摄像机"><a href="#着色器，纹理，变换，坐标系、摄像机" class="headerlink" title="着色器，纹理，变换，坐标系、摄像机"></a>着色器，纹理，变换，坐标系、摄像机</h1><h2 id="一、着色器-Shader"><a href="#一、着色器-Shader" class="headerlink" title="一、着色器 Shader"></a>一、着色器 Shader</h2><ul>
<li><strong>概念</strong>：着色器(Shader)是运行在GPU上的小程序。这些小程序为图形渲染管线的某个特定部分而运行。</li>
<li><strong>抽象描述</strong>：着色器只是一种把输入转化为输出的程序。</li>
<li><strong>独立</strong>：着色器也是一种非常独立的程序，因为它们之间不能相互通信；它们之间唯一的沟通只有通过输入和输出。</li>
</ul>
<span id="more"></span>

<h2 id><a href="#" class="headerlink" title></a></h2><h3 id="OpengGL的着色器语言——GLSL"><a href="#OpengGL的着色器语言——GLSL" class="headerlink" title="OpengGL的着色器语言——GLSL"></a>OpengGL的着色器语言——GLSL</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul>
<li><p>C语言 like</p>
</li>
<li><p>为图形计算量身定制，包含一些针对向量和矩阵操作的有用特性</p>
</li>
</ul>
<h4 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h4><ul>
<li>声明版本</li>
<li>输入变量，输出变量</li>
<li>uniform</li>
<li>main函数</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version version_number</span></span><br><span class="line"><span class="keyword">in</span> type in_variable_name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> type out_variable_name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> type uniform_name;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 处理输入并进行一些图形操作</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 输出处理过的结果到输出变量</span></span><br><span class="line">  out_variable_name = weird_stuff_we_processed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>每个着色器的入口点都是main函数，在这个函数中我们处理所有的输入变量，并将结果输出到输出变量中。</p>
</blockquote>
<blockquote>
<p>特定于顶点着色器</p>
<ul>
<li><p>每个输入变量也叫顶点属性(Vertex Attribute)</p>
</li>
<li><p>由硬件来决定顶点属性的数量</p>
</li>
<li><p>OpenGL确保至少有16个包含4分量的顶点属性可用，但是有些硬件或许允许更多的顶点属性</p>
</li>
<li><p>&#96;&#96;&#96;c<br>&#x2F;&#x2F; 查询顶点属性数量<br>int nrAttributes;<br>glGetIntegerv(GL_MAX_VERTEX_ATTRIBS, &amp;nrAttributes);<br>std::cout &lt;&lt; “Maximum nr of vertex attributes supported: “ &lt;&lt; nrAttributes &lt;&lt; std::endl;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 数据类型</span><br><span class="line"></span><br><span class="line">- 默认基础数据类型：`int`,`float`,`double`,`uint`,`bool`</span><br><span class="line">- 容器类型：`Vector`和`Matrix`</span><br><span class="line"></span><br><span class="line">##### 向量Vector</span><br><span class="line"></span><br><span class="line">- 可以包含有2、3或者4个分量的容器，分量的类型可以是前面默认基础类型的任意一个</span><br><span class="line"></span><br><span class="line">![image-20240331001426533](LearnOpenGL摘要（2）/image-20240331001426533.png)</span><br><span class="line"></span><br><span class="line">- 可通过`.xyzw`，`.rgba`，`stpq`访问分量</span><br><span class="line"></span><br><span class="line">- 向量重组的语法：</span><br><span class="line"></span><br><span class="line"> ```glsl</span><br><span class="line"> vec2 someVec;</span><br><span class="line"> vec4 differentVec = someVec.xyxx;</span><br><span class="line"> vec3 anotherVec = differentVec.zyw;</span><br><span class="line"> vec4 otherVec = someVec.xxxx + anotherVec.yxzy;</span><br><span class="line"> </span><br><span class="line"> // 以及构造函数的参数</span><br><span class="line"> vec2 vect = vec2(0.5, 0.7);</span><br><span class="line"> vec4 result = vec4(vect, 0.0, 0.0);</span><br><span class="line"> vec4 otherResult = vec4(result.xyz, 1.0);</span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
<h4 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h4><ul>
<li>着色器之间是各自独立的程序</li>
<li>但是为了完成同一个整体目标，需要通过<code>输入输出</code>来彼此进行数据交流和传递</li>
<li>使用关键字 in out 设定输入和输出，只要一个输出变量与下一个着色器阶段的输入匹配，它就会传递下去。</li>
</ul>
<p><strong>在顶点和片段着色器中会有点不同</strong>：</p>
<ul>
<li>顶点着色器 ——— 接收的是一种特殊形式的输入<ul>
<li>从顶点数据中直接接收输入</li>
<li>使用<code>location</code>这一元数据指定输入变量的位置，对应我们在CPU上配置的顶点属性</li>
<li><code>layout (location = 0)</code>：为顶点着色器的输入提供一个额外的<code>layout</code>标识，把它链接到顶点数据</li>
</ul>
</li>
<li>片段着色器 ———— 需要一个<code>vec4</code>颜色输出变量<ul>
<li>需要生成一个最终输出的颜色（否则默认输出黑&#x2F;白）</li>
</ul>
</li>
</ul>
<p><strong>定义输入与输出</strong></p>
<ul>
<li><p>如果我们打算从一个着色器向另一个着色器发送数据，我们必须在发送方着色器中声明一个输出，在接收方着色器中声明一个类似的输入</p>
</li>
<li><p><strong>当类型和名字都一样</strong>的时候，OpenGL就会把两个变量链接到一起，它们之间就能发送数据了（这是在链接着色器程序对象时完成的）</p>
</li>
<li><p>新的顶点着色器</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos; <span class="comment">// 位置变量的属性位置值为0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> vertexColor; <span class="comment">// 为片段着色器指定一个颜色输出</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(aPos, <span class="number">1.0</span>); <span class="comment">// 注意我们如何把一个vec3作为vec4的构造器的参数</span></span><br><span class="line">    vertexColor = <span class="type">vec4</span>(<span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>); <span class="comment">// 把输出变量设置为暗红色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>新的片段着色器</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec4</span> vertexColor; <span class="comment">// 从顶点着色器传来的输入变量（名称相同、类型相同）</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    FragColor = vertexColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Uniform"><a href="#Uniform" class="headerlink" title="Uniform"></a>Uniform</h4><p>用于从CPU中的应用向GPU中的着色器发送数据的方式</p>
<p>但uniform和顶点属性有些不同</p>
<ul>
<li><p>uniform是全局的(Global)</p>
<ul>
<li>必须在每个·着色器程序对象·中都是独一无二的</li>
<li>可以被着色器程序的任意着色器在任意阶段访问</li>
<li>uniform会一直保存它们的数据，直到它们被重置或更新</li>
</ul>
</li>
<li><p>在着色器代码中声明</p>
<ul>
<li><code>uniform vec4 ourColor; // 在OpenGL程序代码中设定这个变量</code></li>
<li>声明之后，如果该uniform变量不被使用，编译器会默认移除这个变量。这可能会导致一些问题</li>
</ul>
</li>
<li><p>在应用代码中设置数据</p>
<ul>
<li><p>首先需要找到着色器程序中对应uniform属性的索引&#x2F;位置值：<code>glGetUniformLocation</code></p>
</li>
<li><p>设置数据：<code>glUniform4</code></p>
</li>
<li><p>案例：随时间改变颜色数值</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> timeValue = glfwGetTime();</span><br><span class="line"><span class="type">float</span> greenValue = (<span class="built_in">sin</span>(timeValue) / <span class="number">2.0</span>f) + <span class="number">0.5</span>f;</span><br><span class="line"><span class="type">int</span> vertexColorLocation = glGetUniformLocation(shaderProgram, &quot;ourColor&quot;);</span><br><span class="line">glUseProgram(shaderProgram);</span><br><span class="line">glUniform4f(vertexColorLocation, <span class="number">0.0</span>f, greenValue, <span class="number">0.0</span>f, <span class="number">1.0</span>f);</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询uniform地址不要求你之前使用过着色器程序，但是更新一个uniform之前你<strong>必须</strong>先使用程序（调用glUseProgram)，因为它是在当前激活的着色器程序中设置uniform的。</p>
</li>
</ul>
</li>
<li><pre><code class="c">// 变色示例中的渲染循环

while(!glfwWindowShouldClose(window))
&#123;
    // 输入
    processInput(window);

    // 渲染
    // 清除颜色缓冲
    glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT);

    // 记得激活着色器
    glUseProgram(shaderProgram);

    // 更新uniform颜色
    float timeValue = glfwGetTime();
    float greenValue = sin(timeValue) / 2.0f + 0.5f;
    int vertexColorLocation = glGetUniformLocation(shaderProgram, &quot;ourColor&quot;);
    glUniform4f(vertexColorLocation, 0.0f, greenValue, 0.0f, 1.0f);

    // 绘制三角形
    glBindVertexArray(VAO);
    glDrawArrays(GL_TRIANGLES, 0, 3);

    // 交换缓冲并查询IO事件
    glfwSwapBuffers(window);
    glfwPollEvents();
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;OpenGL不支持函数重载（C语言库），对应的有多种函数后缀</span><br><span class="line">&gt;</span><br><span class="line">&gt;- 每当你打算配置一个OpenGL的选项时就可以简单地根据这些规则选择适合你的数据类型的重载函数。</span><br><span class="line">&gt;</span><br><span class="line">&gt;![image-20240331014255103](LearnOpenGL摘要（2）/image-20240331014255103.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 为顶点设置更多属性</span><br><span class="line"></span><br><span class="line">之前的顶点属性只有位置</span><br><span class="line"></span><br><span class="line">在前面的教程中，我们了解了：</span><br><span class="line"></span><br><span class="line">- 如何填充VBO（设置顶点缓冲区对象，把内存中的顶点数据映射到GPU显存）</span><br><span class="line">- 配置顶点属性指针（指定顶点数据中的顶点属性信息）</span><br><span class="line">- 如何把它们都储存到一个VAO里（顶点属性指针和VBO的关联可以存放到VAO里，以便于重复利用）</span><br><span class="line"></span><br><span class="line">![image-20240331015257562](LearnOpenGL摘要（2）/image-20240331015257562.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 案例</span><br><span class="line"></span><br><span class="line">- 顶点数据：</span><br><span class="line"></span><br><span class="line">  ```c</span><br><span class="line">  float vertices[] = &#123;</span><br><span class="line">      // 位置              // 颜色</span><br><span class="line">       0.5f, -0.5f, 0.0f,  1.0f, 0.0f, 0.0f,   // 右下</span><br><span class="line">      -0.5f, -0.5f, 0.0f,  0.0f, 1.0f, 0.0f,   // 左下</span><br><span class="line">       0.0f,  0.5f, 0.0f,  0.0f, 0.0f, 1.0f    // 顶部</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>顶点着色器：新增一个 in 颜色属性，指定location 为 1</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;   <span class="comment">// 位置变量的属性位置值为 0 </span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec3</span> aColor; <span class="comment">// 颜色变量的属性位置值为 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> ourColor; <span class="comment">// 向片段着色器输出一个颜色</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line">    ourColor = aColor; <span class="comment">// 将ourColor设置为我们从顶点数据那里得到的输入颜色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>片段着色器：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;  </span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> ourColor;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    FragColor = <span class="type">vec4</span>(ourColor, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置顶点属性指针：</p>
<ul>
<li><p>目标<br><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240331015638950.png" alt="image-20240331015638950"></p>
</li>
<li><p>&#96;&#96;&#96;c<br>&#x2F;&#x2F; 位置属性<br>glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);<br>glEnableVertexAttribArray(0);</p>
<p>&#x2F;&#x2F; 颜色属性<br>glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(3* sizeof(float)));<br>glEnableVertexAttribArray(1);</p>
<p>glVertexAttribPointer:</p>
<ul>
<li>第一个参数指定我们要配置的顶点属性的位置值（对应顶点着色器中in属性的location）</li>
<li>第二个参数指定顶点属性的大小</li>
<li>第三个参数指定数据的类型</li>
<li>第四个参数定义我们是否希望数据被标准化(Normalize)</li>
<li>第五个参数叫做步长(Stride)，它告诉我们在连续的顶点属性组之间的间隔</li>
<li>最后一个参数的类型是<code>void*</code>，所以需要我们进行这个奇怪的强制类型转换。它表示位置数据在缓冲中起始位置的偏移量(Offset)。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 着色器管理</span><br><span class="line"></span><br><span class="line">编写、编译、管理着色器是件麻烦事。</span><br><span class="line"></span><br><span class="line">可以封装一个着色器类：</span><br><span class="line"></span><br><span class="line">- 从硬盘读取着色器，然后编译并链接成着色器程序，并对它们进行错误检测</span><br><span class="line">- 激活着色器程序操作</span><br><span class="line">- uniform变量设置操作</span><br><span class="line"></span><br><span class="line">详细代码见[着色器 - LearnOpenGL CN (learnopengl-cn.github.io)](https://learnopengl-cn.github.io/01 Getting started/05 Shaders/)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 二、纹理</span><br><span class="line"></span><br><span class="line">纹理是一个2D图片（甚至也有1D和3D的纹理），它可以用来添加物体的细节。</span><br><span class="line"></span><br><span class="line">除了图像以外，纹理也可以被用来储存大量的数据，这些数据可以发送到着色器上。</span><br><span class="line"></span><br><span class="line">### 相关概念</span><br><span class="line"></span><br><span class="line">#### 纹理映射(Map)</span><br><span class="line"></span><br><span class="line">- 三角形的每个顶点各自关联着一个纹理坐标(Texture Coordinate)，标明该从纹理图像的哪个部分采样</span><br><span class="line">- 非顶点的片段通过片段插值(Fragment Interpolation)，获取纹理坐标的插值结果，再从纹理上采样对应的数值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 纹理坐标</span><br><span class="line"></span><br><span class="line">- （2D纹理图像）纹理坐标在x和y轴上，范围为0到1之间。又称uv坐标</span><br><span class="line">- 使用纹理坐标获取纹理颜色叫做采样(Sampling)</span><br><span class="line">- 顶点的纹理坐标一般是先确定好的，需要从应用中传递给顶点着色器。顶点着色器再传递给片段着色器进行插值计算。</span><br><span class="line">  ![image-20240331024628030](LearnOpenGL摘要（2）/image-20240331024628030.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 纹理环绕方式</span><br><span class="line"></span><br><span class="line">纹理坐标值的范围为（0，0）到（1，1）</span><br><span class="line"></span><br><span class="line">讨论坐标值在这个范围之外的情况：</span><br><span class="line"></span><br><span class="line">- OpenGL默认的行为是重复这个纹理图像（忽略浮点数的整数部分）</span><br><span class="line"></span><br><span class="line">- 不同的重复方式：</span><br><span class="line">  ![image-20240331032852725](LearnOpenGL摘要（2）/image-20240331032852725.png)</span><br><span class="line"></span><br><span class="line">   ![image-20240331032805953](LearnOpenGL摘要（2）/image-20240331032805953.png)</span><br><span class="line"></span><br><span class="line">- 设置方法：`glTexParameter*`函数</span><br><span class="line"></span><br><span class="line">  ```c</span><br><span class="line">  // 分别对 S,T(,R) 方向（和xyz等价）设置GL_MIRRORED_REPEAT</span><br><span class="line">  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);</span><br><span class="line">  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);</span><br><span class="line">  </span><br><span class="line">  或者是</span><br><span class="line">      </span><br><span class="line">  // 设置 GL_CLAMP_TO_BORDER</span><br><span class="line">  float borderColor[] = &#123; 1.0f, 1.0f, 0.0f, 1.0f &#125;;</span><br><span class="line">  glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="纹理过滤"><a href="#纹理过滤" class="headerlink" title="纹理过滤"></a>纹理过滤</h3><p>纹理坐标的基于浮点值，精细度是无限的。</p>
<p>而纹理图片是由有限的像素组成的，是具有有限分辨率的。</p>
<p>考虑一个问题：</p>
<ul>
<li>OpenGL需要知道怎样将纹理像素(Texture Pixel，也叫Texel)映射到纹理坐标。</li>
<li>即纹理坐标(u,v)，其对应的纹理像素应该是哪个&#x2F;些，颜色值应该是多少</li>
</ul>
<p>OpenGL的两种纹理过滤方式</p>
<h4 id="GL-NEAREST-临近过滤"><a href="#GL-NEAREST-临近过滤" class="headerlink" title="GL_NEAREST 临近过滤"></a>GL_NEAREST 临近过滤</h4><ul>
<li>OpenGL默认的纹理过滤方式</li>
<li>选择中心点最接近纹理坐标的那个像素</li>
<li><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240331033826506.png" alt="image-20240331033826506"></li>
</ul>
<h4 id="GL-LINEAR-线性过滤"><a href="#GL-LINEAR-线性过滤" class="headerlink" title="GL_LINEAR 线性过滤"></a>GL_LINEAR 线性过滤</h4><ul>
<li>基于纹理坐标附近的纹理像素，计算出一个插值，近似出这些纹理像素之间的颜色</li>
<li>距离越近权值越大</li>
<li><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240331033858271.png" alt="image-20240331033858271"></li>
</ul>
<p><strong>设置</strong></p>
<ul>
<li><p>可以设置纹理在放大(Magnify)和缩小(Minify)情况下的纹理过滤选项</p>
</li>
<li><p>&#96;&#96;&#96;c<br>&#x2F;&#x2F; 在纹理被缩小的时候使用邻近过滤，被放大时使用线性过滤。</p>
<p>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);<br>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">-  ![image-20240331034553017](LearnOpenGL摘要（2）/image-20240331034553017.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; 纹理分辨率相对太小的情况 (上面文章中的情况)</span><br><span class="line">&gt;</span><br><span class="line">&gt; - 对应纹理放大情况(Magnify)</span><br><span class="line">&gt; - 一个片段的纹理坐标，只能对应到一个纹理像素的内部。或者说一个纹理像素，可能对应着多个片段。</span><br><span class="line">&gt; - 解决：</span><br><span class="line">&gt;   - 临近</span><br><span class="line">&gt;   - 线性（双线性插值）</span><br><span class="line">&gt;   - bicubic</span><br><span class="line">&gt;</span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br><span class="line">&gt; 纹理分辨率相对太大的情况：（下面文章中的情况）</span><br><span class="line">&gt;</span><br><span class="line">&gt; - 对应纹理缩小情况(Minify)</span><br><span class="line">&gt; - 纹理像素和片段几乎一一对应，但是临近的两个片段对应的两个纹理像素中间的那些纹理是没有被任何片段对应到的。</span><br><span class="line">&gt; - 解决：</span><br><span class="line">&gt;   - 超采样</span><br><span class="line">&gt;   - 范围查询</span><br><span class="line">&gt;   - mipmap</span><br><span class="line">&gt;   - 三线性插值</span><br><span class="line">&gt;   - 各向异性过滤</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 多级渐远纹理 Mipmap</span><br><span class="line"></span><br><span class="line">有些物体会很远，但其纹理会拥有与近处物体同样高的分辨率。</span><br><span class="line"></span><br><span class="line">由于远处的物体可能只产生很少的片段，OpenGL从高分辨率纹理中为这些片段获取正确的颜色值就很困难，因为它需要对一个跨过纹理很大部分的片段只拾取一个纹理颜色。</span><br><span class="line"></span><br><span class="line">在小物体上这会产生不真实的感觉，更不用说对它们使用高分辨率纹理浪费内存的问题了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image-20240331035431064](LearnOpenGL摘要（2）/image-20240331035431064.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**理念**：距观察者的距离超过一定的阈值，OpenGL会使用不同的多级渐远纹理，即最适合物体的距离的那个。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 使用方法</span><br><span class="line"></span><br><span class="line">- glGenerateMipmaps，在创建完一个纹理后调用它OpenGL就会承担接下来的所有工作了。</span><br><span class="line"></span><br><span class="line">- 不同级别的渐远纹理之间的过渡</span><br><span class="line"></span><br><span class="line">  - 跨级的时候纹理会由生硬的边界</span><br><span class="line"></span><br><span class="line">  - 可以采样临近过滤或线性过滤来处理</span><br><span class="line"></span><br><span class="line">  -  ![image-20240331035927857](LearnOpenGL摘要（2）/image-20240331035927857.png)</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);</span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="实操：加载和创建纹理"><a href="#实操：加载和创建纹理" class="headerlink" title="实操：加载和创建纹理"></a>实操：加载和创建纹理</h3><h4 id="加载纹理"><a href="#加载纹理" class="headerlink" title="加载纹理"></a>加载纹理</h4><ul>
<li><p>纹理的格式：png，jpg，tga等</p>
</li>
<li><p>加载纹理的库：stb_image.h</p>
</li>
<li><p>加载木箱图片：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> width, height, nrChannels;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *data = stbi_load(<span class="string">&quot;container.jpg&quot;</span>, &amp;width, &amp;height, &amp;nrChannels, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 纹理图像的宽度、高度和颜色通道的个数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>释放内存：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">stbi_image_free(data);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="生成纹理"><a href="#生成纹理" class="headerlink" title="生成纹理"></a>生成纹理</h4><ul>
<li><p>opengl中对纹理对象也是用一个id引用</p>
</li>
<li><p>生成和绑定纹理对象：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> texture;</span><br><span class="line"><span class="comment">// 生成纹理的数量 1</span></span><br><span class="line">glGenTextures(<span class="number">1</span>, &amp;texture);</span><br><span class="line"><span class="comment">// 绑定纹理对象</span></span><br><span class="line">glBindTexture(GL_TEXTURE_2D, texture);</span><br></pre></td></tr></table></figure>
</li>
<li><p>为纹理对象附加上纹理图像：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 附加纹理图像数据，指定多级渐远纹理为基本级别</span></span><br><span class="line">glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data);</span><br><span class="line"><span class="comment">// 生成所有需要的多级渐远纹理</span></span><br><span class="line">glGenerateMipmap(GL_TEXTURE_2D);</span><br></pre></td></tr></table></figure>

<ul>
<li>glTexImage2D函数<ul>
<li>第一个参数指定了纹理目标(Target)</li>
<li>第二个参数为纹理指定多级渐远纹理的级别，0为基本级别</li>
<li>第三个参数告诉OpenGL我们希望把纹理储存为何种格式</li>
<li>第四个和第五个参数设置最终的纹理的宽度和高度</li>
<li>第六个参数设为0就行</li>
<li>第七第八个参数定义了源图的格式和数据类型</li>
<li>第九个参数是是真正的图像数据</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="大致使用过程"><a href="#大致使用过程" class="headerlink" title="大致使用过程"></a>大致使用过程</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> texture;</span><br><span class="line">glGenTextures(<span class="number">1</span>, &amp;texture);</span><br><span class="line">glBindTexture(GL_TEXTURE_2D, texture);</span><br><span class="line"><span class="comment">// 为当前绑定的纹理对象设置环绕、过滤方式</span></span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);   </span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line"><span class="comment">// 加载并生成纹理</span></span><br><span class="line"><span class="type">int</span> width, height, nrChannels;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *data = stbi_load(<span class="string">&quot;container.jpg&quot;</span>, &amp;width, &amp;height, &amp;nrChannels, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (data)</span><br><span class="line">&#123;</span><br><span class="line">    glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data);</span><br><span class="line">    glGenerateMipmap(GL_TEXTURE_2D);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Failed to load texture&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">stbi_image_free(data);</span><br></pre></td></tr></table></figure>



<h3 id="实操：应用纹理"><a href="#实操：应用纹理" class="headerlink" title="实操：应用纹理"></a>实操：应用纹理</h3><p>更新顶点属性格式</p>
<ul>
<li><p><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240331150944358.png" alt="image-20240331150944358"></p>
</li>
<li><pre><code class="c">    // 位置属性
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);
    glEnableVertexAttribArray(0);

    // 颜色属性
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));
    glEnableVertexAttribArray(1);

    // 纹理属性
    glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));
    glEnableVertexAttribArray(2);
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 顶点着色器</span><br><span class="line"></span><br><span class="line">  ```glsl</span><br><span class="line">  #version 330 core</span><br><span class="line">  layout (location = 0) in vec3 aPos;</span><br><span class="line">  layout (location = 1) in vec3 aColor;</span><br><span class="line">  layout (location = 2) in vec2 aTexCoord;</span><br><span class="line">  </span><br><span class="line">  out vec3 ourColor;</span><br><span class="line">  out vec2 TexCoord;</span><br><span class="line">  </span><br><span class="line">  void main()</span><br><span class="line">  &#123;</span><br><span class="line">      gl_Position = vec4(aPos, 1.0);</span><br><span class="line">      ourColor = aColor;</span><br><span class="line">      TexCoord = aTexCoord;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>片段着色器</p>
<ul>
<li>片段着色器可以访问纹理对象，通过<code>uniform sampler2D</code> 变，此外还有sampler1D、sampler3D</li>
<li>GLSL有一个供纹理对象使用的内建数据类型，叫做采样器(Sampler)，以纹理类型作为后缀(1D,2D,3D)</li>
<li>GLSL内建的<code>texture函数</code>：采样纹理的颜色<ul>
<li>第一个参数是纹理采样器sampler</li>
<li>第二个参数是对应的纹理坐标</li>
</ul>
</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> ourColor;</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec2</span> TexCoord;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> ourTexture;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    FragColor = <span class="built_in">texture</span>(ourTexture, TexCoord);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>应用层代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// 生成和绑定纹理对象</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> texture;</span><br><span class="line">   glGenTextures(<span class="number">1</span>, &amp;texture);</span><br><span class="line">   glBindTexture(GL_TEXTURE_2D, texture);</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 载入纹理数据</span></span><br><span class="line">   <span class="type">int</span> width, height, nrChannels;</span><br><span class="line">   <span class="type">unsigned</span> <span class="type">char</span>* data = stbi_load(<span class="string">&quot;resource/container.jpg&quot;</span>, &amp;width, &amp;height, &amp;nrChannels, <span class="number">0</span>);</span><br><span class="line">   <span class="keyword">if</span> (data)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">// 将纹理数据加载到纹理对象</span></span><br><span class="line">       glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data);</span><br><span class="line">       glGenerateMipmap(GL_TEXTURE_2D);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Failed to load texture&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   stbi_image_free(data);</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">while</span>(xxx) &#123;</span><br><span class="line">	...</span><br><span class="line">  </span><br><span class="line">       glBindTexture(GL_TEXTURE_2D, texture);</span><br><span class="line">       glBindVertexArray(VAO);</span><br><span class="line">       glDrawElements(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">   	...</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="纹理单元"><a href="#纹理单元" class="headerlink" title="纹理单元"></a>纹理单元</h3><ul>
<li>使用<code>glUniform1i</code>为纹理采样器sampler分配一个位置值</li>
<li>为多个sampler分配多个位置值，我们能够在一个片段着色器中设置多个纹理</li>
<li>一个纹理的位置值通常称为一个纹理单元(Texture Unit)</li>
</ul>
<p>使用：</p>
<ul>
<li><p>首先激活纹理单元</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">glActiveTexture(GL_TEXTURE0); <span class="comment">// 在绑定纹理之前先激活纹理单元</span></span><br><span class="line"></span><br><span class="line">glBindTexture(GL_TEXTURE_2D, texture); <span class="comment">// glBindTexture函数调用会绑定这个纹理到当前激活的纹理单元</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>纹理单元GL_TEXTURE0默认总是被激活</p>
</li>
</ul>
<blockquote>
<ul>
<li><p>OpenGL至少保证有16个纹理单元供你使用，也就是说你可以激活从GL_TEXTURE0到GL_TEXTRUE15。</p>
</li>
<li><p>它们都是按顺序定义的，所以我们也可以通过GL_TEXTURE0 + 8的方式获得GL_TEXTURE8，这在当我们需要循环一些纹理单元的时候会很有用。</p>
</li>
</ul>
</blockquote>
<ul>
<li><p>增加片段着色器中的纹理采样器</p>
<ul>
<li>GLSL内建的mix函数：接受两个值作为参数，并对它们根据第三个参数进行线性插值</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> texture1;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> texture2;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    FragColor = <span class="built_in">mix</span>(<span class="built_in">texture</span>(texture1, TexCoord), <span class="built_in">texture</span>(texture2, TexCoord), <span class="number">0.2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>更新用户层代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 激活两个纹理单元</span></span><br><span class="line">glActiveTexture(GL_TEXTURE0);</span><br><span class="line">glActiveTexture(GL_TEXTURE1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定两个纹理到对应的纹理单元</span></span><br><span class="line">glBindTexture(GL_TEXTURE_2D, texture1);</span><br><span class="line">glBindTexture(GL_TEXTURE_2D, texture2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后定义哪个uniform采样器对应哪个纹理单元</span></span><br><span class="line">shader.use();</span><br><span class="line">shader.setInt(<span class="string">&quot;texture1&quot;</span>, <span class="number">0</span>);</span><br><span class="line">shader.setInt(<span class="string">&quot;texture2&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(...) &#123;</span><br><span class="line">    ...</span><br><span class="line">    glBindVertexArray(VAO);</span><br><span class="line">    glDrawElements(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>注意：</p>
<p>PNG的颜色通道为RGBA，JPG的颜色通道为RGB</p>
<ul>
<li>映射图片数据到纹理对象时注意</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">glBindTexture(GL_TEXTURE_2D, texture1);</span><br><span class="line">...</span><br><span class="line">glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data);</span><br><span class="line"></span><br><span class="line">glBindTexture(GL_TEXTURE_2D, texture2);</span><br><span class="line">...</span><br><span class="line"> glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGBA, width2, height2, <span class="number">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, data2);</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="三、变换"><a href="#三、变换" class="headerlink" title="三、变换"></a>三、变换</h2><p>改变顶点位置的两个思路：</p>
<ul>
<li>一（改变输入）：在应用层改变传给OpenGL的顶点数据，以及重新绑定顶点相关对象。<ul>
<li>效率低</li>
</ul>
</li>
<li>二（变换）：传入的顶点数据不变。在应用层计算变换矩阵，传给着色器。在着色器计算顶点的新位置。</li>
</ul>
<h3 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h3><p>概念：</p>
<ul>
<li><p>表示一个方向</p>
</li>
<li><p>包含：方向(Direction)和大小(Magnitude，也叫做强度或长度)</p>
</li>
<li><p>习惯上，在字母上面加一横表示向量</p>
</li>
<li><p>位置向量(Position Vector)：指定向量起点（一般是原点），则可以表示一个位置</p>
</li>
</ul>
<p>运算：</p>
<ul>
<li><p>与标量(Scalar)</p>
<ul>
<li><p><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240401151350661.png" alt="image-20240401151350661"></p>
</li>
<li><blockquote>
<p>数学上是没有向量与标量相加这个运算的</p>
</blockquote>
</li>
</ul>
</li>
<li><p>取反(Negate)</p>
</li>
<li><p>加减</p>
</li>
<li><p>长度</p>
</li>
<li><p>标准化（得到单位向量，单位向量头上有一个^）</p>
</li>
<li><p>相乘：</p>
<ul>
<li>点乘<ul>
<li><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240401151736967.png" alt="image-20240401151736967"></li>
<li><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240401152036509.png" alt="image-20240401152036509"></li>
<li>求夹角余弦值</li>
<li>判断正交、平行</li>
</ul>
</li>
<li>叉乘<ul>
<li>叉乘只在3D空间中有定义，它需要两个不平行向量作为输入，生成一个正交于两个输入向量的第三个向量。</li>
<li><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240401152147432.png" alt="image-20240401152147432"></li>
<li>已知两个轴，求3D坐标系中的第三个轴</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><ul>
<li><p>与标量的加减</p>
<ul>
<li><p><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240401152432621.png" alt="image-20240401152432621"></p>
</li>
<li><blockquote>
<p>数学上是没有矩阵与标量相加减的运算的，但是很多线性代数的库都对它有支持</p>
</blockquote>
</li>
</ul>
</li>
<li><p>矩阵加减</p>
<ul>
<li><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240401152516356.png" alt="image-20240401152516356"></li>
</ul>
</li>
<li><p>矩阵数乘</p>
<ul>
<li><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240401152544583.png" alt="image-20240401152544583"></li>
</ul>
</li>
<li><p>矩阵相乘</p>
<ul>
<li><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240401152648582.png" alt="image-20240401152648582"></li>
<li>只有当左侧矩阵的列数与右侧矩阵的行数相等，两个矩阵才能相乘。</li>
<li>矩阵相乘不遵守交换律(Commutative)</li>
</ul>
</li>
<li><p>单位矩阵</p>
<ul>
<li><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240401153125352.png" alt="image-20240401153125352"></li>
</ul>
</li>
</ul>
<blockquote>
<p>单位矩阵通常是生成其他变换矩阵的起点，如果我们深挖线性代数，这还是一个对证明定理、解线性方程非常有用的矩阵。</p>
</blockquote>
<h3 id="在变换中的应用"><a href="#在变换中的应用" class="headerlink" title="在变换中的应用"></a>在变换中的应用</h3><ul>
<li><p>向量可以拿来表示位置，方向，颜色，甚至是纹理坐标。</p>
</li>
<li><p>正巧，很多有趣的2D&#x2F;3D变换都可以放在一个矩阵中。</p>
</li>
<li><p>用这个矩阵乘以我们的向量将<strong>变换</strong>(Transform)这个向量。</p>
</li>
</ul>
<h4 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h4><p>分为</p>
<ul>
<li>不均匀(Non-uniform)缩放</li>
<li>均匀缩放(Uniform Scale)</li>
</ul>
<p><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240401153415065.png" alt="image-20240401153415065"></p>
<h4 id="位移"><a href="#位移" class="headerlink" title="位移"></a>位移</h4><p>位移(Translation)是在原始向量的基础上加上另一个向量从而获得一个在不同位置的新向量的过程。</p>
<p><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240401153501671.png" alt="image-20240401153501671"></p>
<blockquote>
<p><strong>齐次坐标(Homogeneous Coordinates)</strong></p>
<p>向量的w分量也叫齐次坐标。想要从齐次向量得到3D向量，我们可以把x、y和z坐标分别除以w坐标。我们通常不会注意这个问题，因为w分量通常是1.0。</p>
<p>使用齐次坐标有几点好处：它允许我们在3D向量上进行位移（如果没有w分量我们是不能位移向量的），而且下一章我们会用w值创建3D视觉效果。</p>
<p>如果一个向量的齐次坐标是0，这个坐标就是方向向量(Direction Vector)，因为w坐标是0，这个向量就不能位移（译注：这也就是我们说的不能位移一个方向）。</p>
<p>齐次坐标非0的是位置向量。</p>
</blockquote>
<h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><ul>
<li>度量：角度制（180）或弧度制（PI）</li>
<li>在3D空间中旋转需要定义一个角<strong>和</strong>一个旋转轴(Rotation Axis)<ul>
<li>沿坐标轴旋转<ul>
<li><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240401154232617.png" alt="image-20240401154232617"></li>
<li>可以组合几次沿坐标轴的旋转</li>
<li>但是会出现<code>万向节死锁</code></li>
</ul>
</li>
<li>沿任意轴旋转<ul>
<li>（Rx，Ry，Rz）表示旋转轴</li>
<li><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240401154423576.png" alt="image-20240401154423576"></li>
<li>仍存在万向节死锁</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>上面都是基于<code>欧拉角</code>的旋转，存在万向节死锁的问题。</p>
<p>还有一种方案是基于 <code>四元数</code> 。</p>
</blockquote>
<h4 id="矩阵组合"><a href="#矩阵组合" class="headerlink" title="矩阵组合"></a>矩阵组合</h4><ul>
<li>注意矩阵乘法是没有交换率的，即变换的结果跟变换的顺序是有关的。</li>
<li>建议：先进行缩放操作，然后是旋转，最后才是位移，否则它们会（消极地）互相影响</li>
</ul>
<p><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240401155222918.png" alt="image-20240401155222918"></p>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><h4 id="库"><a href="#库" class="headerlink" title="库"></a>库</h4><ul>
<li>数学库：GLM</li>
</ul>
<blockquote>
<p>GLM 0.9.9之后的版本中，矩阵的默认初始化为零矩阵，而非之前的单位矩阵。</p>
<p>使用<code>glm::mat4 mat = glm::mat4(1.0f)</code>可以初始化单位矩阵。</p>
</blockquote>
<ul>
<li>用到的头文件</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/gtc/matrix_transform.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/gtc/type_ptr.hpp&gt;</span></span></span><br></pre></td></tr></table></figure>



<h4 id="矩阵构造"><a href="#矩阵构造" class="headerlink" title="矩阵构造"></a>矩阵构造</h4><ul>
<li><p>案例一：构造一个位移矩阵，并应用到一个向量上</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">glm::vec4 <span class="title function_">vec</span><span class="params">(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>)</span>;</span><br><span class="line"><span class="comment">// 译注：下面就是矩阵初始化的一个例子，如果使用的是0.9.9及以上版本</span></span><br><span class="line"><span class="comment">// 下面这行代码就需要改为:</span></span><br><span class="line"><span class="comment">// glm::mat4 trans = glm::mat4(1.0f)</span></span><br><span class="line"><span class="comment">// 之后将不再进行提示</span></span><br><span class="line">glm::mat4 trans;</span><br><span class="line">trans = glm::translate(trans, glm::vec3(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">vec = trans * vec;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; vec.x &lt;&lt; vec.y &lt;&lt; vec.z &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>案例二：构造一个先缩放后旋转的变换矩阵</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">glm::mat4 trans;</span><br><span class="line">trans = glm::rotate(trans, glm::radians(<span class="number">90.0f</span>), glm::vec3(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>));</span><br><span class="line">trans = glm::scale(trans, glm::vec3(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先，我们把箱子在每个轴都缩放到0.5倍，然后沿z轴旋转90度。GLM希望它的角度是弧度制的(Radian)，所以我们使用glm::radians将角度转化为弧度。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="将矩阵传递给着色器"><a href="#将矩阵传递给着色器" class="headerlink" title="将矩阵传递给着色器"></a>将矩阵传递给着色器</h4><p>顶点着色器</p>
<ul>
<li><p>glsl中的 mat4 类型</p>
</li>
<li><p>uniform 变量</p>
</li>
<li><pre><code class="glsl">#version 330 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec2 aTexCoord;

out vec2 TexCoord;

uniform mat4 transform;

void main()
&#123;
    gl_Position = transform * vec4(aPos, 1.0f);
    TexCoord = vec2(aTexCoord.x, 1.0 - aTexCoord.y);
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">传入着色器程序对象</span><br><span class="line"></span><br><span class="line">- ```c</span><br><span class="line">  unsigned int transformLoc = glGetUniformLocation(ourShader.ID, &quot;transform&quot;);</span><br><span class="line">  glUniformMatrix4fv(transformLoc, 1, GL_FALSE, glm::value_ptr(trans));</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>我们首先查询uniform变量的地址，然后用有<code>Matrix4fv</code>后缀的glUniform函数把矩阵数据发送给着色器。第一个参数你现在应该很熟悉了，它是uniform的位置值。第二个参数告诉OpenGL我们将要发送多少个矩阵，这里是1。第三个参数询问我们是否希望对我们的矩阵进行转置(Transpose)，也就是说交换我们矩阵的行和列。OpenGL开发者通常使用一种内部矩阵布局，叫做列主序(Column-major Ordering)布局。GLM的默认布局就是列主序，所以并不需要转置矩阵，我们填<code>GL_FALSE</code>。最后一个参数是真正的矩阵数据，但是GLM并不是把它们的矩阵储存为OpenGL所希望接受的那种，因此我们要先用GLM的自带的函数value_ptr来变换这些数据。</p>
</li>
</ul>
<h2 id="四、坐标系统"><a href="#四、坐标系统" class="headerlink" title="四、坐标系统"></a>四、坐标系统</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="坐标空间"><a href="#坐标空间" class="headerlink" title="坐标空间"></a>坐标空间</h4><p>OpenGL希望在每次顶点着色器运行后，我们可见的所有顶点都为<code>标准化设备坐标</code>(Normalized Device Coordinate, NDC)。</p>
<ul>
<li>即顶点着色器输出的<code>gl_position</code>是在<code>标准化设备坐标系</code>下的坐标</li>
<li>每个顶点的<strong>x</strong>，<strong>y</strong>，<strong>z</strong>坐标都应该在**-1.0<strong>到</strong>1.0**之间，超出这个坐标范围的顶点都将不可见</li>
</ul>
<p>我们通常会自己设定一个坐标的范围，之后再在顶点着色器中将这些坐标变换为标准化设备坐标。</p>
<p>然后将这些标准化设备坐标传入光栅器(Rasterizer)，将它们变换为屏幕上的二维坐标或像素。</p>
<ul>
<li>在顶点从初始坐标系转化到最终的屏幕坐标的过程中，会有经过多种坐标系的过渡转换。</li>
<li>原因是：在特定的坐标系统中，一些操作或运算更加方便和容易<ul>
<li>例如，当需要对物体进行修改的时候，在局部空间中来操作会更说得通；如果要对一个物体做出一个相对于其它物体位置的操作时，在世界坐标系中来做这个才更说得通，等等。</li>
</ul>
</li>
<li>比较重要的5个不同的坐标系：<ul>
<li><strong>局部空间</strong>(Local Space，或者称为物体空间(Object Space))</li>
<li><strong>世界空间</strong>(World Space)</li>
<li><strong>观察空间</strong>(View Space，或者称为视觉空间(Eye Space))</li>
<li><strong>裁剪空间</strong>(Clip Space)</li>
<li><strong>屏幕空间</strong>(Screen Space)</li>
</ul>
</li>
</ul>
<h4 id="坐标空间变换"><a href="#坐标空间变换" class="headerlink" title="坐标空间变换"></a>坐标空间变换</h4><p>将坐标从一个坐标系变换到另一个坐标系</p>
<ul>
<li>重要的变换矩阵：模型(Model)、观察(View)、投影(Projection)三个矩阵</li>
<li>顶点坐标起始于局部空间(Local Space)，在这里它称为局部坐标(Local Coordinate)，之后会变为世界坐标(World Coordinate)，观察坐标(View Coordinate)，裁剪坐标(Clip Coordinate)，并最后以屏幕坐标(Screen Coordinate)的形式结束。</li>
</ul>
<p><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240401165205323.png" alt="image-20240401165205323"></p>
<h3 id="局部空间"><a href="#局部空间" class="headerlink" title="局部空间"></a>局部空间</h3><p>指物体所在的坐标空间，物体有自己的一个原点位置。</p>
<p>物体&#x2F;模型的所有顶点的位置是相对于模型自身的局部空间的原点来说的。</p>
<h3 id="世界空间"><a href="#世界空间" class="headerlink" title="世界空间"></a>世界空间</h3><p>容纳多个物体的世界，采用一个共同的原点和一套坐标轴。</p>
<p>物体在世界空间中的坐标即物体相对于世界原点的坐标。</p>
<blockquote>
<p>物体的顶点的坐标从局部空间到世界空间的转换 —— 模型转换</p>
<ul>
<li>用到的变换矩阵称为 模型矩阵</li>
<li>包含 缩放、旋转、位移 操作</li>
</ul>
<p>通过物体的局部坐标系和世界坐标系的相对关系来求。</p>
</blockquote>
<h3 id="观察空间"><a href="#观察空间" class="headerlink" title="观察空间"></a>观察空间</h3><p>基于眼睛或摄像机的空间，即以摄像机的位置为原点，基于摄像机的朝向建立坐标轴的空间。</p>
<blockquote>
<p>物体的顶点的坐标从世界空间到相机空间的转换 —— 观察转换</p>
<ul>
<li>用到的变换矩阵称为 观察矩阵</li>
<li>包含 旋转、位移 操作</li>
</ul>
<p>摄像机在世界空间中会有一个位置，根据世界坐标系和相机坐标系的相对关系来建立变换矩阵 —— 观察矩阵</p>
</blockquote>
<h3 id="裁剪空间"><a href="#裁剪空间" class="headerlink" title="裁剪空间"></a>裁剪空间</h3><p>在一个顶点着色器运行的最后，OpenGL期望所有的坐标都能落在一个特定的范围内，且任何在这个范围之外的点都应该被裁剪掉(Clipped)。</p>
<ul>
<li><p>从观察空间（特定范围内）变换到裁剪空间，称为 投影变换；</p>
</li>
<li><p>用到的变换矩阵称为 投影矩阵；</p>
</li>
<li><p>从观察空间的某个坐标范围内，变换到（-1，1）的范围，范围外的坐标会被裁剪掉。</p>
</li>
<li><p>变换到裁剪空间之后，顶点着色器最后会自动进行 <code>透视除法</code></p>
<ul>
<li>在这个过程中我们将位置向量的x，y，z分量分别除以向量的齐次w分量</li>
<li>将4D裁剪空间坐标变换为3D标准化设备坐标</li>
</ul>
</li>
</ul>
<blockquote>
<p>如果只是图元(Primitive)(例如三角形)的一部分超出了裁剪体积(Clipping Volume)，则OpenGL会重新构建这个三角形为一个或多个三角形让其能够适合这个裁剪范围。</p>
</blockquote>
<p>投影变换是如何进行的？</p>
<ul>
<li>需要先定义观察范围，即摄像机的观察范围，又称为<code>观察箱</code>或<code>平戳头体 Frustum</code></li>
<li>两种平戳头体：<ul>
<li>正交</li>
<li>透视</li>
</ul>
</li>
<li>对应的，有两种投影矩阵需要计算</li>
</ul>
<h4 id="正射-x2F-正交投影"><a href="#正射-x2F-正交投影" class="headerlink" title="正射&#x2F;正交投影"></a>正射&#x2F;正交投影</h4><ul>
<li>正射投影矩阵定义了一个类似立方体的平截头箱，它定义了一个裁剪空间，在这空间之外的顶点都会被裁剪掉。</li>
<li>需要指定可见平截头体的<code>宽、高和近(Near)平面和远(Far)平面</code></li>
</ul>
<p><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240401174839859.png" alt="image-20240401174839859"></p>
<ul>
<li>任何出现在近平面之前或远平面之后的坐标都会被裁剪掉</li>
<li>正射平截头体直接将平截头体内部的所有坐标映射为标准化设备坐标，因为每个向量的w分量都没有进行改变</li>
<li>如果w分量等于1.0，透视除法则不会改变这个坐标。</li>
</ul>
<p>使用glm库创建正射投影矩阵</p>
<ul>
<li>这个投影矩阵会将处于这些x，y，z值范围内的坐标变换为标准化设备坐标。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">glm::ortho(<span class="number">0.0f</span>, <span class="number">800.0f</span>, <span class="number">0.0f</span>, <span class="number">600.0f</span>, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br><span class="line"><span class="comment">// 前两个参数指定了平截头体的左右坐标，第三和第四参数指定了平截头体的底部和顶部。</span></span><br><span class="line"><span class="comment">// 第五和第六个参数则定义了近平面和远平面的距离。</span></span><br></pre></td></tr></table></figure>



<h4 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h4><p>近大远小</p>
<ul>
<li><p>透视投影矩阵除了将给定的平截头体范围映射到裁剪空间，还修改了每个顶点坐标的w值，从而使得离观察者越远的顶点坐标w分量越大。</p>
</li>
<li><p>被变换到裁剪空间的坐标都会在-w到w的范围之间（任何大于这个范围的坐标都会被裁剪掉）。</p>
</li>
</ul>
<p>在变换到裁剪空间后，需要进行透视除法，以便能够得到最后的归一化设备坐标</p>
<p><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240401175607210.png" alt="image-20240401175607210"></p>
<p>顶点坐标的每个分量都会除以它的w分量，距离观察者越远顶点坐标就会越小。</p>
<p>这是也是w分量非常重要的另一个原因，它能够帮助我们进行透视投影。</p>
<p>在GLM中创建透视投影矩阵：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">glm::mat4 proj = glm::perspective(glm::radians(<span class="number">45.0f</span>), (<span class="type">float</span>)width/(<span class="type">float</span>)height, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br></pre></td></tr></table></figure>

<p>透视平戳头体的定义：</p>
<ul>
<li>视角 FOV</li>
<li>宽高比</li>
<li>远&#x2F;近平面与摄像机的距离</li>
</ul>
<p><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240401175851375.png" alt="image-20240401175851375"></p>
<blockquote>
<p>正射投影主要用于二维渲染以及一些建筑或工程的程序，在这些场景中我们更希望顶点不会被透视所干扰。</p>
<p>某些如 <em>Blender</em> 等进行三维建模的软件有时在建模时也会使用正射投影，因为它在各个维度下都更准确地描绘了每个物体。</p>
<p><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240401180518844.png" alt="image-20240401180518844"></p>
</blockquote>
<h3 id="屏幕空间"><a href="#屏幕空间" class="headerlink" title="屏幕空间"></a>屏幕空间</h3><p>前面的空间变换，组合起来就是：</p>
<p><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240401181028777.png" alt="image-20240401181028777"></p>
<p>此时得到的是裁剪空间下的坐标（即在顶点着色器中传给gl_position的坐标）</p>
<ul>
<li>OpenGL会自己进行透视除法和裁剪</li>
<li>最后就得到了标准化设备坐标。</li>
</ul>
<h4 id="视口变换"><a href="#视口变换" class="headerlink" title="视口变换"></a>视口变换</h4><ul>
<li>标准化设备坐标 到 屏幕坐标</li>
</ul>
<p>有了屏幕大小信息，就可以将标准化设备坐标映射到屏幕坐标，与屏幕的一个像素一一对应。</p>
<h3 id="实操一"><a href="#实操一" class="headerlink" title="实操一"></a>实操一</h3><p>目标效果</p>
<p><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240401194035654.png" alt="image-20240401194035654"></p>
<ul>
<li><p>首先，顶点的模型坐标就是最初的顶点位置信息</p>
</li>
<li><p>然后，定义模型在世界中的坐标&#x2F;旋转&#x2F;缩放</p>
<ul>
<li><p>构建 模型矩阵 （需要自己计算）</p>
<ul>
<li><p>假设：该模型是在世界空间中原点的位置，并绕x轴旋转一定度数</p>
</li>
<li><p>&#96;&#96;&#96;c<br>glm::mat4 model;<br>model &#x3D; glm::rotate(model, glm::radians(-55.0f), glm::vec3(1.0f, 0.0f, 0.0f));</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 然后，定义摄像机的位置和朝向</span><br><span class="line"></span><br><span class="line">  - 构建观察矩阵 （同样需要自己计算）</span><br><span class="line"></span><br><span class="line">    - 摄像机一开始在世界空间的原点处</span><br><span class="line"></span><br><span class="line">      - 那么将摄像机移动到世界空间中的指定位置，相当于反过来将其他物体的按相反的方式移动。</span><br><span class="line">      - 透视矩阵做的就是，按这个相反的操作移动整个场景</span><br><span class="line"></span><br><span class="line">    - 假设：摄像机在z轴正向上的某个位置</span><br><span class="line"></span><br><span class="line">    - ```c</span><br><span class="line">      glm::mat4 view;</span><br><span class="line">      // 注意，我们将矩阵向我们要进行移动场景的反方向移动。</span><br><span class="line">      view = glm::translate(view, glm::vec3(0.0f, 0.0f, -3.0f));</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>然后，确定投影类型</p>
<ul>
<li><p>计算投影矩阵（正交和透视两种，确定平戳头体的参数即可）</p>
</li>
<li><p>以透视投影为例：</p>
<ul>
<li>&#96;&#96;&#96;c<br>glm::mat4 projection;<br>projection &#x3D; glm::perspective(glm::radians(45.0f), screenWidth &#x2F; screenHeight, 0.1f, 100.0f);<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 将所有变换矩阵传给顶点着色器</span><br><span class="line"></span><br><span class="line">  - ```glsl</span><br><span class="line">    #version 330 core</span><br><span class="line">    layout (location = 0) in vec3 aPos;</span><br><span class="line">    ...</span><br><span class="line">    uniform mat4 model;</span><br><span class="line">    uniform mat4 view;</span><br><span class="line">    uniform mat4 projection;</span><br><span class="line">    </span><br><span class="line">    void main()</span><br><span class="line">    &#123;</span><br><span class="line">        // 注意乘法要从右向左读</span><br><span class="line">        gl_Position = projection * view * model * vec4(aPos, 1.0);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>传入变换矩阵（这通常在每次的渲染迭代中进行，因为变换矩阵会经常变动）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> modelLoc = glGetUniformLocation(ourShader.ID, <span class="string">&quot;model&quot;</span>));</span><br><span class="line">glUniformMatrix4fv(modelLoc, <span class="number">1</span>, GL_FALSE, glm::value_ptr(model));</span><br><span class="line">... <span class="comment">// 观察矩阵和投影矩阵与之类似</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>右手坐标系(Right-handed System)</strong></p>
<p><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240401184027481.png" alt="image-20240401184027481"></p>
<ul>
<li>OpenGL使用的是右手系</li>
<li>DirectX使用的是左手系</li>
</ul>
</blockquote>
<h3 id="实操二"><a href="#实操二" class="headerlink" title="实操二"></a>实操二</h3><p>渲染一个立方体</p>
<ul>
<li><p>顶点属性</p>
<ul>
<li>不使用EBO&#x2F;IBO了，直接使用VBO，即<code>glDrawArrays</code></li>
<li>移除了颜色属性，即仅剩位置属性和纹理坐标属性（需要更新<code>顶点属性指针</code></li>
<li>代码就不贴上来了</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>效果（未做深度测试）<br><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240401195047440.png" alt="image-20240401195047440"></p>
</li>
</ul>
<h3 id="实操三"><a href="#实操三" class="headerlink" title="实操三"></a>实操三</h3><ul>
<li><p>在二的基础上，加上深度测试，以显示正确的遮挡关系</p>
</li>
<li><p>OpenGL会维护 Z-buffer 即深度缓冲，结合片段的深度值，在渲染时可以判断哪些片段应该被显示在前面。</p>
</li>
<li><p>深度值存储在每个片段里面（作为片段的<strong>z</strong>值），当片段想要输出它的颜色时，OpenGL会将它的深度值和z缓冲进行比较，如果当前的片段在其它片段之后，它将会被丢弃，否则将会覆盖。这个过程称为深度测试(Depth Testing)，它是由OpenGL自动完成的。</p>
</li>
<li><p>启用深度测试：</p>
<ul>
<li>&#96;&#96;&#96;c<br>glEnable(GL_DEPTH_TEST);<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 在每一帧开始时，清楚深度缓冲</span><br><span class="line"></span><br><span class="line">  - ```c</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>效果<br><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240401200809266.png" alt="image-20240401200809266"></p>
</li>
</ul>
<h3 id="实操四"><a href="#实操四" class="headerlink" title="实操四"></a>实操四</h3><ul>
<li>绘制更多立方体</li>
<li>区别在于它们在世界的位置及旋转角度不同。</li>
<li>当渲染更多物体的时候我们不需要改变我们的缓冲数组和属性数组，我们唯一需要做的只是改变每个对象的模型矩阵来将立方体变换到世界坐标系中。</li>
</ul>
<p>代码：</p>
<ul>
<li><p>各个物体的位置信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">glm::vec3 cubePositions[] = &#123;</span><br><span class="line">  glm::vec3( <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>), </span><br><span class="line">  glm::vec3( <span class="number">2.0f</span>,  <span class="number">5.0f</span>, <span class="number">-15.0f</span>), </span><br><span class="line">  glm::vec3(<span class="number">-1.5f</span>, <span class="number">-2.2f</span>, <span class="number">-2.5f</span>),  </span><br><span class="line">  glm::vec3(<span class="number">-3.8f</span>, <span class="number">-2.0f</span>, <span class="number">-12.3f</span>),  </span><br><span class="line">  glm::vec3( <span class="number">2.4f</span>, <span class="number">-0.4f</span>, <span class="number">-3.5f</span>),  </span><br><span class="line">  glm::vec3(<span class="number">-1.7f</span>,  <span class="number">3.0f</span>, <span class="number">-7.5f</span>),  </span><br><span class="line">  glm::vec3( <span class="number">1.3f</span>, <span class="number">-2.0f</span>, <span class="number">-2.5f</span>),  </span><br><span class="line">  glm::vec3( <span class="number">1.5f</span>,  <span class="number">2.0f</span>, <span class="number">-2.5f</span>), </span><br><span class="line">  glm::vec3( <span class="number">1.5f</span>,  <span class="number">0.2f</span>, <span class="number">-1.5f</span>), </span><br><span class="line">  glm::vec3(<span class="number">-1.3f</span>,  <span class="number">1.0f</span>, <span class="number">-1.5f</span>)  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在渲染循环中，通过改变变换矩阵来渲染同一个模型，以达到渲染多个物体的效果</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">glBindVertexArray(VAO);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">  glm::mat4 model;</span><br><span class="line">  model = glm::translate(model, cubePositions[i]);</span><br><span class="line">  <span class="type">float</span> angle = <span class="number">20.0f</span> * i; </span><br><span class="line">  model = glm::rotate(model, glm::radians(angle), glm::vec3(<span class="number">1.0f</span>, <span class="number">0.3f</span>, <span class="number">0.5f</span>));</span><br><span class="line">  ourShader.setMat4(<span class="string">&quot;model&quot;</span>, model);</span><br><span class="line"></span><br><span class="line">  glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>效果<br><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240401201917505.png" alt="image-20240401201917505"></p>
</li>
</ul>
<h2 id="五、摄像机"><a href="#五、摄像机" class="headerlink" title="五、摄像机"></a>五、摄像机</h2><p>OpenGL本身没有<strong>摄像机</strong>(Camera)的概念，但我们可以通过把场景中的所有物体往相反方向移动的方式来模拟出摄像机，产生一种<strong>我们</strong>在移动的感觉，而不是场景在移动。</p>
<h3 id="相机-x2F-观察空间"><a href="#相机-x2F-观察空间" class="headerlink" title="相机&#x2F;观察空间"></a>相机&#x2F;观察空间</h3><p>以摄像机的视角作为场景原点时，场景中所有的顶点坐标：观察矩阵把所有的世界坐标变换为相对于摄像机位置与方向的观察坐标。</p>
<ul>
<li><p>定义一个相机：（在世界空间中）</p>
<ul>
<li><p>位置坐标</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">glm::vec3 cameraPos = glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">3.0f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右手系中，z轴正方向 是从屏幕指向你的。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><p>观察方向（相机z轴）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">glm::vec3 cameraTarget = glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">glm::vec3 cameraDirection = glm::normalize(cameraPos - cameraTarget);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过两个位置向量相减得到，这里是看向原点。</span></span><br><span class="line"><span class="comment">// 然而，用来表示相机观察方向的 &quot;方向向量&quot; 一般与相机实际观察方向相反。所以这里是用相机位置减去相机看向的目标。</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>右侧方向（相机x轴）</p>
<ul>
<li>需要先定义一个 up 向量，表示世界空间中y轴的方向</li>
<li>将 up向量 和 相机方向向量 进行叉乘，可得相机的右轴（叉乘顺序不能反了——右手螺旋）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">glm::vec3 up = glm::vec3(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>); </span><br><span class="line">glm::vec3 cameraRight = glm::normalize(glm::cross(up, cameraDirection));</span><br></pre></td></tr></table></figure>


</li>
<li><p>上方方向（相机y轴）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">glm::vec3 cameraUp = glm::cross(cameraDirection, cameraRight);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>基于相机上述信息，可以形成一个新的坐标系</p>
</li>
</ul>
<p><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240401203015989.png" alt="image-20240401203015989"></p>
<h3 id="Look-At-矩阵"><a href="#Look-At-矩阵" class="headerlink" title="Look At 矩阵"></a>Look At 矩阵</h3><ul>
<li><p>如果你使用3个相互垂直（或非线性）的轴定义了一个坐标空间，你可以用这3个轴外加一个平移向量（根据新坐标空间原点相对原坐标空间的位置）来创建一个矩阵</p>
</li>
<li><p>这个矩阵乘以任何向量，可以将其变换到新的坐标空间</p>
</li>
</ul>
<p><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240401204810640.png" alt="image-20240401204810640"></p>
<ul>
<li>其中R是右向量，U是上向量，D是方向向量，P是摄像机位置向量。</li>
</ul>
<p>把这个 LookAt矩阵 作为 观察矩阵 可以很高效地把所有世界坐标变换到刚刚定义的观察空间。</p>
<p>也即，对于某摄像机，观察变换使用的观察矩阵 就是该摄像机的 Look At 矩阵</p>
<p>在GLM中，可以直接定义LookAt矩阵:</p>
<ul>
<li>glm::LookAt函数需要一个相机位置、观察目标和上向量。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">glm::mat4 view;</span><br><span class="line">view = glm::lookAt(glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">3.0f</span>), </span><br><span class="line">           glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>), </span><br><span class="line">           glm::vec3(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br></pre></td></tr></table></figure>



<h3 id="实操一-1"><a href="#实操一-1" class="headerlink" title="实操一"></a>实操一</h3><p>假设：观察目标保持为世界原点，而摄像机绕着原点在场景中旋转。</p>
<ul>
<li>用sin,cos函数设置相机的x,z坐标即可，并使用LookAt矩阵作为观察矩阵</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> radius = <span class="number">10.0f</span>;</span><br><span class="line"><span class="type">float</span> camX = <span class="built_in">sin</span>(glfwGetTime()) * radius;</span><br><span class="line"><span class="type">float</span> camZ = <span class="built_in">cos</span>(glfwGetTime()) * radius;</span><br><span class="line">glm::mat4 view;</span><br><span class="line">view = glm::lookAt(glm::vec3(camX, <span class="number">0.0</span>, camZ), glm::vec3(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>), glm::vec3(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>)); </span><br></pre></td></tr></table></figure>



<p><img src="/2024/04/02/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%882%EF%BC%89/image-20240401205923860.png" alt="image-20240401205923860"></p>
<h3 id="实操二-1"><a href="#实操二-1" class="headerlink" title="实操二"></a>实操二</h3><p>实现一个相机系统，由用户自主控制摄像机的位置、朝向、缩放</p>
<ul>
<li><p>定义好相机的三个信息：</p>
<ul>
<li>位置</li>
<li>方向向量</li>
<li>up向量</li>
</ul>
</li>
<li><p>&#96;&#96;&#96;c<br>glm::vec3 cameraPos   &#x3D; glm::vec3(0.0f, 0.0f,  3.0f);<br>glm::vec3 cameraFront &#x3D; glm::vec3(0.0f, 0.0f, -1.0f);<br>glm::vec3 cameraUp    &#x3D; glm::vec3(0.0f, 1.0f,  0.0f);</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 则LookAt函数的参数为</span><br><span class="line"></span><br><span class="line">  ```c</span><br><span class="line">  view = glm::lookAt(cameraPos, cameraPos + cameraFront, cameraUp);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h4><ul>
<li><p>根据键盘输入，修改<code>cameraPos</code></p>
</li>
<li><p>由GLFW获取输入</p>
</li>
<li><p>&#96;&#96;&#96;c<br>void processInput(GLFWwindow *window)<br>{<br>…<br>float cameraSpeed &#x3D; 0.05f; &#x2F;&#x2F; adjust accordingly<br>if (glfwGetKey(window, GLFW_KEY_W) &#x3D;&#x3D; GLFW_PRESS)<br>    cameraPos +&#x3D; cameraSpeed * cameraFront;<br>if (glfwGetKey(window, GLFW_KEY_S) &#x3D;&#x3D; GLFW_PRESS)<br>    cameraPos -&#x3D; cameraSpeed * cameraFront;<br>if (glfwGetKey(window, GLFW_KEY_A) &#x3D;&#x3D; GLFW_PRESS)<br>    cameraPos -&#x3D; glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed;<br>if (glfwGetKey(window, GLFW_KEY_D) &#x3D;&#x3D; GLFW_PRESS)<br>    cameraPos +&#x3D; glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed;<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 在封装类的时候，如果相机类的成员变量是glm库中的类型，需要注意拷贝数据的方式可能导致的问题。</span><br><span class="line"></span><br><span class="line">- 平均速度</span><br><span class="line"></span><br><span class="line">  - 渲染帧时间差 Deltatime，储存了渲染上一帧所用的时间</span><br><span class="line">  - 固定速度 * Deltatime 的结果：可以使得在相同的时间内，不同机器上渲染帧数不同的情况下，保持相同的速率</span><br><span class="line"></span><br><span class="line">#### 朝向</span><br><span class="line"></span><br><span class="line">- 用鼠标控制朝向</span><br><span class="line">  - 水平的移动影响偏航角，竖直的移动影响俯仰角。</span><br><span class="line">  - 储存上一帧鼠标的位置，在当前帧中我们当前计算鼠标位置与上一帧的位置相差多少。</span><br><span class="line">-  欧拉角</span><br><span class="line">  - 俯仰角(Pitch)、偏航角(Yaw)和滚转角(Roll)</span><br><span class="line">  -  ![image-20240402000146667](LearnOpenGL摘要（2）/image-20240402000146667.png)</span><br><span class="line"></span><br><span class="line">- 一般对于摄像机来说，只关心俯仰角和偏航角即可，滚筒角用不到</span><br><span class="line"></span><br><span class="line">  - 对于给定的俯仰角和偏航角，我们需要计算出一个方向向量</span><br><span class="line"></span><br><span class="line">  - 引用别人的图：</span><br><span class="line"></span><br><span class="line">    - h为方向向量（长度为1），我们的目标是求这个方向向量的x,y,z分量</span><br><span class="line"></span><br><span class="line">    - 如图可得：</span><br><span class="line"></span><br><span class="line">      - y = sin(pitch)</span><br><span class="line">      - x = cos(pitch) * cos(yaw)</span><br><span class="line">      - z = cos(pitch) * sin(yaw)</span><br><span class="line"></span><br><span class="line">      &lt;img src=&quot;LearnOpenGL摘要（2）/image-20240402010939180.png&quot; alt=&quot;image-20240402010939180&quot; style=&quot;zoom:80%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    - pitch，yaw 都初始化为0的话，则初始朝向 x轴 方向。</span><br><span class="line"></span><br><span class="line">- 编程</span><br><span class="line"></span><br><span class="line">  - FPS风格的鼠标输入和摄像机控制：</span><br><span class="line">    1. 计算鼠标距上一帧的偏移量。</span><br><span class="line">    2. 把偏移量添加到摄像机的俯仰角和偏航角中。</span><br><span class="line">    3. 对偏航角和俯仰角进行最大和最小值的限制。</span><br><span class="line">    4. 计算方向向量。</span><br><span class="line"></span><br><span class="line">  - GLFW鼠标设置：隐藏光标，并捕捉(Capture)鼠标</span><br><span class="line"></span><br><span class="line">    ```c</span><br><span class="line">    glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>监听鼠标移动事件，鼠标移动时，调用回调函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 监听</span></span><br><span class="line">glfwSetCursorPosCallback(window, mouse_callback);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mouse_callback</span><span class="params">(GLFWwindow* window, <span class="type">double</span> xpos, <span class="type">double</span> ypos)</span> &#123;</span><br><span class="line"> 	<span class="keyword">if</span>(firstMouse)</span><br><span class="line">    &#123;</span><br><span class="line">        lastX = xpos;</span><br><span class="line">        lastY = ypos;</span><br><span class="line">        firstMouse = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> xoffset = xpos - lastX;</span><br><span class="line">    <span class="type">float</span> yoffset = lastY - ypos; </span><br><span class="line">    lastX = xpos;</span><br><span class="line">    lastY = ypos;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> sensitivity = <span class="number">0.05</span>;</span><br><span class="line">    xoffset *= sensitivity;</span><br><span class="line">    yoffset *= sensitivity;</span><br><span class="line"></span><br><span class="line">    yaw   += xoffset;</span><br><span class="line">    pitch += yoffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pitch &gt; <span class="number">89.0f</span>)</span><br><span class="line">        pitch = <span class="number">89.0f</span>;</span><br><span class="line">    <span class="keyword">if</span>(pitch &lt; <span class="number">-89.0f</span>)</span><br><span class="line">        pitch = <span class="number">-89.0f</span>;</span><br><span class="line"></span><br><span class="line">    glm::vec3 front;</span><br><span class="line">    front.x = <span class="built_in">cos</span>(glm::radians(yaw)) * <span class="built_in">cos</span>(glm::radians(pitch));</span><br><span class="line">    front.y = <span class="built_in">sin</span>(glm::radians(pitch));</span><br><span class="line">    front.z = <span class="built_in">sin</span>(glm::radians(yaw)) * <span class="built_in">cos</span>(glm::radians(pitch));</span><br><span class="line">    cameraFront = glm::normalize(front);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="缩放-1"><a href="#缩放-1" class="headerlink" title="缩放"></a>缩放</h4><ul>
<li><p>主要是通过改变透视投影矩阵，即改变透视平戳头体</p>
<ul>
<li>改变FOV的视角：<ul>
<li>缩小视角则投影出的空间变少，可以产生放大的效果</li>
<li>反之则是缩小的效果</li>
</ul>
</li>
<li>限定FOV范围为 1.0f ~ 45.0f</li>
</ul>
</li>
<li><p>鼠标滚轮控制</p>
<ul>
<li><p>回调函数</p>
<ul>
<li>当滚动鼠标滚轮的时候，yoffset值代表我们竖直滚动的大小</li>
<li></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">scroll_callback</span><span class="params">(GLFWwindow* window, <span class="type">double</span> xoffset, <span class="type">double</span> yoffset)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(fov &gt;= <span class="number">1.0f</span> &amp;&amp; fov &lt;= <span class="number">45.0f</span>)</span><br><span class="line">    fov -= yoffset;</span><br><span class="line">  <span class="keyword">if</span>(fov &lt;= <span class="number">1.0f</span>)</span><br><span class="line">    fov = <span class="number">1.0f</span>;</span><br><span class="line">  <span class="keyword">if</span>(fov &gt;= <span class="number">45.0f</span>)</span><br><span class="line">    fov = <span class="number">45.0f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>图形学</category>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis基础（一）</title>
    <url>/2024/01/24/Redis%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Redis（一）"><a href="#Redis（一）" class="headerlink" title="Redis（一）"></a>Redis（一）</h1><h2 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h2><p><strong>非关系型数据库</strong></p>
<ul>
<li>采用 Key-Value 形式存储数据，而不是传统的关系表</li>
<li>更好拓展，并发性能高</li>
<li>不支持 ACID，不支持回滚事务</li>
</ul>
<p><strong>Redis</strong></p>
<ul>
<li>数据存在内存中，但支持持久化，用作备份恢复</li>
<li>key-value的value有多种类型：string、list、set、zset、hash等</li>
<li>一般是作为缓存数据库辅助持久化的数据库</li>
<li>Redis 6.0之前是 单线程+I&#x2F;O多路复用</li>
</ul>
<p><strong>MongoDB</strong></p>
<ul>
<li>文档型数据库，格式类似Json</li>
<li>数据一般在内存中，当内存不足时把不常用的数据保存到硬盘</li>
<li>对key-value中的 value 提供丰富的查询功能</li>
<li>支持二进制数据和大型对象</li>
</ul>
<span id="more"></span>

<h2 id><a href="#" class="headerlink" title></a></h2><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="基础命令使用"><a href="#基础命令使用" class="headerlink" title="基础命令使用"></a>基础命令使用</h3><ul>
<li>key的增删查</li>
<li>库的增删查</li>
</ul>
<h3 id="string-字符串"><a href="#string-字符串" class="headerlink" title="string 字符串"></a>string 字符串</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ul>
<li>是二进制安全的：<ul>
<li>Redis的string可以表示任何数据。如图片、序列化的对象。</li>
</ul>
</li>
<li>单个string最大是512M</li>
<li>命令：<ul>
<li>Set Get</li>
<li>增删查改</li>
<li>字符串操作</li>
</ul>
</li>
</ul>
<blockquote>
<p>tip：命令操作一般都是原子性的，得益于redis的单线程。</p>
<p>6.0之后引入的多线程是针对网络I&#x2F;O的，命令操作仍然使用单线程。</p>
</blockquote>
<h4 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h4><p><strong>简单动态字符串　SDS</strong></p>
<p>图示：</p>
<img src="/2024/01/24/Redis%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/image-20240125000323050.png" alt="image-20240125000323050" style="zoom:80%;">

<img src="/2024/01/24/Redis%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/image-20240125000433103.png" alt="image-20240125000433103" style="zoom:80%;">



<ul>
<li>动态记录字符串长度，以及空闲空间，O(1)复杂的获取字符串大小</li>
<li>动态空间分配<ul>
<li>空间预分配：当字符串大小小于 1M 时成倍增长（提供与len同等大小的free空间），之后都是额外分配1M的free空间</li>
<li>惰性空间释放：缩短字符串后不会立即释放空间，而是继续用作free区域。同时提供了释放空间的API以供不时之需</li>
</ul>
</li>
<li>缓冲区溢出检查和自动扩容</li>
<li>二进制安全<ul>
<li>C语言字符串受制于ASCII编码和<code>&#39;\0&#39;</code>等的影响，无法用来存储某些二进制数据（像图片、音频、视频、压缩文件）</li>
<li>Redis以处理二进制的方式来处理SDS存放在buf数组里的数据</li>
</ul>
</li>
<li>保留结尾的’\0’，因此可以兼容部分C库的字符串处理函数</li>
</ul>
<h3 id="list-链表"><a href="#list-链表" class="headerlink" title="list 链表"></a>list 链表</h3><p>单key多value，value用链表组织起来</p>
<h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><ul>
<li>双向链表</li>
<li>命令：lpush&#x2F;rpush，lpop&#x2F;rpop</li>
<li>增删查改</li>
</ul>
<h4 id="底层数据结构-1"><a href="#底层数据结构-1" class="headerlink" title="底层数据结构"></a>底层数据结构</h4><ul>
<li>最简单的基础双向链表</li>
<li>3.0之后——ziplist，有点类似STL的deque</li>
<li>3.2之后——quicklist</li>
<li>5.0之后——listpack</li>
</ul>
<p>基础双向链表</p>
<img src="/2024/01/24/Redis%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/image-20240125004947003.png" alt="image-20240125004947003" style="zoom:80%;">



<p>压缩链表</p>
<img src="/2024/01/24/Redis%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/image-20240125010028582.png" alt="image-20240125010028582" style="zoom: 67%;">

<ul>
<li>优势<ul>
<li>使数据的内存分布更为紧凑（能够提高CPU缓存利用率），节省空间，提高性能</li>
</ul>
</li>
<li>缺陷<ul>
<li>不能保存过多的元素，否则查询效率就会降低；</li>
<li>新增或修改某个元素时，压缩列表占用的内存空间需要重新分配，甚至可能引发连锁更新的问题。</li>
</ul>
</li>
<li>适用于数据数量较少的情况</li>
</ul>
<h3 id="hash-哈希"><a href="#hash-哈希" class="headerlink" title="hash 哈希"></a>hash 哈希</h3><h3 id="set-集合"><a href="#set-集合" class="headerlink" title="set 集合"></a>set 集合</h3><h3 id="zset-有序集合"><a href="#zset-有序集合" class="headerlink" title="zset 有序集合"></a>zset 有序集合</h3>]]></content>
      <categories>
        <category>数据库</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>数据库, Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP之协议机制</title>
    <url>/2023/05/11/TCP%E4%B9%8B%E5%8D%8F%E8%AE%AE%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="TCP之协议机制"><a href="#TCP之协议机制" class="headerlink" title="TCP之协议机制"></a>TCP之协议机制</h1><hr>
<p>主要讨论TCP实现可靠的信息传输的几种机制：<strong>重传机制</strong>、<strong>流量控制（滑动窗口）</strong>、<strong>拥塞控制</strong></p>
<p>此外还有<strong>粘包</strong>问题<strong>拆包</strong>处理</p>
<hr>
<span id="more"></span>

<h2 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h2><h3 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h3><p><strong>数据的发送方</strong>，在发送数据后，以<strong>收到ack响应</strong>作为数据成功发送的标志。</p>
<p>在发送数据时会设置一个<strong>定时器</strong>，若在限定时间内没有收到ack响应，说明<u>发送的数据丢失</u>（或<u>ack丢失</u>），需要<strong>重传</strong>。</p>
<blockquote>
<p>RTT 和 RTO</p>
<ul>
<li><strong>RTT</strong>，Round-Trip Time 往返时延，即从发送数据到收到ack的时间大小。</li>
<li><strong>RTO</strong>，Restransmission Timeout 超时重传时间，超时定时器设置。</li>
</ul>
<p><strong>RTO</strong> 应该设置为略大于 <strong>RTT</strong> 的大小。并且根据网络实际情况，RTT和RTO都是动态变化的。</p>
</blockquote>
<h3 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h3><h4 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h4><p>不依靠<strong>时间</strong>来判断是否需要重传，而是按<strong>收到的ack</strong>判断。减少了判定重传所需的时间。</p>
<ul>
<li><p>发送方发送的数据包seq&#x3D;2丢失了，且后续还有成功发送的数据包</p>
</li>
<li><p>此时接收方没有收到seq&#x3D;2，于是在此后都会回应ack&#x3D;2；</p>
</li>
<li><p>发送方收到几次相同的ack&#x3D;2，说明seq&#x3D;2丢失了，于是触发了重传。</p>
</li>
</ul>
<img src="/2023/05/11/TCP%E4%B9%8B%E5%8D%8F%E8%AE%AE%E6%9C%BA%E5%88%B6/image-20230511225957231.png" alt="image-20230511225957231" style="zoom:80%;">



<p>这里会有一个问题：如何确定需要重传的内容（除了重传ack&#x3D;2对应的包，<strong>是否还需要重传后续所有的包</strong>）</p>
<h4 id="SACK-选择性确认"><a href="#SACK-选择性确认" class="headerlink" title="SACK 选择性确认"></a>SACK 选择性确认</h4><p><strong>通信双方</strong>需要在TCP头部选项字段里添加<strong>SACK选项</strong>。</p>
<p>情况</p>
<ul>
<li>发送方发送的数据丢失</li>
</ul>
<p>ack数据包中会有 记录<strong>已接收的数据情况</strong>的内容，于是发送方可以根据情况来选择要重发的数据包。</p>
<ul>
<li>接收方发现收到的数据seq非目标序列号时，会回发原来的 ack，但会使用 sack 记录当前的接收情况。</li>
<li>这种情况下 ack 会比 sack 小</li>
</ul>
<p><img src="/2023/05/11/TCP%E4%B9%8B%E5%8D%8F%E8%AE%AE%E6%9C%BA%E5%88%B6/image-20230511233550529.png" alt="image-20230511233550529"></p>
<p><strong>Duplicate SACK 重复选择性确认</strong></p>
<p>也即D-SACK，接收方通过记录<strong>重复接收的数据</strong>，让发送方明确数据是否丢失。</p>
<p>情况：</p>
<ul>
<li>ack丢失</li>
<li>网络延时</li>
</ul>
<p>ack 会比 sack 大</p>
<p>作用：</p>
<ul>
<li>可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;</li>
<li>可以知道是不是「发送方」的数据包被网络延迟了;</li>
<li>可以知道网络中是不是把「发送方」的数据包给复制了;</li>
</ul>
<h2 id="流量控制-滑动窗口"><a href="#流量控制-滑动窗口" class="headerlink" title="流量控制-滑动窗口"></a>流量控制-滑动窗口</h2><h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p>解决的问题：</p>
<ul>
<li>每发送一份数据，都要等到收到ack之后才发送下一份数据。</li>
<li>效率低</li>
</ul>
<p>使用的方法：</p>
<ul>
<li>发送窗口的实现实际上是操作系统开辟的一个<strong>缓存空间</strong>，发送方主机在等到确认应答返回之前，必须<strong>在缓冲区中保留已发送的数据</strong>。如果按期收到确认应答（根据<strong>最新的ack</strong>即可，<strong>累计确认</strong>），此时数据就可以从缓存区清除。</li>
<li><strong>TCP头部</strong>中的<strong>window</strong>大小字段，用来表示接收方<strong>接收窗口</strong>的空闲空间大小。发送方可以根据接受方发来的ack中的window字段来调整发送的数据量。</li>
<li>发送方的<strong>发送窗口</strong><br><img src="/2023/05/11/TCP%E4%B9%8B%E5%8D%8F%E8%AE%AE%E6%9C%BA%E5%88%B6/image-20230512000432964.png" alt="image-20230512000432964"><ul>
<li>需要记录 1.<strong>窗口起始地址</strong> 2.<strong>下一个可发送字节的地址</strong> 3.<strong>窗口末尾下一个字节的地址</strong>（起始地址+窗口大小的偏移）</li>
</ul>
</li>
<li>接收方的<strong>接收窗口</strong><br><img src="/2023/05/11/TCP%E4%B9%8B%E5%8D%8F%E8%AE%AE%E6%9C%BA%E5%88%B6/image-20230512000733074.png" alt="image-20230512000733074"><ul>
<li>需要记录 1.<strong>窗口起始地址</strong> 2.<strong>期望的下一个字节的地址</strong> 3.<strong>窗口末尾下一个字节的地址</strong></li>
<li>接收窗口中的数据在<strong>接收方回送ack且应用层提取之后</strong>就可以移除并更新窗口</li>
</ul>
</li>
</ul>
<h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>解决的问题：</p>
<ul>
<li>发送方不能无脑的发数据给接收方，要考虑接收方处理能力。</li>
<li>如果一直无脑的发数据给对方，但对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费。</li>
</ul>
<p>解决的方法：</p>
<ul>
<li>设置滑动窗口</li>
<li>动态调整滑动窗口大小（窗口大小代表着缓冲区情况）</li>
</ul>
<p><img src="/2023/05/11/TCP%E4%B9%8B%E5%8D%8F%E8%AE%AE%E6%9C%BA%E5%88%B6/image-20230512001914792.png" alt="image-20230512001914792"></p>
<p>注意：</p>
<ul>
<li>如果发生了先减少缓冲区内存，再收缩窗口，就会出现丢包的现象。</li>
<li>为了防止这种情况发生，TCP 规定是<strong>不允许同时减少缓存又收缩窗口</strong>的，而是采用<strong>先收缩窗口</strong>，过段时间<strong>再减少缓存</strong>，这样就可以避免了丢包情况</li>
</ul>
<h4 id="窗口关闭（大小为0）"><a href="#窗口关闭（大小为0）" class="headerlink" title="窗口关闭（大小为0）"></a>窗口关闭（大小为0）</h4><p>窗口关闭后潜在的死锁问题（后面开启窗口的ack包丢失所导致）</p>
<img src="/2023/05/11/TCP%E4%B9%8B%E5%8D%8F%E8%AE%AE%E6%9C%BA%E5%88%B6/image-20230512002308803.png" alt="image-20230512002308803" style="zoom:80%;">

<ul>
<li>为了解决这个问题，TCP 为每个连接设有一个持续定时器，<strong>只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。</strong></li>
<li>如果持续计时器超时，就会发送<strong>窗口探测 ( Window probe ) 报文</strong>，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。</li>
<li>若探测成功则继续发送数据，否则每次探测会更新计时器，到达上限则会使用RST断开连接。</li>
</ul>
<h4 id="糊涂窗口综合症（小额数据发送）"><a href="#糊涂窗口综合症（小额数据发送）" class="headerlink" title="糊涂窗口综合症（小额数据发送）"></a>糊涂窗口综合症（小额数据发送）</h4><p>情况：</p>
<ul>
<li>接收方繁忙时处理数据效率很低，导致接收窗口很小，使得发送方的发送窗口也很小</li>
<li>每次接收方处理一点数据就腾出几个字节的窗口空间，并告诉发送方。而发送方立即发送几个字节的数据。（TCP头部就40多字节了，因此效率很低）</li>
</ul>
<p>解决方法：</p>
<ul>
<li><p>接收方：当接收方窗口小于某个大小（MSS，1&#x2F;2缓冲区大小）时，统统当作 <strong>0</strong> 告诉发送方，不让发送方发数据。</p>
</li>
<li><p>发送方：<strong>Nagle</strong> 算法，<strong>延迟发送</strong>，满足下面<strong>任意一个</strong>条件才发送，否则把要发的数据屯着。</p>
<ul>
<li>条件一：要等到窗口大小 &gt;&#x3D; <code>MSS</code> 并且 数据大小 &gt;&#x3D; <code>MSS</code>；</li>
<li>条件二：收到之前发送数据的 <code>ack</code> 回包；</li>
</ul>
<blockquote>
<p>如果对于一些需要小数据包交互的场景的程序，比如，telnet 或 ssh 这样的交互性比较强的程序，则需要关闭 Nagle 算法。</p>
<p>setsockopt TCP_NODELAY</p>
</blockquote>
</li>
</ul>
<h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>流量控制只是对双方的发送和接收能力进行协调配合，对于<strong>网络情况</strong>的控制则需要<strong>拥塞控制</strong>机制来做到。</p>
<p>解决的问题：</p>
<ul>
<li>网络出现拥堵，会触发重传机制，如果不做限制，一直重传下去，则会导致网络情况越来越糟。</li>
<li>形成恶性循环。</li>
</ul>
<p>解决方法：</p>
<ul>
<li>TCP被设计成无私的协议，当发现网络发送拥堵时，会先减少自己发送的数据量</li>
<li>采用一个变量“ <strong>拥塞窗口</strong> <strong>cwnd</strong> ”实现拥塞控制<ul>
<li>只要网络中没有出现拥塞，<code>cwnd</code> 就会增大；</li>
<li>但网络中出现了拥塞，<code>cwnd</code> 就减少；</li>
</ul>
</li>
<li>发送窗口大小 <strong>swnd</strong> &#x3D; min(<strong>cwnd</strong>, <strong>rwnd</strong>)</li>
</ul>
<p>发生<strong>超时重传</strong>就认为网络出现拥塞；</p>
<p>四个拥塞控制算法：慢启动、拥塞避免、拥塞发生、快速恢复</p>
<h3 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h3><ul>
<li>当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。相当于每轮翻一倍。</li>
<li>发送包的数量呈<strong>指数增长</strong></li>
<li>当达到<strong>慢启动门限</strong> <strong>ssthresh</strong>(slow start threshold)后，转为 <strong>拥塞避免算法</strong></li>
</ul>
<p><img src="/2023/05/11/TCP%E4%B9%8B%E5%8D%8F%E8%AE%AE%E6%9C%BA%E5%88%B6/image-20230512013125907.png" alt="image-20230512013125907"></p>
<h3 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h3><ul>
<li>每当收到一个 ACK 时，cwnd 增加 <strong>1&#x2F;cwnd</strong>。相当于cwnd每轮增加 1 。</li>
<li>发送包的数量呈<strong>线性增长</strong>。</li>
<li>直到发送丢包，则转入<strong>拥塞发生</strong>算法</li>
</ul>
<p><img src="/2023/05/11/TCP%E4%B9%8B%E5%8D%8F%E8%AE%AE%E6%9C%BA%E5%88%B6/image-20230512013510913.png" alt="image-20230512013510913"></p>
<h3 id="拥塞发生"><a href="#拥塞发生" class="headerlink" title="拥塞发生"></a>拥塞发生</h3><p>对 <strong>超时重传</strong> 和 <strong>快速重传</strong> 有不同的策略：</p>
<p>针对超时重传（网络情况更为糟糕）</p>
<ul>
<li><code>ssthresh</code> 设为 <code>cwnd/2</code>，即将慢启动门限设为当前cwnd的一半。</li>
<li><code>cwnd</code> 重置为 <strong>初始化值</strong></li>
<li>重新开始<strong>慢启动</strong>。</li>
</ul>
<img src="/2023/05/11/TCP%E4%B9%8B%E5%8D%8F%E8%AE%AE%E6%9C%BA%E5%88%B6/image-20230512013838738.png" alt="超时重传拥塞发生" style="zoom:80%;">





<p>针对快速重传（网络情况可能不好）</p>
<ul>
<li><code>cwnd = cwnd/2</code> ，拥塞窗口减半;</li>
<li><code>ssthresh = cwnd</code>，慢启动门限设为减半后的拥塞窗口;</li>
<li>进入<strong>快速恢复算法</strong></li>
</ul>
<h3 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h3><p>快速重传和快速恢复算法一般同时使用。</p>
<ul>
<li><code>cwnd = ssthresh+3</code>， 相当于前面减半后直接+3（引发快速重传的三个数据包确定是收到了，所以直接+3）；</li>
<li>重传丢失的数据包</li>
<li>若收到重复的ack，则 cwnd+&#x3D;1（目的是为了尽快处理&#x2F;发送丢失的数据包）</li>
<li>若收到新数据的ack，则 cwnd &#x3D; ssthresh，并恢复为<strong>拥塞避免算法</strong>（做出自我牺牲）</li>
</ul>
<p>作为 <strong>拥塞发生(超时重传)&gt;&gt;慢启动</strong> 的加速版，即 <strong>拥塞发生(快速重传)&gt;&gt;快速恢复&gt;&gt;拥塞避免</strong> ，在正确处理完丢失的数据包之后，使得cwnd处于一个更高的起点。</p>
<p><img src="/2023/05/11/TCP%E4%B9%8B%E5%8D%8F%E8%AE%AE%E6%9C%BA%E5%88%B6/image-20230512014231996.png" alt="image-20230512014231996"></p>
]]></content>
      <categories>
        <category>网络</category>
        <category>TCP</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>LearnOpenGL摘要（入门三）</title>
    <url>/2024/04/06/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="光照"><a href="#光照" class="headerlink" title="光照"></a>光照</h1><h2 id="一、光和颜色"><a href="#一、光和颜色" class="headerlink" title="一、光和颜色"></a>一、光和颜色</h2><h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><ul>
<li><p>颜色的表示格式之一 <code>RGB</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">glm::vec3 <span class="title function_">coral</span><span class="params">(<span class="number">1.0f</span>, <span class="number">0.5f</span>, <span class="number">0.31f</span>)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>现实世界中的颜色：我们在现实生活中看到某一物体的颜色并不是这个物体真正拥有的颜色，而是它所<code>反射</code>的(Reflected)颜色。</p>
<ul>
<li>换句话说，那些不能被物体所吸收(Absorb)的颜色（被拒绝的颜色）就是我们能够感知到的物体的颜色。</li>
<li>白色的阳光相当于是所有颜色的集合。</li>
</ul>
</li>
</ul>
<p><img src="/2024/04/06/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%B8%89%EF%BC%89/image-20240405000325715.png" alt="image-20240405000325715"></p>
<span id="more"></span>

<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>在图形学中如何计算光照？这里是一种简单的方式</p>
<ul>
<li><p>输入：</p>
<ul>
<li>具有不同频率（颜色）的能量的光</li>
<li>带有一定颜色（反射率）的物体，</li>
</ul>
</li>
<li><p>过程：吸收一部分光，反射另一部分光</p>
</li>
<li><p>输出：反射出的光的颜色（频率）</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 这里不是点乘</span><br><span class="line"></span><br><span class="line">// 输入：白色光</span><br><span class="line"></span><br><span class="line">glm::vec3 lightColor(0.0f, 1.0f, 0.0f);</span><br><span class="line">glm::vec3 toyColor(1.0f, 0.5f, 0.31f);</span><br><span class="line">glm::vec3 result = lightColor * toyColor; // = (0.0f, 0.5f, 0.0f);</span><br><span class="line"></span><br><span class="line">// 输入：绿光</span><br><span class="line"></span><br><span class="line">glm::vec3 lightColor(0.33f, 0.42f, 0.18f);</span><br><span class="line">glm::vec3 toyColor(1.0f, 0.5f, 0.31f);</span><br><span class="line">glm::vec3 result = lightColor * toyColor; // = (0.33f, 0.21f, 0.06f);</span><br></pre></td></tr></table></figure>



<h3 id="带有光照的场景"><a href="#带有光照的场景" class="headerlink" title="带有光照的场景"></a>带有光照的场景</h3><p>内容：</p>
<ul>
<li><p>一个光源（用之前的立方体表示）</p>
</li>
<li><p>其他物体</p>
</li>
<li><p>只考虑颜色，不考虑角度等</p>
</li>
</ul>
<p>对于光源，我们把它当作立方体来渲染。</p>
<ul>
<li>此处建议为光源物体独自创建一个VAO，因为后续光源物体和实际物体的顶点属性差别会很大。</li>
</ul>
<p>结果图</p>
<p><img src="/2024/04/06/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%B8%89%EF%BC%89/image-20240405144312978.png" alt="image-20240405144312978"></p>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;public.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ShaderMgr.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;camera.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;part1.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">MyCamera g_camera;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> mixValue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//float vertices[] = &#123;</span></span><br><span class="line"><span class="comment">//    // positions          // colors           // texture coords</span></span><br><span class="line"><span class="comment">//     0.5f,  0.5f, 0.0f,   1.0f, 0.0f, 0.0f,   1.0f, 1.0f, // top right</span></span><br><span class="line"><span class="comment">//     0.5f, -0.5f, 0.0f,   0.0f, 1.0f, 0.0f,   1.0f, 0.0f, // bottom right</span></span><br><span class="line"><span class="comment">//    -0.5f, -0.5f, 0.0f,   0.0f, 0.0f, 1.0f,   0.0f, 0.0f, // bottom left</span></span><br><span class="line"><span class="comment">//    -0.5f,  0.5f, 0.0f,   1.0f, 1.0f, 0.0f,   0.0f, 1.0f  // top left </span></span><br><span class="line"><span class="comment">//&#125;;</span></span><br><span class="line"><span class="comment">//unsigned int indices[] = &#123;</span></span><br><span class="line"><span class="comment">//    // 注意索引从0开始! </span></span><br><span class="line"><span class="comment">//    // 此例的索引(0,1,2,3)就是顶点数组vertices的下标，</span></span><br><span class="line"><span class="comment">//    // 这样可以由下标代表顶点组合成矩形</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    0, 1, 3, // 第一个三角形</span></span><br><span class="line"><span class="comment">//    1, 2, 3  // 第二个三角形</span></span><br><span class="line"><span class="comment">//&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">glm::vec3 cubePositions[] = &#123;</span><br><span class="line">  glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>),</span><br><span class="line">  glm::<span class="built_in">vec3</span>(<span class="number">2.0f</span>,  <span class="number">5.0f</span>, <span class="number">-15.0f</span>),</span><br><span class="line">  glm::<span class="built_in">vec3</span>(<span class="number">-1.5f</span>, <span class="number">-2.2f</span>, <span class="number">-2.5f</span>),</span><br><span class="line">  glm::<span class="built_in">vec3</span>(<span class="number">-3.8f</span>, <span class="number">-2.0f</span>, <span class="number">-12.3f</span>),</span><br><span class="line">  glm::<span class="built_in">vec3</span>(<span class="number">2.4f</span>, <span class="number">-0.4f</span>, <span class="number">-3.5f</span>),</span><br><span class="line">  glm::<span class="built_in">vec3</span>(<span class="number">-1.7f</span>,  <span class="number">3.0f</span>, <span class="number">-7.5f</span>),</span><br><span class="line">  glm::<span class="built_in">vec3</span>(<span class="number">1.3f</span>, <span class="number">-2.0f</span>, <span class="number">-2.5f</span>),</span><br><span class="line">  glm::<span class="built_in">vec3</span>(<span class="number">1.5f</span>,  <span class="number">2.0f</span>, <span class="number">-2.5f</span>),</span><br><span class="line">  glm::<span class="built_in">vec3</span>(<span class="number">1.5f</span>,  <span class="number">0.2f</span>, <span class="number">-1.5f</span>),</span><br><span class="line">  glm::<span class="built_in">vec3</span>(<span class="number">-1.3f</span>,  <span class="number">1.0f</span>, <span class="number">-1.5f</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mixValue = <span class="number">0.2f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GLFW 窗口初始化</span></span><br><span class="line">    GLFWwindow* window = <span class="built_in">init_GLFW_window</span>(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;LearnOpenGL&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (window == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to initialize GLFW&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GLAD 函数地址初始化</span></span><br><span class="line">    <span class="keyword">if</span> (GL_FALSE == <span class="built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 相机初始化</span></span><br><span class="line">    g_camera.<span class="built_in">Init</span>(glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">3.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启深度缓冲</span></span><br><span class="line">    <span class="built_in">glEnable</span>(GL_DEPTH_TEST);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 顶点缓冲设置</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> VBO;</span><br><span class="line">    <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">    <span class="comment">// 把之前定义的顶点数据复制到缓冲的内存</span></span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 灯光物体的顶点数组和属性设置</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> lightVAO;</span><br><span class="line">    <span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;lightVAO);</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(lightVAO);</span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">5</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 物体顶点数组生成</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> VAO;</span><br><span class="line">    <span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">5</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 着色器相关初始化，以及uniform变量设置</span></span><br><span class="line">    <span class="function">Shader <span class="title">shader</span><span class="params">(<span class="string">&quot;./ColorVShader.glsl&quot;</span>, <span class="string">&quot;./ColorFShader.glsl&quot;</span>)</span></span>;</span><br><span class="line">    shader.<span class="built_in">use</span>();</span><br><span class="line">    shader.<span class="built_in">setVec3</span>(<span class="string">&quot;objectColor&quot;</span>, <span class="number">1.0f</span>, <span class="number">0.5f</span>, <span class="number">0.31f</span>);</span><br><span class="line">    shader.<span class="built_in">setVec3</span>(<span class="string">&quot;lightColor&quot;</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">Shader <span class="title">lightShader</span><span class="params">(<span class="string">&quot;./ColorVShader.glsl&quot;</span>, <span class="string">&quot;./ColorFShader_Light.glsl&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 光照位置</span></span><br><span class="line">    <span class="function">glm::vec3 <span class="title">lightPos</span><span class="params">(<span class="number">1.2f</span>, <span class="number">1.0f</span>, <span class="number">2.0f</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染循环</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))	<span class="comment">// 检查是否被要求退出窗口</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 输入处理</span></span><br><span class="line">        <span class="built_in">processInput</span>(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 帧渲染时间</span></span><br><span class="line">        <span class="type">float</span> deltaTime;</span><br><span class="line">        <span class="type">float</span> lastFrame = <span class="number">0</span>;</span><br><span class="line">        <span class="type">float</span> currentFrame = <span class="built_in">glfwGetTime</span>();</span><br><span class="line">        deltaTime = currentFrame - lastFrame;</span><br><span class="line">        lastFrame = currentFrame;</span><br><span class="line"></span><br><span class="line">        g_camera.<span class="built_in">SetSpeed</span>(deltaTime);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重置颜色缓冲和深度缓冲</span></span><br><span class="line">        <span class="built_in">glClearColor</span>(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算mvp变换矩阵</span></span><br><span class="line">        glm::mat4 view = g_camera.<span class="built_in">GetLookAt</span>();</span><br><span class="line"></span><br><span class="line">        glm::mat4 projection = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">        projection = glm::<span class="built_in">perspective</span>(glm::<span class="built_in">radians</span>(g_camera.<span class="built_in">GetFov</span>()), <span class="number">800.0f</span> / <span class="number">600.0f</span>, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绘制光照立方体</span></span><br><span class="line">        lightShader.<span class="built_in">use</span>();</span><br><span class="line">        glm::mat4 light_model = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">        light_model = glm::<span class="built_in">translate</span>(light_model, lightPos);</span><br><span class="line">        light_model = glm::<span class="built_in">scale</span>(light_model, glm::<span class="built_in">vec3</span>(<span class="number">0.2f</span>));</span><br><span class="line"></span><br><span class="line">        lightShader.<span class="built_in">setMat4</span>(<span class="string">&quot;model&quot;</span>, light_model);</span><br><span class="line">        lightShader.<span class="built_in">setMat4</span>(<span class="string">&quot;view&quot;</span>, view);</span><br><span class="line">        lightShader.<span class="built_in">setMat4</span>(<span class="string">&quot;projection&quot;</span>, projection);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">glBindVertexArray</span>(lightVAO);</span><br><span class="line">        <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绘制立方体</span></span><br><span class="line">        shader.<span class="built_in">use</span>();</span><br><span class="line">        shader.<span class="built_in">setMat4</span>(<span class="string">&quot;view&quot;</span>, view);</span><br><span class="line">        shader.<span class="built_in">setMat4</span>(<span class="string">&quot;projection&quot;</span>, projection);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            glm::mat4 model = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">            model = glm::<span class="built_in">translate</span>(model, cubePositions[i]);</span><br><span class="line">            <span class="type">float</span> angle = <span class="number">20.0f</span> * i * (<span class="type">float</span>)<span class="built_in">glfwGetTime</span>();</span><br><span class="line">            model = glm::<span class="built_in">rotate</span>(model, glm::<span class="built_in">radians</span>(angle), glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">0.3f</span>, <span class="number">0.5f</span>));</span><br><span class="line">            shader.<span class="built_in">setMat4</span>(<span class="string">&quot;model&quot;</span>, model);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 交换颜色缓冲，输出显示到屏幕</span></span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">        <span class="comment">// 检查有没有触发什么事件（比如键盘输入、鼠标移动等）、更新窗口状态，并调用对应的回调函数</span></span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="二、基础光照"><a href="#二、基础光照" class="headerlink" title="二、基础光照"></a>二、基础光照</h2><h3 id="Phong-光照模型"><a href="#Phong-光照模型" class="headerlink" title="Phong-光照模型"></a>Phong-光照模型</h3><ul>
<li>三个分量组成：<ul>
<li>环境(Ambient)：<ul>
<li>即使在黑暗的情况下，世界上通常也仍然有一些光亮（月亮、远处的光）</li>
<li>用一个常量，表示基础的环境光颜色</li>
</ul>
</li>
<li>漫反射(Diffuse)：<ul>
<li>模拟光源对物体的方向性影响(Directional Impact)。</li>
<li>物体的某一部分越是正对着光源，它就会越亮。</li>
<li>影响最显著的一个分量。</li>
</ul>
</li>
<li>镜面(Specular)：<ul>
<li>模拟有光泽物体上面出现的亮点。</li>
<li>相比于物体的颜色会更倾向于光的颜色。</li>
<li>与视线和光照之间的夹角有关。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/2024/04/06/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%B8%89%EF%BC%89/image-20240405151330165.png" alt="image-20240405151330165"></p>
<h4 id="环境光照"><a href="#环境光照" class="headerlink" title="环境光照"></a>环境光照</h4><blockquote>
<p>全局照明(Global Illumination)：</p>
<ul>
<li>考虑分散的很多光源</li>
<li>考虑光在其他表面上的反射，以及对一个物体产生间接的影响</li>
</ul>
</blockquote>
<p>Phong模型里的环境光照是一种最简单的全局照明模型。</p>
<p>一种简单的定义：</p>
<ul>
<li><p>用光的颜色乘以一个很小的常量环境因子，再乘以物体的颜色</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> objectColor;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> lightColor;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> ambientStrength = <span class="number">0.1</span>;</span><br><span class="line">    <span class="type">vec3</span> ambient = ambientStrength * lightColor;</span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> result = ambient * objectColor;</span><br><span class="line">    FragColor = <span class="type">vec4</span>(result, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="/2024/04/06/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%B8%89%EF%BC%89/image-20240405155532957.png" alt="image-20240405155532957"></p>
<h4 id="漫反射光照"><a href="#漫反射光照" class="headerlink" title="漫反射光照"></a>漫反射光照</h4><p>漫反射光照使物体上与光线方向越接近的片段能从光源处获得更多的亮度。</p>
<ul>
<li>考虑 <code>光照方向</code> 和 物体<code>表面法线方向</code><ul>
<li>法向量：一个垂直于顶点表面的向量。</li>
<li>光照方向向量：作为光源的位置与片段的位置之间向量差的方向向量。</li>
</ul>
</li>
<li>使用这两个方向的<code>单位向量</code>进行点乘</li>
</ul>
<img src="/2024/04/06/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%B8%89%EF%BC%89/image-20240405155649729.png" alt="image-20240405155649729" style="zoom:80%;">

<h5 id="法向量"><a href="#法向量" class="headerlink" title="法向量"></a>法向量</h5><p><strong>顶点法向量：</strong></p>
<ul>
<li><p>在obj文件中，一般会给出一个顶点对应的法向量。</p>
</li>
<li><p>由于顶点本身并没有表面（它只是空间中一个独立的点），我们利用它周围的顶点来计算出这个顶点的表面。</p>
<ul>
<li>利用顶点与周围的顶点形成的向量，叉乘求出所在三角形面的法向量。</li>
<li>如果这个顶点同时在多个三角形上，要对各个三角形的法向量计算结果求均值。</li>
</ul>
</li>
</ul>
<p><strong>平面法向量：</strong></p>
<p>三角形平面上的点的法向量通过三角形三个顶点的法向量插值计算求出：</p>
<img src="/2024/04/06/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%B8%89%EF%BC%89/image-20240405161201710.png" alt="image-20240405161201710" style="zoom: 67%;">



<blockquote>
<ul>
<li><p>在片段着色器中：</p>
<ul>
<li><p>对光线方向和法线夹角的计算，一般都在世界空间中做的</p>
</li>
<li><p>考虑：如何将obj文件中基于模型空间的顶点法向量变换到世界空间中？</p>
<ul>
<li>法向量的变换不考虑平移，只考虑缩放和旋转变换</li>
<li>法向量没有齐次分量</li>
<li>对于出现非等比缩放的情况（会导致法向量不再垂直于表面）</li>
</ul>
</li>
</ul>
</li>
<li><p>直接说结论：</p>
<ul>
<li>需要专门定义一个<code>法线矩阵</code><ul>
<li>定义为: <code>模型矩阵</code>左上角3x3部分的逆矩阵的转置矩阵</li>
<li>（大部分的资源都会将法线矩阵定义为应用到<code>模型-观察矩阵</code>(Model-view Matrix)上的操作）</li>
</ul>
</li>
</ul>
</li>
<li><p>在顶点着色器中，我们可以使用<code>inverse</code>和<code>transpose</code>函数自己生成这个法线矩阵</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Normal = <span class="type">mat3</span>(<span class="built_in">transpose</span>(<span class="built_in">inverse</span>(model))) * aNormal;</span><br></pre></td></tr></table></figure>
</li>
<li><p>此外：</p>
<p>矩阵求逆是一项对于着色器开销很大的运算，因为它必须在场景中的每一个顶点上进行，所以应该尽可能地避免在着色器中进行求逆运算。以学习为目的的话这样做还好，但是对于一个高效的应用来说，你最好先在CPU上计算出法线矩阵，再通过uniform把它传递给着色器（就像模型矩阵一样）。</p>
</li>
</ul>
<img src="/2024/04/06/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%B8%89%EF%BC%89/image-20240405163758376.png" alt="image-20240405163758376" style="zoom: 67%;">
</blockquote>
<h5 id="漫反射光照计算"><a href="#漫反射光照计算" class="headerlink" title="漫反射光照计算"></a>漫反射光照计算</h5><ul>
<li>需要：<ul>
<li>光源位置、片段位置 来计算 光照方向</li>
<li>法向量</li>
</ul>
</li>
</ul>
<p>感觉不太对</p>
<img src="/2024/04/06/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%B8%89%EF%BC%89/image-20240405172135625.png" alt="image-20240405172135625" style="zoom:80%;">

<p>原因是顶点属性设置错了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改为</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)(<span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>)));</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">1</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>正确结果</p>
<img src="/2024/04/06/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%B8%89%EF%BC%89/image-20240405172615151.png" alt="image-20240405172615151" style="zoom:80%;">





<h4 id="镜面光照"><a href="#镜面光照" class="headerlink" title="镜面光照"></a>镜面光照</h4><ul>
<li><p>和漫反射光照一样，镜面光照也决定于光的方向向量和物体的法向量，但是它也决定于观察方向。</p>
</li>
<li><p>如何得到观察方向</p>
<ul>
<li>使用观察者(相机）的世界空间位置和片段的位置来计算</li>
</ul>
</li>
<li><p>如何计算镜面光照方向与观察方向的夹角关系</p>
<ul>
<li>根据法向量翻折入射光的方向来计算反射向量 R</li>
<li>然后我们计算反射向量与观察方向的角度差，它们之间夹角越小，镜面光的作用就越大。</li>
</ul>
</li>
<li><p>定义相关常量：</p>
<ul>
<li><p>镜面光照强度（Specular Strength） —— 0.5</p>
</li>
<li><p>反光度(Shininess) 系数 —— 32</p>
<ul>
<li>物体的反光度越高，反射光的能力越强，散射得越少，高光点就会越小。</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> specularStrength = <span class="number">0.5</span>;</span><br><span class="line"><span class="type">vec3</span> viewDir = <span class="built_in">normalize</span>(viewPos - FragPos);</span><br><span class="line"><span class="type">vec3</span> reflectDir = <span class="built_in">reflect</span>(-lightDir, norm);</span><br><span class="line"><span class="type">float</span> spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(viewDir, reflectDir), <span class="number">0.0</span>), <span class="number">32</span>);</span><br><span class="line"><span class="type">vec3</span> specular = specularStrength * spec * lightColor;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<img src="/2024/04/06/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%B8%89%EF%BC%89/image-20240405182324357.png" alt="image-20240405182324357" style="zoom:80%;">



<p>不同反光度：</p>
<img src="/2024/04/06/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%B8%89%EF%BC%89/image-20240405183551135.png" alt="image-20240405183551135" style="zoom:80%;">

<blockquote>
<p>在哪个坐标空间中计算光照？</p>
<p>我们选择在世界空间进行光照计算，但是大多数人趋向于更偏向在观察空间进行光照计算。在观察空间计算的优势是，观察者的位置总是在(0, 0, 0)，所以你已经零成本地拿到了观察者的位置。然而，若以学习为目的，我认为在世界空间中计算光照更符合直觉。如果你仍然希望在观察空间计算光照的话，你需要将所有相关的向量也用观察矩阵进行变换（不要忘记也修改法线矩阵）。</p>
</blockquote>
<h3 id="Gouraud-光照模型"><a href="#Gouraud-光照模型" class="headerlink" title="Gouraud-光照模型"></a>Gouraud-光照模型</h3><p>在顶点着色器中实现Phong冯氏光照模型。</p>
<ul>
<li>相比片段来说，顶点要少得多，光照计算频率会更低。</li>
<li>片段的颜色值是由插值顶点的光照颜色所得来的。</li>
</ul>
<p><img src="/2024/04/06/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%B8%89%EF%BC%89/image-20240405183932117.png" alt="image-20240405183932117"></p>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>结果图：</p>
<img src="/2024/04/06/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%B8%89%EF%BC%89/image-20240405184019507.png" alt="image-20240405184019507" style="zoom:80%;">

<img src="/2024/04/06/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%B8%89%EF%BC%89/image-20240405184041379.png" alt="image-20240405184041379" style="zoom:80%;">



<p>顶点着色器代码</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec3</span> aNormal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> model;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> view;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> projection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> Normal;</span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> FragPos;  </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 计算MVP变换后的顶点位置，位于投影空间中（OpenGL会完成裁剪，以及转换到归一化设备坐标，并进行视口坐标的映射）</span></span><br><span class="line">    <span class="built_in">gl_Position</span> = projection * view * model * <span class="type">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算世界空间中的顶点位置</span></span><br><span class="line">    FragPos = <span class="type">vec3</span>(model * <span class="type">vec4</span>(aPos, <span class="number">1.0</span>));</span><br><span class="line">    <span class="comment">// 计算变换到世界空间的顶点法向量</span></span><br><span class="line">    Normal = <span class="type">vec3</span>(<span class="type">mat3</span>(<span class="built_in">transpose</span>(<span class="built_in">inverse</span>(model))) * aNormal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>片段着色器代码</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> objectColor;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> lightColor;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> lightPos;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> viewPos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> Normal;</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> FragPos;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 环境光项</span></span><br><span class="line">    <span class="type">float</span> ambientStrength = <span class="number">0.1</span>;</span><br><span class="line">    <span class="type">vec3</span> ambient = ambientStrength * lightColor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 漫反射项</span></span><br><span class="line">    <span class="comment">// 计算世界坐标下的片段法向量和光照方向，并点乘得到影响值</span></span><br><span class="line">    <span class="type">vec3</span> norm = <span class="built_in">normalize</span>(Normal);</span><br><span class="line">    <span class="type">vec3</span> lightDir = <span class="built_in">normalize</span>(lightPos - FragPos);</span><br><span class="line">    <span class="type">float</span> diff = <span class="built_in">max</span>(<span class="built_in">dot</span>(norm, lightDir), <span class="number">0.0</span>); <span class="comment">// 是负数则认为是0</span></span><br><span class="line">    <span class="type">vec3</span> diffuse = diff * lightColor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 高光项</span></span><br><span class="line">    <span class="type">float</span> specularStrength = <span class="number">0.5</span>;</span><br><span class="line">    <span class="type">vec3</span> viewDir = <span class="built_in">normalize</span>(viewPos - FragPos);</span><br><span class="line">    <span class="type">vec3</span> reflectDir = <span class="built_in">reflect</span>(-lightDir, norm);</span><br><span class="line">    <span class="type">float</span> spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(viewDir, reflectDir), <span class="number">0.0</span>), <span class="number">32</span>);</span><br><span class="line">    <span class="type">vec3</span> specular = specularStrength * spec * lightColor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最终光照结果</span></span><br><span class="line">    <span class="type">vec3</span> result = (ambient + diffuse + specular) * objectColor;</span><br><span class="line"></span><br><span class="line">    FragColor = <span class="type">vec4</span>(result, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>主要代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;public.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ShaderMgr.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;camera.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;part1.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">MyCamera g_camera;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> mixValue;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">glm::vec3 cubePositions[] = &#123;</span><br><span class="line">  glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>),</span><br><span class="line">  glm::<span class="built_in">vec3</span>(<span class="number">2.0f</span>,  <span class="number">5.0f</span>, <span class="number">-15.0f</span>),</span><br><span class="line">  glm::<span class="built_in">vec3</span>(<span class="number">-1.5f</span>, <span class="number">-2.2f</span>, <span class="number">-2.5f</span>),</span><br><span class="line">  glm::<span class="built_in">vec3</span>(<span class="number">-3.8f</span>, <span class="number">-2.0f</span>, <span class="number">-12.3f</span>),</span><br><span class="line">  glm::<span class="built_in">vec3</span>(<span class="number">2.4f</span>, <span class="number">-0.4f</span>, <span class="number">-3.5f</span>),</span><br><span class="line">  glm::<span class="built_in">vec3</span>(<span class="number">-1.7f</span>,  <span class="number">3.0f</span>, <span class="number">-7.5f</span>),</span><br><span class="line">  glm::<span class="built_in">vec3</span>(<span class="number">1.3f</span>, <span class="number">-2.0f</span>, <span class="number">-2.5f</span>),</span><br><span class="line">  glm::<span class="built_in">vec3</span>(<span class="number">1.5f</span>,  <span class="number">2.0f</span>, <span class="number">-2.5f</span>),</span><br><span class="line">  glm::<span class="built_in">vec3</span>(<span class="number">1.5f</span>,  <span class="number">0.2f</span>, <span class="number">-1.5f</span>),</span><br><span class="line">  glm::<span class="built_in">vec3</span>(<span class="number">-1.3f</span>,  <span class="number">1.0f</span>, <span class="number">-1.5f</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mixValue = <span class="number">0.2f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GLFW 窗口初始化</span></span><br><span class="line">    GLFWwindow* window = <span class="built_in">init_GLFW_window</span>(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;LearnOpenGL&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (window == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to initialize GLFW&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GLAD 函数地址初始化</span></span><br><span class="line">    <span class="keyword">if</span> (GL_FALSE == <span class="built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 相机初始化</span></span><br><span class="line">    g_camera.<span class="built_in">Init</span>(glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">3.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启深度缓冲</span></span><br><span class="line">    <span class="built_in">glEnable</span>(GL_DEPTH_TEST);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 顶点缓冲设置</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> VBO;</span><br><span class="line">    <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">    <span class="comment">// 把之前定义的顶点数据复制到缓冲的内存</span></span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 灯光物体的顶点数组和属性设置</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> lightVAO;</span><br><span class="line">    <span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;lightVAO);</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(lightVAO);</span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 物体顶点数组生成</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> VAO;</span><br><span class="line">    <span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)(<span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>)));</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 光源位置</span></span><br><span class="line">    <span class="function">glm::vec3 <span class="title">lightPos</span><span class="params">(<span class="number">1.2f</span>, <span class="number">1.0f</span>, <span class="number">2.0f</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 光物体的着色器</span></span><br><span class="line">    <span class="function">Shader <span class="title">lightShader</span><span class="params">(<span class="string">&quot;./ColorVShader.glsl&quot;</span>, <span class="string">&quot;./ColorFShader_Light.glsl&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通物体的着色器</span></span><br><span class="line">    <span class="function">Shader <span class="title">shader</span><span class="params">(<span class="string">&quot;./BasicLightingVShader.glsl&quot;</span>, <span class="string">&quot;./BasicLightingFShader.glsl&quot;</span>)</span></span>;</span><br><span class="line">    shader.<span class="built_in">use</span>();</span><br><span class="line">    shader.<span class="built_in">setVec3</span>(<span class="string">&quot;objectColor&quot;</span>, glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">0.5f</span>, <span class="number">0.31f</span>));</span><br><span class="line">    shader.<span class="built_in">setVec3</span>(<span class="string">&quot;lightColor&quot;</span>, glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>));</span><br><span class="line">    shader.<span class="built_in">setVec3</span>(<span class="string">&quot;lightPos&quot;</span>, lightPos);</span><br><span class="line">    shader.<span class="built_in">setVec3</span>(<span class="string">&quot;viewPos&quot;</span>, g_camera.<span class="built_in">GetPos</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染循环</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))	<span class="comment">// 检查是否被要求退出窗口</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 输入处理</span></span><br><span class="line">        <span class="built_in">processInput</span>(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 帧渲染时间</span></span><br><span class="line">        <span class="type">float</span> deltaTime;</span><br><span class="line">        <span class="type">float</span> lastFrame = <span class="number">0</span>;</span><br><span class="line">        <span class="type">float</span> currentFrame = <span class="built_in">glfwGetTime</span>();</span><br><span class="line">        deltaTime = currentFrame - lastFrame;</span><br><span class="line">        lastFrame = currentFrame;</span><br><span class="line"></span><br><span class="line">        g_camera.<span class="built_in">SetSpeed</span>(deltaTime);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新着色器中的观察位置变量</span></span><br><span class="line">        shader.<span class="built_in">setVec3</span>(<span class="string">&quot;viewPos&quot;</span>, g_camera.<span class="built_in">GetPos</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重置颜色缓冲和深度缓冲</span></span><br><span class="line">        <span class="built_in">glClearColor</span>(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算mvp变换矩阵</span></span><br><span class="line">        glm::mat4 view = g_camera.<span class="built_in">GetLookAt</span>();</span><br><span class="line"></span><br><span class="line">        glm::mat4 projection = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">        projection = glm::<span class="built_in">perspective</span>(glm::<span class="built_in">radians</span>(g_camera.<span class="built_in">GetFov</span>()), <span class="number">800.0f</span> / <span class="number">600.0f</span>, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绘制光照立方体</span></span><br><span class="line">        lightShader.<span class="built_in">use</span>();</span><br><span class="line">        glm::mat4 light_model = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">        light_model = glm::<span class="built_in">translate</span>(light_model, lightPos);</span><br><span class="line">        light_model = glm::<span class="built_in">scale</span>(light_model, glm::<span class="built_in">vec3</span>(<span class="number">0.2f</span>));</span><br><span class="line"></span><br><span class="line">        lightShader.<span class="built_in">setMat4</span>(<span class="string">&quot;model&quot;</span>, light_model);</span><br><span class="line">        lightShader.<span class="built_in">setMat4</span>(<span class="string">&quot;view&quot;</span>, view);</span><br><span class="line">        lightShader.<span class="built_in">setMat4</span>(<span class="string">&quot;projection&quot;</span>, projection);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">glBindVertexArray</span>(lightVAO);</span><br><span class="line">        <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绘制立方体</span></span><br><span class="line">        shader.<span class="built_in">use</span>();</span><br><span class="line">        shader.<span class="built_in">setMat4</span>(<span class="string">&quot;view&quot;</span>, view);</span><br><span class="line">        shader.<span class="built_in">setMat4</span>(<span class="string">&quot;projection&quot;</span>, projection);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            glm::mat4 model = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">            model = glm::<span class="built_in">translate</span>(model, cubePositions[i]);</span><br><span class="line">            <span class="type">float</span> angle = <span class="number">20.0f</span> * i * (<span class="type">float</span>)<span class="built_in">glfwGetTime</span>();</span><br><span class="line">            model = glm::<span class="built_in">rotate</span>(model, glm::<span class="built_in">radians</span>(angle), glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">0.3f</span>, <span class="number">0.5f</span>));</span><br><span class="line">            shader.<span class="built_in">setMat4</span>(<span class="string">&quot;model&quot;</span>, model);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 交换颜色缓冲，输出显示到屏幕</span></span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">        <span class="comment">// 检查有没有触发什么事件（比如键盘输入、鼠标移动等）、更新窗口状态，并调用对应的回调函数</span></span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="三、材质"><a href="#三、材质" class="headerlink" title="三、材质"></a>三、材质</h2><p>在现实世界里，每个物体会<u>对光产生不同的反应</u>。</p>
<p>比如，钢制物体看起来通常会比陶土花瓶更闪闪发光，一个木头箱子也不会与一个钢制箱子反射同样程度的光。</p>
<p>如果我们想要在OpenGL中模拟多种类型的物体，我们必须针对<code>每种表面</code>定义不同的<code>材质(Material)属性</code>。</p>
<h3 id="材质定义"><a href="#材质定义" class="headerlink" title="材质定义"></a>材质定义</h3><h4 id="材质属性"><a href="#材质属性" class="headerlink" title="材质属性"></a>材质属性</h4><p>包含的内容：（一种定义方式）</p>
<ul>
<li><p>定义材质对颜色计算的影响因素：物体的</p>
<ul>
<li>环境色 - ambient</li>
<li>漫反射色 - diffuse</li>
<li>高光色 - specular</li>
<li>反光度 - shininess</li>
<li>相当于将原来单一物体的颜色拆分成Phong-光照模型中的多项</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">struct Material &#123;</span><br><span class="line">    <span class="type">vec3</span> ambient;</span><br><span class="line">    <span class="type">vec3</span> diffuse;</span><br><span class="line">    <span class="type">vec3</span> specular;</span><br><span class="line">    <span class="type">float</span> shininess;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> Material material;</span><br></pre></td></tr></table></figure>
</li>
<li><p>新的片段颜色计算</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;    </span><br><span class="line">    <span class="comment">// 环境光</span></span><br><span class="line">    <span class="type">vec3</span> ambient = lightColor * material.ambient;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 漫反射 </span></span><br><span class="line">    <span class="type">vec3</span> norm = <span class="built_in">normalize</span>(Normal);</span><br><span class="line">    <span class="type">vec3</span> lightDir = <span class="built_in">normalize</span>(lightPos - FragPos);</span><br><span class="line">    <span class="type">float</span> diff = <span class="built_in">max</span>(<span class="built_in">dot</span>(norm, lightDir), <span class="number">0.0</span>);</span><br><span class="line">    <span class="type">vec3</span> diffuse = lightColor * (diff * material.diffuse);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 镜面光</span></span><br><span class="line">    <span class="type">vec3</span> viewDir = <span class="built_in">normalize</span>(viewPos - FragPos);</span><br><span class="line">    <span class="type">vec3</span> reflectDir = <span class="built_in">reflect</span>(-lightDir, norm);  </span><br><span class="line">    <span class="type">float</span> spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(viewDir, reflectDir), <span class="number">0.0</span>), material.shininess);</span><br><span class="line">    <span class="type">vec3</span> specular = lightColor * (spec * material.specular);  </span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> result = ambient + diffuse + specular;</span><br><span class="line">    FragColor = <span class="type">vec4</span>(result, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>原来的片段颜色计算</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 环境光项</span></span><br><span class="line">    <span class="type">float</span> ambientStrength = <span class="number">0.1</span>;</span><br><span class="line">    <span class="type">vec3</span> ambient = ambientStrength * lightColor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 漫反射项</span></span><br><span class="line">    <span class="comment">// 计算世界坐标下的片段法向量和光照方向，并点乘得到影响值</span></span><br><span class="line">    <span class="type">vec3</span> norm = <span class="built_in">normalize</span>(Normal);</span><br><span class="line">    <span class="type">vec3</span> lightDir = <span class="built_in">normalize</span>(lightPos - FragPos);</span><br><span class="line">    <span class="type">float</span> diff = <span class="built_in">max</span>(<span class="built_in">dot</span>(norm, lightDir), <span class="number">0.0</span>); <span class="comment">// 是负数则认为是0</span></span><br><span class="line">    <span class="type">vec3</span> diffuse = diff * lightColor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 高光项</span></span><br><span class="line">    <span class="type">float</span> specularStrength = <span class="number">0.5</span>;</span><br><span class="line">    <span class="type">vec3</span> viewDir = <span class="built_in">normalize</span>(viewPos - FragPos);</span><br><span class="line">    <span class="type">vec3</span> reflectDir = <span class="built_in">reflect</span>(-lightDir, norm);</span><br><span class="line">    <span class="type">float</span> spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(viewDir, reflectDir), <span class="number">0.0</span>), <span class="number">32</span>);</span><br><span class="line">    <span class="type">vec3</span> specular = specularStrength * spec * lightColor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最终光照结果</span></span><br><span class="line">    <span class="type">vec3</span> result = (ambient + diffuse + specular) * objectColor;</span><br><span class="line"></span><br><span class="line">    FragColor = <span class="type">vec4</span>(result, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>效果：</p>
<ul>
<li>问题：亮度太高了，不真实。</li>
<li>原因：<ul>
<li>环境光、漫反射和镜面光这三个颜色对任何一个光源都全力反射。</li>
<li>没有定义各项光照的相关系数，参见上面的片段着色器代码</li>
</ul>
</li>
</ul>
<img src="/2024/04/06/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%B8%89%EF%BC%89/image-20240405204111666.png" alt="image-20240405204111666" style="zoom:80%;">



<h4 id="光照属性"><a href="#光照属性" class="headerlink" title="光照属性"></a>光照属性</h4><p>定义光源的位置和各项的影响系数</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">struct Light &#123;</span><br><span class="line">    <span class="type">vec3</span> position;</span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> ambient;</span><br><span class="line">    <span class="type">vec3</span> diffuse;</span><br><span class="line">    <span class="type">vec3</span> specular;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> Light light;</span><br></pre></td></tr></table></figure>

<ul>
<li>表示一个光源对它的ambient、diffuse和specular光照分量有着不同的强度。<ul>
<li>环境光照通常被设置为一个比较低的强度，因为我们不希望环境光颜色太过主导。</li>
<li>光源的漫反射分量通常被设置为我们希望光所具有的那个颜色，通常是一个比较明亮的白色。</li>
<li>镜面光分量通常会保持为<code>vec3(1.0)</code>，以最大强度发光。</li>
</ul>
</li>
<li>注意我们也将光源的位置向量加入了结构体。</li>
</ul>
<p>结果：</p>
<img src="/2024/04/06/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%B8%89%EF%BC%89/image-20240405205421410.png" alt="image-20240405205421410" style="zoom:80%;">







<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><p>光源颜色变化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 光照颜色随时间变化</span></span><br><span class="line">glm::vec3 lightColor;</span><br><span class="line">lightColor.x = <span class="built_in">sin</span>(<span class="built_in">glfwGetTime</span>() * <span class="number">2.0f</span>);</span><br><span class="line">lightColor.y = <span class="built_in">sin</span>(<span class="built_in">glfwGetTime</span>() * <span class="number">0.7f</span>);</span><br><span class="line">lightColor.z = <span class="built_in">sin</span>(<span class="built_in">glfwGetTime</span>() * <span class="number">1.3f</span>);</span><br><span class="line">  </span><br><span class="line">glm::vec3 diffuseColor = lightColor * glm::<span class="built_in">vec3</span>(<span class="number">0.5f</span>); <span class="comment">// 降低影响</span></span><br><span class="line">glm::vec3 ambientColor = diffuseColor * glm::<span class="built_in">vec3</span>(<span class="number">0.2f</span>); <span class="comment">// 很低的影响</span></span><br><span class="line">  </span><br><span class="line">shader.<span class="built_in">setVec3</span>(<span class="string">&quot;light.ambient&quot;</span>, ambientColor);</span><br><span class="line">shader.<span class="built_in">setVec3</span>(<span class="string">&quot;light.diffuse&quot;</span>, diffuseColor);</span><br></pre></td></tr></table></figure></li>
</ul>
<img src="/2024/04/06/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%B8%89%EF%BC%89/image-20240405210932654.png" alt="image-20240405210932654" style="zoom:80%;">





<h2 id="四、光照贴图"><a href="#四、光照贴图" class="headerlink" title="四、光照贴图"></a>四、光照贴图</h2><p>在同一个物体中，不同的部分可能有多种材质属性，相同的部分在不同的时刻也可能有多种材质属性。</p>
<p>除了材质属性，如何为一个物体的视觉输出提供更多的灵活性。</p>
<ul>
<li>引入<strong>漫反射</strong>和<strong>镜面光</strong>贴图(Map)</li>
<li>这允许我们对物体的漫反射分量（以及间接地对环境光分量，它们几乎总是一样的）和镜面光分量有着更精确的控制。</li>
</ul>
<h3 id="漫反射贴图"><a href="#漫反射贴图" class="headerlink" title="漫反射贴图"></a>漫反射贴图</h3><p>其实也就是纹理贴图：</p>
<ul>
<li>都是使用一张覆盖物体的图像，让我们能够逐片段索引其独立的颜色值。</li>
</ul>
<p>在光照场景中，通常叫做一个漫反射贴图(Diffuse Map)（3D艺术家通常都这么叫它），它是一个表现了物体所有的漫反射颜色的纹理图像。</p>
<p>纹理：</p>
 <img src="/2024/04/06/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%B8%89%EF%BC%89/image-20240405222214188.png" alt="image-20240405222214188" style="zoom: 50%;">



<p>这次将纹理信息 sampler2D 放在片段着色器的material结构体的uniform变量里，替换之前的漫反射颜色向量分量。</p>
<p>片段着色器：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line">struct Material &#123;</span><br><span class="line">    <span class="comment">// vec3 ambient;</span></span><br><span class="line">    <span class="comment">// vec3 diffuse;</span></span><br><span class="line">    <span class="comment">// 替代</span></span><br><span class="line">    <span class="type">sampler2D</span> diffuse;</span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> specular;</span><br><span class="line">    <span class="type">float</span> shininess;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">struct Light &#123;</span><br><span class="line">    <span class="type">vec3</span> position;</span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> ambient;</span><br><span class="line">    <span class="type">vec3</span> diffuse;</span><br><span class="line">    <span class="type">vec3</span> specular;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> Light light;</span><br><span class="line"><span class="keyword">uniform</span> Material material;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> viewPos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec2</span> TexCoords;</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> Normal;</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> FragPos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 环境光项</span></span><br><span class="line">    <span class="type">vec3</span> ambient = light.ambient * <span class="type">vec3</span>(<span class="built_in">texture</span>(material.diffuse, TexCoords));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 漫反射项</span></span><br><span class="line">    <span class="comment">// 计算世界坐标下的片段法向量和光照方向，并点乘得到影响值</span></span><br><span class="line">    <span class="type">vec3</span> norm = <span class="built_in">normalize</span>(Normal);</span><br><span class="line">    <span class="type">vec3</span> lightDir = <span class="built_in">normalize</span>(light.position - FragPos);</span><br><span class="line">    <span class="type">float</span> diff = <span class="built_in">max</span>(<span class="built_in">dot</span>(norm, lightDir), <span class="number">0.0</span>); <span class="comment">// 是负数则认为是0</span></span><br><span class="line">    <span class="type">vec3</span> diffuse = light.diffuse * diff * <span class="type">vec3</span>(<span class="built_in">texture</span>(material.diffuse, TexCoords));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 高光项</span></span><br><span class="line">    <span class="type">vec3</span> viewDir = <span class="built_in">normalize</span>(viewPos - FragPos);</span><br><span class="line">    <span class="type">vec3</span> reflectDir = <span class="built_in">reflect</span>(-lightDir, norm);</span><br><span class="line">    <span class="type">float</span> spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(viewDir, reflectDir), <span class="number">0.0</span>), material.shininess);</span><br><span class="line">    <span class="type">vec3</span> specular = light.specular * (spec * material.specular);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最终光照结果</span></span><br><span class="line">    <span class="type">vec3</span> result = ambient + diffuse + specular;</span><br><span class="line">    FragColor = <span class="type">vec4</span>(result, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>结果：</p>
<img src="/2024/04/06/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%B8%89%EF%BC%89/image-20240405220915532.png" alt="image-20240405220915532" style="zoom:80%;">



<h3 id="镜面光贴图"><a href="#镜面光贴图" class="headerlink" title="镜面光贴图"></a>镜面光贴图</h3><p>上面的箱子的木头部分的高光不是很真实，考虑使用镜面光贴图进行改进。</p>
<ul>
<li>我们想要让物体的某些部分以不同的强度显示镜面高光。</li>
<li>这也就意味着我们需要生成一个黑白的（如果你想得话也可以是彩色的）纹理，来定义物体每部分的镜面光强度。</li>
<li>镜面光贴图上的每个像素都可以由一个颜色向量来表示，比如说黑色代表颜色向量<code>vec3(0.0)</code>，灰色代表颜色向量<code>vec3(0.5)</code>。</li>
</ul>
 <img src="/2024/04/06/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%B8%89%EF%BC%89/image-20240405222316977.png" alt="image-20240405222316977" style="zoom:50%;">

<p>片段着色器：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line">struct Material &#123;</span><br><span class="line">    <span class="comment">// vec3 ambient;</span></span><br><span class="line">    <span class="comment">// vec3 diffuse;</span></span><br><span class="line">    <span class="comment">// vec3 specular;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">sampler2D</span> diffuse;</span><br><span class="line">    <span class="type">sampler2D</span> specular;</span><br><span class="line">    <span class="type">float</span> shininess;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">struct Light &#123;</span><br><span class="line">    <span class="type">vec3</span> position;</span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> ambient;</span><br><span class="line">    <span class="type">vec3</span> diffuse;</span><br><span class="line">    <span class="type">vec3</span> specular;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> Light light;</span><br><span class="line"><span class="keyword">uniform</span> Material material;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> viewPos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec2</span> TexCoords;</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> Normal;</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> FragPos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 环境光项</span></span><br><span class="line">    <span class="type">vec3</span> ambient  = light.ambient  * <span class="type">vec3</span>(<span class="built_in">texture</span>(material.diffuse, TexCoords));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 漫反射项</span></span><br><span class="line">    <span class="comment">// 计算世界坐标下的片段法向量和光照方向，并点乘得到影响值</span></span><br><span class="line">    <span class="type">vec3</span> norm = <span class="built_in">normalize</span>(Normal);</span><br><span class="line">    <span class="type">vec3</span> lightDir = <span class="built_in">normalize</span>(light.position - FragPos);</span><br><span class="line">    <span class="type">float</span> diff = <span class="built_in">max</span>(<span class="built_in">dot</span>(norm, lightDir), <span class="number">0.0</span>); <span class="comment">// 是负数则认为是0</span></span><br><span class="line">    <span class="type">vec3</span> diffuse  = light.diffuse  * diff * <span class="type">vec3</span>(<span class="built_in">texture</span>(material.diffuse, TexCoords));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 高光项</span></span><br><span class="line">    <span class="type">vec3</span> viewDir = <span class="built_in">normalize</span>(viewPos - FragPos);</span><br><span class="line">    <span class="type">vec3</span> reflectDir = <span class="built_in">reflect</span>(-lightDir, norm);</span><br><span class="line">    <span class="type">float</span> spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(viewDir, reflectDir), <span class="number">0.0</span>), material.shininess);</span><br><span class="line">    <span class="type">vec3</span> specular = light.specular * spec * <span class="type">vec3</span>(<span class="built_in">texture</span>(material.specular, TexCoords));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最终光照结果</span></span><br><span class="line">    <span class="type">vec3</span> result = ambient + diffuse + specular;</span><br><span class="line">    FragColor = <span class="type">vec4</span>(result, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>结果：</p>
<img src="/2024/04/06/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%B8%89%EF%BC%89/image-20240405225134498.png" alt="image-20240405225134498" style="zoom:80%;">



<p>镜面光贴图能够在漫反射贴图之上给予我们更高一层的控制。</p>
<p>比如物体的哪些部分需要有<strong>闪闪发光</strong>的属性，我们甚至可以设置它们对应的强度。</p>
<blockquote>
<p>如果你想另辟蹊径，你也可以在镜面光贴图中使用真正的颜色，不仅设置每个片段的镜面光强度，还设置了镜面高光的颜色。</p>
<p>从现实角度来说，镜面高光的颜色大部分（甚至全部）都是由光源本身所决定的，所以这样并不能生成非常真实的视觉效果（这也是为什么高光贴图的图像通常是黑白的，我们只关心强度）。</p>
</blockquote>
<blockquote>
<p>此外还有法线贴图和反射贴图等，用法不一样。</p>
</blockquote>
<h2 id="五、投光物"><a href="#五、投光物" class="headerlink" title="五、投光物"></a>五、投光物</h2><h3 id="平行光"><a href="#平行光" class="headerlink" title="平行光"></a>平行光</h3><p>当一个光源处于很远的地方时，来自光源的每条光线就会近似于互相平行。</p>
<ul>
<li>比如太阳光</li>
</ul>
<img src="/2024/04/06/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%B8%89%EF%BC%89/image-20240405233716747.png" alt="image-20240405233716747" style="zoom: 67%;">



<p>替代之前光照信息中的位置向量，直接给出光照的方向向量</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">struct Light &#123;</span><br><span class="line">    <span class="comment">// vec3 position; // 使用定向光就不再需要了</span></span><br><span class="line">    <span class="type">vec3</span> direction;</span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> ambient;</span><br><span class="line">    <span class="type">vec3</span> diffuse;</span><br><span class="line">    <span class="type">vec3</span> specular;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 我们目前使用的光照计算需求一个从片段至光源的光线方向，但人们更习惯定义定向光为一个从光源出发的全局方向，所以需要取反</span></span><br><span class="line">  <span class="type">vec3</span> lightDir = <span class="built_in">normalize</span>(-light.direction);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<img src="/2024/04/06/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%B8%89%EF%BC%89/image-20240405234521244.png" alt="image-20240405234521244" style="zoom:67%;">



<p>使用一个vec4表示光照的位置向量和方向向量</p>
<ul>
<li>根据w分量为 0 还是 1（表示位置还是方向）</li>
<li>可以区分用哪种方式计算光照</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(lightVector.w == 0.0) // 注意浮点数据类型的误差</span><br><span class="line">  // 执行定向光照计算</span><br><span class="line">else if(lightVector.w == 1.0)</span><br><span class="line">  // 根据光源的位置做光照计算（与上一节一样）</span><br></pre></td></tr></table></figure>



<h3 id="点光源"><a href="#点光源" class="headerlink" title="点光源"></a>点光源</h3><p>定向光对于照亮整个场景的全局光源是非常棒的，但除了定向光之外我们也需要一些分散在场景中的点光源(Point Light)。</p>
<ul>
<li>点光源是处于世界中某一个位置的光源，它会朝着所有方向发光。</li>
<li>但光线会随着距离逐渐衰减。（之前的简单案例都是不考虑衰减的）</li>
<li>比如：灯泡和火把</li>
</ul>
<img src="/2024/04/06/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%B8%89%EF%BC%89/image-20240405235005437.png" alt="image-20240405235005437" style="zoom: 67%;">



<h4 id="衰减-Attenuation"><a href="#衰减-Attenuation" class="headerlink" title="衰减(Attenuation)"></a>衰减(Attenuation)</h4><p>在现实世界中，灯在近处通常会非常亮，但随着距离的增加光源的亮度一开始会下降非常快，但在远处时剩余的光强度就会下降的非常缓慢了。</p>
<h5 id="公式："><a href="#公式：" class="headerlink" title="公式："></a>公式：</h5> <img src="/2024/04/06/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%B8%89%EF%BC%89/image-20240405235445197.png" alt="image-20240405235445197" style="zoom:80%;">

<ul>
<li><p><code>d</code> 代表了片段距光源的距离。</p>
</li>
<li><p>系数：常数项<code>Kc</code>、一次项 <code>Kl</code> 和二次项 <code>Kq</code> 。</p>
<ul>
<li><p>常数项通常保持为1.0，它的主要作用是保证分母永远不会比1小，否则的话在某些距离上它反而会增加强度，这肯定不是我们想要的效果。</p>
</li>
<li><p>一次项会与距离值相乘，以线性的方式减少强度。</p>
</li>
<li><p>二次项会与距离的平方相乘，让光源以二次递减的方式减少强度。</p>
<ul>
<li>二次项在距离比较小的时候影响会比一次项小很多</li>
<li>但当距离值比较大的时候它就会比一次项更大了</li>
</ul>
</li>
</ul>
</li>
<li><p>由于二次项的存在，光线会在大部分时候以线性的方式衰退，直到距离变得足够大，让二次项超过一次项，光的强度会以更快的速度下降。</p>
</li>
<li><p>以达到这样的效果：光在近距离时亮度很高，但随着距离变远亮度迅速降低，最后会以更慢的速度减少亮度。</p>
</li>
</ul>
<img src="/2024/04/06/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%B8%89%EF%BC%89/image-20240405235822137.png" alt="image-20240405235822137" style="zoom:67%;">



<h5 id="系数的选择："><a href="#系数的选择：" class="headerlink" title="系数的选择："></a>系数的选择：</h5><ul>
<li>第一列指定的是光所能覆盖的距离。</li>
</ul>
<img src="/2024/04/06/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%B8%89%EF%BC%89/image-20240405235944719.png" alt="image-20240405235944719" style="zoom: 67%;">



<h5 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h5><p>在片段着色器的光照信息中，除了有光照的位置向量，还要加入三个系数，然后以上面的公式计算</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">struct Light &#123;</span><br><span class="line">    <span class="type">vec3</span> position;  </span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> ambient;</span><br><span class="line">    <span class="type">vec3</span> diffuse;</span><br><span class="line">    <span class="type">vec3</span> specular;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> constant;</span><br><span class="line">    <span class="type">float</span> linear;</span><br><span class="line">    <span class="type">float</span> quadratic;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>计算距离和衰减率</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 片段和光源的距离</span></span><br><span class="line"><span class="type">float</span> <span class="built_in">distance</span>    = <span class="built_in">length</span>(light.position - FragPos);</span><br><span class="line"><span class="comment">// 衰减率</span></span><br><span class="line"><span class="type">float</span> attenuation = <span class="number">1.0</span> / (light.constant + light.linear * <span class="built_in">distance</span> + light.quadratic * (<span class="built_in">distance</span> * <span class="built_in">distance</span>));</span><br><span class="line"></span><br><span class="line">ambient  *= attenuation; </span><br><span class="line">diffuse  *= attenuation;</span><br><span class="line">specular *= attenuation;</span><br></pre></td></tr></table></figure>



<p>结果：</p>
<p><img src="/2024/04/06/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%B8%89%EF%BC%89/image-20240406004925849.png" alt="image-20240406004925849"></p>
<p>点光源就是一个能够配置位置和衰减的光源。它是我们光照工具箱中的又一个光照类型。</p>
<h3 id="聚光灯"><a href="#聚光灯" class="headerlink" title="聚光灯"></a>聚光灯</h3><p>聚光(Spotlight)是位于环境中某个位置的光源，它只朝一个特定方向而不是所有方向照射光线。</p>
<ul>
<li>只有在聚光方向的特定半径内的物体才会被照亮，其它的物体都会保持黑暗。</li>
<li>比如路灯或手电筒。</li>
</ul>
<p>OpenGL中聚光的表示:</p>
<ul>
<li>一个世界空间位置</li>
<li>一个方向</li>
<li>一个切光角(Cutoff Angle)</li>
</ul>
<p>对于每个片段，我们会计算片段是否位于聚光的切光方向之间（也就是在锥形内），如果是的话，我们就会相应地照亮片段。</p>
<img src="/2024/04/06/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%B8%89%EF%BC%89/image-20240406005025127.png" alt="image-20240406005025127" style="zoom:80%;">

<ul>
<li><code>LightDir</code>：从片段指向光源的向量。</li>
<li><code>SpotDir</code>：聚光所指向的方向。</li>
<li><code>Phi</code>ϕ：指定了聚光半径（圆锥底部半径）的切光角。落在这个角度之外的物体都不会被这个聚光所照亮。</li>
<li><code>Theta</code>θ：LightDir向量和SpotDir向量之间的夹角。在聚光内部的话θ值应该比ϕ值小。</li>
</ul>
<p>所以我们要做的就是计算LightDir向量和SpotDir向量之间的点积，并将它与切光角ϕ值对比。</p>
<h4 id="手电筒"><a href="#手电筒" class="headerlink" title="手电筒"></a>手电筒</h4><p>手电筒(Flashlight)是一个位于观察者位置的聚光。其位置和方向会随着玩家的位置和朝向不断更新，而切光角一般是固定的。</p>
<ul>
<li>着色器中的光照信息</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">struct Light &#123;</span><br><span class="line">    <span class="type">vec3</span>  position;</span><br><span class="line">    <span class="type">vec3</span>  direction;</span><br><span class="line">    <span class="type">float</span> cutOff;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>计算</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> theta = <span class="built_in">dot</span>(lightDir, <span class="built_in">normalize</span>(-light.direction));</span><br><span class="line"><span class="comment">// 90°以内，余弦值越大，角度越小</span></span><br><span class="line"><span class="keyword">if</span>(theta &gt; light.cutOff) </span><br><span class="line">&#123;       </span><br><span class="line">  <span class="comment">// 执行光照计算</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>  <span class="comment">// 否则，使用环境光，让场景在聚光之外时不至于完全黑暗</span></span><br><span class="line">  color = <span class="type">vec4</span>(light.ambient * <span class="type">vec3</span>(<span class="built_in">texture</span>(material.diffuse, TexCoords)), <span class="number">1.0</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>传入的数据（在外部直接计算余弦值，而不是在着色器中计算）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">lightingShader.<span class="built_in">setVec3</span>(<span class="string">&quot;light.position&quot;</span>,  camera.Position);</span><br><span class="line">lightingShader.<span class="built_in">setVec3</span>(<span class="string">&quot;light.direction&quot;</span>, camera.Front);</span><br><span class="line">lightingShader.<span class="built_in">setFloat</span>(<span class="string">&quot;light.cutOff&quot;</span>,   glm::<span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(<span class="number">12.5f</span>)));</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="/2024/04/06/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%B8%89%EF%BC%89/image-20240406013344365.png" alt="image-20240406013344365"></p>
<h4 id="平滑-x2F-软化边缘"><a href="#平滑-x2F-软化边缘" class="headerlink" title="平滑&#x2F;软化边缘"></a>平滑&#x2F;软化边缘</h4><p>为了创建一种看起来边缘平滑的聚光，我们需要模拟聚光有一个内圆锥(Inner Cone)和一个外圆锥(Outer Cone)。</p>
<ul>
<li>内圆锥设置为上一部分中的那个圆锥<ul>
<li>片段在内圆锥之内，它的强度就是1.0</li>
</ul>
</li>
<li>增加一个外圆锥，光从内圆锥逐渐减暗，直到外圆锥的边界<ul>
<li>再定义一个余弦值来代表聚光方向向量和外圆锥向量（等于它的半径）的夹角。</li>
<li>如果一个片段处于内外圆锥之间，将会给它计算出一个0.0到1.0之间的强度值。</li>
</ul>
</li>
</ul>
<p><strong>公式</strong>：</p>
<p> <img src="/2024/04/06/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%B8%89%EF%BC%89/image-20240406013847202.png" alt="image-20240406013847202"></p>
<p>这里ϵ(Epsilon)是内（ϕ）和外圆锥（γ）之间的余弦值差（ϵ&#x3D;ϕ−γ）。最终的I值就是在当前片段聚光的强度。</p>
<ul>
<li>θ就是片段与聚光方向的夹角余弦值</li>
</ul>
<p><strong>参考值</strong>：</p>
<p><img src="/2024/04/06/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%B8%89%EF%BC%89/image-20240406014434836.png" alt="image-20240406014434836"></p>
<ul>
<li>基本是在内外余弦值之间根据θ插值</li>
<li>在聚光外是负的，在内圆锥内大于1.0的，在边缘处于0-1之间</li>
</ul>
<p>片段着色器</p>
<ul>
<li>clamp函数，它把第一个参数约束(Clamp)在了0.0到1.0之间。</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> theta     = <span class="built_in">dot</span>(lightDir, <span class="built_in">normalize</span>(-light.direction));</span><br><span class="line"><span class="type">float</span> epsilon   = light.cutOff - light.outerCutOff;</span><br><span class="line"><span class="type">float</span> intensity = <span class="built_in">clamp</span>((theta - light.outerCutOff) / epsilon, <span class="number">0.0</span>, <span class="number">1.0</span>);    </span><br><span class="line">...</span><br><span class="line"><span class="comment">// 将不对环境光做出影响，让它总是能有一点光</span></span><br><span class="line">diffuse  *= intensity;</span><br><span class="line">specular *= intensity;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="/2024/04/06/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%B8%89%EF%BC%89/image-20240406015833314.png" alt="image-20240406015833314"></p>
<h2 id="六、多光源"><a href="#六、多光源" class="headerlink" title="六、多光源"></a>六、多光源</h2><p>目标：</p>
<ul>
<li>创建一个包含六个光源的场景。我们将模拟一个类似太阳的定向光(Directional Light)光源，四个分散在场景中的点光源(Point Light)，以及一个手电筒(Flashlight)。</li>
</ul>
<p>将光照计算封装到GLSL函数中</p>
<ul>
<li>GLSL中的函数和C函数很相似，它有一个函数名、一个返回值类型</li>
<li>如果函数不是在main函数之前声明的，我们还必须在代码文件顶部声明一个原型</li>
<li>我们对每个光照类型都创建一个不同的函数：定向光、点光源和聚光。</li>
</ul>
<p>在场景中使用多个光源时的实现思路：</p>
<ul>
<li><p>有一个单独的颜色向量代表片段的输出颜色</p>
</li>
<li><p>对于每一个光源，它对片段的贡献颜色将会加到片段的输出颜色向量上</p>
</li>
<li><p>大体结构：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 定义一个输出颜色值</span></span><br><span class="line">  <span class="type">vec3</span> output;</span><br><span class="line">  <span class="comment">// 将定向光的贡献加到输出中</span></span><br><span class="line">  output += someFunctionToCalculateDirectionalLight();</span><br><span class="line">  <span class="comment">// 对所有的点光源也做相同的事情</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nr_of_point_lights; i++)</span><br><span class="line">    output += someFunctionToCalculatePointLight();</span><br><span class="line">  <span class="comment">// 也加上其它的光源（比如聚光）</span></span><br><span class="line">  output += someFunctionToCalculateSpotLight();</span><br><span class="line"></span><br><span class="line">  FragColor = <span class="type">vec4</span>(output, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>给着色器中的uniform数组元素设值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">lightingShader.<span class="built_in">setFloat</span>(<span class="string">&quot;pointLights[0].constant&quot;</span>, <span class="number">1.0f</span>);</span><br></pre></td></tr></table></figure>



<p>结果：</p>
<p><img src="/2024/04/06/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%B8%89%EF%BC%89/image-20240406025406054.png" alt="image-20240406025406054"></p>
<p>片段着色器</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="meta">#define NR_POINT_LIGHTS 4</span></span><br><span class="line"></span><br><span class="line">struct Material &#123;</span><br><span class="line">    <span class="comment">// vec3 ambient;</span></span><br><span class="line">    <span class="comment">// vec3 diffuse;</span></span><br><span class="line">    <span class="comment">// vec3 specular;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">sampler2D</span> diffuse;</span><br><span class="line">    <span class="type">sampler2D</span> specular;</span><br><span class="line">    <span class="type">float</span> shininess;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 定向光</span></span><br><span class="line">struct DirLight &#123;</span><br><span class="line">    <span class="type">vec3</span> direction;</span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> ambient;</span><br><span class="line">    <span class="type">vec3</span> diffuse;</span><br><span class="line">    <span class="type">vec3</span> specular;</span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 点光源</span></span><br><span class="line">struct PointLight &#123;</span><br><span class="line">    <span class="type">vec3</span> position;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> constant;</span><br><span class="line">    <span class="type">float</span> linear;</span><br><span class="line">    <span class="type">float</span> quadratic;</span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> ambient;</span><br><span class="line">    <span class="type">vec3</span> diffuse;</span><br><span class="line">    <span class="type">vec3</span> specular;</span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 聚光灯</span></span><br><span class="line">struct SpotLight &#123;</span><br><span class="line">    <span class="type">vec3</span> position;    </span><br><span class="line">    <span class="type">vec3</span> direction;</span><br><span class="line">    <span class="type">float</span> cutOff;</span><br><span class="line">    <span class="type">float</span> outerCutOff;</span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> ambient;</span><br><span class="line">    <span class="type">vec3</span> diffuse;</span><br><span class="line">    <span class="type">vec3</span> specular;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> constant;</span><br><span class="line">    <span class="type">float</span> linear;</span><br><span class="line">    <span class="type">float</span> quadratic;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> DirLight dirLight;</span><br><span class="line"><span class="keyword">uniform</span> PointLight pointLights[NR_POINT_LIGHTS];</span><br><span class="line"><span class="keyword">uniform</span> SpotLight spotLight;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> Material material;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> viewPos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec2</span> TexCoords;</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> Normal;</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> FragPos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="type">vec3</span> CalcDirLight(DirLight light, <span class="type">vec3</span> normal, <span class="type">vec3</span> viewDir);</span><br><span class="line"><span class="type">vec3</span> CalcPointLight(PointLight light, <span class="type">vec3</span> normal, <span class="type">vec3</span> fragPos, <span class="type">vec3</span> viewDir);</span><br><span class="line"><span class="type">vec3</span> CalcSpotLight(SpotLight light, <span class="type">vec3</span> norm, <span class="type">vec3</span> FragPos, <span class="type">vec3</span> viewDir);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="type">vec3</span> norm = <span class="built_in">normalize</span>(Normal);</span><br><span class="line">    <span class="type">vec3</span> viewDir = <span class="built_in">normalize</span>(viewPos - FragPos);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一阶段：定向光照</span></span><br><span class="line">    <span class="type">vec3</span> result = CalcDirLight(dirLight, norm, viewDir);</span><br><span class="line">    <span class="comment">// 第二阶段：点光源</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; NR_POINT_LIGHTS; i++)</span><br><span class="line">        result += CalcPointLight(pointLights[i], norm, FragPos, viewDir);    </span><br><span class="line">    <span class="comment">// 第三阶段：聚光</span></span><br><span class="line">    result += CalcSpotLight(spotLight, norm, FragPos, viewDir);    </span><br><span class="line"></span><br><span class="line">    FragColor = <span class="type">vec4</span>(result, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">vec3</span> CalcDirLight(DirLight light, <span class="type">vec3</span> normal, <span class="type">vec3</span> viewDir)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec3</span> lightDir = <span class="built_in">normalize</span>(-light.direction);</span><br><span class="line">    <span class="comment">// 漫反射着色</span></span><br><span class="line">    <span class="type">float</span> diff = <span class="built_in">max</span>(<span class="built_in">dot</span>(normal, lightDir), <span class="number">0.0</span>);</span><br><span class="line">    <span class="comment">// 镜面光着色</span></span><br><span class="line">    <span class="type">vec3</span> reflectDir = <span class="built_in">reflect</span>(-lightDir, normal);</span><br><span class="line">    <span class="type">float</span> spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(viewDir, reflectDir), <span class="number">0.0</span>), material.shininess);</span><br><span class="line">    <span class="comment">// 合并结果</span></span><br><span class="line">    <span class="type">vec3</span> ambient  = light.ambient  * <span class="type">vec3</span>(<span class="built_in">texture</span>(material.diffuse, TexCoords));</span><br><span class="line">    <span class="type">vec3</span> diffuse  = light.diffuse  * diff * <span class="type">vec3</span>(<span class="built_in">texture</span>(material.diffuse, TexCoords));</span><br><span class="line">    <span class="type">vec3</span> specular = light.specular * spec * <span class="type">vec3</span>(<span class="built_in">texture</span>(material.specular, TexCoords));</span><br><span class="line">    <span class="keyword">return</span> (ambient + diffuse + specular);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">vec3</span> CalcPointLight(PointLight light, <span class="type">vec3</span> normal, <span class="type">vec3</span> fragPos, <span class="type">vec3</span> viewDir)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec3</span> lightDir = <span class="built_in">normalize</span>(light.position - fragPos);</span><br><span class="line">    <span class="comment">// 漫反射着色</span></span><br><span class="line">    <span class="type">float</span> diff = <span class="built_in">max</span>(<span class="built_in">dot</span>(normal, lightDir), <span class="number">0.0</span>);</span><br><span class="line">    <span class="comment">// 镜面光着色</span></span><br><span class="line">    <span class="type">vec3</span> reflectDir = <span class="built_in">reflect</span>(-lightDir, normal);</span><br><span class="line">    <span class="type">float</span> spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(viewDir, reflectDir), <span class="number">0.0</span>), material.shininess);</span><br><span class="line">    <span class="comment">// 衰减</span></span><br><span class="line">    <span class="type">float</span> <span class="built_in">distance</span>    = <span class="built_in">length</span>(light.position - fragPos);</span><br><span class="line">    <span class="type">float</span> attenuation = <span class="number">1.0</span> / (light.constant + light.linear * <span class="built_in">distance</span> + </span><br><span class="line">                 light.quadratic * (<span class="built_in">distance</span> * <span class="built_in">distance</span>));    </span><br><span class="line">    <span class="comment">// 合并结果</span></span><br><span class="line">    <span class="type">vec3</span> ambient  = light.ambient  * <span class="type">vec3</span>(<span class="built_in">texture</span>(material.diffuse, TexCoords));</span><br><span class="line">    <span class="type">vec3</span> diffuse  = light.diffuse  * diff * <span class="type">vec3</span>(<span class="built_in">texture</span>(material.diffuse, TexCoords));</span><br><span class="line">    <span class="type">vec3</span> specular = light.specular * spec * <span class="type">vec3</span>(<span class="built_in">texture</span>(material.specular, TexCoords));</span><br><span class="line">    ambient  *= attenuation;</span><br><span class="line">    diffuse  *= attenuation;</span><br><span class="line">    specular *= attenuation;</span><br><span class="line">    <span class="keyword">return</span> (ambient + diffuse + specular);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">vec3</span> CalcSpotLight(SpotLight light, <span class="type">vec3</span> norm, <span class="type">vec3</span> FragPos, <span class="type">vec3</span> viewDir) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec3</span> lightDir = <span class="built_in">normalize</span>(light.position - FragPos);</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> theta     = <span class="built_in">dot</span>(lightDir, <span class="built_in">normalize</span>(-light.direction));</span><br><span class="line">    <span class="type">float</span> epsilon   = light.cutOff - light.outerCutOff;</span><br><span class="line">    <span class="type">float</span> intensity = <span class="built_in">clamp</span>((theta - light.outerCutOff) / epsilon, <span class="number">0.0</span>, <span class="number">1.0</span>); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 90°以内，余弦值越大，角度越小</span></span><br><span class="line">    <span class="comment">// 环境光项</span></span><br><span class="line">    <span class="type">vec3</span> ambient  = light.ambient  * <span class="type">vec3</span>(<span class="built_in">texture</span>(material.diffuse, TexCoords));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 漫反射项</span></span><br><span class="line">    <span class="comment">// 计算世界坐标下的片段法向量和光照方向，并点乘得到影响值</span></span><br><span class="line">    <span class="type">float</span> diff = <span class="built_in">max</span>(<span class="built_in">dot</span>(norm, lightDir), <span class="number">0.0</span>); <span class="comment">// 是负数则认为是0</span></span><br><span class="line">    <span class="type">vec3</span> diffuse  = light.diffuse  * diff * <span class="type">vec3</span>(<span class="built_in">texture</span>(material.diffuse, TexCoords));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 高光项</span></span><br><span class="line">    <span class="type">vec3</span> reflectDir = <span class="built_in">reflect</span>(-lightDir, norm);</span><br><span class="line">    <span class="type">float</span> spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(viewDir, reflectDir), <span class="number">0.0</span>), material.shininess);</span><br><span class="line">    <span class="type">vec3</span> specular = light.specular * spec * (<span class="type">vec3</span>(<span class="built_in">texture</span>(material.specular, TexCoords)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 片段和光源的距离</span></span><br><span class="line">    <span class="type">float</span> <span class="built_in">distance</span>    = <span class="built_in">length</span>(light.position - FragPos);</span><br><span class="line">    <span class="comment">// 衰减率</span></span><br><span class="line">    <span class="type">float</span> attenuation = <span class="number">1.0</span> / (light.constant + light.linear * <span class="built_in">distance</span> + </span><br><span class="line">                    light.quadratic * (<span class="built_in">distance</span> * <span class="built_in">distance</span>));</span><br><span class="line"></span><br><span class="line">    ambient  *= attenuation;  <span class="comment">// 聚光灯不对环境光做出影响，让它总是能有一点光</span></span><br><span class="line">    diffuse  *= attenuation * intensity;</span><br><span class="line">    specular *= attenuation * intensity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最终光照结果</span></span><br><span class="line">    <span class="keyword">return</span> (ambient + diffuse + specular);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>主要代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;public.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ShaderMgr.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;camera.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;part1.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line">MyCamera g_camera;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> mixValue;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="comment">// positions          // normals           // texture coords</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">glm::vec3 cubePositions[] = &#123;</span><br><span class="line">  glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>),</span><br><span class="line">  glm::<span class="built_in">vec3</span>(<span class="number">2.0f</span>,  <span class="number">5.0f</span>, <span class="number">-15.0f</span>),</span><br><span class="line">  glm::<span class="built_in">vec3</span>(<span class="number">-1.5f</span>, <span class="number">-2.2f</span>, <span class="number">-2.5f</span>),</span><br><span class="line">  glm::<span class="built_in">vec3</span>(<span class="number">-3.8f</span>, <span class="number">-2.0f</span>, <span class="number">-12.3f</span>),</span><br><span class="line">  glm::<span class="built_in">vec3</span>(<span class="number">2.4f</span>, <span class="number">-0.4f</span>, <span class="number">-3.5f</span>),</span><br><span class="line">  glm::<span class="built_in">vec3</span>(<span class="number">-1.7f</span>,  <span class="number">3.0f</span>, <span class="number">-7.5f</span>),</span><br><span class="line">  glm::<span class="built_in">vec3</span>(<span class="number">1.3f</span>, <span class="number">-2.0f</span>, <span class="number">-2.5f</span>),</span><br><span class="line">  glm::<span class="built_in">vec3</span>(<span class="number">1.5f</span>,  <span class="number">2.0f</span>, <span class="number">-2.5f</span>),</span><br><span class="line">  glm::<span class="built_in">vec3</span>(<span class="number">1.5f</span>,  <span class="number">0.2f</span>, <span class="number">-1.5f</span>),</span><br><span class="line">  glm::<span class="built_in">vec3</span>(<span class="number">-1.3f</span>,  <span class="number">1.0f</span>, <span class="number">-1.5f</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mixValue = <span class="number">0.2f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GLFW 窗口初始化</span></span><br><span class="line">    GLFWwindow* window = <span class="built_in">init_GLFW_window</span>(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;LearnOpenGL&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (window == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to initialize GLFW&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GLAD 函数地址初始化</span></span><br><span class="line">    <span class="keyword">if</span> (GL_FALSE == <span class="built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 相机初始化</span></span><br><span class="line">    g_camera.<span class="built_in">Init</span>(glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">3.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启深度缓冲</span></span><br><span class="line">    <span class="built_in">glEnable</span>(GL_DEPTH_TEST);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 顶点缓冲设置</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> VBO;</span><br><span class="line">    <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">    <span class="comment">// 把之前定义的顶点数据复制到缓冲的内存</span></span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 灯光物体的顶点数组和属性设置</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> lightVAO;</span><br><span class="line">    <span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;lightVAO);</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(lightVAO);</span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">8</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 物体顶点数组生成</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> VAO;</span><br><span class="line">    <span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">8</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">8</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)(<span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>)));</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">2</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">8</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)(<span class="number">6</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>)));</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成和绑定纹理对象，并载入纹理数据</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> texture1;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* data1 = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">int</span> width1, height1, nrChannels1;</span><br><span class="line">    texture1 = <span class="built_in">GenAndLoadTexture</span>(<span class="string">&quot;resource/container2.png&quot;</span>, &amp;width1, &amp;height1, &amp;nrChannels1, data1, GL_RGBA);</span><br><span class="line">    <span class="keyword">if</span> (texture1 == <span class="number">-1</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;load texture failed1\n&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stbi_image_free</span>(data1);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> texture2;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* data2 = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">int</span> width2, height2, nrChannels2;</span><br><span class="line">    texture2 = <span class="built_in">GenAndLoadTexture</span>(<span class="string">&quot;resource/container2_specular.png&quot;</span>, &amp;width2, &amp;height2, &amp;nrChannels2, data2, GL_RGBA);</span><br><span class="line">    <span class="keyword">if</span> (texture2 == <span class="number">-1</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;load texture failed2\n&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stbi_image_free</span>(data2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 激活纹理单元并绑定两个纹理对象到对应的纹理单元</span></span><br><span class="line">    <span class="built_in">glActiveTexture</span>(GL_TEXTURE0);</span><br><span class="line">    <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glActiveTexture</span>(GL_TEXTURE1);</span><br><span class="line">    <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 光源位置</span></span><br><span class="line">    <span class="function">glm::vec3 <span class="title">dirLightPos</span><span class="params">(<span class="number">1.2f</span>, <span class="number">1.0f</span>, <span class="number">2.0f</span>)</span></span>;</span><br><span class="line">    glm::vec3 pointLightPositions[] = &#123;</span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">0.7f</span>,  <span class="number">0.2f</span>,  <span class="number">2.0f</span>),</span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">2.3f</span>, <span class="number">-3.3f</span>, <span class="number">-4.0f</span>),</span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">-4.0f</span>,  <span class="number">2.0f</span>, <span class="number">-12.0f</span>),</span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">-3.0f</span>)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 光物体的着色器</span></span><br><span class="line">    <span class="function">Shader <span class="title">lightShader</span><span class="params">(<span class="string">&quot;./ColorVShader.glsl&quot;</span>, <span class="string">&quot;./MaterialFShader_Light.glsl&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通物体的着色器</span></span><br><span class="line">    <span class="function">Shader <span class="title">shader</span><span class="params">(<span class="string">&quot;./MultiLightVShader.glsl&quot;</span>, <span class="string">&quot;./MultiLightFShader.glsl&quot;</span>)</span></span>;</span><br><span class="line">    shader.<span class="built_in">use</span>();</span><br><span class="line">    shader.<span class="built_in">setVec3</span>(<span class="string">&quot;viewPos&quot;</span>, g_camera.<span class="built_in">GetPos</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 物体材质属性</span></span><br><span class="line">    shader.<span class="built_in">setInt</span>(<span class="string">&quot;material.diffuse&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    shader.<span class="built_in">setInt</span>(<span class="string">&quot;material.specular&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    shader.<span class="built_in">setFloat</span>(<span class="string">&quot;material.shininess&quot;</span>, <span class="number">32.0f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 光照属性</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 平行光</span></span><br><span class="line">    shader.<span class="built_in">setVec3</span>(<span class="string">&quot;dirLight.ambient&quot;</span>, glm::<span class="built_in">vec3</span>(<span class="number">0.2f</span>, <span class="number">0.2f</span>, <span class="number">0.2f</span>));</span><br><span class="line">    shader.<span class="built_in">setVec3</span>(<span class="string">&quot;dirLight.diffuse&quot;</span>, glm::<span class="built_in">vec3</span>(<span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.5f</span>)); <span class="comment">// 将光照调暗了一些以搭配场景</span></span><br><span class="line">    shader.<span class="built_in">setVec3</span>(<span class="string">&quot;dirLight.specular&quot;</span>, glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>));</span><br><span class="line">    shader.<span class="built_in">setVec3</span>(<span class="string">&quot;dirLight.direction&quot;</span>, glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>));</span><br><span class="line">    <span class="comment">// 点光源</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        std::string name = <span class="string">&quot;pointLights[&quot;</span>;</span><br><span class="line">        name += std::<span class="built_in">to_string</span>(i);</span><br><span class="line">        std::string after;</span><br><span class="line">        after = <span class="string">&quot;].constant&quot;</span>;</span><br><span class="line">        shader.<span class="built_in">setFloat</span>(name + after, <span class="number">1.0f</span>);</span><br><span class="line">        after = <span class="string">&quot;].linear&quot;</span>;</span><br><span class="line">        shader.<span class="built_in">setFloat</span>(name + after, <span class="number">0.09f</span>);</span><br><span class="line">        after = <span class="string">&quot;].quadratic&quot;</span>;</span><br><span class="line">        shader.<span class="built_in">setFloat</span>(name + after, <span class="number">0.032f</span>);</span><br><span class="line">        after = <span class="string">&quot;].ambient&quot;</span>;</span><br><span class="line">        shader.<span class="built_in">setVec3</span>(name + after, glm::<span class="built_in">vec3</span>(<span class="number">0.2f</span>, <span class="number">0.2f</span>, <span class="number">0.2f</span>));</span><br><span class="line">        after = <span class="string">&quot;].diffuse&quot;</span>;</span><br><span class="line">        shader.<span class="built_in">setVec3</span>(name + after, glm::<span class="built_in">vec3</span>(<span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.5f</span>)); <span class="comment">// 将光照调暗了一些以搭配场景</span></span><br><span class="line">        after = <span class="string">&quot;].specular&quot;</span>;</span><br><span class="line">        shader.<span class="built_in">setVec3</span>(name + after, glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 聚光灯</span></span><br><span class="line">    shader.<span class="built_in">setFloat</span>(<span class="string">&quot;spotLight.constant&quot;</span>, <span class="number">1.0f</span>);</span><br><span class="line">    shader.<span class="built_in">setFloat</span>(<span class="string">&quot;spotLight.linear&quot;</span>, <span class="number">0.09f</span>);</span><br><span class="line">    shader.<span class="built_in">setFloat</span>(<span class="string">&quot;spotLight.quadratic&quot;</span>, <span class="number">0.032f</span>);</span><br><span class="line">    shader.<span class="built_in">setFloat</span>(<span class="string">&quot;spotLight.cutOff&quot;</span>, glm::<span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(<span class="number">12.5f</span>)));</span><br><span class="line">    shader.<span class="built_in">setFloat</span>(<span class="string">&quot;spotLight.outerCutOff&quot;</span>, glm::<span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(<span class="number">17.5f</span>)));</span><br><span class="line">    shader.<span class="built_in">setVec3</span>(<span class="string">&quot;spotLight.ambient&quot;</span>, glm::<span class="built_in">vec3</span>(<span class="number">0.2f</span>, <span class="number">0.2f</span>, <span class="number">0.2f</span>));</span><br><span class="line">    shader.<span class="built_in">setVec3</span>(<span class="string">&quot;spotLight.diffuse&quot;</span>, glm::<span class="built_in">vec3</span>(<span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.5f</span>)); <span class="comment">// 将光照调暗了一些以搭配场景</span></span><br><span class="line">    shader.<span class="built_in">setVec3</span>(<span class="string">&quot;spotLight.specular&quot;</span>, glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染循环</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))	<span class="comment">// 检查是否被要求退出窗口</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 输入处理</span></span><br><span class="line">        <span class="built_in">processInput</span>(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 帧渲染时间</span></span><br><span class="line">        <span class="type">float</span> deltaTime;</span><br><span class="line">        <span class="type">float</span> lastFrame = <span class="number">0</span>;</span><br><span class="line">        <span class="type">float</span> currentFrame = <span class="built_in">glfwGetTime</span>();</span><br><span class="line">        deltaTime = currentFrame - lastFrame;</span><br><span class="line">        lastFrame = currentFrame;</span><br><span class="line"></span><br><span class="line">        g_camera.<span class="built_in">SetSpeed</span>(deltaTime);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新着色器中的观察位置变量</span></span><br><span class="line">        shader.<span class="built_in">setVec3</span>(<span class="string">&quot;viewPos&quot;</span>, g_camera.<span class="built_in">GetPos</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重置颜色缓冲和深度缓冲</span></span><br><span class="line">        <span class="built_in">glClearColor</span>(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算mvp变换矩阵</span></span><br><span class="line">        glm::mat4 view = g_camera.<span class="built_in">GetLookAt</span>();</span><br><span class="line"></span><br><span class="line">        glm::mat4 projection = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">        projection = glm::<span class="built_in">perspective</span>(glm::<span class="built_in">radians</span>(g_camera.<span class="built_in">GetFov</span>()), <span class="number">800.0f</span> / <span class="number">600.0f</span>, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br><span class="line"></span><br><span class="line">        lightShader.<span class="built_in">use</span>();</span><br><span class="line">        <span class="comment">// 绘制点光源光照立方体</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            glm::mat4 light_model = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">            light_model = glm::<span class="built_in">translate</span>(light_model, pointLightPositions[i]);</span><br><span class="line">            <span class="comment">// 光源绕圈移动（模型变换修改）</span></span><br><span class="line">            <span class="type">float</span> angle = <span class="number">2.0f</span> * (<span class="type">float</span>)<span class="built_in">glfwGetTime</span>();</span><br><span class="line">            light_model = glm::<span class="built_in">translate</span>(light_model, glm::<span class="built_in">vec3</span>(<span class="built_in">sin</span>(angle), <span class="built_in">cos</span>(angle), <span class="number">0</span>));</span><br><span class="line">            light_model = glm::<span class="built_in">scale</span>(light_model, glm::<span class="built_in">vec3</span>(<span class="number">0.2f</span>));</span><br><span class="line"></span><br><span class="line">            lightShader.<span class="built_in">setMat4</span>(<span class="string">&quot;model&quot;</span>, light_model);</span><br><span class="line">            lightShader.<span class="built_in">setMat4</span>(<span class="string">&quot;view&quot;</span>, view);</span><br><span class="line">            lightShader.<span class="built_in">setMat4</span>(<span class="string">&quot;projection&quot;</span>, projection);</span><br><span class="line">            lightShader.<span class="built_in">setVec3</span>(<span class="string">&quot;lightColor&quot;</span>, glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>));</span><br><span class="line"></span><br><span class="line">            <span class="built_in">glBindVertexArray</span>(lightVAO);</span><br><span class="line">            <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绘制立方体</span></span><br><span class="line">        shader.<span class="built_in">use</span>();</span><br><span class="line">        shader.<span class="built_in">setMat4</span>(<span class="string">&quot;view&quot;</span>, view);</span><br><span class="line">        shader.<span class="built_in">setMat4</span>(<span class="string">&quot;projection&quot;</span>, projection);</span><br><span class="line">        <span class="comment">// 更新着色器中的光源信息</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 点光源位置</span></span><br><span class="line">        <span class="type">float</span> angle = <span class="number">2.0f</span> * (<span class="type">float</span>)<span class="built_in">glfwGetTime</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            std::string name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            name += <span class="string">&quot;pointLights[&quot;</span>;</span><br><span class="line">            name += std::<span class="built_in">to_string</span>(i);</span><br><span class="line">            name += <span class="string">&quot;].position&quot;</span>;</span><br><span class="line">            shader.<span class="built_in">setVec3</span>(name, pointLightPositions[i] + glm::<span class="built_in">vec3</span>(<span class="built_in">sin</span>(angle), <span class="built_in">cos</span>(angle), <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 聚光灯位置和方向</span></span><br><span class="line">        shader.<span class="built_in">setVec3</span>(<span class="string">&quot;spotLight.position&quot;</span>, g_camera.<span class="built_in">GetPos</span>());</span><br><span class="line">        shader.<span class="built_in">setVec3</span>(<span class="string">&quot;spotLight.direction&quot;</span>, g_camera.<span class="built_in">GetFront</span>());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            glm::mat4 model = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">            model = glm::<span class="built_in">translate</span>(model, cubePositions[i]);</span><br><span class="line">            <span class="type">float</span> angle = <span class="number">20.0f</span> * i * (<span class="type">float</span>)<span class="built_in">glfwGetTime</span>();</span><br><span class="line">            model = glm::<span class="built_in">rotate</span>(model, glm::<span class="built_in">radians</span>(angle), glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">0.3f</span>, <span class="number">0.5f</span>));</span><br><span class="line">            shader.<span class="built_in">setMat4</span>(<span class="string">&quot;model&quot;</span>, model);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 交换颜色缓冲，输出显示到屏幕</span></span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">        <span class="comment">// 检查有没有触发什么事件（比如键盘输入、鼠标移动等）、更新窗口状态，并调用对应的回调函数</span></span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





































]]></content>
      <categories>
        <category>图形学</category>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP之概念and三握四挥</title>
    <url>/2023/05/11/TCP%E4%B9%8B%E6%A6%82%E5%BF%B5and%E4%B8%89%E6%8F%A1%E5%9B%9B%E6%8C%A5/</url>
    <content><![CDATA[<h1 id="TCP之概念、三握四挥"><a href="#TCP之概念、三握四挥" class="headerlink" title="TCP之概念、三握四挥"></a>TCP之概念、三握四挥</h1><p>图片和部分文字来源<a href="https://xiaolincoding.com/network/3_tcp/tcp_interview.html">小林coding (xiaolincoding.com)</a></p>
<hr>
<p>TCP是传输层的协议，全称”<strong>传输控制协议</strong>“，用于在IP网络上实现数据和消息的<strong>可靠</strong>传输，并以建立<strong>连接</strong>的方式进行面向<strong>字节流</strong>的数据的传输。</p>
<span id="more"></span>

<br>

<p>在可靠性方面，TCP实现了：</p>
<ul>
<li><strong>连接的建立和断开</strong>，<strong>重传机制</strong>（定时器），<strong>流量控制</strong>（滑动窗口），<strong>拥塞控制</strong>等机制功能。</li>
<li>达到的可靠效果：网络包的收发是<strong>无损坏、无间隔、按序（seq，ack）、非冗余</strong></li>
</ul>
<hr>
<br>

<p><br><br></p>
<br>

<h2 id="TCP格式"><a href="#TCP格式" class="headerlink" title="TCP格式"></a>TCP格式</h2><h3 id="TCP头部"><a href="#TCP头部" class="headerlink" title="TCP头部"></a>TCP头部</h3><img src="/2023/05/11/TCP%E4%B9%8B%E6%A6%82%E5%BF%B5and%E4%B8%89%E6%8F%A1%E5%9B%9B%E6%8C%A5/image-20230510150751458.png" alt="image-20230510150751458" style="zoom:80%;">

<ul>
<li><strong>源端口号、目的端口号</strong></li>
<li><strong>序列号</strong>seq</li>
<li><strong>确认应答号</strong>ack</li>
<li><strong>首部长度</strong> 因为有长度不固定的选项字段，所以首部长度需要明确表示</li>
<li><strong>标志位</strong>（URG、ACK、PSH、RST、SYN、FIN）<ul>
<li>RST 是强制对方断开连接，说明出现异常</li>
<li>SYN 在建立连接时用到，同步</li>
<li>ACK 为确认应答标识</li>
<li>FIN 在断开连接时用到</li>
<li>URG 表示有紧急数据，并通过紧急指针定位</li>
<li>PSH 告诉接收方立即将数据交给应用层，不用等到缓冲区满了</li>
</ul>
</li>
<li><strong>窗口大小</strong></li>
<li>校验和、紧急指针</li>
<li><strong>选项</strong>（可变长度）</li>
</ul>
<br>

<br>

<h3 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h3><p>一个连接包括连接双方的：</p>
<ul>
<li>socket（IP + port）</li>
<li>滑窗大小（接收窗口、发送窗口）</li>
<li>序列号（seq）</li>
<li>…</li>
</ul>
<br>

<p>理论上可以一个服务端socket可以与 <strong>IP数量*端口数量</strong> 个socket建立连接，但实际上受系统<strong>fd数量</strong>、<strong>内存</strong>的限制。</p>
<br>

<br>

<h2 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h2><h3 id="UDP格式"><a href="#UDP格式" class="headerlink" title="UDP格式"></a>UDP格式</h3><p><strong>头部</strong></p>
<img src="/2023/05/11/TCP%E4%B9%8B%E6%A6%82%E5%BF%B5and%E4%B8%89%E6%8F%A1%E5%9B%9B%E6%8C%A5/image-20230510161730776.png" alt="image-20230510161730776" style="zoom:80%;">

<ul>
<li><strong>源端口号、目标端口号</strong></li>
<li><strong>包长度</strong>（数据报）</li>
<li><strong>校验和</strong>（可以校验首部和数据是否正确）</li>
</ul>
<br>

<br>

<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol>
<li>连接：TCP有连接，UDP无连接</li>
<li>传输对象：TCP一对一，<strong>UDP一对一、一对多、多对多</strong></li>
<li><strong>可靠性</strong>：TCP传输<strong>按序</strong>、<strong>无差错</strong>、<strong>不丢失</strong>、<strong>无重复</strong>，UDP不保证</li>
<li><strong>流量控制、拥塞控制</strong>：TCP的机制</li>
<li><strong>传输方式</strong>：TCP流式传输，面向<strong>字节流</strong>，保证数据<strong>顺序</strong>和<strong>可靠</strong>，但是<strong>数据没有边界</strong>（粘包问题）；UDP传输数据包，面向<strong>数据报</strong>，但可能会<strong>乱序和丢包</strong>。</li>
</ol>
<br>

<p><strong>应用场景</strong></p>
<p><strong>TCP</strong>：倾向可靠性要求的</p>
<ul>
<li>文件传输</li>
<li>HTTP&#x2F;HTTPS</li>
</ul>
<br>

<p><strong>UDP</strong>：倾向传输速率的、即时性的</p>
<ul>
<li>DNS，SNMP，数据量较少的</li>
<li>视频、音频、游戏</li>
<li>广播通信</li>
</ul>
<br>

<br>

<br>

<br>

<h2 id="TCP连接建立-三次握手"><a href="#TCP连接建立-三次握手" class="headerlink" title="TCP连接建立-三次握手"></a>TCP连接建立-三次握手</h2><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><img src="/2023/05/11/TCP%E4%B9%8B%E6%A6%82%E5%BF%B5and%E4%B8%89%E6%8F%A1%E5%9B%9B%E6%8C%A5/image-20230510163728483.png" alt="image-20230510163728483" style="zoom:80%;">

<ul>
<li>客户端(SYN_SENT) &gt; 服务端(LISTEN-&gt;SYN_RCVD)： SYN（seq&#x3D;c_x）</li>
<li>客户端(SYN_SENT-&gt;EST) &lt; 服务端(SYN_RCVD)：    SYN+ACK（seq&#x3D;s_x,ack&#x3D;c_x+1）</li>
<li>客户端(EST) &gt; 服务端(SYN_RCVD-&gt;EST)：         ACK（ack&#x3D;s_x+1）</li>
</ul>
<blockquote>
<p><strong>第三次</strong>握手可以<strong>携带数据</strong>，因为经过前两次握手已经确认同步了客户端这边的序列号</p>
</blockquote>
<br>

<br>

<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题:"></a>常见问题:</h3><h4 id="为什么是三次握手？"><a href="#为什么是三次握手？" class="headerlink" title="为什么是三次握手？"></a>为什么是三次握手？</h4><p>为什么不是两次：</p>
<p><strong>三次握手让服务端多了一个过渡状态即SYN_RECV，在此期间可以先确认连接的正确性，排除重复的历史连接</strong></p>
<p>客户端的第一次握手发送的SYN包（A）收到网络阻塞超时了，于是客户端重发新的SYN包（B）（并采用另一个seq号）;</p>
<p>但是服务端最终先收到了旧的SYN包（A），于是进行了第二次握手（回送ack&#x3D;A+1）:</p>
<ul>
<li><p>如果不进行第三次握手，此时就建立连接，会导致双方对客户端seq序列号的不同步：客户端用的是 B，服务端用的是 A</p>
</li>
<li><p>而进行第三次握手，客户端会检查第二次握手的ack&#x3D;A+1，发现并非期待的ack&#x3D;B+1，则会回送RST报文告诉服务端这个错误终止连接。并等待服务端回送正确的ack&#x3D;B+1。</p>
</li>
</ul>
<p>之后服务端收到最新的SYN（B）并回送正确的ack&#x3D;B+1，客户端收到后进行第三次握手，同步服务端这边的序列号。</p>
<blockquote>
<p>如果服务端<u>连续收到两个SYN报文（先A后B）</u>，即<u>没有在中间收到RST报文</u>，那么服务端第二次收到之后会回送 <strong>Challenge Ack</strong> 报文（其序列号仍是旧SYN报文的响应即ack&#x3D;A+1）</p>
</blockquote>
<p>阻止重复历史连接的目的是：<strong>为了避免资源浪费</strong></p>
<ul>
<li>三次握手中服务端会有一个 SYN_RCVD 状态，作为中间状态来确认连接的正确建立。</li>
<li>如果是两次握手，没有中间状态过渡，服务端收到SYN就立即建立连接，但服务端最终还是会收到客户端发来的RST报文断开连接，在此期间连接占用了系统资源（连接队列、socket_fd、内核内存），并且可能会发送数据（无效）</li>
</ul>
<br>

<p>为什么不是四次：</p>
<p><strong>三次握手的目的是建立连接并且同步双方初始序列号，同步序列号需要一来一回，理论上需要两个来回，但是中间的两步可以合并</strong></p>
<p>第一次握手和第二次握手同步了客户端的序列号：seq&#x3D;A，ack&#x3D;A+1</p>
<p>第二次握手和第三次握手同步了服务端的序列号：seq&#x3D;B，ack&#x3D;B+1</p>
<ul>
<li>第二次握手把 seq&#x3D;B, ack&#x3D;A+1 一起发了，所以相当于减少了一次握手，所以不是四次</li>
</ul>
<br>

<br>

<h4 id="为什么每次TCP连接建立时的序列号不同？"><a href="#为什么每次TCP连接建立时的序列号不同？" class="headerlink" title="为什么每次TCP连接建立时的序列号不同？"></a>为什么每次TCP连接建立时的序列号不同？</h4><ul>
<li>分辨不同的连接同步情况，主要是跟历史连接区分（前后两次连接建立时的seq都相同的话，后续发送的数据包的序列号也可能相同，如果历史连接的数据包延迟到新连接时才被接收，若序列号相同则会导致不应该的数据接收）</li>
</ul>
<blockquote>
<p>此外，还是有可能会发生历史数据包的seq冲突，还需要利用 <strong>时间戳</strong> 来分辨</p>
</blockquote>
<ul>
<li>防止黑客伪造相同序列号的报文让接收方接收</li>
</ul>
<p>初始序列号 ISN 的生成利用到了时钟和哈希算法，重复率很低。</p>
<br>

<br>

<h4 id="IP-层会分片（MTU），为什么TCP层还需要分片（MSS）"><a href="#IP-层会分片（MTU），为什么TCP层还需要分片（MSS）" class="headerlink" title="IP 层会分片（MTU），为什么TCP层还需要分片（MSS）"></a>IP 层会分片（MTU），为什么TCP层还需要分片（MSS）</h4><img src="/2023/05/11/TCP%E4%B9%8B%E6%A6%82%E5%BF%B5and%E4%B8%89%E6%8F%A1%E5%9B%9B%E6%8C%A5/image-20230510220202657.png" alt="image-20230510220202657" style="zoom:80%;">

<ul>
<li><strong>MTU</strong>：<strong>IP网络包的最大长度</strong>，以太网的一般为1500字节；</li>
<li><strong>MSS</strong>：IP网络包除去IP头、TCP头，剩下的<strong>TCP数据的最大长度</strong>；</li>
</ul>
<p>MTU是针对数据在IP层的分片大小，MSS是针对数据在TCP层的分片大小。</p>
<p>假设TCP层要发送的数据长度为3个MTU左右：（注意 <strong>重传</strong> 是TCP而不是IP的机制）</p>
<ul>
<li><strong>无MSS</strong>的情况下，数据通过3个IP包来发送，但只有第一个包中包含TCP头。如果<strong>其中一个IP包</strong>丢失了，因为<strong>唯一的TCP头</strong>中说明的数据长度应该是大概3个MTU的大小，无法确认丢失部分的长度，那么就得重新发送<strong>所有的IP包</strong>。</li>
<li><strong>有MSS</strong>的情况下（一般MSS长度略小于MTU，使得MSS分片不需要在MTU中再分），如果其中一个IP包丢失了，则可以根据缺失的TCP头（重传情况之一：收到重复的ack）来确定要重发哪一部分的数据，即只需重新发送少量IP包。</li>
</ul>
<blockquote>
<p><strong>建立连接的时候</strong>，通信双方会协商各自的MSS值</p>
</blockquote>
<br>

<br>

<h4 id="握手丢失的情况"><a href="#握手丢失的情况" class="headerlink" title="握手丢失的情况"></a>握手丢失的情况</h4><ol>
<li><strong>第一次握手丢失</strong></li>
</ol>
<ul>
<li>服务端没有收到SYN，则不会回送SYN-ACK；客户端长时间没收到ACK，触发超时重传，重新发送SYN。</li>
<li>重传次数：由内核文件中的参数<code>tcp_syn_retries</code>设置；超时时间：每次是上一次的2倍</li>
<li>当超时次数达到上限之后，若还是没有收到ACK，那么客户端就会断开</li>
</ul>
<ol start="2">
<li><strong>第二次握手丢失</strong></li>
</ol>
<ul>
<li>客户端长时间没有收到SYN-ACK，触发超时重传</li>
<li>服务端长时间没有收到第三次握手的ACK，触发超时重传</li>
<li>在达到重传次数上限后，若还没有收到回应，则会断开，CLOSE</li>
</ul>
<ol start="3">
<li><strong>第三次握手丢失</strong></li>
</ol>
<ul>
<li>服务端长时间没有收到第三次握手的ACK，触发超时重传</li>
<li>客户端已经建立起了连接，若收到服务端的重传，则会发送ACK</li>
<li>服务端达到重传次数上限，若还没有收到回应，则会断开，CLOSE</li>
<li><strong>客户端处于ESTABLISHED状态</strong>：<ul>
<li>若客户端不主动发数据，则长时间无数据交互，客户端最终会断开。</li>
<li>若客户端主动发数据，则会一直触发重传并到达上限断开。</li>
</ul>
</li>
</ul>
<br>

<br>

<h3 id="其他知识：SYN攻击、半连接队列、全连接队列"><a href="#其他知识：SYN攻击、半连接队列、全连接队列" class="headerlink" title="其他知识：SYN攻击、半连接队列、全连接队列"></a>其他知识：SYN攻击、半连接队列、全连接队列</h3><p>针对服务端的攻击，攻击者发送大量SYN包给服务端，但不进行第三次握手，使得服务端的TCP<strong>半连接队列</strong>爆满，无法正常接收后续的SYN连接请求。</p>
<blockquote>
<img src="/2023/05/11/TCP%E4%B9%8B%E6%A6%82%E5%BF%B5and%E4%B8%89%E6%8F%A1%E5%9B%9B%E6%8C%A5/image-20230511162030421.png" alt="image-20230511162030421" style="zoom: 67%;">

<p>半连接队列（SYN队列）：存放已进行第一次握手的客户端</p>
<p>全连接队列（accept队列）：存放已进行第三次握手的客户端</p>
<ul>
<li>收到第一次握手后把客户端放入SYN队列，并进行第二次握手；</li>
<li>收到第三次握手后把客户端移出SYN队列，并放入Accept队列；</li>
<li>应用程序执行accept()从Accept队列中取出客户端，建立起连接。</li>
</ul>
</blockquote>
<p><strong>应对方式</strong>：</p>
<ol>
<li>调大 netdev_max_backlog ：内核处理速度<u>小于</u>网卡接收数据速度时的额外数据缓存队列大小。</li>
<li>增大 TCP半连接队列 ：<ul>
<li>增大 net.ipv4.tcp_max_syn_backlog</li>
<li>增大 listen() 函数中的 backlog</li>
<li>增大 net.core.somaxconn</li>
</ul>
</li>
<li>开启 net.ipv4.tcp_syncookies ：SYN队列满了以后，服务端对于收到的新的SYN连接请求，根据算法算出cookie并直接进行第二次握手，且将cookie作为seq。服务端收到第三次握手时，检查ack&#x3D;cookie+1，并将客户端连接放入全连接Accept队列。</li>
<li>减少 SYN+ACK 重传次数（修改内核参数）：减少了无效连接的占用队列的时间。</li>
</ol>
<br>

<br>

<h2 id="TCP连接断开-四次挥手"><a href="#TCP连接断开-四次挥手" class="headerlink" title="TCP连接断开-四次挥手"></a>TCP连接断开-四次挥手</h2><h3 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h3><p>以客户端主动关闭连接为例。</p>
<img src="/2023/05/11/TCP%E4%B9%8B%E6%A6%82%E5%BF%B5and%E4%B8%89%E6%8F%A1%E5%9B%9B%E6%8C%A5/image-20230511163506620.png" alt="image-20230511163506620" style="zoom: 67%;">

<ol>
<li>客户端发送FIN，并进入<strong>FIN_WAIT_1</strong>状态；</li>
<li>服务端收到FIN，回送ACK，并进入<strong>CLOSED_WAIT</strong>状态；在服务端发送FIN之前，服务端还可以发送数据；</li>
<li>客户端收到ACK，进入<strong>FIN_WAIT_2</strong>状态，等待服务端的FIN，在此期间可以接收数据；</li>
<li>服务端处理完数据后，发送FIN，并进入<strong>LAST_ACK</strong>状态；</li>
<li>客户端收到FIN，回送ACK，并进入<strong>TIME_WAIT</strong>状态等待一段时间（留机会给服务端重发FIN），确保对方收到了ACK。之后连接正常关闭。</li>
<li>服务端收到ACK，连接关闭。</li>
</ol>
<br>

<br>

<h3 id="常见问题："><a href="#常见问题：" class="headerlink" title="常见问题："></a>常见问题：</h3><p>以客户端主动断开为例</p>
<h4 id="为什么是4次"><a href="#为什么是4次" class="headerlink" title="为什么是4次"></a>为什么是4次</h4><ul>
<li>关闭连接时，客户端先发送FIN包仅表示客户端不再发送数据，但能继续接收数据</li>
<li>服务端收到FIN后回送ACK，但在发送FIN之前还可以处理剩余数据并发送，等到不再需要发送数据之后才发送FIN，向客户端表示同一关闭连接</li>
</ul>
<p>如果中间无其余数据需要处理，可以合并服务端的ACK和FIN可以为合并为一次。</p>
<br>

<br>

<h4 id="挥手丢失的情况"><a href="#挥手丢失的情况" class="headerlink" title="挥手丢失的情况"></a>挥手丢失的情况</h4><p>FIN的重发次数由<code>tcp_orphan_retrie</code>设置</p>
<ol>
<li><strong>第一次挥手丢失</strong></li>
</ol>
<p>服务端没有收到FIN，则不会回送ACK。客户端没有收到ACK，触发超时重传，达到上限后直接断开连接，而此时服务端的连接还没关闭，则可分为有数据发送（重传到关闭）和无数据发送（长时间后关闭）的两种情况。</p>
<ol start="2">
<li><strong>第二次挥手丢失</strong></li>
</ol>
<p>服务端的ACK丢失，客户端没有收到ACK，触发超时重传，达到上限后直接断开连接，而此时服务端处于CLOSE_WAIT状态，后续会发送数据以及发送FIN。</p>
<ol start="3">
<li><strong>第三次挥手丢失</strong></li>
</ol>
<p>客户端收到ACK后，关于<strong>FIN_WAIT_2</strong>状态：</p>
<ul>
<li>若客户端采用的是close()关闭连接，则FIN_WAIT_2状态的持续时间由内核参数<code>tcp_fin_timeout</code>决定，在此时限内没有收到服务端的FIN的话会直接断开连接；</li>
<li>若客户端采用的是shutdown()关闭连接（明确表示后续还要接收数据，即只关闭客户端连接的<strong>发送</strong>方向，保留接收方向），则FIN_WAIT_2状态会一直持续；</li>
</ul>
<p>服务端收到FIN，并回送ACK后，处于<strong>CLOSE_WAIT</strong>状态，后续<strong>何时发送FIN</strong>则由<strong>程序中执行close()的时机</strong>决定。</p>
<ul>
<li>第三次挥手丢失，客户端没有回送ACK，服务端触发超时重传FIN，直到超限断开。</li>
<li>后续客户端则处于FIN_WAIT_2直到超时断开。</li>
</ul>
<ol start="4">
<li><strong>第四次挥手丢失</strong></li>
</ol>
<p>客户端发送ACK后进入TIME_WAIT状态（<strong>2MSL</strong>时间）。四挥丢失会触发服务端的FIN超时重传，客户端在TIME_WAIT状态内收到FIN的话也会重发ACK（并且<strong>重置2MSL定时器</strong>）。</p>
<ul>
<li>第四次挥手一直丢失，则服务端重发FIN次数达到上线后便会直接关闭。而客户端经过2MSL时长后便会关闭。</li>
</ul>
<br>

<br>

<h4 id="关于TIME-WAIT"><a href="#关于TIME-WAIT" class="headerlink" title="关于TIME_WAIT"></a>关于TIME_WAIT</h4><p><strong>为什么TIME_WAIT时长是2MSL</strong></p>
<p><code>MSL</code> 是 Maximum Segment Lifetime，<strong>报文最大生存时间</strong>。大概是消耗掉最大<strong>TTL</strong>的时间。（Linux下约30s）</p>
<p>TIME_WAIT 等待 2 倍的 MSL，比较合理的解释是： </p>
<ul>
<li>网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以<strong>一来一回需要等待 2 倍的时间</strong>。</li>
<li>相当于允许我方发送的报文丢失一次，<strong>留一个时间来接收对方可能重发的报文</strong>。比如，若 ACK 在一个 MSL 内丢失，这样被动方重发的 FIN 会在第 2 个 MSL 内到达。</li>
</ul>
<p>为什么不是4MSL、8MSL：因为连续丢包的概率很小，忽略不做处理的性价比更高。</p>
<br>

<br>

<p><strong>TIME_WAIT状态的作用</strong></p>
<ol>
<li>防止<strong>历史连接中的数据</strong>，被后面相同四元组的连接错误的接收。（发生seq绕回的情况，即报文seq出现重复而无法识别新老数据的情况）</li>
</ol>
<p>经过2MSL的时间可以确保旧连接的数据包全部失效。</p>
<ol start="2">
<li>保证<strong>被动关闭连接方</strong>（此例为服务端）能正确关闭</li>
</ol>
<p>即在客户端ACK丢失的情况下，<strong>让客户端有机会收到服务端重发的FIN</strong>，并重发ACK给服务端。</p>
<p>否则，在客户端关闭之后，服务端后续重发的FIN会返回RST报文</p>
<img src="/2023/05/11/TCP%E4%B9%8B%E6%A6%82%E5%BF%B5and%E4%B8%89%E6%8F%A1%E5%9B%9B%E6%8C%A5/image-20230511213003866.png" alt="image-20230511213003866" style="zoom:80%;">



<img src="/2023/05/11/TCP%E4%B9%8B%E6%A6%82%E5%BF%B5and%E4%B8%89%E6%8F%A1%E5%9B%9B%E6%8C%A5/image-20230511213043392.png" alt="image-20230511213043392" style="zoom: 80%;">



<p><strong>TIME_WAIT过多的影响</strong></p>
<ul>
<li>第一是占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等；</li>
<li>第二是占用端口资源；端口资源也是有限的，一般可以开启的端口为 <code>32768～61000</code>，也可以通过 <code>net.ipv4.ip_local_port_range</code>参数指定范围。</li>
</ul>
<p>可以分别对客户端（主要是端口）和服务端（主要是系统资源）进行分析</p>
<ul>
<li>如果<strong>服务端</strong>要避免过多的 TIME_WAIT 状态的连接，就<strong>永远不要主动断开连接</strong>，让客户端去断开，由分布在各处的客户端去承受 TIME_WAIT</li>
</ul>
<br>

<br>

<h4 id="优雅关闭连接"><a href="#优雅关闭连接" class="headerlink" title="优雅关闭连接"></a>优雅关闭连接</h4><ul>
<li>默认为优雅关闭连接，即正常地完成4次握手地流程。</li>
<li>不优雅地关闭连接，对 socket 设置 <em>SO_LINGER</em> 选项：<ul>
<li>使得调用close()后直接给对方发送RST报文，并关闭连接</li>
</ul>
</li>
</ul>
<br>

<br>

<h3 id="保活机制"><a href="#保活机制" class="headerlink" title="保活机制"></a>保活机制</h3><p>建立连接后，客户端发生了故障如<strong>宕机、断电</strong>的情况（<strong>进程崩溃</strong>的情况会自己发FIN或RST报文给对方），若服务端不主动发送数据给客户端，会发生什么？</p>
<p>长时间没有数据交互的情况，对应有<strong>保活机制</strong>，服务端会每隔一个时间间隔发送一个<strong>探测报文</strong>，如果连续几个探测报文都没有响应，则内核会认为连接失效并报告错误信息。</p>
<ul>
<li><p>tcp_keepalive_xxx 系列内核参数设置时间。</p>
</li>
<li><p>SO_KEEPALIVE 设置socket选项开启保活机制。</p>
</li>
</ul>
<p>此外，我们一般在<strong>应用层</strong>程序实现<strong>定时器、心跳</strong>之类的机制，来关闭长时间没有数据交互的连接。</p>
<br>

<p><br><br></p>
<br>
]]></content>
      <categories>
        <category>网络</category>
        <category>TCP</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity入门(一)</title>
    <url>/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/</url>
    <content><![CDATA[<h2 id="Unity新手入门（一）"><a href="#Unity新手入门（一）" class="headerlink" title="Unity新手入门（一）"></a>Unity新手入门（一）</h2><p>资料来源<a href="https://space.bilibili.com/34412870">擅码网-Monkey的个人空间_哔哩哔哩_bilibili</a></p>
<h3 id="（1）Unity基础使用"><a href="#（1）Unity基础使用" class="headerlink" title="（1）Unity基础使用"></a>（1）Unity基础使用</h3><p><strong>特点</strong>：开发跨平台，资源商店（含开发插件）</p>
<p><strong>界面</strong>：</p>
<ul>
<li>菜单栏</li>
<li>状态栏</li>
<li>操作界面</li>
</ul>
<span id="more"></span>

<p><strong>项目结构</strong>：</p>
<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230524185031458.png" alt="image-20230524185031458" style="zoom:80%;">

<p><strong>Editor</strong> <strong>界面和组织</strong>：</p>
<ul>
<li>Project<ul>
<li>目录文件结构</li>
</ul>
</li>
<li>Hierarchy<ul>
<li>含有场景内的Gameobj对象</li>
</ul>
</li>
<li>Inspector<ul>
<li>检查面板</li>
</ul>
</li>
<li>Scene<ul>
<li>场景视图</li>
</ul>
</li>
</ul>
<p><strong>场景视图内的操作</strong>：</p>
<ul>
<li>几何模型，素材模型</li>
<li>坐标系（世界坐标系、局部坐标系）</li>
<li>选择物体按F快速定位，或双击物体</li>
<li>ALT +鼠标左键旋转、+右键拉远拉近</li>
<li>光源预渲染失败：需要到lighting设置中generate</li>
<li>观察模式：透视persp，正交iso</li>
</ul>
<h3 id="（2）游戏物体与组件"><a href="#（2）游戏物体与组件" class="headerlink" title="（2）游戏物体与组件"></a>（2）游戏物体与组件</h3><h4 id="游戏物体"><a href="#游戏物体" class="headerlink" title="游戏物体"></a>游戏物体</h4><p>场景中所有物体都是GameObject</p>
<p>操作：</p>
<ul>
<li>F2重命名</li>
<li>shift+点击首个和末尾的obj可以多选</li>
<li>ctrl单个选择</li>
<li>Gizmos菜单Scene界面显示设置</li>
</ul>
<h4 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h4><p>inspector窗口</p>
<p>挂载于GameObject的各种Component</p>
<h4 id="项目资产管理"><a href="#项目资产管理" class="headerlink" title="项目资产管理"></a>项目资产管理</h4><p>Assets文件夹内容管理</p>
<p>创建各类二级文件夹</p>
<h4 id="模型与材质"><a href="#模型与材质" class="headerlink" title="模型与材质"></a>模型与材质</h4><p>模型 Model</p>
<p>材质 Material</p>
<p>纹理贴图 Texture</p>
<p><strong>材质球制作</strong></p>
<p>贴图与模型之间的中间过渡——材质球</p>
<ul>
<li><p>Create material</p>
</li>
<li><p>纹理贴图拖到材质的Albedo参数</p>
<ul>
<li>Albedo：反照率[贴图]；用于体现模型的纹理，颜色。</li>
</ul>
</li>
<li><p>材质球拖到模型的组件位置</p>
</li>
</ul>
<h4 id="资源复用和预制体"><a href="#资源复用和预制体" class="headerlink" title="资源复用和预制体"></a>资源复用和预制体</h4><p>Prefab</p>
<p>获取外部资源的Prefab后，放到编辑器内进行二次编辑，然后保存为自己的Prefab</p>
<p> <img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230524194033102.png" alt="image-20230524194033102"></p>
<p>编辑prefab</p>
<ul>
<li>直接编辑文件</li>
<li>点击Hierarchy中prefab对应的游戏对象的 &gt; icon</li>
<li>点击对象的Inspector的Open选项</li>
<li>直接在场景内编辑预制体游戏对象，编辑后点Override-&gt; Apply all</li>
</ul>
<p>断开prefab关联</p>
<ul>
<li>右键Hierarchy中的游戏对象，选择Prefab-&gt;Unpack</li>
</ul>
<h4 id="基础组件"><a href="#基础组件" class="headerlink" title="基础组件"></a>基础组件</h4><h5 id="Transform-组件"><a href="#Transform-组件" class="headerlink" title="Transform 组件"></a>Transform 组件</h5><ul>
<li>位置</li>
<li>旋转</li>
<li>缩放</li>
</ul>
<p>位置是相对于世界坐标轴，旋转和缩放是相对于物体自身坐标轴。</p>
<p>GameObject最基本的组件——Transform。</p>
<p>Empty object可以用来控制层级关系，是天然的父物体。</p>
<h5 id="摄像机组件"><a href="#摄像机组件" class="headerlink" title="摄像机组件"></a>摄像机组件</h5><ul>
<li>视锥体</li>
<li>选中物体 Align with View（按ctrl+shift+f 快速改变位置 </li>
<li>第一人称、第三人称、上帝视角、过肩视角…</li>
</ul>
<p>常用参数：</p>
<ul>
<li>投影 Projection：<ul>
<li>透视 perspective：可以设置Field of View视野范围FOV</li>
<li>正交 Orthographic：可以设置 矩形大小Size</li>
</ul>
</li>
<li>裁剪面 Clipping Planes：<ul>
<li>near，far 控制视锥体的两个面距离摄像机的距离</li>
</ul>
</li>
</ul>
<p> <img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230524201739062.png" alt="image-20230524201739062"></p>
<h5 id="灯光组件"><a href="#灯光组件" class="headerlink" title="灯光组件"></a>灯光组件</h5><p>类型：</p>
<ul>
<li>方向光（太阳）<ul>
<li><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230524202214099.png" alt="image-20230524202214099"></li>
</ul>
</li>
<li>点光源（灯泡）</li>
<li>聚光灯（探照灯）</li>
</ul>
<p>部分属性</p>
<p> <img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230524202327394.png" alt="image-20230524202327394"></p>
<p> <img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230524203010795.png" alt="image-20230524203010795"></p>
<p>重点：<strong>阴影</strong> 和 <strong>光照模式</strong></p>
<h4 id="Shader-与-PBR"><a href="#Shader-与-PBR" class="headerlink" title="Shader 与 PBR"></a>Shader 与 PBR</h4><h5 id="Shader"><a href="#Shader" class="headerlink" title="Shader"></a>Shader</h5><p>着色器 Shader，包含如下属性等。 跟材质球是 蛋壳(材质球Material) 和 蛋清蛋黄(着色器Shader) 的关系，即一个负责展示表现效果，一个负责效果的实现</p>
<p> <img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230524203324571.png" alt="image-20230524203324571"></p>
<p>基本信息</p>
<p><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230524203426130.png" alt="image-20230524203426130"></p>
<h5 id="PBR"><a href="#PBR" class="headerlink" title="PBR"></a>PBR</h5><p>Physicallly-Based-Rendering 基于物理的渲染</p>
<p><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230524203605166.png" alt="image-20230524203605166"></p>
<p>工作流程  </p>
<p><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230524204152889.png" alt="image-20230524204152889"></p>
<h5 id="Unity-标准着色器"><a href="#Unity-标准着色器" class="headerlink" title="Unity 标准着色器"></a>Unity 标准着色器</h5><ul>
<li>材质球的默认 Shader着色器 为 Standard Shader (Unity内的 PBR 渲染Shader)</li>
</ul>
<p>材质球的三种常用效果</p>
<ul>
<li>单贴图：将Texture拖到Albedo属性上</li>
<li>单颜色：直接修改Albedo属性的颜色项</li>
<li>地面瓷砖效果：<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230524234036586.png" alt="image-20230524234036586" style="zoom: 67%;"></li>
</ul>
<p>贴图 - 材质球 - Shader - 游戏物体 之间的关系</p>
<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230524234516928.png" alt="image-20230524234516928" style="zoom:80%;">





<h4 id="脚本代码（脚本组件）"><a href="#脚本代码（脚本组件）" class="headerlink" title="脚本代码（脚本组件）"></a>脚本代码（脚本组件）</h4><p>即 C# 脚本代码 </p>
<ul>
<li>创建script后要立即重命名，使得脚本名和类名一致。</li>
<li>往GameObject上挂脚本组件，相当于new一个脚本对象供后续使用。</li>
</ul>
 <img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230525001709436.png" alt="image-20230525001709436" style="zoom:67%;">



<p><strong>普通C#项目文件与 Unity C#文件对比</strong></p>
<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230525002444458.png" alt="image-20230525002444458" style="zoom: 67%;">





<h5 id="脚本生命周期"><a href="#脚本生命周期" class="headerlink" title="脚本生命周期"></a>脚本生命周期</h5><ul>
<li><p>C# 控制台项目的脚本类对象生命周期（方法&#x2F;函数）：构造，使用字段、属性、方法，析构</p>
</li>
<li><p>继承MonoBehaviour类的脚本类对象的九大生命周期（方法&#x2F;函数）：</p>
<ol>
<li>Awake 函数 :</li>
</ol>
<p>在加载场景时运行 , 即在游戏开始之前初始化变量或者游戏状态 . 只执行一次</p>
<ol start="2">
<li>OnEnable 函数 :</li>
</ol>
<p>在激活当前脚本时调用 , 每激活一次就调用一次该方法</p>
<ol start="3">
<li>Start 函数 :</li>
</ol>
<p>在第一次启动时执行 , 用于游戏对象的初始化 , 在Awake 函数之后执行,只执行一次</p>
<ol start="4">
<li><p>Fixed Update : 固定频率调用 , 与硬件无关, 可以在 Edit -&gt; Project Setting -&gt; Time -&gt; Fixed Time Step 修改</p>
</li>
<li><p>Update : 几乎每一帧都在调用 , 取决于你的电脑硬件 , 不稳定</p>
</li>
<li><p>LateUpdate : 在Update函数之后调用 , 一般用作摄像机跟随</p>
</li>
<li><p>OnGUI 函数 : 调用速度是上面的两倍 , 一般用于老版本的 GUI 显示</p>
</li>
<li><p>OnDisable 函数 : 和 OnEnable 函数成对出现 , 只要从激活状态变为取消激活状态 , 就会执行一次 (和 OnEnable互斥)</p>
</li>
<li><p>OnDestroy 函数 : 当前游戏对象或游戏组件被销毁时执行</p>
</li>
</ol>
</li>
<li><p>不加访问权限修饰的字段、属性、方法默认为private</p>
</li>
</ul>
<h5 id="获取鼠标键盘操作状态"><a href="#获取鼠标键盘操作状态" class="headerlink" title="获取鼠标键盘操作状态"></a>获取鼠标键盘操作状态</h5><p>时刻检测，在Update里面调用</p>
<p><strong>鼠标</strong></p>
<p><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230525185943332.png" alt="image-20230525185943332"></p>
<p>键盘</p>
<p><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230525190200986.png" alt="image-20230525190200986"></p>
<h5 id="从脚本代码理解游戏对象和组件"><a href="#从脚本代码理解游戏对象和组件" class="headerlink" title="从脚本代码理解游戏对象和组件"></a>从脚本代码理解游戏对象和组件</h5><ul>
<li><p>值传递：基本类型赋值</p>
</li>
<li><p>引用传递：非基本类型赋值，相当于浅拷贝</p>
</li>
</ul>
<p><strong>GameObject 和 gameObject</strong></p>
<p><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230525191849546.png" alt="image-20230525191849546"></p>
<p><strong>命名方法</strong></p>
<ul>
<li>小驼峰命名：首个单词小写，其余单词首字母大写</li>
<li>帕斯卡命名（大驼峰）：每个单词首字母都大写</li>
</ul>
<p><strong>持有对象关系</strong></p>
<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230525193241066.png" alt="image-20230525193241066" style="zoom:80%;">

<ul>
<li>持有<strong>自身游戏对象</strong>：使用gameObject属性获取</li>
<li>持有<strong>其他游戏物体对象</strong><ul>
<li><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230525192845788.png" alt="image-20230525192845788" style="zoom: 67%;"></li>
<li>可以用成员变量来存放引用，延长使用周期<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230525193100022.png" alt="image-20230525193100022" style="zoom:67%;"></li>
</ul>
</li>
<li>持有<strong>自身组件对象</strong><ul>
<li><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230525193218416.png" alt="image-20230525193218416" style="zoom:67%;"></li>
</ul>
</li>
<li>持有其他游戏对象的组件对象<ul>
<li>结合前面“持有<strong>其他游戏物体对象</strong>”和“持有<strong>自身组件对象</strong>”</li>
</ul>
</li>
</ul>
<h4 id="Transform组件的代码控制"><a href="#Transform组件的代码控制" class="headerlink" title="Transform组件的代码控制"></a>Transform组件的代码控制</h4><h5 id="移动物体位置"><a href="#移动物体位置" class="headerlink" title="移动物体位置"></a>移动物体位置</h5><ul>
<li>Translate()方法<ul>
<li><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230525200237435.png" alt="image-20230525200237435" style="zoom:80%;"></li>
</ul>
</li>
<li>结合键盘输入，可以设置四方向移动</li>
</ul>
<h3 id="（3）物理系统"><a href="#（3）物理系统" class="headerlink" title="（3）物理系统"></a>（3）物理系统</h3><ul>
<li>三个最基础的系统：<strong>物理、动画、UI</strong></li>
<li>此外还有<strong>输入控制、特效、导航、音效、渲染、热更新系统</strong>等</li>
</ul>
<p>Unity物理系统：模拟了 <strong>重力</strong> 和 <strong>碰撞</strong></p>
<ul>
<li><p>分有 3D物理（基于PhysX引擎） 和 2D物理（基于Box2D引擎）</p>
</li>
<li><p>主要有 刚体组件（重力） 和 碰撞器组件（碰撞）</p>
</li>
</ul>
<h4 id="刚体"><a href="#刚体" class="headerlink" title="刚体"></a>刚体</h4><p>刚体组件的参数：</p>
<ul>
<li>Mass 质量</li>
<li>Drag 阻力</li>
<li>Angular Drag 角阻力</li>
<li>Use Gravity 重力开关</li>
<li>Is Kinematic 运动学开关</li>
</ul>
<p>移动刚体组件的位置</p>
<ul>
<li>MovePosition(Vector3)方法<ul>
<li><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230525202623202.png" alt="image-20230525202623202" style="zoom:67%;"></li>
</ul>
</li>
</ul>
<p>刚体组件添加动力</p>
<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230525203319825.png" alt="image-20230525203319825" style="zoom:67%;">



<p><strong>固定更新</strong></p>
<p>Update 和 FixedUpdate</p>
<p><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230525204535359.png" alt="image-20230525204535359"></p>
<p><strong>控制组件的启用与否</strong></p>
<ul>
<li>Inspector界面勾选</li>
<li>代码控制：<ul>
<li>GameObject<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230525204925251.png" alt="image-20230525204925251" style="zoom:80%;"></li>
<li>Component<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230525205107297.png" alt="image-20230525205107297" style="zoom:80%;"></li>
</ul>
</li>
</ul>
<p><strong>轴向约束控制</strong></p>
<p>Constraints约束</p>
<ul>
<li>position和rotation</li>
<li>xyz三个轴</li>
</ul>
<h4 id="（非物理组件）网格-Mesh"><a href="#（非物理组件）网格-Mesh" class="headerlink" title="（非物理组件）网格 Mesh"></a>（非物理组件）网格 Mesh</h4><p>网格：三维模型的数据文件，美术完成三维建模就是完成模型的网格制作。三维模型由点线面组成。</p>
<ul>
<li><p><strong>Mesh Filter组件</strong></p>
<ul>
<li>设置网格模型（文件）</li>
<li><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230525205549024.png" alt="image-20230525205549024" style="zoom:80%;"></li>
</ul>
</li>
<li><p><strong>Mesh Renderer组件</strong></p>
<ul>
<li>设置网格模型的渲染</li>
<li>核心参数<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230525205947620.png" alt="image-20230525205947620" style="zoom:80%;"></li>
</ul>
</li>
</ul>
<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230525210116122.png" alt="image-20230525210116122" style="zoom:80%;">





<h4 id="碰撞器"><a href="#碰撞器" class="headerlink" title="碰撞器"></a>碰撞器</h4><p>和刚体组件配合使用</p>
<ul>
<li>Box、Sphere、Mesh、Capsule四种常用collider模型</li>
</ul>
<p>参数：</p>
<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230525211319012.png" alt="image-20230525211319012" style="zoom:80%;">



<h5 id="碰撞检测"><a href="#碰撞检测" class="headerlink" title="碰撞检测"></a>碰撞检测</h5><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230525212908508.png" alt="image-20230525212908508" style="zoom:80%;">

<ul>
<li>collision Detection 参数设置碰撞检测频率</li>
<li>gameObject.Collision 只读属性，返回物理碰撞到的游戏物体</li>
</ul>
<h5 id="触发检测"><a href="#触发检测" class="headerlink" title="触发检测"></a>触发检测</h5><p>Collider组件的 Is Trigger 选项</p>
<ul>
<li>勾选后，不会产生物理碰撞，而是进行触发检测</li>
<li>触发的三种状态跟碰撞检测相同</li>
</ul>
<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230526141317266.png" alt="image-20230526141317266" style="zoom:80%;">

<ul>
<li>gameObject.Collider 只读属性，返回物理触发到的游戏物体</li>
</ul>
<h3 id="（4）Transfom组件控制"><a href="#（4）Transfom组件控制" class="headerlink" title="（4）Transfom组件控制"></a>（4）Transfom组件控制</h3><h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><ul>
<li>欧拉角<ul>
<li>存在万向锁</li>
</ul>
</li>
<li>四元数<ul>
<li>无法直观地表示旋转角度</li>
</ul>
</li>
</ul>
<p>Unity的使用</p>
<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230526143606371.png" alt="image-20230526143606371" style="zoom:80%;">

<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230526143748810.png" alt="image-20230526143748810" style="zoom:80%;">



<p><strong>游戏物体持续旋转</strong></p>
<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230526143913425.png" alt="image-20230526143913425" style="zoom:80%;">



<p><strong>中心点的改变</strong></p>
<ul>
<li>创建空子物体，移动到特定位置</li>
<li>空子物体改为同级空物体</li>
<li>将原物体作为空物体的子物体</li>
</ul>
<p>Scene界面的设置</p>
<p><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230526145520652.png" alt="image-20230526145520652"></p>
<p><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230526145531225.png" alt="image-20230526145531225"></p>
<h3 id="Unity协程相关"><a href="#Unity协程相关" class="headerlink" title="Unity协程相关"></a>Unity协程相关</h3><p>切换时机</p>
<p><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/image-20230526151919486.png" alt="image-20230526151919486"></p>
<p><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%B8%80/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxNDgwODM5,size_16,color_FFFFFF,t_70.png" alt="img"></p>
]]></content>
      <categories>
        <category>游戏开发</category>
        <category>客户端</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity入门(二)</title>
    <url>/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/</url>
    <content><![CDATA[<h2 id="Unity新手入门（二）"><a href="#Unity新手入门（二）" class="headerlink" title="Unity新手入门（二）"></a>Unity新手入门（二）</h2><p>资料来源<a href="https://space.bilibili.com/34412870">擅码网-Monkey的个人空间_哔哩哔哩_bilibili</a></p>
<span id="more"></span>

<h3 id="UI系统"><a href="#UI系统" class="headerlink" title="UI系统"></a>UI系统</h3><p>指UGUI</p>
<p>由UI游戏对象和UI组件</p>
<h4 id="两大UI游戏对象"><a href="#两大UI游戏对象" class="headerlink" title="两大UI游戏对象"></a>两大UI游戏对象</h4><p><strong>Canvas 画布</strong></p>
<ul>
<li>画布Gameobject，是所有 UI Gameobject (如Image、text等)的父物体；</li>
</ul>
<p><strong>EventSystem 事件系统</strong></p>
<ul>
<li>用于响应和处理用户对UI的各种操作</li>
<li>同一场景内，Canvas可以有多个，EventSystem只能有一个</li>
</ul>
<h4 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h4><p>由两部分组成：</p>
<ul>
<li>UI布局组件 Layout</li>
<li>UI元素组件 UI</li>
</ul>
<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230526155807850.png" alt="image-20230526155807850" style="zoom: 67%;">



<h5 id="Text组件"><a href="#Text组件" class="headerlink" title="Text组件"></a>Text组件</h5><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230526160528295.png" alt="image-20230526160528295" style="zoom:67%;">

<p>字体.ttf格式</p>
<h5 id="Text-TMP组件"><a href="#Text-TMP组件" class="headerlink" title="Text TMP组件"></a>Text TMP组件</h5><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230526160937644.png" alt="image-20230526160937644" style="zoom:67%;">

<p>字体.SDF格式</p>
<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230526162202757.png" alt="image-20230526162202757" style="zoom:80%;">

<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230526162352685.png" alt="image-20230526162352685" style="zoom:80%;">

<h5 id="Image组件"><a href="#Image组件" class="headerlink" title="Image组件"></a>Image组件</h5><p>常用的图片格式为PNG，可以存储透明通道。</p>
<ul>
<li>图片素材的管理<ul>
<li><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230526161620578.png" alt="image-20230526161620578" style="zoom:67%;"></li>
</ul>
</li>
<li>参数<ul>
<li><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230526161749972.png" alt="image-20230526161749972" style="zoom:67%;"></li>
</ul>
</li>
</ul>
<h5 id="Button组件"><a href="#Button组件" class="headerlink" title="Button组件"></a>Button组件</h5><p><strong>普通Button</strong></p>
<p>Interactable可交互</p>
<p>Transition过渡模式</p>
<ul>
<li>Color Tint颜色过渡<ul>
<li><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230526163008977.png" alt="image-20230526163008977" style="zoom:80%;"></li>
</ul>
</li>
</ul>
<p><strong>TMP Button</strong></p>
<ul>
<li>跟普通button的区别在于子text物体的格式：普通和TMP两种格式</li>
</ul>
<p><strong>点击事件</strong></p>
<ul>
<li>点击按钮，触发事件，执行事件处理函数</li>
<li><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230526163512810.png" alt="image-20230526163512810" style="zoom:80%;"></li>
</ul>
<h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230526164636319.png" alt="image-20230526164636319" style="zoom:80%;">

<h5 id="TextMeshPro插件"><a href="#TextMeshPro插件" class="headerlink" title="TextMeshPro插件"></a>TextMeshPro插件</h5><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230526164203169.png" alt="image-20230526164203169" style="zoom:80%;">

<p><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230526164441402.png" alt="image-20230526164441402"></p>
<p>TMP中文字体文件的实质是<strong>图集</strong></p>
<h3 id="特效系统"><a href="#特效系统" class="headerlink" title="特效系统"></a>特效系统</h3><p>Unity的特效系统主要是</p>
<ul>
<li>粒子系统 Particle System</li>
<li>力场 Force Field</li>
<li>拖尾 Trail</li>
<li>线 Line</li>
</ul>
<h4 id="拖尾渲染器组件"><a href="#拖尾渲染器组件" class="headerlink" title="拖尾渲染器组件"></a>拖尾渲染器组件</h4><p><strong>参数</strong></p>
<ul>
<li>宽度设置</li>
<li>其他<ul>
<li><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230526170224474.png" alt="image-20230526170224474" style="zoom:80%;"></li>
</ul>
</li>
</ul>
<p><strong>材质</strong></p>
<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230526170434673.png" alt="image-20230526170434673" style="zoom:80%;">

<p><strong>调试面板</strong></p>
<p><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230526170622052.png" alt="image-20230526170622052"></p>
<p><strong>细节</strong></p>
<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230526170836210.png" alt="image-20230526170836210" style="zoom:80%;">





<h4 id="线渲染器"><a href="#线渲染器" class="headerlink" title="线渲染器"></a>线渲染器</h4><p>用途：绘制“特效线”，如激光，台球线，或各种辅助线。</p>
<p>基本使用</p>
<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527190643282.png" alt="image-20230527190643282" style="zoom:80%;">

<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527191836723.png" alt="image-20230527191836723" style="zoom:80%;">



<h3 id="音效系统"><a href="#音效系统" class="headerlink" title="音效系统"></a>音效系统</h3><p>各种音效</p>
<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527191958959.png" alt="image-20230527191958959" style="zoom:80%;">



<p>Unity内的音效系统，两大核心：</p>
<ul>
<li>播放音效</li>
<li>监听音效</li>
</ul>
<p>音效产生器：</p>
<ul>
<li>AudioSource<ul>
<li>参数：<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527193709932.png" alt="image-20230527193709932" style="zoom:80%;"></li>
<li><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527193727920.png" alt="image-20230527193727920" style="zoom:80%;"></li>
</ul>
</li>
</ul>
<p>音效文件：</p>
<ul>
<li>AudioClip</li>
</ul>
<p>音频监听器：</p>
<ul>
<li>AudioListener</li>
</ul>
<h3 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h3><hr>
<h4 id="Resource类"><a href="#Resource类" class="headerlink" title="Resource类"></a>Resource类</h4><ul>
<li>用于资源文件的加载</li>
<li>需要先创建&#x2F;Assets&#x2F;Resources文件夹存放资源文件</li>
<li>常用资源类型<ul>
<li><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527194338981.png" alt="image-20230527194338981" style="zoom:80%;"></li>
</ul>
</li>
</ul>
<p><strong>单个资源加载</strong></p>
<p><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527194551425.png" alt="image-20230527194551425"></p>
<p><strong>多个资源加载</strong></p>
<p><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527194745834.png" alt="image-20230527194745834"></p>
<h4 id="AudioSource"><a href="#AudioSource" class="headerlink" title="AudioSource"></a>AudioSource</h4><p><strong>AudioSource组件</strong></p>
<p>AudioSource类的.clip字段对应AudioSource组件的AudioClip参数</p>
<p>AudioSource组件的使用</p>
<p><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527195339288.png" alt="image-20230527195339288"></p>
<p><strong>AudioSource类</strong></p>
<ul>
<li>在指定位置播放小段音频（one shot）<ul>
<li><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527195604149.png" alt="image-20230527195604149" style="zoom:80%;"></li>
<li><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527195634797.png" alt="image-20230527195634797" style="zoom:80%;"></li>
</ul>
</li>
</ul>
<h4 id="游戏物体设置"><a href="#游戏物体设置" class="headerlink" title="游戏物体设置"></a>游戏物体设置</h4><p><strong>两类资源</strong></p>
<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527200104757.png" alt="image-20230527200104757" style="zoom:80%;">

<ul>
<li>纯资源</li>
<li>GameObject资源<ul>
<li>需要多一步实例化instantiate，相当于new出来</li>
</ul>
</li>
</ul>
<h5 id="实例化游戏物体"><a href="#实例化游戏物体" class="headerlink" title="实例化游戏物体"></a>实例化游戏物体</h5><p><strong>API</strong></p>
<p><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527200451065.png" alt="image-20230527200451065"></p>
<p><strong>预制体</strong></p>
<p><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527200739291.png" alt="image-20230527200739291"></p>
<p><strong>实例化操作的作用</strong></p>
<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527200913883.png" alt="image-20230527200913883" style="zoom:80%;">





<h5 id="销毁游戏物体"><a href="#销毁游戏物体" class="headerlink" title="销毁游戏物体"></a>销毁游戏物体</h5><ul>
<li>实例化和销毁对游戏物体的出生和死亡</li>
<li>比在如战死后进行销毁</li>
</ul>
<p><strong>API</strong></p>
<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527201131059.png" alt="image-20230527201131059" style="zoom:80%;">



<h5 id="添加-x2F-移除组件"><a href="#添加-x2F-移除组件" class="headerlink" title="添加&#x2F;移除组件"></a>添加&#x2F;移除组件</h5><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527201356611.png" alt="image-20230527201356611" style="zoom:80%;">



<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527201424529.png" alt="image-20230527201424529" style="zoom:80%;">



<p>移除方式：</p>
<ul>
<li>使用GetComponent&lt;T&gt;()获取组件</li>
<li>使用Destroy()销毁组件</li>
</ul>
<h4 id="脚本生命周期"><a href="#脚本生命周期" class="headerlink" title="脚本生命周期"></a>脚本生命周期</h4><p><strong>三种状态</strong></p>
<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527201712437.png" alt="image-20230527201712437" style="zoom:80%;">



<p><strong>脚本生命周期</strong></p>
<p><strong>GameObject生命周期</strong></p>
<p><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxNDgwODM5,size_16,color_FFFFFF,t_70.png" alt="img"></p>
<p><strong>脚本生命周期</strong>（MonoBehaviour类的子类）</p>
<p><strong>说明</strong></p>
<p>开启状态：</p>
<p><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527202238558.png" alt="image-20230527202238558"></p>
<ul>
<li>awake和start只会执行一次</li>
</ul>
<p>进行中状态：</p>
<p><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527202645563.png" alt="image-20230527202645563"></p>
<p>结束状态：</p>
<p><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527202909950.png" alt="image-20230527202909950"></p>
<p><strong>其他问题</strong></p>
<p>Awake和Start</p>
<p><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527203357409.png" alt="image-20230527203357409"></p>
<ul>
<li>A脚本调用B脚本为例，B脚本的初始化操作要放在Awake内完成，然后A脚本在Start内查找B脚本并调用其方法。</li>
</ul>
<h4 id="Invoke函数"><a href="#Invoke函数" class="headerlink" title="Invoke函数"></a>Invoke函数</h4><p>延迟调用、重复调用</p>
<p><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527205946049.png" alt="image-20230527205946049"></p>
<p><strong>API</strong></p>
<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527210036874.png" alt="image-20230527210036874" style="zoom:80%;">

<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527210217620.png" alt="image-20230527210217620" style="zoom:80%;">

<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527210254671.png" alt="image-20230527210254671" style="zoom:80%;">





<h4 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h4><p><strong>介绍</strong></p>
<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527210709676.png" alt="image-20230527210709676" style="zoom:80%;">

<ul>
<li>协程方法</li>
<li>协程操作：开启，关闭</li>
</ul>
<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527210756780.png" alt="image-20230527210756780" style="zoom:80%;">

<ul>
<li>Unity的线程比较特殊，大多数内容在主线程中执行。</li>
<li>子线程无法调用引擎相关API，于是采用协程来替代线程。</li>
</ul>
<p><strong>语法</strong></p>
<ul>
<li>协程方法的编写<ul>
<li><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527211004688.png" alt="image-20230527211004688" style="zoom:80%;"></li>
</ul>
</li>
<li>开启协程<ul>
<li><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527211644562.png" alt="image-20230527211644562" style="zoom:80%;"></li>
</ul>
</li>
<li>终止协程<ul>
<li><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527211809047.png" alt="image-20230527211809047" style="zoom:80%;"></li>
</ul>
</li>
</ul>
<p><strong>应用</strong></p>
<ul>
<li>物体移动，每帧移动一点点<ul>
<li>while循环配合yield return null</li>
<li><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527213237458.png" alt="image-20230527213237458" style="zoom:80%;"></li>
</ul>
</li>
<li>。</li>
<li>。</li>
<li>。</li>
</ul>
<p><strong>生命周期</strong></p>
<p><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527213458805.png" alt="image-20230527213458805"></p>
<ul>
<li>不使用协程，while循环的代码会在1帧内完成。</li>
<li>使用协程，可以达到每帧分步完成的效果</li>
</ul>
<p><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527213807780.png" alt="image-20230527213807780"></p>
<p><strong>协程的运行时机</strong></p>
<ul>
<li><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527213329201.png" alt="image-20230527213329201"></li>
<li><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527213339744.png" alt="image-20230527213339744"></li>
</ul>
<p><strong>由其他脚本调用的情况</strong></p>
<ul>
<li>原始：其他脚本使用该脚本的引用来调用StartCorotine</li>
<li>常用：该脚本封装好协程开启和关闭的代码，供其他脚本调用</li>
</ul>
<p><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230527214016638.png" alt="image-20230527214016638"></p>
<p><strong>协程与Invoke对比</strong></p>
<ul>
<li>相同之处<ul>
<li>都是MonoBehaviour类中定义的公开方法</li>
<li>都可以实现延迟调用</li>
</ul>
</li>
<li>不同之处<ul>
<li>协程可以动态传递参数，Invoke只能使用无参方法</li>
<li>协程的方法体内可以多次延迟，Invoke只能在开启时延迟</li>
</ul>
</li>
</ul>
<h4 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h4><p>问题：</p>
<p>对于同一个游戏物体的脚本组件 ——</p>
 <img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230529151745528.png" alt="image-20230529151745528" style="zoom: 67%;">

<p>解决：</p>
<ul>
<li>给同级、子级脚本发送消息</li>
</ul>
<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230529151838922.png" alt="image-20230529151838922" style="zoom:67%;">

<ul>
<li>给同级、子级脚本广播发送消息</li>
</ul>
<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230529152349402.png" alt="image-20230529152349402" style="zoom: 67%;">

<ul>
<li>给父级脚本发送消息</li>
</ul>
<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230529161205066.png" alt="image-20230529161205066" style="zoom:67%;">





<h4 id="GameObject查找"><a href="#GameObject查找" class="headerlink" title="GameObject查找"></a>GameObject查找</h4><p><strong>全局名称查找</strong></p>
<ul>
<li><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230529162445884.png" alt="image-20230529162445884" style="zoom:50%;"></li>
<li><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230529162601624.png" alt="image-20230529162601624" style="zoom:50%;"> 
- 如果要持有隐藏的物体：<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230529163003658.png" alt="image-20230529163003658" style="zoom:50%;"></li>
<li>含有重名的游戏物体的情况：<ul>
<li><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230529163142987.png" alt="image-20230529163142987" style="zoom:50%;"></li>
</ul>
</li>
</ul>
<p>采用路径查找</p>
<ul>
<li><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230529163233301.png" alt="image-20230529163233301" style="zoom: 50%;"></li>
</ul>
<p><strong>全局标签查找</strong></p>
 <img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230529163616238.png" alt="image-20230529163616238" style="zoom:50%;">

<p><strong>API</strong></p>
<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230529163710271.png" alt="image-20230529163710271" style="zoom:67%;">







<h4 id="Transform查找"><a href="#Transform查找" class="headerlink" title="Transform查找"></a>Transform查找</h4><p><strong>查找子物体</strong></p>
 <img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230529165243944.png" alt="image-20230529165243944" style="zoom: 50%;">

 <img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230529165407539.png" alt="image-20230529165407539" style="zoom:50%;">



<p><strong>查找子物体组件</strong></p>
 <img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230529165518177.png" alt="image-20230529165518177" style="zoom:50%;">

<p>可以获取多层嵌套的子物体及其组件</p>
 <img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230529165757497.png" alt="image-20230529165757497" style="zoom:50%;">





<p><strong>两种查找的对比</strong></p>
<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230529211353535.png" alt="image-20230529211353535" style="zoom:80%;">



<h3 id="物理射线"><a href="#物理射线" class="headerlink" title="物理射线"></a>物理射线</h3><ul>
<li>可以与collider发生碰撞</li>
<li>从<strong>起点</strong>往<strong>指定方向</strong>无限延申的物理射线</li>
</ul>
<h4 id="创建物理射线"><a href="#创建物理射线" class="headerlink" title="创建物理射线"></a>创建物理射线</h4><ul>
<li>射线结构体：<strong>Ray</strong></li>
<li>创建方式：<ul>
<li>直接new一个Ray对象</li>
<li>通过摄像机相关API构造<ul>
<li><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230531153113688.png" alt="image-20230531153113688" style="zoom:67%;"></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>主摄像机</strong></p>
 <img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230531152955214.png" alt="image-20230531152955214" style="zoom:67%;">

<h4 id="检测物理射线"><a href="#检测物理射线" class="headerlink" title="检测物理射线"></a>检测物理射线</h4><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230531153432898.png" alt="image-20230531153432898" style="zoom:67%;">



<p><strong>绘制线段</strong></p>
<ul>
<li>Scene中显示射线</li>
</ul>
 <img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230531154612018.png" alt="image-20230531154612018" style="zoom:67%;">

<ul>
<li>游戏中的射线</li>
</ul>
 <img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230531154825692.png" alt="image-20230531154825692" style="zoom:67%;">



<h3 id="插值运算"><a href="#插值运算" class="headerlink" title="插值运算"></a>插值运算</h3><h4 id="Time时间类"><a href="#Time时间类" class="headerlink" title="Time时间类"></a>Time时间类</h4><p><strong>API</strong></p>
 <img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230531173033800.png" alt="image-20230531173033800" style="zoom:67%;">



<h4 id="Mathf数学类"><a href="#Mathf数学类" class="headerlink" title="Mathf数学类"></a>Mathf数学类</h4> <img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230531174106687.png" alt="image-20230531174106687" style="zoom:50%;">

<ul>
<li>角度与弧度转换<ul>
<li><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230531174038979.png" alt="image-20230531174038979" style="zoom: 50%;"></li>
</ul>
</li>
</ul>
<h4 id="插值运算-1"><a href="#插值运算-1" class="headerlink" title="插值运算"></a>插值运算</h4><p>确定两个参数A和B，从A平滑过渡到B</p>
 <img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230531174411627.png" alt="image-20230531174411627" style="zoom: 67%;">

<p><strong>使用</strong>：</p>
<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230531174502851.png" alt="image-20230531174502851" style="zoom:67%;">

 <img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230531174606819.png" alt="image-20230531174606819" style="zoom: 50%;">

 <img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230531174714699.png" alt="image-20230531174714699" style="zoom:50%;">

 <img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230531174741231.png" alt="image-20230531174741231" style="zoom:50%;">



<p><strong>采用累加插值系数解决前快后慢</strong></p>
 <img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230531212916531.png" alt="image-20230531212916531" style="zoom:67%;">



<p><strong>其他插值API</strong></p>
<ul>
<li>向量插值<ul>
<li><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230531213456923.png" alt="image-20230531213456923" style="zoom:50%;"></li>
</ul>
</li>
<li>四元数插值<ul>
<li><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230531213735772.png" alt="image-20230531213735772" style="zoom:50%;"></li>
</ul>
</li>
</ul>
<h3 id="Unity核心类的继承关系"><a href="#Unity核心类的继承关系" class="headerlink" title="Unity核心类的继承关系"></a>Unity核心类的继承关系</h3><img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230531214121060.png" alt="image-20230531214121060">

<p>Unity安全模式</p>
<img src="/2023/05/26/Unity%E5%85%A5%E9%97%A8-%E4%BA%8C/image-20230531220339763.png" alt="image-20230531220339763" style="zoom:67%;">
]]></content>
      <categories>
        <category>游戏开发</category>
        <category>客户端</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>git简单入门</title>
    <url>/2023/02/12/git%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="Git简单入门"><a href="#Git简单入门" class="headerlink" title="Git简单入门"></a>Git简单入门</h1><p>基本命令</p>
<p>git </p>
<p><img src="/2023/02/12/git%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/image-20230212074446947.png" alt="image-20230212074446947"></p>
<p>更多命令</p>
<p><img src="/2023/02/12/git%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/image-20230212074320214.png" alt="image-20230212074320214"></p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>用不同电脑写hexo博客</title>
    <url>/2022/07/11/%E4%B8%8D%E5%90%8C%E7%94%B5%E8%84%91%E5%86%99hexo%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="基于GitHub双分支方法"><a href="#基于GitHub双分支方法" class="headerlink" title="基于GitHub双分支方法"></a>基于GitHub双分支方法</h1><h2 id="1-在每次编辑之前"><a href="#1-在每次编辑之前" class="headerlink" title="1. 在每次编辑之前"></a>1. 在每次编辑之前</h2><hr>
<p>需要先 <code>git pull</code> 拉取hexo分支的内容到本地，即同步更新，然后再进行上述操作。</p>
<hr>
<p><br><br><br></p>
<h2 id="2-修改本地文件和编辑博客内容"><a href="#2-修改本地文件和编辑博客内容" class="headerlink" title="2. 修改本地文件和编辑博客内容"></a>2. 修改本地文件和编辑博客内容</h2><hr>
<p>Windows下用 git bash 打开本地文件夹</p>
<p>然后就是 <code>hexo new [layout] &lt;title&gt;</code> 创建新文件</p>
<img src="/2022/07/11/%E4%B8%8D%E5%90%8C%E7%94%B5%E8%84%91%E5%86%99hexo%E5%8D%9A%E5%AE%A2/07/11/%E4%B8%8D%E5%90%8C%E7%94%B5%E8%84%91%E5%86%99hexo%E5%8D%9A%E5%AE%A2/1.png" class>

<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/156915260">相关hexo操作</a></p>
</blockquote>
<blockquote>
<p><a href="https://markdown.com.cn/basic-syntax/">markdown语法</a></p>
</blockquote>
<blockquote>
<p>图片插入格式 <code>&#123;% asset_img example.jpg This is an example image %&#125;</code></p>
</blockquote>
<hr>
<p><br><br><br></p>
<h2 id="3-编辑和修改完成之后"><a href="#3-编辑和修改完成之后" class="headerlink" title="3. 编辑和修改完成之后"></a>3. 编辑和修改完成之后</h2><hr>
<p>先归并到hexo分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;xxx&quot;&#x27;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<p>再用</p>
<p> <code>hexo d -g</code></p>
<p> 部署到master分支中的网页上。</p>
<hr>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>初探GPU运作方式及特点</title>
    <url>/2023/06/01/%E5%88%9D%E6%8E%A2GPU%E8%BF%90%E4%BD%9C%E6%96%B9%E5%BC%8F%E5%8F%8A%E7%89%B9%E7%82%B9/</url>
    <content><![CDATA[<h1 id="GPU的特点以及与CPU有何不同"><a href="#GPU的特点以及与CPU有何不同" class="headerlink" title="GPU的特点以及与CPU有何不同"></a>GPU的特点以及与CPU有何不同</h1><h2 id="New-Bing-的回答"><a href="#New-Bing-的回答" class="headerlink" title="New Bing 的回答"></a>New Bing 的回答</h2><p>GPU和CPU的区别在于它们的设计目标不同。</p>
<ul>
<li>CPU需要<strong>很强的通用性</strong>来处理<strong>各种不同的数据类型</strong>，同时又要逻辑判断又会引入大量的<strong>分支跳转和中断</strong>的处理。这些都使得CPU的内部结构异常复杂。</li>
<li>而GPU面对的则是<strong>类型高度统一的</strong>、<strong>相互无依赖的</strong>大规模数据和<strong>不需要被打断的</strong>纯净的计算环境。</li>
<li>于是CPU和GPU就呈现出非常不同的架构。GPU采用了<u>数量众多的计算单元和超长的流水线</u>，但只有<u>非常简单的控制逻辑</u>并<u>省去了Cache</u><a href="https://blog.csdn.net/shuiyixin/article/details/82915378">1</a>。</li>
</ul>
<p>简单来说，&#96;GPU是专门为PC或者嵌入式设备进行<strong>图像运算工作</strong>的微处理器，而CPU则是一台计算机的<strong>控制和运算核心</strong>，它主要功能便是解释计算机发出的指令以及处理电脑软件中的大数据<a href="https://zhidao.baidu.com/question/422288800.html">2</a>。</p>
<span id="more"></span>

<p>相关链接：</p>
<p><a href="https://zhuanlan.zhihu.com/p/592006016">聊聊GPU与CPU的区别 - 知乎 (zhihu.com)</a></p>
<h2 id="架构对比"><a href="#架构对比" class="headerlink" title="架构对比"></a>架构对比</h2><p>CPU and GPU</p>
<p> <img src="/2023/06/01/%E5%88%9D%E6%8E%A2GPU%E8%BF%90%E4%BD%9C%E6%96%B9%E5%BC%8F%E5%8F%8A%E7%89%B9%E7%82%B9/image-20230601192543579.png" alt="image-20230601192543579" style="zoom: 55%;"> <img src="/2023/06/01/%E5%88%9D%E6%8E%A2GPU%E8%BF%90%E4%BD%9C%E6%96%B9%E5%BC%8F%E5%8F%8A%E7%89%B9%E7%82%B9/image-20230601192628892.png" alt="image-20230601192628892" style="zoom: 60%;"></p>
<img src="/2023/06/01/%E5%88%9D%E6%8E%A2GPU%E8%BF%90%E4%BD%9C%E6%96%B9%E5%BC%8F%E5%8F%8A%E7%89%B9%E7%82%B9/image-20230601194723789.png" alt="image-20230601194723789" style="zoom:67%;"> 

<ul>
<li>CPU 基于低延时的设计：</li>
<li>CPU有强大的ALU（算术运算单元）,它可以在很少的时钟周期内完成算术计算。<ul>
<li>当今的CPU可以达到64bit 双精度。执行双精度浮点源算的加法和乘法只需要1～3个时钟周期。CPU的时钟周期的频率是非常高的，达到1.532～3gigahertz(千兆HZ, 10的9次方).大的缓存也可以降低延时。保存很多的数据放在缓存里面，当需要访问的这些数据，只要在之前访问过的，如今直接在缓存里面取即可。</li>
<li>复杂的逻辑控制单元。当程序含有多个分支的时候，它通过提供分支预测的能力来降低延时。数据转发。 当一些指令依赖前面的指令结果时，数据转发的逻辑控制单元决定这些指令在pipeline中的位置并且尽可能快的转发一个指令的结果给后续的指令。这些动作需要很多的对比电路单元和转发电路单元。</li>
</ul>
</li>
</ul>
 <img src="/2023/06/01/%E5%88%9D%E6%8E%A2GPU%E8%BF%90%E4%BD%9C%E6%96%B9%E5%BC%8F%E5%8F%8A%E7%89%B9%E7%82%B9/image-20230601194746798.png" alt="image-20230601194746798" style="zoom:67%;">

<ul>
<li>GPU是基于大的吞吐量设计。<ul>
<li>GPU的特点是有很多的ALU和很少的cache. 缓存的目的不是保存后面需要访问的数据的，这点和CPU不同，而是为thread提高服务的。如果有很多线程需要访问同一个相同的数据，缓存会合并这些访问，然后再去访问dram（因为需要访问的数据保存在dram中而不是cache里面），获取数据后cache会转发这个数据给对应的线程，这个时候是数据转发的角色。但是由于需要访问dram，自然会带来延时的问题。</li>
</ul>
</li>
<li>GPU的控制单元（左边黄色区域块）可以把多个的访问合并成少的访问。<ul>
<li>GPU的虽然有dram延时，却有非常多的ALU和非常多的thread. 为啦平衡内存延时的问题，我们可以中充分利用多的ALU的特性达到一个非常大的吞吐量的效果。尽可能多的分配多的Threads.通常来看GPU ALU会有非常重的pipeline就是因为这样。所以与CPU擅长逻辑控制，串行的运算。和通用类型数据运算不同，GPU擅长的是大规模并发计算，这也正是密码破解等所需要的。所以GPU除了图像处理，也越来越多的参与到计算当中来。</li>
</ul>
</li>
</ul>
<h3 id="GPU的由来"><a href="#GPU的由来" class="headerlink" title="GPU的由来"></a><strong>GPU的由来</strong></h3><p>计算机对图像进行实时渲染， 一般需要经过<strong>图形流水线</strong>的过程：<code>顶点处理-&gt;图元处理-&gt;栅格化-&gt;片段处理-&gt;像素操作</code>, 期间需要大量的计算，比如 640×480的分辨率的屏幕，为了显示游戏画面，大概有30万个像素需要渲染 ，为了让人眼看到画面动起来，其不像电影一样只需要24帧，至少需要60帧，即每秒我们需要完成 1800 万次单个像素的渲染，每个像素都需要经过<strong>图形流水线过程</strong>，需要耗费大量资源。</p>
<p>由于图像渲染的流程是固定的，通过硬件来解决这个问题，那就设计一个不需要考虑CPU的流水线停顿、乱序执行、 分支预测、内存管理、IO等等的各类问题的芯片，这其实就是GPU。</p>
<h3 id="GPU优化设计思路"><a href="#GPU优化设计思路" class="headerlink" title="GPU优化设计思路"></a>GPU优化设计思路</h3><p>现代的 GPU 为了图形渲染、深度学习上有相较于CPU更强大的性能，做出来哪些设计上的优化：</p>
<ol>
<li>由于GPU不需要考虑CPU的流水线停顿、乱序执行、分支预测等等的各类问题，只需要流式计算的功能，所以内部许多CPU的电路是不需要的，这样就节约了大量空间</li>
<li>由于GPU相比CPU电路就简单多了，这样就可以塞入更多的电路，即更多的”核”，他们都是<strong>并行</strong>的，能够极大提升性能</li>
<li>除了塞更多的核，为了更大程度提升GPU的性能，还采用 <strong>SIMT</strong> 技术，可以把多条数据，交给不同的线程去处理。类似于CPU中，SIMD技术，但是其只能一次性取出了固定长度的多个数据，放到寄存器里面，用一个指令去执行</li>
<li>GPU同样采用<strong>超线程</strong>技术，当任务计算遇到停顿的时候，调度一些别的计算任务给当前的 ALU ，这样就需要保证核心中提供更多的执行上下文给ALU算数计算单元使用</li>
</ol>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>CPU和GPU因为最初用来处理的任务就不同，所以设计上有不小的区别，而某些任务和GPU最初用来解决的问题比较相似，所以用GPU来算了，GPU的运算速度取决于雇了多少小学生，CPU的运算速度取决于请了多么厉害的教授，教授处理复杂任务的能力是碾压小学生的，但是对于没那么复杂的任务，还是顶不住人多。</p>
<p>当然现在的GPU也能做一些稍微复杂的工作了，相当于升级成初中生高中生的水平，但还需要CPU来把数据喂到嘴边才能开始干活，究竟还是靠CPU来管的。</p>
]]></content>
      <categories>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>GPU, 图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>初探图形流水线（渲染管线）</title>
    <url>/2023/06/01/%E5%88%9D%E6%8E%A2%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E6%B5%81%E6%B0%B4%E7%BA%BF%EF%BC%88%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%EF%BC%89/</url>
    <content><![CDATA[<h1 id="什么是图形流水线"><a href="#什么是图形流水线" class="headerlink" title="什么是图形流水线"></a>什么是图形流水线</h1><p>链接：</p>
<p><a href="https://zhuanlan.zhihu.com/p/137780634">猴子也能看懂的渲染管线（Render Pipeline） - 知乎 (zhihu.com)</a></p>
<p>一图流：</p>
<img src="/2023/06/01/%E5%88%9D%E6%8E%A2%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E6%B5%81%E6%B0%B4%E7%BA%BF%EF%BC%88%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%EF%BC%89/image-20230601195513975.png" alt="image-20230601195513975" style="zoom:80%;">

<span id="more"></span>

<img src="/2023/06/01/%E5%88%9D%E6%8E%A2%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E6%B5%81%E6%B0%B4%E7%BA%BF%EF%BC%88%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%EF%BC%89/image-20230602162311045.png" alt="image-20230602162311045" style="zoom:80%;">



<p>相关概念：</p>
<ul>
<li>显存<ul>
<li>GPU显存是一种高速缓存，用于存储图形处理器需要的数据。GPU显存是专门为图形处理器设计的，因此它具有比CPU内存更高的带宽和更低的延迟。GPU显存通常用于存储<strong>纹理、顶点数据、渲染目标和其他与图形相关</strong>的数据。</li>
</ul>
</li>
<li>渲染管线<ul>
<li>渲染管线是一种将<strong>3D场景转换为2D图像</strong>的过程，它包括<strong>几何处理、光照计算、纹理映射等多个阶段</strong>。这些阶段可以被分为<strong>顶点处理</strong>、<strong>光栅化</strong>和<strong>像素处理</strong>三个部分。</li>
</ul>
</li>
<li>渲染图元<ul>
<li>渲染图元是指在图形处理流水线中的基本图形单元，例如点、线和三角形。在渲染过程中，这些基本图形单元被组合成更复杂的几何体，例如多边形和曲面。这些几何体可以被进一步处理，例如进行光照计算、纹理映射等操作。最终，这些几何体被转换为像素，并在屏幕上显示出来。</li>
</ul>
</li>
<li>顶点<ul>
<li>在图形处理流水线中，顶点是指几何体的基本构成单元。在三维图形中，顶点通常由三个浮点数表示，分别表示顶点的x、y和z坐标。在渲染过程中，顶点被组合成更复杂的几何体，例如多边形和曲面。这些几何体可以被进一步处理，例如进行光照计算、纹理映射等操作。最终，这些几何体被转换为像素，并在屏幕上显示出来。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>图形学, 渲染管线</tag>
      </tags>
  </entry>
  <entry>
    <title>珍惜时间</title>
    <url>/2023/02/12/%E5%90%B8%E5%8F%96%E6%95%99%E8%AE%AD/</url>
    <content><![CDATA[<p><a href="https://www.bilibili.com/video/BV1YR4y187Dw/?spm_id_from=333.1007.tianma.2-1-4.click&vd_source=c36c31c15822f9e983f85418bfdcddd9">如何欺骗大脑爱上做困难的事 远离超量多巴胺让你沉迷学习</a></p>
<p>现在是2023年2月12日，凌晨1：33…</p>
<p>临近大三下学期开学，目前三线作战，一条线是考试复习，一条线是SRP项目，一条线是实习秋招。感觉时间非常紧张，精神压力也非常大。甚至考试上已经放弃了某一难啃的科目。</p>
<p>那么时间为什么又会如此紧迫？</p>
<span id="more"></span>

<br>

<br>

<br>

<p>这里需要展开一场自我反思</p>
<br>

<br>

<br>

<br>

<h2 id="拷打FW"><a href="#拷打FW" class="headerlink" title="拷打FW"></a>拷打FW</h2><h3 id="一事无成"><a href="#一事无成" class="headerlink" title="一事无成"></a>一事无成</h3><p>其实我是很早就了解到大学应该做什么的（可惜不知道具体该如何去做）。在<strong>大一上学期，差不多2020年10月份的时候</strong>，已经有学长指明了三条路：1.竞赛（CTF，ACM…） 2.工作（尽早去实习） 3.绩点科研（搞成绩以及进实验室）</p>
<br>

<p><strong>竞赛：</strong></p>
<p>那时候又刚好听了CTF的讲座，于是心中默认自己以后要走安全路线。可惜我太高估自己了，选择了pwn路线来入门CTF。因为很多前置知识都没学过，也不知道要去学，去哪学，也就没有一个循序渐进的学习过程，所以就学不下去了。</p>
<p>连一点语言基础、操作系统方面的知识都没有，所以看那些什么虚拟地址空间、段、函数引用表等词汇完全没有概念，即使是到网上查资料看视频，也很难消化进去。比起艰难地去理解一些新概念，打游戏实在爽快多了，所以我也就没有学下去了。（现在想想，当时也不太会检索信息）</p>
<br>

<p>到了大二自己还是有一点这方面的想法，也稍微付出了多一点的时间，浅浅地捡了一点东西，去应付招新的事。结果，花的时间和学的东西还是太少了，只能用特殊方式入队。</p>
<p>入队后，又没有驱动力去学了，就一直搁置着，后面也没有参加过一次比赛。</p>
<br>

<p>现在回想，也许我应该选一个简单一点的方向，或者是，学的时候直接从解题入手，边做题边学新概念。在学习过程中，以解出题目作为激励，或许我就能学的下去，从而形成一个良性循环。</p>
<p>不过还是得怪自己太懒了。</p>
<p><br><br></p>
<p><strong>工作：</strong></p>
<p>当时，我默认自己不读研，本科毕业就工作。所以我应该是尽早往工作路线靠拢，但是，那会儿实在是不知道要学什么方向。</p>
<p><strong>开始的开始</strong></p>
<p>真正开始学习计算机之前，也就是中学时期，我因为喜欢玩各种单机游戏，就曾有过日后做一名游戏开发者的想法。在高考完的暑假，我也买了一本C语言的教材。可惜当时并不知道怎么学习这些东西，还按照高中的学习方式，学一点就记一点（比如C语言的关键字还要列出来然后去背…），导致效率很低。于是没学多少就没一点兴趣了（好像也没那么少，可惜没有进度没有推到内存管理和网络编程相的部分）。unity也不知道因为什么始终没有开始学。</p>
<blockquote>
<p>翻看了那时候的笔记，感觉那是高考结束到目前为止，自己最认真学习的一段时间了，泪目啊</p>
<p>好恨啊，如果当时的学习方式对了，后面这几年应该会顺利很多</p>
</blockquote>
<p>又因为中学过得太憋屈了，加上自控力差，高考完的那个暑假就疯狂的玩。当时我对未来十分憧憬、充满动力，然而这些还是没能变成我的自制力。</p>
<br>

<p><strong>路线</strong></p>
<p>到后来，每一年，每一学期，都会更新自己的方向。一会儿是游戏开发，一会儿是Linux C++，一会儿是信息安全，一会儿是区块链。看到网上的一些信息，就会影响自己的心态，忧虑这个那个。再加上我的学习方式不正确，就导致什么都没有学好。</p>
<br>

<p><strong>数据结构与算法</strong></p>
<p>大一寒假（两年前），有学长告诉我们得趁早刷题，可惜我当时不了解这方面的重要性，以及该如何去学，答案稍微看不懂，就不想学了。也不知道原来平时C++上机的内容，就是一些数据结构和算法题。每次只能看着大神们30分钟解决战斗，潇洒离开机房，而自己只有羡慕的份。</p>
<p>在数据结构和算法题这方面，后面又是因为学习方式不对，搁置了很长一段时间（还有自己懒惰）。</p>
<p>直到最近换了方式，先分类，然后边做题边看别人的总结，才顺利起来。</p>
<br>

<p><strong>编程语言</strong></p>
<p>这个应该是我大三之前就要掌握好的。</p>
<p>大一的时候决定要学C++，可惜，学了基本语法和一点点面向对象、泛型编程之后就停了，也就是学完课本上的一点东西就停了。还记得两年前的寒假，我在艰难地翻看C++课本，因为太关注那些语法规则，那些细枝末节，导致因小失大，学得很难受而学不下去。</p>
<p>又因为课本上没有STL的内容，STL的东西也没学到。</p>
<p>也不知道有系统编程，网络编程这些东西，虽然那会儿还没学操作系统和计算机网络。我要是能够意识到这两点，就应该早点自学操作系统和计算机网络，不用等到大二下学期才去学。</p>
<p>还有应该面向项目来学习编程语言，在学语言的同时，又能掌握工程技能。可惜自己太懒，浅学即止。</p>
<p>到现在因为要找实习找工作，需要项目经验，才从网上找视频一步一步跟着构建。对了，在项目选择这方面，我又浪费了不少时间。</p>
<p>除了做项目，C++其实还有好多需要学的，哎…</p>
<br>

<br>

<p><strong>本科学习</strong></p>
<p>这是我在选择摆烂的同时，又不愿放弃的东西。</p>
<p>大一上学期玩得很嗨，把学分最高的两门数学可都丢了。</p>
<p>大一下学期，稍微知耻而后勇了一点，但是还是把学分最高的数学丢了。并且该学好的专业课，也没好好学。</p>
<p>大二上学期（大一虽然浪飞了，但是分流后的排名也不是说毫无保研希望），于是就想在这方面努力一点，最后这学期的成绩总体也还不错，但还是够高，某些科目拖了后腿。分析原因，主要还是因为自己贪玩，没有花足够的时间学习。</p>
<p>大二下学期，明显后劲不足了，但是三门专业课都还行，就计算机网络稍微拖了一点后腿（这时候还没意识到计网的重要性），政治课成绩掉大分。</p>
<p>大三上学期，现在正在复习的。其实一开始还是打算好好学，然而还是第n次虎头蛇尾。有一个原因是因为自己选的课太多，但也只是我的借口罢了。</p>
<br>

<p>为什么说不愿放弃：因为对于主要科目，我在学习的时候都会做好很多笔记，包括大一被我丢掉的数学分析、线性代数。</p>
<p>为什么又说是摆烂：虽然做了笔记，但是，就仅限于笔记。该刷题的科目，我几乎都没有刷题；该深入实践的科目，我都是应付任务。</p>
<p>最后成绩不上不下，不下是因为我确实学了，不上是因为我没有花更多时间去加强我学的东西。</p>
<p>其实想要分数更高，只要再多刷一点题就行了，笔记甚至也可以不做。而我在笔记上面花费了大量时间，最后也没有好好利用笔记去提高分数（但保住了下限），只能说怪谁呢？怪自己SB，认命了。</p>
<br>

<br>

<br>

<br>

<h3 id="时间都去哪了"><a href="#时间都去哪了" class="headerlink" title="时间都去哪了"></a>时间都去哪了</h3><p>上了大学后，我生活的各项内容占比，大概是：</p>
<p>（计算方式： 实际时间*权值）</p>
<ol>
<li>打游戏</li>
<li>踢球</li>
<li>刷视频，刷知乎</li>
<li>学习</li>
</ol>
<br>

<p>这个权值，可以认为是实际做事时的优先级</p>
<p>权值排行：</p>
<p>top1 踢球</p>
<p>top2 打游戏</p>
<p>top3 刷视频，刷知乎</p>
<p>top4 学习</p>
<p>而我认为的，正确的优先级排行应该是：</p>
<p>top1 学习</p>
<p>top2 踢球</p>
<p>top3 打游戏</p>
<p>top4 刷视频，刷知乎</p>
<br>

<p>实际时间排行:</p>
<ol>
<li>学习（上课）</li>
<li>打游戏</li>
<li>踢球</li>
<li>学习（课后）or 刷视频，刷知乎</li>
</ol>
<br>

<br>

<p><strong>关于游戏：</strong></p>
<p>有很多个晚上，我在宿舍里快乐开黑打 LOL ，可以从六七点打到九点十点，或者是从九点十点，打倒十二点断网。如果是白天，可以打一整个下午。只要是开始了游戏，就会持续很久，没有说打一把两把就关了的。除了LOL，又有很多时间贡献给了 Planeside2，骑马与砍杀，饥荒……</p>
<p>我知道自己深陷其中，也尝试过很多次物理戒断，但是一直不能解决这个问题。把这个游戏卸载了，过段时间就会去玩没有卸载地游戏。把所有游戏都卸载了，过段时间又会忍不住重新下回来一个。每次破戒，都会破得很彻底。</p>
<p>也许根本原因在于自制力不足，我习惯了中学时期的种种约束，现在给予了我足够的自由，我却不能够合理地去发展。</p>
<br>

<p><strong>关于踢球：</strong></p>
<p>虽然说运动强身健体，但是踢球确实占据了我不少时间和精力。每次踢球，一般是从四五点，踢到六七点，然后吃饭、洗澡、歇息，一晃就八点多九点多，也快半天时间。而且踢完球了，一般也提不起学习的念头，就又是游戏，短视频…</p>
<p>一周多则踢个3次4次，少则1次2次，时间也就这么消失了。</p>
<br>

<p><strong>关于刷视频：</strong></p>
<p>这个没什么好说的，手机打开，只要一点进去，时间就消失了。尤其是微信视频号，毫无营养的视频非常多，但却能让我在半夜刷上一两个小时。因为太容易点到这个玩意儿了，现在我已经把视频号给撤了。</p>
<p>另外就是B站，知乎…很多没意义没营养的内容，都消耗了我不少时间。并且，知乎的很多负能量在不经意间击碎了我对未来的憧憬，陡增焦虑。</p>
<br>

<p><strong>剖析每一天的时间：</strong></p>
<p>每学期都有一段时间课比较多，一段时间没什么课</p>
<ul>
<li>有课：获得逃课技能之前，上完课之后的时间，几乎都不想学习。习得逃课技能之后，该逃不该逃的课也都逃过了，逃了之后有去自学的，也有去游戏人生的，还有去踢球的…</li>
<li>没课：没课一般是中午起床，吃个饭之后就一点多了。这个时候要么会犯困（奇了怪了），要么没忍住点开了游戏，通常来说一下午就又没了。如果衔接踢球的话，这一天就没了。衔接学习的话，多半是在完成作业什么的，完成任务罢了。到了比较晚的时候，就轮到短视频、新媒体什么的来抢占我的时间了。</li>
</ul>
<br>

<p><strong>再仔细回想，发现我用来学习的时间几乎都在深夜。好像只有在这个时候我才能保持专注，才能进入状态。</strong></p>
<p>浪费了一天的时间后，夜里常常感到愧疚。这个时候我就有动力学习了，而一旦进入状态，我就舍不得去睡觉。或许这就是我深夜学习的原因。</p>
<br>

<p><strong>放长假：</strong></p>
<p>每个假期都会带几本书回家，然而一点也没看。</p>
<p>在家里就是阴间作息+游戏人生。完全没有考虑学习什么的，有的话也是浅尝即止，觉得香不过游戏。</p>
<p>直到这个寒假的前2&#x2F;3部分，也还是如此。虽然刚回家的那几天都有刷题。</p>
<p>到现在因为面临春招实习的压力（很可能寄了，来不及），这段时间才开始猛学，才开始追悔莫及。</p>
<br>

<br>

<p>就像我在一天中的深夜里学习一样，在某些时间段的尾段，我也是冲刺地学习。这并不是一个好的现象和方式，因为情况通常都是时间不够充裕，大脑不能稳定和冷静地运行。冲刺式的学习不能够深入知识和技术，通常只是以应付任务作为目的，达到应付任务的效果。</p>
<br>

<p>这样子的一天一天连在一起，就成了我不堪回首的大学时光。（虽然也就过了5&#x2F;8，还有一点抢救的机会）</p>
<br>

<br>

<br>

<h3 id="为什么会这样"><a href="#为什么会这样" class="headerlink" title="为什么会这样"></a>为什么会这样</h3><p>不妨回忆一下高中生涯，跟现在很相似。高一高二处于半摆烂状态，高三开始冲刺，就像我半摆烂到现在开始冲刺。高三冲刺到最后填平了前面摆烂挖的坑，结果也还不错。而现在，我实在不敢去奢求未来有多好的结果，只要不是烂果就行了。但是冲刺不能停，这点必须时刻提醒自己。</p>
<br>

<p>这种 半摆烂+冲刺 现象的成因如何解释。</p>
<ul>
<li><p>先说为什么会出现冲刺：时间临近终点，即将取得某种结果。此时，我会明确的希望自己能达到什么层次，确定自己的风格路线，并去了解应该如何去实现目标。</p>
<ul>
<li><p>概括下来就是：</p>
<p>​	一定的野心 + 明确的目标 + 合适的方法</p>
<p>分析高三冲刺：</p>
<p>​	希望中学生涯有个好的结尾  + 92计算机专业 + 学习方法比较正确</p>
<p>分析现在的冲刺：</p>
<p>​	希望毕业有个匹配的工作 + C++服务器开发 + 我不好说</p>
</li>
</ul>
</li>
<li><p>再说为什么会半摆烂：无非就是，没有明确的目标，学习方式不对，迷茫，没有动力，自制力不足，玩心太重…</p>
</li>
</ul>
<br>

<p>补救措施：</p>
<ul>
<li>目标，现在有了</li>
<li>路线，有了</li>
<li>学习方式，这个感觉得参考别人了</li>
<li>动力，压力都变成动力了</li>
<li>自制力，只能改，从好习惯开始</li>
<li>玩心重，不敢玩了</li>
</ul>
<p>还有一个，自我监督。</p>
<br>

<br>

<h3 id="以后怎么办"><a href="#以后怎么办" class="headerlink" title="以后怎么办"></a>以后怎么办</h3><p>高三和现在又有些许不同：高三靠约束，现在靠自律；高三有贵人相伴，现在孤身奋战。约束养不成我的自控力，但代替了我的自控力；而贵人在我低落的时候给了我不少鼓励，在我松懈的时候给了我十足的动力。而目前形势严峻。</p>
<p>我不好说未来会是什么结果，只能再次提醒自己，冲刺不能停。</p>
<p>还有就是，吸取教训。不要过了这个坎，就觉得万事大吉，等到下一个坎到来，又像现在这样猴急。</p>
<p>先从养成习惯开始吧，两个目标：<strong>规律作息，按时三餐</strong>。</p>
<img src="/2023/02/12/%E5%90%B8%E5%8F%96%E6%95%99%E8%AE%AD/image-20230212062855952.png" alt="image-20230212062855952">

<br>

<p>今晚无论有什么事情没做，也要在12点前熄灯睡觉</p>
<br>

<br>

<br>

<br>

<br>

<p>而现在是2023年2月12日，早上6点27。本来是想反思一下自己的拖延症和网瘾，一不小心反思了一个晚上。</p>
]]></content>
      <categories>
        <category>反思录</category>
      </categories>
      <tags>
        <tag>时间</tag>
        <tag>拷打</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用UDP做到TCP的效果</title>
    <url>/2023/05/11/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8UDP%E5%81%9A%E5%88%B0TCP%E7%9A%84%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<h1 id="使用UDP做到TCP的效果"><a href="#使用UDP做到TCP的效果" class="headerlink" title="使用UDP做到TCP的效果"></a>使用UDP做到TCP的效果</h1><p>图片和部分文字来自<a href="https://xiaolincoding.com/network/3_tcp/quic.html#quic-%E5%AF%B9%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%94%B9%E8%BF%9B">4.17 如何基于 UDP 协议实现可靠传输？ | 小林coding (xiaolincoding.com)</a></p>
<hr>
<p>即基于UDP协议实现<strong>可靠传输</strong>，以 <strong>QUIC</strong> 协议为例</p>
<p>TCP存在的几个问题：</p>
<ul>
<li>需要建立连接，会产生<strong>延迟</strong></li>
<li>Http2及之前的版本使用TCP存在<strong>队头阻塞</strong></li>
<li><strong>网络迁移</strong>需要重新建立连接</li>
</ul>
<span id="more"></span>

<p>QUIC需要实现的效果：</p>
<ul>
<li>可靠传输</li>
<li>解决队头阻塞</li>
<li>流量控制</li>
<li>拥塞控制</li>
<li>更快的建立连接</li>
<li>迁移连接</li>
</ul>
<h2 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h2><p>在应用层下功夫：</p>
<p><img src="/2023/05/11/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8UDP%E5%81%9A%E5%88%B0TCP%E7%9A%84%E6%95%88%E6%9E%9C/image-20230512223729083.png" alt="image-20230512223729083"></p>
<p>以 HTTP3.0 为例：</p>
<p>UDP格式照旧，但是<strong>UDP的数据内容</strong>则包含了多层用户层的协议数据：QUIC包、QUIC帧、最后才是HTTP&#x2F;3的帧。</p>
<h3 id="QUIC-Packet-header"><a href="#QUIC-Packet-header" class="headerlink" title="QUIC Packet header"></a>QUIC Packet header</h3><p>分为</p>
<ul>
<li><p><strong>Long</strong> Packet header <strong>首次建立连接</strong></p>
<ul>
<li><strong>源连接ID</strong>、<strong>目标连接ID</strong></li>
</ul>
</li>
<li><p><strong>Short</strong> Packet header <strong>日常传输数据</strong></p>
<ul>
<li><strong>目标连接ID</strong></li>
<li>编号 Packet Number，类似seq，但是<strong>严格单调递增</strong>，数据发生重传也使用递增的编号（可以通过ACK的不同判定是哪个重传的包还是原始包被收到了，便于计算 RTT ）</li>
<li>数据负载</li>
</ul>
</li>
<li><p>需要 <strong>三次握手</strong> ，协商<strong>连接ID</strong>。</p>
</li>
<li><p>后续发送数据只需要指定目标连接ID。</p>
</li>
<li><p>编号<strong>单调递增</strong>，使得支持<strong>乱序确认</strong></p>
</li>
<li><p>编号单调递增，使得发生重传时，窗口可以继续移动，解决队头阻塞</p>
</li>
</ul>
<h3 id="QUIC-Frame-header"><a href="#QUIC-Frame-header" class="headerlink" title="QUIC Frame header"></a>QUIC Frame header</h3><p>QUIC帧放在QUIC包的数据负载部分。</p>
<p>Frame分有不同类型，各自有不同的格式和功能。</p>
<p>以 Stream 类型为例（类似HTTP&#x2F;2的Stream），一条<strong>Stream</strong>对应一次<strong>HTTP请求和响应</strong>，格式包含：</p>
<ul>
<li>Stream <strong>ID</strong></li>
<li><strong>Offset</strong>，类似seq</li>
<li><strong>Length</strong></li>
<li>数据负载</li>
</ul>
<p>通过 <strong>Stream ID + Offset</strong> 来体现<strong>数据的有序性</strong>，标识具体数据内容。</p>
<p>即 QUIC 通过<strong>单向递增的 Packet Number</strong>，配合 <strong>Stream ID 与 Offset</strong> 字段信息，可以<strong>支持乱序确认</strong>而不影响数据包的<strong>正确组装</strong>。</p>
<h2 id="解决队头阻塞"><a href="#解决队头阻塞" class="headerlink" title="解决队头阻塞"></a>解决队头阻塞</h2><p><strong>接收窗口</strong>的队头阻塞。</p>
<p>若有<strong>数据丢失</strong>，或者是<strong>乱序</strong>，TCP只有在处理完丢失或未收到的数据之后，才能继续移动窗口。</p>
<p>于是在一段时间内，<strong>接收窗口停留</strong>，导致后面的数据无法接收，造成队头阻塞。</p>
<p>HTTP&#x2F;2 的Stream是在TCP基础之上，将一次HTTP请求和响应抽象成一条Stream，通过Stream ID标识。</p>
<p>对于并发的HTTP请求和响应，<strong>不同的Stream</strong>可以<strong>乱序</strong>发送和接收，<u>而<strong>每条Stream内的数据</strong>则需要保证<strong>有序</strong>发送和接收。</u></p>
<p>因为<strong>多条Stream会共用一条TCP连接</strong>，如果某一条Stream出现阻塞，则会阻塞整个TCP连接的窗口，造成队头阻塞。</p>
<p>HTTP&#x2F;3使用QUIC之后，每条Stream内的数据也可以做到乱序的接收（并进行有序的重组）。（通过 递增编号 和 Stream ID+Offset 机制实现）</p>
<p>QUIC为每条Stream都建立了一个窗口，则当某条Stream出现阻塞，只有一个窗口停滞，其他Stream的窗口还还能继续接收数据。</p>
<h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>接收方通过：</p>
<ul>
<li>window_update Frame 告知窗口大小</li>
<li>Block Frame 告知窗口关闭</li>
</ul>
<p>两种级别的流量控制：</p>
<ul>
<li><strong>Stream</strong> 级别：<ul>
<li>Stream 可以认为就是一条 HTTP 请求，每个 Stream 都有独立的滑动窗口，所以每个 Stream 都可以做流量控制，防止单个 Stream 消耗连接（Connection）的全部接收缓冲。</li>
</ul>
</li>
<li><strong>Connection</strong> 级别<ul>
<li>限制连接中所有 Stream 相加起来的总字节数，防止发送方超过连接的缓冲容量。</li>
</ul>
</li>
</ul>
<p>Connection级别限制了连接的总流量，Stream级别保证了流量的分配均匀。</p>
<h3 id="Stream-级"><a href="#Stream-级" class="headerlink" title="Stream 级"></a>Stream 级</h3><p><strong>接收方</strong>：</p>
<img src="/2023/05/11/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8UDP%E5%81%9A%E5%88%B0TCP%E7%9A%84%E6%95%88%E6%9E%9C/image-20230513140555364.png" alt="image-20230513140555364" style="zoom:80%;">

<p><strong>发送方</strong>：</p>
<p><img src="/2023/05/11/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8UDP%E5%81%9A%E5%88%B0TCP%E7%9A%84%E6%95%88%E6%9E%9C/image-20230513142006952.png" alt="发生重传"></p>
<p>上面的数字是 <strong>编号</strong></p>
<p>控制数据发送的唯一限制就是<strong>最大绝对字节偏移量</strong>，该值是接收方基于当前已经提交的偏移量（连续已确认并向上层应用提交的数据包offset）和发送方协商得出。</p>
<h3 id="Connection-级"><a href="#Connection-级" class="headerlink" title="Connection 级"></a>Connection 级</h3><img src="/2023/05/11/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8UDP%E5%81%9A%E5%88%B0TCP%E7%9A%84%E6%95%88%E6%9E%9C/image-20230513142217715.png" alt="image-20230513142217715" style="zoom:80%;">

<p>可用窗口大小就是各个Stream可用窗口大小之和。</p>
<ul>
<li>各个Stream的流量不超过各个Stream窗口</li>
<li>所有Stream的流量不超过Connection窗口</li>
</ul>
<h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>参照TCP的拥塞控制，但QUIC可以作更多改进，且更容易进行修改和普及应用。</p>
<ul>
<li>TCP 更改拥塞控制算法是对系统中所有应用都生效，无法根据不同应用设定不同的拥塞控制策略。</li>
<li>但是因为 QUIC 处于应用层，所以就<strong>可以针对不同的应用设置不同的拥塞控制算法</strong>，这样灵活性就很高了</li>
</ul>
<h2 id="快速建立连接"><a href="#快速建立连接" class="headerlink" title="快速建立连接"></a>快速建立连接</h2><p>对于HTTP：</p>
<ul>
<li><p>HTTP&#x2F;3之前的连接建立：TCP三次握手+TLS四次握手</p>
</li>
<li><p>QUIC建立连接只需一次握手</p>
</li>
</ul>
<p><strong>HTTP&#x2F;3的 QUIC 内部包含了 TLS</strong>，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商，甚至在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果。</p>
<h2 id="迁移连接"><a href="#迁移连接" class="headerlink" title="迁移连接"></a>迁移连接</h2><ul>
<li><p>TCP连接 是通过四元组来标识通信两端，若网络环境发生变化导致IP或端口改变，则需要重新建立连接，代价较高。</p>
</li>
<li><p>QUIC 通过<strong>连接 ID</strong>来标记通信两端，连接建立时双方协商好各自的 <strong>连接ID</strong>。当网络环境变化时，只要仍保有<strong>上下文信息</strong>（比如<strong>连接 ID</strong>、<strong>TLS 密钥</strong>等），就可以“无缝”地复用原连接，消除重连的成本，达到了<strong>连接迁移</strong>的功能。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
        <category>UDP</category>
      </categories>
      <tags>
        <tag>TCP, UDP</tag>
      </tags>
  </entry>
  <entry>
    <title>异常的分类和处理</title>
    <url>/2024/01/11/%E5%BC%82%E5%B8%B8%E7%9A%84%E5%88%86%E7%B1%BB%E5%92%8C%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="异常的分类"><a href="#异常的分类" class="headerlink" title="异常的分类"></a>异常的分类</h2><br>

<h3 id="异常分类和处理思路"><a href="#异常分类和处理思路" class="headerlink" title="异常分类和处理思路"></a>异常分类和处理思路</h3><ul>
<li><p><strong>网络异常</strong>：如连接超时、连接中断、DNS解析失败等。</p>
<ol>
<li><strong>错误重试</strong>：对于临时性的网络异常，可以尝试重新执行失败的操作，如重新建立连接或重新发送请求。</li>
<li><strong>超时设置</strong>：为网络操作设置合理的超时时间，当操作耗时超过设定的阈值时，应该放弃当前操作并进行适当的处理。</li>
<li><strong>断线重连</strong>：针对长连接的情况，当检测到连接断开时，可以尝试自动重新建立连接，以保持与服务端的通信。</li>
<li><strong>异常通知</strong>：将网络异常信息记录下来，并向相关人员发送通知，以便及时发现和处理潜在的问题。</li>
<li><strong>降级处理</strong>：对于一些关键操作，可以提供备用方案或者降级处理，以确保系统在部分网络异常的情况下仍能够正常运行。</li>
<li><strong>连接池管理</strong>：对于频繁建立连接的场景，使用连接池可以减少连接建立的开销，同时在连接出现问题时能够及时进行回收和重建。</li>
<li><strong>异常捕获和处理</strong>：在代码中合理捕获网络相关异常，并进行适当的处理，包括错误日志记录、资源释放等。</li>
</ol>
<br>

<span id="more"></span>
</li>
<li><p><strong>数据库异常</strong>：包括连接失败、查询错误、事务处理问题等。</p>
<ul>
<li><strong>连接失败</strong>：实施连接池技术，通过合适的配置和管理来减少连接失败的可能性，并在连接失败时进行重试操作。另外，确保数据库连接字符串配置正确，以避免连接失败。</li>
<li><strong>查询错误</strong>：编写健壮的SQL查询语句，进行输入验证和参数化查询，以防止SQL注入攻击，并通过合适的异常处理机制来捕获并处理查询错误。</li>
<li><strong>事务处理问题</strong>：使用数据库事务来确保原子性、一致性、隔离性和持久性（ACID特性），并在遇到事务处理问题时实施适当的回滚操作或补偿措施，以维护数据的完整性。</li>
<li><strong>连接超时和资源释放</strong>：设置合理的数据库连接超时时间，及时释放数据库连接以避免资源泄露。同时，使用try-with-resources或类似的语言特性来确保在使用后关闭数据库连接和释放相关资源。</li>
<li><strong>监控和报警</strong>：建立数据库性能监控系统，追踪数据库连接池的使用情况、查询性能等指标，并设置报警规则以便及时发现潜在的数据库异常情况。</li>
<li><strong>日志记录</strong>：在应用程序中添加适当的日志记录，记录数据库操作的详细信息，以便在发生异常时进行故障诊断和排查。</li>
</ul>
<br>
</li>
<li><p><strong>文件系统异常</strong>：例如文件不存在、权限不足、IO错误等。</p>
<br>
</li>
<li><p><strong>代码逻辑异常</strong>：由于程序设计或实现问题引起的异常，比如空指针引用、数组越界等。</p>
<ul>
<li><strong>代码审查</strong>：定期进行代码审查，特别关注潜在的空指针引用、数组越界等问题。通过同行评审或利用静态代码分析工具来发现可能存在的问题。</li>
<li><strong>输入验证</strong>：对外部输入数据进行严格验证，确保输入符合预期的格式和范围。这可以有效防止数组越界等问题。</li>
<li><strong>异常处理</strong>：在代码中增加适当的异常处理机制，捕获并处理可能导致空指针引用或数组越界的情况，以避免程序崩溃。</li>
<li><strong>单元测试</strong>：编写全面的单元测试用例，覆盖各种边界条件和异常情况，以确保代码在面对异常时能够正确处理。</li>
<li><strong>日志记录</strong>：在程序中添加适当的日志记录，可以帮助开发人员追踪程序执行过程中出现的异常情况，以便快速定位和修复问题。</li>
</ul>
<br>
</li>
<li><p><strong>第三方服务异常</strong>：调用外部服务时出现的异常，如API调用失败、认证问题等。</p>
<ul>
<li><strong>异常捕获和日志记录</strong>：在调用第三方服务的地方，使用合适的异常处理机制来捕获异常，并将异常信息作为日志记录下来，以便后续的分析和研究。</li>
<li><strong>重试机制</strong>：当第三方服务发生异常时，可以尝试进行重试操作。重试的次数和时间间隔可以根据具体情况进行调整。使用指数退避算法，逐渐增加重试间隔时间，可以避免过度压力和频繁调用外部服务。同时，需要控制重试次数，以免无限制地重试导致系统资源耗尽。</li>
<li><strong>用户友好的错误提示</strong>：对于用户发起的请求，如果第三方服务发生异常，需要向用户展示有意义的错误提示信息，以便用户理解和解决问题。可以根据异常类型返回相应的错误码和错误信息，或提供相关的解决方法。</li>
<li><strong>降级处理和备选方案</strong>：当第三方服务无法正常提供服务时，可以考虑降级处理，使用备选方案或本地缓存数据来代替。例如，如果某些服务不可用，可以使用默认值或预先缓存的数据进行响应，以保持系统的可用性。</li>
<li><strong>监控和报警</strong>：及时监控第三方服务的可用性和性能，通过合适的监控系统来收集指标数据，识别潜在的问题和风险。当发生异常时，触发报警机制，及时通知相关团队进行处理和恢复。</li>
</ul>
<br>
</li>
<li><p><strong>资源耗尽异常</strong>：内存、CPU、线程池等资源耗尽导致的异常。</p>
<ul>
<li><strong>异常处理与回滚</strong>：当发生资源耗尽异常时，可以先捕获异常并进行相应的处理。可能的处理方式包括中止当前操作，回滚事务，释放资源，关闭连接等。这样可以尽量避免异常向上传递，导致更严重的问题。</li>
<li><strong>重新分配资源</strong>：对于发生资源耗尽的情况，可以考虑重新分配或增加资源。例如，增加服务器的内存，增加线程池的大小，使用更高配置的硬件等。然后重新启动系统，并确保资源得到合理分配，以避免资源耗尽重复发生。</li>
<li><strong>快速定位问题原因</strong>：对于资源耗尽，需要迅速定位具体的原因。可以通过查看系统日志、监控工具和性能分析工具等来定位导致资源耗尽的具体原因，例如错误的配置、持续高负载、死锁等。</li>
<li><strong>限制资源使用量</strong>：通过调整相应的配置参数，限制系统的资源使用量。例如，降低线程池的大小，限制请求的并发数，设置合理的内存使用上限等。这样可以在资源耗尽异常发生时，避免进一步的资源浪费。</li>
</ul>
<br>
</li>
<li><p><strong>安全异常</strong>：包括拒绝访问、未经授权的操作等安全相关异常。</p>
</li>
</ul>
<br>

<h3 id="异常捕获和处理方式"><a href="#异常捕获和处理方式" class="headerlink" title="异常捕获和处理方式"></a>异常捕获和处理方式</h3><p><strong>使用 exception 机制</strong></p>
<ol>
<li>Try-Catch语句：使用try块包围可能引发异常的代码，然后使用catch块捕获并处理相应的异常。</li>
<li>Finally块：可以在try-catch结构中添加finally块，无论是否发生异常，其中的代码都会被执行，通常用于资源清理等操作。</li>
<li>异常类型匹配：针对不同类型的异常，可以使用多个catch块进行捕获和处理，以执行针对特定异常类型的特定逻辑。</li>
<li>抛出异常：在遇到无法处理的情况下，可以通过throw语句主动抛出异常，以通知调用者或上层代码出现了问题。</li>
<li>异常链传递：在捕获异常后，可以选择将当前异常封装在新的异常中并重新抛出，以保留原始异常信息，并让调用者能够更清晰地了解异常发生的上下文。</li>
<li>自定义异常：针对特定业务场景，可以创建自定义的异常类来标识和处理特定的异常情况，使得异常处理更加具体和精确。</li>
<li>异常处理策略：针对不同类型的异常，可以采取不同的处理策略，如重试、回滚、记录日志、通知相关人员等。</li>
</ol>
<p><strong>不使用 exception 机制</strong></p>
<ol>
<li>返回错误码或错误状态：在函数或方法调用发生异常时，返回一个特定的错误码或错误状态，由调用方来检查并处理异常情况。</li>
<li>回调机制：通过回调函数或回调接口将异常信息传递给调用方，让调用方自行处理异常情况。</li>
<li>异步通知：使用异步通知机制，当发生异常时向相关组件或模块发送通知，由接收方来处理异常情况。</li>
<li>使用断言：在开发阶段通过断言来检查程序中的不变量和前置条件，以及对可能出现异常的地方进行预先检查。</li>
<li>使用条件判断语句：在执行关键操作之前，通过条件判断语句来检查输入参数、环境状态等，以避免可能引发异常的情况发生。</li>
</ol>
<br>

<br>

<h2 id="异常的传递（不使用-Try-Catch）"><a href="#异常的传递（不使用-Try-Catch）" class="headerlink" title="异常的传递（不使用 Try Catch）"></a>异常的传递（不使用 Try Catch）</h2><h3 id="网络层操作失败产生的异常"><a href="#网络层操作失败产生的异常" class="headerlink" title="网络层操作失败产生的异常"></a>网络层操作失败产生的异常</h3><p>此处以网络操作 connect 为例</p>
<h4 id="从网络库的操作开始往上看"><a href="#从网络库的操作开始往上看" class="headerlink" title="从网络库的操作开始往上看"></a>从网络库的操作开始往上看</h4><p>以使用 libuv 网络库中的 uv_tcp_connect 函数为例</p>
<ul>
<li>其返回值是一个 int，代表一个 error code，为0则表示成功，否则表示失败</li>
<li>error code 的值是事先定义好的</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">uv_tcp_connect</span><span class="params">(<span class="type">uv_connect_t</span>* req,</span></span><br><span class="line"><span class="params">                   <span class="type">uv_tcp_t</span>* handle,</span></span><br><span class="line"><span class="params">                   <span class="type">const</span> <span class="keyword">struct</span> sockaddr* addr,</span></span><br><span class="line"><span class="params">                   uv_connect_cb cb)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> addrlen;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (handle-&gt;type != UV_TCP)</span><br><span class="line">    <span class="keyword">return</span> UV_EINVAL;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (addr-&gt;sa_family == AF_INET)</span><br><span class="line">    addrlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (addr-&gt;sa_family == AF_INET6)</span><br><span class="line">    addrlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in6);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> UV_EINVAL;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> uv__tcp_connect(req, handle, addr, addrlen, cb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<br>

<p>上层的用户函数可能是一个 init() 函数，用来初始化一些网络资源</p>
<ul>
<li>用户使用时，根据 uv_tcp_connect 函数的返回值判断执行是否成功即可</li>
<li>此处使用 goto Exit0 转到单一出口处，进行用户 Init 函数中的错误处理，并通过 return false 返回用户函数的执行结果</li>
</ul>
<p><img src="/2024/01/11/%E5%BC%82%E5%B8%B8%E7%9A%84%E5%88%86%E7%B1%BB%E5%92%8C%E5%A4%84%E7%90%86/Users\kingsoft\Desktop\blog\mang959595.github.io\source_posts\异常的分类和处理.assets\image-20240111140902402.png" alt="image-20240111140902402"></p>
<p><img src="/2024/01/11/%E5%BC%82%E5%B8%B8%E7%9A%84%E5%88%86%E7%B1%BB%E5%92%8C%E5%A4%84%E7%90%86/Users\kingsoft\Desktop\blog\mang959595.github.io\source_posts\异常的分类和处理.assets\image-20240111141135793.png" alt="image-20240111141135793"></p>
<br>

<br>

<p>再往上层看调用了 Init() 函数的地方，这里是在一个断线重连的操作中调用了 Init() ，即函数 TryReconnect()</p>
<ul>
<li>通过判断Init()的结果，可以区分重连请求成功还是失败（此处并非真正的重连成功，只是connect请求成功。当连接建立时，会在 uv_tcp_connect 设置的回调函数中对连接结果进行判断和处理）</li>
<li>此处同样使用goto，对重连请求失败的情况进行处理，并将结果返回给再上一层</li>
</ul>
<p><img src="/2024/01/11/%E5%BC%82%E5%B8%B8%E7%9A%84%E5%88%86%E7%B1%BB%E5%92%8C%E5%A4%84%E7%90%86/Users\kingsoft\Desktop\blog\mang959595.github.io\source_posts\异常的分类和处理.assets\image-20240111141930566.png" alt="image-20240111141930566"></p>
<br>

<br>

<p>再往上一层看，哪里调用了 TryReconnect()，这里是在一个Update里面定期对掉线队列里的连接进行重连尝试</p>
<ul>
<li>但是这里是直接将重连函数结果丢弃了</li>
<li>结合前面来看，在 TryReconnect 函数里已经把失败情况下的连接重新加到了掉线队列里，所以此处丢弃 TryReconnect 结果是没问题的，但是最好还是判断一下并输出日志，方便查看情况。</li>
</ul>
<p><img src="/2024/01/11/%E5%BC%82%E5%B8%B8%E7%9A%84%E5%88%86%E7%B1%BB%E5%92%8C%E5%A4%84%E7%90%86/Users\kingsoft\Desktop\blog\mang959595.github.io\source_posts\异常的分类和处理.assets\image-20240111142939480.png" alt="image-20240111142939480"></p>
<br>

<br>

<h4 id="从网络库的操作开始往下看"><a href="#从网络库的操作开始往下看" class="headerlink" title="从网络库的操作开始往下看"></a>从网络库的操作开始往下看</h4><p>直接上代码</p>
<p>第一层</p>
<ul>
<li>主要是进行了一些条件、参数的判断和处理</li>
<li>然后调用第二层函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 顶层第一层</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">uv_tcp_connect</span><span class="params">(<span class="type">uv_connect_t</span>* req,</span></span><br><span class="line"><span class="params">                   <span class="type">uv_tcp_t</span>* handle,</span></span><br><span class="line"><span class="params">                   <span class="type">const</span> <span class="keyword">struct</span> sockaddr* addr,</span></span><br><span class="line"><span class="params">                   uv_connect_cb cb)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> addrlen;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (handle-&gt;type != UV_TCP)</span><br><span class="line">    <span class="keyword">return</span> UV_EINVAL;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (addr-&gt;sa_family == AF_INET)</span><br><span class="line">    addrlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (addr-&gt;sa_family == AF_INET6)</span><br><span class="line">    addrlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in6);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> UV_EINVAL;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> uv__tcp_connect(req, handle, addr, addrlen, cb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<br>

<p>第二层</p>
<ul>
<li>进行错误码的转换</li>
<li>调用第三层函数，获取其 error code 并按需转换</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第二层</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">uv__tcp_connect</span><span class="params">(<span class="type">uv_connect_t</span>* req,</span></span><br><span class="line"><span class="params">                    <span class="type">uv_tcp_t</span>* handle,</span></span><br><span class="line"><span class="params">                    <span class="type">const</span> <span class="keyword">struct</span> sockaddr* addr,</span></span><br><span class="line"><span class="params">                    <span class="type">unsigned</span> <span class="type">int</span> addrlen,</span></span><br><span class="line"><span class="params">                    uv_connect_cb cb)</span> &#123;</span><br><span class="line">  <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">  err = uv_tcp_try_connect(req, handle, addr, addrlen, cb);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">return</span> uv_translate_sys_error(err); <span class="comment">// 只是将一些系统错误码换成libuv的错误码</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<br>

<p>第三层</p>
<ul>
<li>真正进行底层的系统调用，包含各个过程的子函数</li>
<li>一般是直接返回各个过程中异常的错误码</li>
<li>也有不太一样的，比如 handle-&gt;delayed_error<ul>
<li>在 uv_tcp_try_bind 里面，WSAEADDRINUSE 错误是不直接返回错误码的，而是暂且认为 uv_tcp_connect 请求成功，并设置tcp句柄的 delayed_error ，最终在处理 pending req 时将错误信息传递到 uv_tcp_connect  请求设置的回调函数中进行处理</li>
<li><img src="/2024/01/11/%E5%BC%82%E5%B8%B8%E7%9A%84%E5%88%86%E7%B1%BB%E5%92%8C%E5%A4%84%E7%90%86/Users\kingsoft\Desktop\blog\mang959595.github.io\source_posts\异常的分类和处理.assets\image-20240111150833055.png" alt="uv_try_bind内部"></li>
<li><img src="/2024/01/11/%E5%BC%82%E5%B8%B8%E7%9A%84%E5%88%86%E7%B1%BB%E5%92%8C%E5%A4%84%E7%90%86/Users\kingsoft\Desktop\blog\mang959595.github.io\source_posts\异常的分类和处理.assets\image-20240111151150825.png" alt="回调函数"></li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第三层</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">uv_tcp_try_connect</span><span class="params">(<span class="type">uv_connect_t</span>* req,</span></span><br><span class="line"><span class="params">                              <span class="type">uv_tcp_t</span>* handle,</span></span><br><span class="line"><span class="params">                              <span class="type">const</span> <span class="keyword">struct</span> sockaddr* addr,</span></span><br><span class="line"><span class="params">                              <span class="type">unsigned</span> <span class="type">int</span> addrlen,</span></span><br><span class="line"><span class="params">                              uv_connect_cb cb)</span> &#123;</span><br><span class="line">  <span class="type">uv_loop_t</span>* loop = handle-&gt;loop;</span><br><span class="line">  TCP_INITIAL_RTO_PARAMETERS retransmit_ioctl;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span>* <span class="title">bind_addr</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">converted</span>;</span></span><br><span class="line">  BOOL success;</span><br><span class="line">  DWORD bytes;</span><br><span class="line">  <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 函数 1</span></span><br><span class="line">  err = uv__convert_to_localhost_if_unspecified(addr, &amp;converted);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">  <span class="keyword">if</span> (handle-&gt;delayed_error != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!(handle-&gt;flags &amp; UV_HANDLE_BOUND)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (addrlen == <span class="keyword">sizeof</span>(uv_addr_ip4_any_)) &#123;</span><br><span class="line">      bind_addr = (<span class="type">const</span> <span class="keyword">struct</span> sockaddr*) &amp;uv_addr_ip4_any_;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (addrlen == <span class="keyword">sizeof</span>(uv_addr_ip6_any_)) &#123;</span><br><span class="line">      bind_addr = (<span class="type">const</span> <span class="keyword">struct</span> sockaddr*) &amp;uv_addr_ip6_any_;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 函数 2</span></span><br><span class="line">    err = uv_tcp_try_bind(handle, bind_addr, addrlen, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">      <span class="keyword">return</span> err;</span><br><span class="line">    <span class="keyword">if</span> (handle-&gt;delayed_error != <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> out;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 异常情况</span></span><br><span class="line">  <span class="keyword">if</span> (!handle-&gt;tcp.conn.func_connectex) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!uv_get_connectex_function(handle-&gt;socket, &amp;handle-&gt;tcp.conn.func_connectex)) &#123;</span><br><span class="line">      <span class="keyword">return</span> WSAEAFNOSUPPORT;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* This makes connect() fail instantly if the target port on the localhost</span></span><br><span class="line"><span class="comment">   * is not reachable, instead of waiting for 2s. We do not care if this fails.</span></span><br><span class="line"><span class="comment">   * This only works on Windows version 10.0.16299 and later.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (uv__is_fast_loopback_fail_supported() &amp;&amp; uv__is_loopback(&amp;converted)) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;retransmit_ioctl, <span class="number">0</span>, <span class="keyword">sizeof</span>(retransmit_ioctl));</span><br><span class="line">    retransmit_ioctl.Rtt = TCP_INITIAL_RTO_NO_SYN_RETRANSMISSIONS;</span><br><span class="line">    retransmit_ioctl.MaxSynRetransmissions = TCP_INITIAL_RTO_NO_SYN_RETRANSMISSIONS;</span><br><span class="line">        <span class="comment">// 配置 TCP 初始重传超时和最大 SYN 重传次数等参数</span></span><br><span class="line">    WSAIoctl(handle-&gt;socket,</span><br><span class="line">             SIO_TCP_INITIAL_RTO,</span><br><span class="line">             &amp;retransmit_ioctl,</span><br><span class="line">             <span class="keyword">sizeof</span>(retransmit_ioctl),</span><br><span class="line">             <span class="literal">NULL</span>,</span><br><span class="line">             <span class="number">0</span>,</span><br><span class="line">             &amp;bytes,</span><br><span class="line">             <span class="literal">NULL</span>,</span><br><span class="line">             <span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line"></span><br><span class="line">  UV_REQ_INIT(req, UV_CONNECT);</span><br><span class="line">  req-&gt;handle = (<span class="type">uv_stream_t</span>*) handle;</span><br><span class="line">  req-&gt;cb = cb;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;req-&gt;u.io.overlapped, <span class="number">0</span>, <span class="keyword">sizeof</span>(req-&gt;u.io.overlapped));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 无法立即处理的错误，不直接返回错误码给上层</span></span><br><span class="line">  <span class="comment">// 这里是把请求塞到tcp句柄的待办队列里，等下一个loop的时候将请求取出来，调用回调进行最终的(错误)处理</span></span><br><span class="line">  <span class="keyword">if</span> (handle-&gt;delayed_error != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/* Process the req without IOCP. */</span></span><br><span class="line">    handle-&gt;reqs_pending++;</span><br><span class="line">    REGISTER_HANDLE_REQ(loop, handle, req);</span><br><span class="line">    uv_insert_pending_req(loop, (<span class="type">uv_req_t</span>*)req);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用 Windows API，这里应该是通过加载动态库来调用的</span></span><br><span class="line">  success = handle-&gt;tcp.conn.func_connectex(handle-&gt;socket,</span><br><span class="line">                                            (<span class="type">const</span> <span class="keyword">struct</span> sockaddr*) &amp;converted,</span><br><span class="line">                                            addrlen,</span><br><span class="line">                                            <span class="literal">NULL</span>,</span><br><span class="line">                                            <span class="number">0</span>,</span><br><span class="line">                                            &amp;bytes,</span><br><span class="line">                                            &amp;req-&gt;u.io.overlapped);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (UV_SUCCEEDED_WITHOUT_IOCP(success)) &#123;</span><br><span class="line">    <span class="comment">/* Process the req without IOCP. */</span></span><br><span class="line">    handle-&gt;reqs_pending++;</span><br><span class="line">    REGISTER_HANDLE_REQ(loop, handle, req);</span><br><span class="line">    uv_insert_pending_req(loop, (<span class="type">uv_req_t</span>*)req);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (UV_SUCCEEDED_WITH_IOCP(success)) &#123;</span><br><span class="line">    <span class="comment">/* The req will be processed with IOCP. */</span></span><br><span class="line">    handle-&gt;reqs_pending++;</span><br><span class="line">    REGISTER_HANDLE_REQ(loop, handle, req);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 这里返回API调用出错的 Windows 错误码</span></span><br><span class="line">    <span class="keyword">return</span> WSAGetLastError();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<p>感兴趣的可以看一下 libuv 对待办队列中的请求完成结果的处理</p>
<ul>
<li>这里会对 delayed_error 状态进行判断，取出err并传给回调函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">uv_process_tcp_connect_req</span><span class="params">(<span class="type">uv_loop_t</span>* loop, <span class="type">uv_tcp_t</span>* handle,</span></span><br><span class="line"><span class="params">    <span class="type">uv_connect_t</span>* req)</span> &#123;</span><br><span class="line">  <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">  assert(handle-&gt;type == UV_TCP);</span><br><span class="line"></span><br><span class="line">  UNREGISTER_HANDLE_REQ(loop, handle, req);</span><br><span class="line"></span><br><span class="line">  err = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (handle-&gt;delayed_error) &#123;</span><br><span class="line">    <span class="comment">/* To smooth over the differences between unixes errors that</span></span><br><span class="line"><span class="comment">     * were reported synchronously on the first connect can be delayed</span></span><br><span class="line"><span class="comment">     * until the next tick--which is now.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    err = handle-&gt;delayed_error;</span><br><span class="line">    handle-&gt;delayed_error = <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (REQ_SUCCESS(req)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (handle-&gt;flags &amp; UV_HANDLE_CLOSING) &#123;</span><br><span class="line">      <span class="comment">/* use UV_ECANCELED for consistency with Unix */</span></span><br><span class="line">      err = ERROR_OPERATION_ABORTED;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (setsockopt(handle-&gt;socket,</span><br><span class="line">                          SOL_SOCKET,</span><br><span class="line">                          SO_UPDATE_CONNECT_CONTEXT,</span><br><span class="line">                          <span class="literal">NULL</span>,</span><br><span class="line">                          <span class="number">0</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      uv_connection_init((<span class="type">uv_stream_t</span>*)handle);</span><br><span class="line">      handle-&gt;flags |= UV_HANDLE_READABLE | UV_HANDLE_WRITABLE;</span><br><span class="line">      loop-&gt;active_tcp_streams++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      err = WSAGetLastError();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    err = GET_REQ_SOCK_ERROR(req);</span><br><span class="line">  &#125;</span><br><span class="line">  req-&gt;cb(req, uv_translate_sys_error(err));</span><br><span class="line"></span><br><span class="line">  DECREASE_PENDING_REQ_COUNT(handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程</category>
        <category>异常处理</category>
      </categories>
      <tags>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title>框架汇总</title>
    <url>/2022/07/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="算法学习"><a href="#算法学习" class="headerlink" title="算法学习"></a>算法学习</h1><br>

<h2 id="day1——核心框架汇总"><a href="#day1——核心框架汇总" class="headerlink" title="day1——核心框架汇总"></a>day1——核心框架汇总</h2><h3 id="1-框架思维"><a href="#1-框架思维" class="headerlink" title="1-框架思维"></a>1-框架思维</h3><h4 id="基本数据结构及其操作"><a href="#基本数据结构及其操作" class="headerlink" title="基本数据结构及其操作"></a>基本数据结构及其操作</h4><p>数据结构的存储方式只有两种：<strong>数组（顺序存储）和链表（链式存储）</strong></p>
<p>在此之上可以构成：<strong>散列表、栈、队列、堆、树、图等等各种数据结构</strong></p>
<p>基本操作：无非就是<strong>遍历 + 访问</strong>，再具体一点就是：<strong>增删查改</strong>。</p>
<p>数据结构种类很多，但它们存在的目的都是在不同的应用场景，尽可能高效地增删查改。</p>
<span id="more"></span>

<hr>
<h4 id="算法的框架思维"><a href="#算法的框架思维" class="headerlink" title="算法的框架思维"></a>算法的框架思维</h4><p>数组遍历框架</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">voidtraverse</span>(<span class="type">int</span>[]arr)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i &lt;arr.length; i++)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 迭代访问 arr[i]</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<p>链表遍历框架，兼具迭代和递归结构：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 基本的单链表节点 */</span></span><br><span class="line"></span><br><span class="line">classListNode&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">voidtraverse</span>(ListNodehead)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(ListNode p = head; p != null; p =p.next)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 迭代访问 p.val</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">voidtraverse</span>(ListNodehead)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归访问 head.val</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">traverse</span>(head.next);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<p>二叉树遍历框架，典型的非线性递归遍历结构：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 基本的二叉树节点 */</span></span><br><span class="line"></span><br><span class="line">classTreeNode&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">    TreeNode left, right;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">voidtraverse</span>(TreeNoderoot)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">traverse</span>(root.left);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">traverse</span>(root.right);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<p>N 叉树的遍历框架：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 基本的 N 叉树节点 */</span></span><br><span class="line"></span><br><span class="line">classTreeNode&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">    TreeNode[] children;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">voidtraverse</span>(TreeNoderoot)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(TreeNode child :root.children)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">traverse</span>(child);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>1、先学习像数组、链表这种基本数据结构的常用算法</strong></p>
<p><strong>2、学会基础算法之后，不要急着上来就刷回溯算法、动态规划这类笔试常考题，而应该先刷二叉树</strong></p>
<hr>
<br>

<h3 id="2-刷题心得"><a href="#2-刷题心得" class="headerlink" title="2-刷题心得"></a>2-刷题心得</h3><h4 id="数组-x2F-单链表系列算法"><a href="#数组-x2F-单链表系列算法" class="headerlink" title="数组&#x2F;单链表系列算法"></a>数组&#x2F;单链表系列算法</h4><blockquote>
<p>-<strong>单链表常考的技巧就是双指针</strong></p>
</blockquote>
<blockquote>
<p>-<strong>数组常用的技巧有很大一部分还是双指针相关的技巧，说白了是教你如何聪明地进行穷举</strong></p>
</blockquote>
<blockquote>
<p>-<strong>滑动窗口算法技巧，典型的快慢双指针，快慢指针中间就是滑动的「窗口」，主要用于解决子串问题。</strong></p>
</blockquote>
<blockquote>
<p>-**最后说说 <a href="https://labuladong.github.io/algo/2/20/24/">前缀和技巧</a> 和 <a href="https://labuladong.github.io/algo/2/20/25/">差分数组技巧</a>**。</p>
</blockquote>
<blockquote>
<blockquote>
<p>如果频繁地让你计算子数组的和，每次用 for 循环去遍历肯定没问题，但前缀和技巧预计算一个 <code>preSum</code> 数组，就可以避免循环。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>类似的，如果频繁地让你对子数组进行增减操作，也可以每次用 for 循环去操作，但差分数组技巧维护一个 <code>diff</code> 数组，也可以避免循环。</p>
</blockquote>
</blockquote>
<br>

<h4 id="二叉树系列算法"><a href="#二叉树系列算法" class="headerlink" title="二叉树系列算法"></a>二叉树系列算法</h4><p>二叉树题目的递归解法可以分两类思路，第一类是遍历一遍二叉树得出答案，第二类是通过分解问题计算出答案，这两类思路分别对应着 <a href="https://labuladong.github.io/algo/4/31/105/">回溯算法核心框架</a> 和 <a href="https://labuladong.github.io/algo/3/25/69/">动态规划核心框架</a>。</p>
<p>更进一步，图论相关的算法也是二叉树算法的延续。</p>
<p>比如 <a href="https://labuladong.github.io/algo/2/22/50/">图论基础</a>， <a href="https://labuladong.github.io/algo/2/22/51/">环判断和拓扑排序</a> 和 <a href="https://labuladong.github.io/algo/2/22/52/">二分图判定算法</a> 就用到了 DFS 算法；再比如 <a href="https://labuladong.github.io/algo/2/22/56/">Dijkstra 算法模板</a>，就是改造版 BFS 算法加上一个类似 dp table 的数组。</p>
<p>这些算法的本质都是穷举二（多）叉树，有机会的话通过剪枝或者备忘录的方式减少冗余计算，提高效率，就这么点事儿。</p>
<hr>
<br>

<h3 id="3-双指针（七道链表题）"><a href="#3-双指针（七道链表题）" class="headerlink" title="3-双指针（七道链表题）"></a>3-双指针（七道链表题）</h3><br>

<h4 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h4><p>用到了3个指针：指向原链表的p1、p2，连接链表的p</p>
<p>注意要新建一个空的链表头</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">ListNodemergeTwoLists</span>(ListNodel1,ListNodel2)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 虚拟头结点</span></span><br><span class="line"></span><br><span class="line">    ListNode dummy =<span class="built_in">newListNode</span>(<span class="number">-1</span>), p = dummy;</span><br><span class="line"></span><br><span class="line">    ListNode p1 = l1, p2 = l2;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p1 != null &amp;&amp; p2 != null)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较 p1 和 p2 两个指针</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将值较小的的节点接到 p 指针</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(p1.val&gt;p2.val)&#123;</span><br><span class="line"></span><br><span class="line">            p.next= p2;</span><br><span class="line"></span><br><span class="line">            p2 =p2.next;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">            p.next= p1;</span><br><span class="line"></span><br><span class="line">            p1 =p1.next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// p 指针不断前进</span></span><br><span class="line"></span><br><span class="line">        p =p.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p1 != null)&#123;</span><br><span class="line"></span><br><span class="line">        p.next= p1;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p2 != null)&#123;</span><br><span class="line"></span><br><span class="line">        p.next= p2;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    returndummy.next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<h4 id="链表的分解"><a href="#链表的分解" class="headerlink" title="链表的分解"></a>链表的分解</h4><p><img src="https://labuladong.github.io/algo/images/%e9%93%be%e8%a1%a8%e6%8a%80%e5%b7%a7/title4.jpg" alt="img"></p>
<br>

<h4 id="合并k个有序链表"><a href="#合并k个有序链表" class="headerlink" title="合并k个有序链表"></a>合并k个有序链表</h4><p>利用优先级队列（堆）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">ListNodemergeKLists</span>(ListNode[]lists)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(lists.length==<span class="number">0</span>)<span class="keyword">return</span> null;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 虚拟头结点</span></span><br><span class="line"></span><br><span class="line">    ListNode dummy =<span class="built_in">newListNode</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    ListNode p = dummy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优先级队列，最小堆</span></span><br><span class="line"></span><br><span class="line">    PriorityQueue&lt;ListNode&gt; pq =newPriorityQueue&lt;&gt;(</span><br><span class="line"></span><br><span class="line">        lists.length,(a, b)-&gt;(a.val-b.val));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 k 个链表的头结点加入最小堆</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(ListNode head : lists)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(head != null)</span><br><span class="line"></span><br><span class="line">            pq.<span class="built_in">add</span>(head);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!pq.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取最小节点，接到结果链表中</span></span><br><span class="line"></span><br><span class="line">        ListNode node =pq.<span class="built_in">poll</span>();</span><br><span class="line"></span><br><span class="line">        p.next= node;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node.next!= null)&#123;</span><br><span class="line"></span><br><span class="line">            pq.<span class="built_in">add</span>(node.next);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// p 指针不断前进</span></span><br><span class="line"></span><br><span class="line">        p =p.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    returndummy.next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>优先队列 <code>pq</code> 中的元素个数最多是 <code>k</code>，所以一次 <code>poll</code> 或者 <code>add</code> 方法的时间复杂度是 <code>O(logk)</code>；所有的链表节点都会被加入和弹出 <code>pq</code>，<strong>所以算法整体的时间复杂度是 <code>O(Nlogk)</code>，其中 <code>k</code> 是链表的条数，<code>N</code> 是这些链表的节点总数</strong>。</p>
<br>

<h4 id="寻找单链表的倒数第k个节点"><a href="#寻找单链表的倒数第k个节点" class="headerlink" title="寻找单链表的倒数第k个节点"></a>寻找单链表的倒数第k个节点</h4><p>不告诉链表长度；</p>
<p>只遍历一次链表的解法：用p1走k步后，p2再出发</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 返回链表的倒数第 k 个节点</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">ListNodefindFromEnd</span>(ListNodehead,intk)&#123;</span><br><span class="line"></span><br><span class="line">    ListNode p1 = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// p1 先走 k 步</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line"></span><br><span class="line">        p1 =p1.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode p2 = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// p1 和 p2 同时走 n - k 步</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p1 != null)&#123;</span><br><span class="line"></span><br><span class="line">        p2 =p2.next;</span><br><span class="line"></span><br><span class="line">        p1 =p1.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// p2 现在指向第 n - k + 1 个节点，即倒数第 k 个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p2;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<h4 id="寻找单链表的中点"><a href="#寻找单链表的中点" class="headerlink" title="寻找单链表的中点"></a>寻找单链表的中点</h4><p>利用快慢指针：快指针走两步，慢指针走一步</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">ListNodemiddleNode</span>(ListNodehead)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快慢指针初始化指向 head</span></span><br><span class="line"></span><br><span class="line">    ListNode slow = head, fast = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快指针走到末尾时停止</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(fast != null &amp;&amp;fast.next!= null)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 慢指针走一步，快指针走两步</span></span><br><span class="line"></span><br><span class="line">        slow =slow.next;</span><br><span class="line"></span><br><span class="line">        fast =fast.next.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 慢指针指向中点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>需要注意的是，如果链表长度为偶数，也就是说中点有两个的时候，我们这个解法返回的节点是靠后的那个节点。</p>
<br>

<h4 id="判断单链表是否包含环并找出环起点"><a href="#判断单链表是否包含环并找出环起点" class="headerlink" title="判断单链表是否包含环并找出环起点"></a>判断单链表是否包含环并找出环起点</h4><p>判断是否含环：快慢指针，如果最终快指针赶上慢指针说明有环。否则快指针遍历直到空指针。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">booleanhasCycle</span>(ListNodehead)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快慢指针初始化指向 head</span></span><br><span class="line"></span><br><span class="line">    ListNode slow = head, fast = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快指针走到末尾时停止</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(fast != null &amp;&amp;fast.next!= null)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 慢指针走一步，快指针走两步</span></span><br><span class="line"></span><br><span class="line">        slow =slow.next;</span><br><span class="line"></span><br><span class="line">        fast =fast.next.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 快慢指针相遇，说明含有环</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(slow == fast)&#123;</span><br><span class="line"></span><br><span class="line">            returntrue;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不包含环</span></span><br><span class="line"></span><br><span class="line">    returnfalse;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>若有环，如何判断环的起点</p>
<blockquote>
<p>当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">ListNodedetectCycle</span>(ListNodehead)&#123;</span><br><span class="line"></span><br><span class="line">    ListNode fast, slow;</span><br><span class="line"></span><br><span class="line">    fast = slow = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(fast != null &amp;&amp;fast.next!= null)&#123;</span><br><span class="line"></span><br><span class="line">        fast =fast.next.next;</span><br><span class="line"></span><br><span class="line">        slow =slow.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(fast == slow)<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上面的代码类似 hasCycle 函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fast == null ||fast.next== null)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// fast 遇到空指针说明没有环</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> null;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新指向头结点</span></span><br><span class="line"></span><br><span class="line">    slow = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快慢指针同步前进，相交点就是环起点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line"></span><br><span class="line">        fast =fast.next;</span><br><span class="line"></span><br><span class="line">        slow =slow.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<h4 id="判断两个单链表是否相交并找出交点"><a href="#判断两个单链表是否相交并找出交点" class="headerlink" title="判断两个单链表是否相交并找出交点"></a>判断两个单链表是否相交并找出交点</h4><p>不使用Hashmap的实现，即仅使用两个指针</p>
<blockquote>
<p>我们可以让 <code>p1</code> 遍历完链表 <code>A</code> 之后开始遍历链表 <code>B</code>，让 <code>p2</code> 遍历完链表 <code>B</code> 之后开始遍历链表 <code>A</code>，这样相当于「逻辑上」两条链表接在了一起。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">ListNodegetIntersectionNode</span>(ListNodeheadA,ListNodeheadB)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// p1 指向 A 链表头结点，p2 指向 B 链表头结点</span></span><br><span class="line"></span><br><span class="line">    ListNode p1 = headA, p2 = headB;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p1 != p2)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// p1 走一步，如果走到 A 链表末尾，转到 B 链表</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(p1 == null) p1 = headB;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>            p1 =p1.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// p2 走一步，如果走到 B 链表末尾，转到 A 链表</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(p2 == null) p2 = headA;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>            p2 =p2.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>或者通过预先求出两个链表的长度，来使p1、p2同时到达相交节点</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> lenA =<span class="number">0</span>, lenB =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算两条链表的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(ListNode p1 = headA; p1 != null; p1 =p1.next)&#123;</span><br><span class="line"></span><br><span class="line">        lenA++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(ListNode p2 = headB; p2 != null; p2 =p2.next)&#123;</span><br><span class="line"></span><br><span class="line">        lenB++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让 p1 和 p2 到达尾部的距离相同</span></span><br><span class="line"></span><br><span class="line">    ListNode p1 = headA, p2 = headB;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(lenA &gt; lenB)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i &lt; lenA - lenB; i++)&#123;</span><br><span class="line"></span><br><span class="line">            p1 =p1.next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i &lt; lenB - lenA; i++)&#123;</span><br><span class="line"></span><br><span class="line">            p2 =p2.next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 看两个指针是否会相同，p1 == p2 时有两种情况：</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、要么是两条链表不相交，他俩同时走到尾部空指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、要么是两条链表相交，他俩走到两条链表的相交点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p1 != p2)&#123;</span><br><span class="line"></span><br><span class="line">        p1 =p1.next;</span><br><span class="line"></span><br><span class="line">        p2 =p2.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<br>

<h3 id="4-双指针（七道数组题）"><a href="#4-双指针（七道数组题）" class="headerlink" title="4-双指针（七道数组题）"></a>4-双指针（七道数组题）</h3><blockquote>
<p>链表和数组题中的双指针有两种</p>
</blockquote>
<blockquote>
<p>-<strong>左右指针</strong>，就是两个指针相向而行或者相背而行；</p>
</blockquote>
<blockquote>
<p>-<strong>快慢指针</strong>，就是两个指针同向而行，一快一慢。</p>
</blockquote>
<br>

<h4 id="快慢指针技巧"><a href="#快慢指针技巧" class="headerlink" title="快慢指针技巧"></a>快慢指针技巧</h4><blockquote>
<p>原地修改数组</p>
</blockquote>
<h5 id="删除有序数组中的重复项"><a href="#删除有序数组中的重复项" class="headerlink" title="删除有序数组中的重复项"></a>删除有序数组中的重复项</h5><p>在不新开数组的情况下的解法</p>
<p><img src="https://labuladong.github.io/algo/images/%e6%95%b0%e7%bb%84%e5%8e%bb%e9%87%8d/1.gif" alt="img"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">intremoveDuplicates</span>(<span class="type">int</span>[]nums)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(nums.length==<span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">        return0;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> slow =<span class="number">0</span>, fast =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(fast &lt;nums.length)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums[fast]!=nums[slow])&#123;</span><br><span class="line"></span><br><span class="line">            slow++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 维护 nums[0..slow] 无重复</span></span><br><span class="line"></span><br><span class="line">            nums[slow]=nums[fast];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fast++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组长度为索引 + 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slow +<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于删除有序链表中的重复项呢？</p>
<p><img src="https://labuladong.github.io/algo/images/%e6%95%b0%e7%bb%84%e5%8e%bb%e9%87%8d/2.gif" alt="img"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">ListNodedeleteDuplicates</span>(ListNodehead)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(head == null)<span class="keyword">return</span> null;</span><br><span class="line"></span><br><span class="line">    ListNode slow = head, fast = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(fast != null)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(fast.val!=slow.val)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// nums[slow] = nums[fast];</span></span><br><span class="line"></span><br><span class="line">            slow.next= fast;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// slow++;</span></span><br><span class="line"></span><br><span class="line">            slow =slow.next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// fast++</span></span><br><span class="line"></span><br><span class="line">        fast =fast.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 断开与后面重复元素的连接</span></span><br><span class="line"></span><br><span class="line">    slow.next= null;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<h5 id="删除无序数组中的某个元素"><a href="#删除无序数组中的某个元素" class="headerlink" title="删除无序数组中的某个元素"></a>删除无序数组中的某个元素</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">intremoveElement</span>(<span class="type">int</span>[]nums,intval)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fast =<span class="number">0</span>, slow =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(fast &lt;nums.length)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums[fast]!= val)&#123;</span><br><span class="line"></span><br><span class="line">            nums[slow]=nums[fast];</span><br><span class="line"></span><br><span class="line">            slow++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fast++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里是先给 <code>nums[slow]</code> 赋值然后再给 slow++</p>
<br>

<h5 id="移动0"><a href="#移动0" class="headerlink" title="移动0"></a>移动0</h5><blockquote>
<p>比如说给你输入 <code>nums = [0,1,4,0,2]</code>，你的算法没有返回值，但是会把 <code>nums</code> 数组原地修改成 <code>[1,4,2,0,0]</code>。</p>
</blockquote>
<blockquote>
<p>其实就相当于移除 <code>nums</code> 中的所有 0，然后再把后面的元素都赋值为 0 即可。</p>
</blockquote>
<p>可以复用上一题的 <code>removeElement</code> 函数</p>
<br>

<h4 id="滑动窗口类型（快慢指针）"><a href="#滑动窗口类型（快慢指针）" class="headerlink" title="滑动窗口类型（快慢指针）"></a>滑动窗口类型（快慢指针）</h4><p>代码框架</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 滑动窗口算法框架 */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">voidslidingWindow</span>(strings,stringt)&#123;</span><br><span class="line"></span><br><span class="line">    unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; need, window;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c : t)need[c]++;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left =<span class="number">0</span>, right =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> valid =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(right &lt;s.<span class="built_in">size</span>())&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> c =s[right];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右移（增大）窗口</span></span><br><span class="line"></span><br><span class="line">        right++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(window needs shrink)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">char</span> d =s[left];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 左移（缩小）窗口</span></span><br><span class="line"></span><br><span class="line">            left++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>left</code> 指针在后，<code>right</code> 指针在前，两个指针中间的部分就是「窗口」，算法通过扩大和缩小「窗口」来解决某些问题。</p>
<hr>
<br>

<h4 id="左右指针技巧"><a href="#左右指针技巧" class="headerlink" title="左右指针技巧"></a>左右指针技巧</h4><h5 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h5><p>简单框架</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">intbinarySearch</span>(<span class="type">int</span>[]nums,inttarget)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一左一右两个指针相向而行</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left =<span class="number">0</span>, right =nums.length<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> mid =(right + left)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums[mid]== target)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">elseif</span>(nums[mid]&lt; target)</span><br><span class="line"></span><br><span class="line">            left = mid +<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">elseif</span>(nums[mid]&gt; target)</span><br><span class="line"></span><br><span class="line">            right = mid <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span><span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<h5 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h5><p>返回的下标是从1算起的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span>[] <span class="built_in">twoSum</span>(<span class="type">int</span>[] nums,<span class="type">int</span> target)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一左一右两个指针相向而行</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left =<span class="number">0</span>, right =nums.length<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> sum =nums[left]+nums[right];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 题目要求的索引是从 1 开始的</span></span><br><span class="line"></span><br><span class="line">            returnnewint[]&#123;left +<span class="number">1</span>, right +<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="built_in">elseif</span>(sum &lt; target)&#123;</span><br><span class="line"></span><br><span class="line">            left++; <span class="comment">// 让 sum 大一点 *</span></span><br><span class="line"></span><br><span class="line">        &#125;<span class="built_in">elseif</span>(sum &gt; target)&#123;</span><br><span class="line"></span><br><span class="line">            right--; <span class="comment">// 让 sum 小一点 *</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    returnnewint[]&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<h5 id="反转数组"><a href="#反转数组" class="headerlink" title="反转数组"></a>反转数组</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">voidreverseString</span>(<span class="type">char</span>[]s)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一左一右两个指针相向而行</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left =<span class="number">0</span>, right =s.length<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 交换 s[left] 和 s[right]</span></span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> temp =s[left];</span><br><span class="line"></span><br><span class="line">        s[left]=s[right];</span><br><span class="line"></span><br><span class="line">        s[right]= temp;</span><br><span class="line"></span><br><span class="line">        left++;</span><br><span class="line"></span><br><span class="line">        right--;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<h5 id="回文串匹配"><a href="#回文串匹配" class="headerlink" title="回文串匹配"></a>回文串匹配</h5><p>简单匹配</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">booleanisPalindrome</span>(Strings)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一左一右两个指针相向而行</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left =<span class="number">0</span>, right =s.<span class="built_in">length</span>()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">charAt</span>(left)!=s.<span class="built_in">charAt</span>(right))&#123;</span><br><span class="line"></span><br><span class="line">            returnfalse;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        left++;</span><br><span class="line"></span><br><span class="line">        right--;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    returntrue;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<p><strong>最长回文子串</strong></p>
<blockquote>
<p>左右指针从中间往两边延申</p>
</blockquote>
<blockquote>
<p>如果回文串的长度为奇数，参数 r &#x3D; l</p>
</blockquote>
<blockquote>
<p>如果回文串的长度为偶数，参数 r &#x3D; l+1</p>
</blockquote>
<blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 s 中寻找以 s[l] 和 s[r] 为中心的最长回文串</span></span><br><span class="line"><span class="built_in">Stringpalindrome</span>(Strings,intl,intr)&#123;</span><br><span class="line"><span class="comment">// 防止索引越界</span></span><br><span class="line"><span class="keyword">while</span>(l &gt;=<span class="number">0</span>&amp;&amp; r &lt;s.<span class="built_in">length</span>()</span><br><span class="line">&amp;&amp;s.<span class="built_in">charAt</span>(l)==s.<span class="built_in">charAt</span>(r))&#123;</span><br><span class="line"><span class="comment">// 双指针，向两边展开</span></span><br><span class="line">l--; r++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回以 s[l] 和 s[r] 为中心的最长回文串</span></span><br><span class="line">returns.<span class="built_in">substring</span>(l +<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">StringlongestPalindrome</span>(Strings)&#123;</span><br><span class="line"></span><br><span class="line">    String res =<span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i &lt;s.<span class="built_in">length</span>(); i++)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以 s[i] 为中心的最长回文子串</span></span><br><span class="line"></span><br><span class="line">        String s1 =<span class="built_in">palindrome</span>(s, i, i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以 s[i] 和 s[i+1] 为中心的最长回文子串</span></span><br><span class="line"></span><br><span class="line">        String s2 =<span class="built_in">palindrome</span>(s, i, i +<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// res = longest(res, s1, s2)</span></span><br><span class="line"></span><br><span class="line">        res =res.<span class="built_in">length</span>()&gt;s1.<span class="built_in">length</span>()? res : s1;</span><br><span class="line"></span><br><span class="line">        res =res.<span class="built_in">length</span>()&gt;s2.<span class="built_in">length</span>()? res : s2;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客看到的一大佬的汇总</title>
    <url>/2024/01/01/%E7%89%9B%E5%AE%A2%E7%9C%8B%E5%88%B0%E7%9A%84%E4%B8%80%E5%A4%A7%E4%BD%AC%E7%9A%84%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<p><img src="/2024/01/01/%E7%89%9B%E5%AE%A2%E7%9C%8B%E5%88%B0%E7%9A%84%E4%B8%80%E5%A4%A7%E4%BD%AC%E7%9A%84%E6%B1%87%E6%80%BB/image-20240101232202608.png" alt="太强了"></p>
<p><a href="https://www.nowcoder.com/discuss/543596390270640128?sourceSSR=users">2023秋招 游戏客户端 个人笔经汇总_牛客网 (nowcoder.com)</a></p>
]]></content>
      <categories>
        <category>面经汇总</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL基础学习</title>
    <url>/2024/01/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h2><p><strong>关系型数据库的三大范式</strong></p>
<ul>
<li>第一范式：<ul>
<li>单一字段只能表示一种数据（字段的原子性）</li>
<li>（否则可分为多个字段）</li>
</ul>
</li>
<li>第二范式：<ul>
<li>非主键必须依赖整个主键，而非部分主键</li>
<li>（否则可以分为多个表）</li>
</ul>
</li>
<li>第三范式：<ul>
<li>非主键必须直接依赖主键，不能间接依赖</li>
<li>（否则可以分为多个表）</li>
</ul>
</li>
</ul>
<span id="more"></span>

<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p><strong>事务的四大特性</strong></p>
<ul>
<li>原子性：事务中的操作 要么全部成功，要么全部失败回滚</li>
<li>一致性：一个事务执行前后，数据库的状态保持一致（类比能量守恒）</li>
<li>隔离性：一个事务只能读到已经提交的修改</li>
<li>持久性：一个事务一旦提交，对数据库中的数据的改变是永久性的，即使数据库系统遇到故障也不会丢失事务操作所做的修改。</li>
</ul>
<p><strong>事务的隔离等级</strong></p>
<p>前置概念</p>
<ul>
<li><strong>脏读</strong>：一个事务处理过程中读取了另一个未提交的事务中的数据<ul>
<li>当一个事务对数据进行修改但还没有提交时，其他事务可能会读取到这个尚未提交的数据。</li>
<li>类似的情况在并发编程中被称为<strong>竞态条件</strong>（Race Condition），它指的是多个线程同时访问临界资源，并且对该资源进行修改，从而导致结果的不确定性或错误。</li>
<li>数据库通常使用锁机制来控制并发访问。</li>
</ul>
</li>
<li><strong>不可重复读</strong><ul>
<li>一个事务范围内，多次相同的查询却返回了不同的数据值</li>
<li>原因是在查询间隔内，另一个事务修改了数据并提交了</li>
</ul>
</li>
<li><strong>幻读</strong><ul>
<li>对于一个事务，在前面进行了查询，之后又有其他事务插入或删除数据，导致前面查询到的数据失去有效性。</li>
<li>原因：使用了读取一致性级别不同的事务隔离级别</li>
</ul>
</li>
</ul>
<p>MySQL的四种隔离级别</p>
<ul>
<li><strong>串行化</strong> Serializable<ul>
<li>强制事务顺序，使之不可能相互冲突，解决幻读</li>
</ul>
</li>
<li><strong>可重复读</strong> Repeatable Read<ul>
<li>默认事务隔离级别，确保同一事务的多个实例在并发读取数据时，会看到同样的数据行，解决了不可重复读的问题。</li>
</ul>
</li>
<li><strong>读已提交</strong> Read Committed<ul>
<li>一个事务只能看见已经提交的事务所做的改变，避免脏读</li>
</ul>
</li>
<li><strong>读未提交</strong> Read Uncommitted<ul>
<li>所有的事务都可以看到其他未提交事务的执行结果</li>
</ul>
</li>
</ul>
<p>生存环境一般使用 <strong>读已提交RC</strong></p>
<ul>
<li>为什么使用RC而不是RR<ul>
<li>RR存在<u>间隙锁</u>，更容易出现死锁</li>
<li>RR级别下，<u>条件列未命中索引</u>会锁表，而RC级别下只锁行</li>
<li>可见RC的并发性高于RR</li>
<li>另外不可重复读问题<u>有时候</u>是可接受的</li>
</ul>
</li>
</ul>
<h2 id="编码与字符集"><a href="#编码与字符集" class="headerlink" title="编码与字符集"></a>编码与字符集</h2><p><strong>编码和字符集</strong></p>
<ul>
<li>ASCII<ul>
<li>单字符：8bits，1Byte</li>
<li>只能表示256个字符</li>
</ul>
</li>
<li>各种特殊编码，如中文的 GB2312，希腊语的 greek，俄语的 cp866</li>
<li>Unicode，统一各种编码为一种<ul>
<li>单字符：2~4Byte</li>
<li><img src="/2024/01/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%AD%A6%E4%B9%A0/image-20240104222222435.png" alt="image-20240104222222435" style="zoom:80%;"></li>
</ul>
</li>
<li>UTF-8<ul>
<li>优化了Unicode的字符中不必要的字节</li>
</ul>
</li>
<li>总结<ul>
<li>按照一定规则把符号和二进制码对应起来，这就是<strong>编码</strong>。而把n多这种已经编码的字符聚在一起，就是我们常说的<strong>字符集</strong>。</li>
<li>比如utf-8字符集就是所有utf-8编码格式的字符的合集。</li>
</ul>
</li>
</ul>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="索引概述"><a href="#索引概述" class="headerlink" title="索引概述"></a>索引概述</h3><blockquote>
<p>是什么</p>
<ul>
<li>索引用于加快磁盘数据的访问，属于用空间换时间</li>
<li>索引记录的内容有一组数据的关键字和数据各个部分的存储位置，通过某些数据结构（B树、B+树）组织关键字，在这样数据结构上对关键字进行查询，从而找到关键字对应数据的存储位置，再到磁盘中直接获取。</li>
<li>数据存储在磁盘中的某个位置，我们要访问某个磁盘中的数据<ul>
<li>在没有使用索引的情况下，就得把全部相关的数据加载到内存中（如果数据量很大，就需要加载多次，非常耗时），然后再从内存中遍历找到数据。</li>
<li>使用索引，只需将索引加载到内存，然后在索引中根据关键字找到数据的存储位置，便可直接找到磁盘中数据并进行加载<ul>
<li>一般来说不会一次性加载所有的索引节点，如果是B树，B+树，每次会根据需要加载一定数量的节点，对磁盘的访问次数最多等于树的高度</li>
<li>此外，对于高频使用的索引，还会将其缓存到内存中</li>
</ul>
</li>
</ul>
</li>
<li>索引键值一般就是该行数据某个列上的具体值</li>
</ul>
</blockquote>
<blockquote>
<p><strong>GPT</strong></p>
<p>Q: 对于数据库中的一列，为其建立索引，那么其键值是什么，查找某个数据的过程是怎样的</p>
<p>A:</p>
<p>在为数据库中的一列建立索引时，键值是该列中的具体值。具体来说，对于每个索引条目，键值是该列中一行数据的值。</p>
<p>当进行通过索引进行数据查询时，数据库系统会使用索引树的结构来加速查询过程。以下是查找某个数据的一般过程：</p>
<ol>
<li>查询条件：首先，根据查询语句中的条件确定需要查找的数据。</li>
<li>索引搜索：数据库会根据索引的键值进行搜索。如果该列上有索引，并且该索引适用于查询条件，则数据库系统会根据索引树进行搜索。</li>
<li>索引树遍历：数据库系统会依次遍历索引树的节点，从根节点开始，在每个节点选择合适的子节点继续查找，直到找到满足查询条件的数据。</li>
<li>数据访问：一旦找到满足条件的索引节点，数据库系统会使用该节点中的指针来访问相应的数据行。这可能涉及到磁盘读取操作，将数据从磁盘中加载到内存。</li>
<li>数据返回：找到满足条件的数据行后，数据库系统会将其返回给用户。</li>
</ol>
<p>需要注意的是，索引的目的是为了加速数据的查询操作。索引的建立和使用需要在一定程度上增加存储空间和维护开销。因此，对于不频繁搜索的列或一些其他条件，建立索引可能并不总是必要或有效的选择。</p>
</blockquote>
<p>作用</p>
<ul>
<li>数据是存储在磁盘上的</li>
<li>查询数据时，如果没有索引，会加载所有的数据到内存，依次进行检索，读取磁盘次数较多。</li>
<li>有了索引，就不需要加载所有数据，因为B+树的高度一般在2-4层，最多只需要读取2-4次磁盘，查询速度大大提升。</li>
</ul>
<p>优点：</p>
<ul>
<li><strong>加快数据查找的速度</strong></li>
<li>为用来排序或者是分组的字段添加索引，可以加快分组和排序的速度</li>
<li>加快表与表之间的连接</li>
</ul>
<p>缺点：</p>
<ul>
<li>建立索引需要<strong>占用物理空间</strong></li>
<li>会降低表的增删改的效率，因为每次对表记录进行增删改，需要进行<strong>动态维护索引</strong>，导致增删改时间变长</li>
</ul>
<p>使用场景</p>
<ul>
<li>经常用于查询的字段</li>
<li>经常用于连接的字段建立索引</li>
<li>经常需要排序的字段建立索引（建立索引就排好序了）</li>
</ul>
<p>不适用的</p>
<ul>
<li><code>where</code>条件中用不到的字段不适合建立索引</li>
<li>表记录较少</li>
<li>需要经常增删改</li>
<li><strong>参与列计算</strong>的列不适合建索引</li>
<li><strong>区分度不高</strong>的字段不适合建立索引，如性别</li>
</ul>
<h3 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h3><h4 id="线性索引"><a href="#线性索引" class="headerlink" title="线性索引"></a>线性索引</h4><ul>
<li>用有序数组组织索引</li>
<li>可以通过二分查找快速找到键值位置</li>
<li>当数据量太大时，可以分为多层线性索引，在最底层记录每一个数据的存储位置</li>
<li>缺点<ul>
<li>对于数组，增删的代价比较大</li>
</ul>
</li>
</ul>
<h4 id="B树索引"><a href="#B树索引" class="headerlink" title="B树索引"></a>B树索引</h4><p>2-3树即3阶B树</p>
<img src="/2024/01/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%AD%A6%E4%B9%A0/image-20240106191056937.png" alt="image-20240106191056937" style="zoom:80%;">

<h4 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h4><ul>
<li>中间结点中，只保存关键字的值（引导） </li>
<li>叶子节点中，保存关键字以及相应的数据记录（即数据记录存放在叶子结点）</li>
</ul>
<img src="/2024/01/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%AD%A6%E4%B9%A0/image-20240106192038264.png" alt="image-20240106192038264" style="zoom:80%;">

<ul>
<li>支持范围查找 ： 同一层的结点还通过链表相连</li>
</ul>
<blockquote>
<p>B树和B+树的插入、删除产生的分裂和合并以及层次变化的过程，可以去看下一华工数据结构慕课。</p>
</blockquote>
<ul>
<li>也有不完全一样的定义方式</li>
</ul>
<img src="/2024/01/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%AD%A6%E4%B9%A0/image-20240106225126484.png" alt="image-20240106225126484" style="zoom:80%;">

<h4 id="哈希表索引"><a href="#哈希表索引" class="headerlink" title="哈希表索引"></a>哈希表索引</h4><ul>
<li>哈希索引是基于哈希表实现的，对于每一行数据，存储引擎会对索引列进行哈希计算得到哈希码，并且哈希算法要尽量保证不同的列值计算出的哈希码值是不同的。</li>
<li>将哈希码的值作为哈希表的key值，将指向数据行的指针作为哈希表的value值。</li>
<li>这样查找一个数据的时间复杂度就是O(1)，一般多用于精确查找。</li>
</ul>
<p>与 B+树 索引的比较</p>
<ul>
<li>哈希索引<strong>不支持排序</strong>，因为哈希表是无序的。</li>
<li>哈希索引<strong>不支持范围查找</strong>。</li>
<li>哈希索引<strong>不支持模糊查询</strong>及多列索引的最左前缀匹配。</li>
<li>因为哈希表中会<strong>存在哈希冲突</strong>，所以哈希索引的性能是不稳定的，而B+树索引的性能是相对稳定的，每次查询都是从根节点到叶子节点。</li>
</ul>
<h4 id="为什么B-树比B树更适合实现数据库索引？"><a href="#为什么B-树比B树更适合实现数据库索引？" class="headerlink" title="为什么B+树比B树更适合实现数据库索引？"></a>为什么B+树比B树更适合实现数据库索引？</h4><ul>
<li>由于B+树的数据都存储在叶子结点中，叶子结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，而在数据库中基于范围的查询是非常频繁的，所以通常B+树用于数据库索引。</li>
<li>B+树的节点只存储索引key值，具体信息的地址存在于叶子节点的地址中。这就使以页为单位的索引中可以存放更多的节点。减少更多的I&#x2F;O支出。</li>
<li>B+树的查询效率更加稳定，任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</li>
</ul>
<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="架构篇"><a href="#架构篇" class="headerlink" title="架构篇"></a>架构篇</h3>]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux多线程</title>
    <url>/2023/02/10/%E7%AC%AC%E4%B8%89%E7%AB%A0Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="第三章-Linux多线程开发"><a href="#第三章-Linux多线程开发" class="headerlink" title="第三章 Linux多线程开发"></a>第三章 Linux多线程开发</h1><hr>
<br>

<h2 id="3-1-线程"><a href="#3-1-线程" class="headerlink" title="3.1 线程"></a>3.1 线程</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><span id="more"></span>

<ul>
<li>与进程类似，线程是允许应用程序并发执行多个任务的一种机制。<ul>
<li>一个进程可以包含多个线程。</li>
<li>同一个程序中的所有线程均会独立执行相同程序，且共享同一份全局内存区域，其中包括初始化数据段、未初始化数据段，以及堆内存段。（传统意义上的 UNIX 进程只是多线程程序的一个特例，该进程只包含一个线程）</li>
</ul>
</li>
<li>进程是 CPU 分配资源的最小单位，线程是操作系统调度执行的最小单位</li>
<li>线程是轻量级的进程( LWP ,Light Weight Process )，在 Linux 环境下线程的本质仍是进程</li>
<li>查看指定进程的 LWP 号：<code>ps -Lf pid</code></li>
</ul>
<br>

<br>

<p><strong>线程与进程的区别</strong></p>
<p>进程：</p>
<ul>
<li>进程间的信息难以共享。由于除去只读代码段外，父子进程并未共享内存，因此必须采用一些进程间通信方式，在进程间进行信息交换</li>
<li>调用 fork() 来创建进程的代价相对较高，即便利用了 写时复制 技术，仍需要复制诸如内存页表和文件描述符表之类的多种进程属性</li>
</ul>
<br>

<p>线程：</p>
<ul>
<li>线程之间能够方便、快速的共享信息。只需要将数据复制到共享(全局或堆)变量中即可</li>
<li>创建线程比创建进程通常要快得多。线程间是共享虚拟地址空间的，无需采用写时复制来复制内存，也无需复制页表</li>
</ul>
<p><img src="/2023/02/10/%E7%AC%AC%E4%B8%89%E7%AB%A0Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20230208234052055.png" alt="image-20230208234052055"></p>
<p><strong>线程资源</strong></p>
<p>共享资源：</p>
<ul>
<li>进程id，父进程id</li>
<li>进程组id，会话id</li>
<li>用户id，用户组id</li>
<li>文件描述符表</li>
<li>信号处置（注册的、默认的）</li>
<li>文件系统的相关信息：umask、当前工作目录</li>
<li>虚拟地址空间（除了栈、.text段)</li>
</ul>
<br>

<p>非共享资源：</p>
<ul>
<li>线程id</li>
<li>信号掩码</li>
<li>线程特有数据</li>
<li>error 变量（线程特有）</li>
<li>实时调度策略 和 优先级</li>
<li>栈、本地变量和函数的调用链接信息</li>
</ul>
<br>

<p><strong>NPTL</strong></p>
<p>查看当前 pthread 库版本：<code>getconf GNU_LIBPTHREAD_VERSION</code></p>
<p><img src="/2023/02/10/%E7%AC%AC%E4%B8%89%E7%AB%A0Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20230208234720549.png" alt="image-20230208234720549"></p>
<br>

<br>

<br>

<h3 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h3><p>一般情况下，main函数所在的线程作为主线程（main线程），其余创建的称为子线程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	创建一个子线程</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- thread：传出参数，线程创建成功后，子线程的线程id被写入该变量</span></span><br><span class="line"><span class="comment">		- attr：设置线程的属性，一般使用默认值 NULL</span></span><br><span class="line"><span class="comment">		- start_routine：函数指针，子线程需要处理的逻辑代码</span></span><br><span class="line"><span class="comment">		- arg：作为start_routine的参数</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		成功 返回0</span></span><br><span class="line"><span class="comment">		失败 返回错误号。与之前的erron不太一样</span></span><br><span class="line"><span class="comment">		获取错误号信息：char *strerror(int errnum);</span></span><br><span class="line"><span class="comment">*/</span>	</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<blockquote>
<p>编译的时候要加 -pthread</p>
</blockquote>
<br>

<p><strong>案例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">callback</span><span class="params">(<span class="type">void</span>*arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child thread and arg: %d\n&quot;</span>,*(<span class="type">int</span> *)arg);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, callback, (<span class="type">void</span>*)&amp;num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span> *errstr = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;err:%s\n&quot;</span>,errstr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<br>

<br>

<h3 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于提前 return</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	终止一个线程，在哪个线程中调用就终止哪个线程</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- retval：需要传递一个指针，作为一个返回值，可以在 pthread_join() 中获取到</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前线程的线程id</span></span><br><span class="line"><span class="type">pthread_t</span> <span class="title function_">pthread_self</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较两个线程 ID 是否相等</span></span><br><span class="line"><span class="comment">// 不同的操作系统，pthread_t类型的实现不同，有的是无符号长整形，有的是结构体。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_equal</span><span class="params">(<span class="type">pthread_t</span> t1, <span class="type">pthread_t</span> t2)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<br>

<h3 id="连接已终止的线程"><a href="#连接已终止的线程" class="headerlink" title="连接已终止的线程"></a>连接已终止的线程</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	和一个已经终止的线程进行连接（阻塞的）</span></span><br><span class="line"><span class="comment">	回收子线程的资源（一次回收一个）</span></span><br><span class="line"><span class="comment">	一般在主线程中使用</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- thread：需要回收的子线程的id</span></span><br><span class="line"><span class="comment">		- retval：二级指针，接收子线程退出时的返回值</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		成功 0</span></span><br><span class="line"><span class="comment">		失败 非0 返回错误号</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<p><strong>接收返回值的join案例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> value =<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">callback</span><span class="params">(<span class="type">void</span>*arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child thread and arg: %d\n&quot;</span>,*(<span class="type">int</span> *)arg);</span><br><span class="line">    pthread_exit((<span class="type">void</span> *)&amp;value);	<span class="comment">// return (void *)&amp;value;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, callback, (<span class="type">void</span>*)&amp;num);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span> *errstr = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;err:%s\n&quot;</span>,errstr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 主线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 回收</span></span><br><span class="line">    <span class="type">int</span> *rtvalue;	<span class="comment">// 作接收的变量</span></span><br><span class="line">    ret = pthread_join(tid,(<span class="type">void</span> **)&amp;rtvalue);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span> *errstr = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;err:%s\n&quot;</span>,errstr);</span><br><span class="line">    &#125;	</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;get return value:%d\n&quot;</span>,*rtvalue);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<br>

<br>

<h3 id="线程分离"><a href="#线程分离" class="headerlink" title="线程分离"></a>线程分离</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	分离一个线程</span></span><br><span class="line"><span class="comment">	将指定线程标记为分离，当该线程终止时系统会自动回收资源，而不再需要别的线程来join回收</span></span><br><span class="line"><span class="comment">	不能 detach / join 一个已经分离的线程</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- thread：需要分离的线程的id</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		成功 0</span></span><br><span class="line"><span class="comment">		失败 非0 返回错误号</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<br>

<h3 id="线程取消"><a href="#线程取消" class="headerlink" title="线程取消"></a>线程取消</h3><ul>
<li>调用 pthread_cancel 之后，线程不会立即退出，而是等运行到某一 取消点 的时候才会真正取消</li>
<li>取消点：系统规定好的一些系统调用，一般在用户态切换到内核态的场景出现</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	取消线程，当子线程执行到一个取消点时，线程才会终止</span></span><br><span class="line"><span class="comment">	线程能否取消取决于线程的一些属性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<br>

<h3 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h3><p>pthread_create()的第二个参数传入线程属性</p>
<p><strong>相关函数</strong></p>
<p><img src="/2023/02/10/%E7%AC%AC%E4%B8%89%E7%AB%A0Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20230209190308454.png" alt="image-20230209190308454"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">线程属性类型 <span class="type">pthread_attr_t</span></span><br><span class="line"></span><br><span class="line">    变量初始化与回收</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_init</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	初始化线程属性变量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_destroy</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	释放线程属性变量的资源</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	属性设置和获取</span><br><span class="line">        </span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getdetachstate</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> </span></span><br><span class="line"><span class="params">*detachstate)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	获取线程分离的状态属性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setdetachstate</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> </span></span><br><span class="line"><span class="params">detachstate)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	设置线程分离的状态属性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<br>

<br>

<br>

<h2 id="3-2-同步互斥"><a href="#3-2-同步互斥" class="headerlink" title="3.2 同步互斥"></a>3.2 同步互斥</h2><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><ul>
<li>线程的主要优势在于能够通过全局变量来共享信息。但是要确保多个线程不会同时修改同一变量，或者某一线程不会读取正在由其他线程修改的变量。</li>
</ul>
<br>

<p><strong>临界区</strong></p>
<p>指访问某一共享资源的代码片段，并且这段代码的执行应该为 原子操作 ，也就是同时访问同一共享资源的其他线程不应该中断该片段的执行。</p>
<br>

<p><strong>同步与互斥</strong></p>
<p><strong>线程同步</strong> 就是协同步调，按预定的先后次序进行运行。如：你说完，我再说。线程同步是指多线程通过特定的设置（如互斥量，事件对象，临界区）来控制线程之间的执行顺序（即所谓的同步）也可以说是在线程之间通过同步建立起执行顺序的关系，如果没有同步，那线程之间是各自运行各自的，也即异步。</p>
<p><strong>线程互斥</strong> 是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步。</p>
<br>

<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><ul>
<li>为了线程更新共享变量时出现问题，可以使用互斥量 mutex( mutual exclusion ) 来确保同时仅有一个线程可以访问某项共享资源。可以使用互斥量来保证对任意共享资源的原子访问。</li>
<li>互斥量有两种状态：锁定locked 和 未锁定unlocked 。任何时刻，至多只有一个线程可以锁定该互斥量。试图对已经锁定的某一互斥量再次加锁，将可能阻塞线程或者报错失败，具体取决于加锁使用的方法。</li>
<li>一旦线程锁定互斥量，随即成为该互斥量的所有者，只有所有者才能给互斥量解锁。一般情况下，对每一共享资源（可能有多个相关变量组成）会使用不同的互斥量，每一线程在访问同一资源时将采用如下协议：<ul>
<li>锁定相应的互斥量</li>
<li>访问共享资源</li>
<li>对互斥量解锁</li>
</ul>
</li>
</ul>
<br>

<p><img src="/2023/02/10/%E7%AC%AC%E4%B8%89%E7%AB%A0Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20230210020752443.png" alt="image-20230210020752443"></p>
<br>

<br>

<p><strong>互斥量相关函数</strong></p>
<p>互斥量类型 <code>pthread_mutex_t</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	初始化互斥量</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- mutex：需要初始化的互斥变量</span></span><br><span class="line"><span class="comment">		- attr：互斥量相关的属性，一般NULL</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	restrict ：C语言的修饰符，被修饰的指针指向的内容不能由别的指针进行操作</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	释放互斥量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	给互斥量加锁</span></span><br><span class="line"><span class="comment">	阻塞的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	给互斥量尝试加锁</span></span><br><span class="line"><span class="comment">	非阻塞</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	解锁</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<br>

<br>

<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul>
<li>有时，一个线程需要同时访问两个或更多不同的共享资源，而每个资源又都有不同的互斥量管理。当超过一个线程加锁同一组互斥量时，就可能发送死锁</li>
</ul>
<p><img src="/2023/02/10/%E7%AC%AC%E4%B8%89%E7%AB%A0Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20230210022902860.png" alt="image-20230210022902860"></p>
<br>

<blockquote>
<p><strong>死锁</strong>：两个或两个以上的进程在执行过程中，因为夺取资源而造成的一种相互等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统发生了死锁。</p>
<p><strong>场景</strong>：</p>
<ul>
<li>忘记释放锁</li>
<li>重复加锁</li>
<li>多线程多锁，抢占资源</li>
</ul>
</blockquote>
<br>

<br>

<p>更多相关内容详见操作系统课程…</p>
<br>

<br>

<br>

<br>

<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><ul>
<li>当一个线程已经持有互斥锁时，互斥锁将所有试图进入临界区的线程都阻塞住。<br>但考虑一种情况：当前持有互斥锁的线程只是读共享资源，而同时有其他几个线程也想读取这个共享资源，但由于互斥锁的排他性，所有线程都无法获取锁，即无法读访问共享资源，但是实际上多个线程同时读访问共享资源并不会导致问题</li>
<li>在对数据的读写操作中，更多的是读操作，写操作较少。为了满足允许多个读出，而只允许单个写入的情况，线程提供了读写锁来实现。</li>
</ul>
<br>

<p><strong>读写锁特点</strong>：</p>
<ul>
<li>如果有其他线程 <strong>读数据</strong> ，则允许其他线程执行读操作，但不允许写操作</li>
<li>如果有其他线程 <strong>写数据</strong> ，则其他线程都不允许读、写操作</li>
<li>写是独占的，写的优先级更高</li>
</ul>
<br>

<br>

<p><strong>相关函数</strong></p>
<p>读写锁类型 <code>pthread_rwlock_t</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化读写锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_init</span><span class="params">(<span class="type">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock, <span class="type">const</span> <span class="type">pthread_rwlock_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回收读写锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_destroy</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加读锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_rdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试加读锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_tryrdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加写锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_wrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试加写锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_trywrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_unlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<br>

<br>

<p><strong>生产者与消费者模型</strong></p>
<p><img src="/2023/02/10/%E7%AC%AC%E4%B8%89%E7%AB%A0Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20230210040352527.png" alt="image-20230210040352527"></p>
<br>

<p>更多相关内容详见操作系统课程…</p>
<br>

<br>

<br>

<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>不是锁，能够配合互斥量使用实现线程的同步关系</p>
<p>类型 <code>pthread_cond_t</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="type">const</span> <span class="type">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回收</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待条件实现（阻塞）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待条件实现（阻塞指定的一段时间）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_timewait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="type">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> abstime)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒等待的一个或多个等待的线程</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒所有等待的线程</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<br>

<blockquote>
<p>注意当 wait 阻塞的时候，会将 互斥锁 解锁；</p>
<p>等到 wait 被唤醒之后，又会在原处重新 对 互斥锁 加锁</p>
</blockquote>
<br>

<br>

<br>

<br>

<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>类型 <code>sem_t</code></p>
<p>与条件变量类似，与互斥锁搭配使用，实现线程同步关系</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	信号量初始化</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		sem：信号量变量的地址</span></span><br><span class="line"><span class="comment">		pshared：0 表示用于线程间， 非0 表示用于进程间</span></span><br><span class="line"><span class="comment">		value：信号量中的值，可表示资源数量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放资源</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_destroy</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若信号量值为 0 就阻塞，信号量值大于 0 就 -1，</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_trywait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_timewait</span><span class="params">(<span class="type">sem_t</span> *sem,<span class="type">const</span> <span class="keyword">struct</span> timespec *abs_timeout)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号量值 +1 ，并且如果有的话就唤醒一个 wait 中的线程</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_getvalue</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> sval)</span>;</span><br></pre></td></tr></table></figure>

<br>

<blockquote>
<p>wait – post 对应 P – V 操作</p>
</blockquote>
<br>

<p>模拟生产者消费者</p>
<p>以资源容量为 8 为例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> resource = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> psem;</span><br><span class="line"><span class="type">sem_t</span> csem;</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">producer</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sem_wait(&amp;psem);</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        ++resource;</span><br><span class="line">        usleep(<span class="number">100</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;tid:%ld, produce : %d\n&quot;</span>,pthread_self(),resource);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        sem_post(&amp;csem);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">consumer</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sem_wait(&amp;csem);</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        --resource;</span><br><span class="line">        usleep(<span class="number">100</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;tid:%ld, consume : %d\n&quot;</span>,pthread_self(),resource);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        sem_post(&amp;psem);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    sem_init(&amp;psem, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">    sem_init(&amp;csem, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> ptids[<span class="number">5</span>],ctids[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">        pthread_create(&amp;ptids[i],<span class="literal">NULL</span>,producer,<span class="literal">NULL</span>);</span><br><span class="line">        pthread_create(&amp;ctids[i],<span class="literal">NULL</span>,consumer,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">        pthread_join(ptids[i],<span class="literal">NULL</span>);</span><br><span class="line">        pthread_join(ctids[i],<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    sem_destroy(&amp;psem);</span><br><span class="line">    sem_destroy(&amp;csem);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<p><img src="/2023/02/10/%E7%AC%AC%E4%B8%89%E7%AB%A0Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20230210071555920.png" alt="image-20230210071555920"></p>
<p><br><br><br></p>
<p>第三章完结！</p>
<br>

<br>







]]></content>
      <categories>
        <category>C++开发</category>
        <category>高性能服务器项目</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>第五章项目实战</title>
    <url>/2023/03/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h1 id="5-项目相关知识点"><a href="#5-项目相关知识点" class="headerlink" title="5.项目相关知识点"></a>5.项目相关知识点</h1><br>

<br>

<br>

<h2 id="5-1-阻塞-x2F-非阻塞，同步-x2F-异步"><a href="#5-1-阻塞-x2F-非阻塞，同步-x2F-异步" class="headerlink" title="5.1 阻塞&#x2F;非阻塞，同步&#x2F;异步"></a>5.1 阻塞&#x2F;非阻塞，同步&#x2F;异步</h2><p>此处是对于 <strong>网络IO</strong></p>
<p>IO的两个阶段：1.<strong>数据就绪</strong> 2.<strong>数据读写</strong></p>
<br>

<p><strong>数据就绪</strong>	操作系统、内核缓冲区中</p>
<ul>
<li>阻塞   ：调用IO方法的线程进入阻塞状态</li>
<li>非阻塞  ：不改变线程的状态，通过返回值判断</li>
</ul>
<br>

<p><strong>数据读写</strong>	缓冲区的数据&lt;–&gt;内存</p>
<ul>
<li>同步   : 应用程序自行读写</li>
<li>异步   : 操作系统辅助读写   （异步IO接口、通知方式）</li>
</ul>
<br>

<span id="more"></span>

<blockquote>
<img src="/2023/03/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20230303232426115.png" alt="image-20230303232426115" style="zoom:80%;">

<p>陈硕：在处理IO的时候，阻塞和非阻塞都是同步IO，只有使用了特殊的API才是异步IO</p>
</blockquote>
<br>

<p>对于网络IO</p>
<ul>
<li>一个典型的<strong>网络IO接口调用</strong>，分为两个阶段，分别是“<strong>数据就绪</strong>” 和 “<strong>数据读写</strong>”<ul>
<li><strong>数据就绪</strong>阶段分为<strong>阻塞和非阻塞</strong>，表现得结果就是，<strong>阻塞当前线程</strong>或是<strong>直接返回</strong>。</li>
</ul>
</li>
</ul>
<br>

<ul>
<li><p><strong>同步</strong>表示A向B请求调用一个网络IO接口时（或者调用某个业务逻辑API接口时），<strong>数据的读写</strong>都是由<strong>请求方A自己来完成的</strong>（不管是阻塞还是非阻塞）</p>
</li>
<li><p><strong>异步</strong>表示A向B请求调用一个网络IO接口时（或者调用某个业务逻辑API接口时），向B传入<strong>请求的事件</strong>以及<strong>事件发生时通知的方式</strong>，<strong>A就可以处理其它逻辑了</strong>，当B监听到事件处理完成后，会用事先约定好的通知方式，通知A处理结果。</p>
<ul>
<li><p>同步阻塞</p>
</li>
<li><p>同步非阻塞</p>
</li>
<li><p>异步阻塞</p>
</li>
<li><p>异步非阻塞</p>
</li>
</ul>
</li>
</ul>
<br>

<br>

<br>

<br>

<h2 id="5-2-Linux的五种IO模型"><a href="#5-2-Linux的五种IO模型" class="headerlink" title="5.2 Linux的五种IO模型"></a>5.2 Linux的五种IO模型</h2><img src="/2023/03/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20230303232426115.png" alt="image-20230303232426115" style="zoom:80%;">

<h3 id="阻塞-blocking"><a href="#阻塞-blocking" class="headerlink" title="阻塞 blocking"></a>阻塞 blocking</h3><p>调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的去检查这个函数有没有返回，必须等待这个函数返回才能进行下一步操作。</p>
<p>以read为例：</p>
<img src="/2023/03/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20230304000806869.png" alt="image-20230304000806869" style="zoom:80%;">

<br>

<h3 id="非阻塞-non-blocking（NIO）"><a href="#非阻塞-non-blocking（NIO）" class="headerlink" title="非阻塞 non-blocking（NIO）"></a>非阻塞 non-blocking（NIO）</h3><p>非阻塞等待，每隔一段时间就去检测IO事件是否就绪，若没有就绪就可以做其他事。</p>
<p>非阻塞I&#x2F;O执行系统调用总是立即返回，不管事件是否已经发生。若事件没有发生，则返回-1，此时可以根据errno区分情况。</p>
<p>对于<strong>accept，recv和send</strong>，事件未发生时，errno通常被设置为<strong>EAGAIN</strong>。</p>
<img src="/2023/03/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20230304001316512.png" alt="image-20230304001316512" style="zoom:80%;">

<br>

<h3 id="IO复用（multiplexing）"><a href="#IO复用（multiplexing）" class="headerlink" title="IO复用（multiplexing）"></a>IO复用（multiplexing）</h3><p>Linux用select&#x2F;poll&#x2F;epoll函数实现IO复用模型，这些函数也会使进程阻塞，但是和阻塞IO所不同的是这些函数<strong>可以同时阻塞多个IO操作</strong>。而且可以<strong>同时对多个读操作、写操作的IO函数进行检测</strong>。直到有数据可读或可写时，才真正调用IO操作函数。</p>
<p>用于在一个服务端线程中响应多个客户端，但是不是处理高并发的（多线程多进程）。</p>
<img src="/2023/03/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20230304002733110.png" alt="image-20230304002733110" style="zoom:80%;">

<br>

<h3 id="信号驱动（signal-driven）"><a href="#信号驱动（signal-driven）" class="headerlink" title="信号驱动（signal-driven）"></a>信号驱动（signal-driven）</h3><p>Linux用套接口进行信号驱动IO，安装一个<strong>信号处理函数</strong>，进程继续运行并不阻塞。当IO事件就绪，进程收到SIGIO信号，然后处理IO事件。</p>
<ul>
<li>内核在数据准备阶段是异步的，在数据读写结段是同步的</li>
<li>与非阻塞IO的区别在于它提供了消息通知机制，不需要用户进程不断轮询检查，减少了系统API的调用次数，提高了效率</li>
</ul>
<img src="/2023/03/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20230304003340232.png" alt="image-20230304003340232" style="zoom:80%;">

<br>

<h3 id="异步IO（asynchronous）"><a href="#异步IO（asynchronous）" class="headerlink" title="异步IO（asynchronous）"></a>异步IO（asynchronous）</h3><p>Linux中，可以调用 aio_read 函数告诉内核<strong>描述符缓冲区指针</strong>和<strong>缓冲区的大小</strong>、<strong>文件偏移</strong>及<strong>通知的方式</strong>等，然后立即返回，当内核将数据拷贝到缓冲区后，在通知应用程序。</p>
<img src="/2023/03/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20230304004046738.png" alt="image-20230304004046738" style="zoom:80%;">

<br>

<img src="/2023/03/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20230304004303084.png" alt="image-20230304004303084" style="zoom:80%;">

<br>

<br>

<br>

<br>

<h2 id="5-3-Web服务器简介及http协议"><a href="#5-3-Web服务器简介及http协议" class="headerlink" title="5.3 Web服务器简介及http协议"></a>5.3 Web服务器简介及http协议</h2><h3 id="Web-Server"><a href="#Web-Server" class="headerlink" title="Web Server"></a>Web Server</h3><p>网页服务器</p>
<p>一个 Web Server 就是一个<strong>服务器软件</strong>（程序），或者是<strong>运行这个服务器软件的硬件</strong>（计算机）。</p>
<p>其主要功能就是通过 <strong>HTTP</strong> 协议与<strong>客户端</strong>（通常是浏览器Browser）进行<strong>通信</strong>，来<strong>接收、存储、处理</strong>来自客户端的 <strong>HTTP请求</strong> ，并对其请求做出 <strong>HTTP响应</strong> ，返回给客户端其请求的内容（<strong>文件、网页等</strong>）或返回一个 <strong>Error 信息</strong>。</p>
<br>

<p><img src="/2023/03/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20230304004705396.png" alt="image-20230304004705396"></p>
<br>

<p>通常用户使用 Web浏览器 与相应服务器进行通信。在浏览器中键入<strong>”域名“或”IP:Port“</strong>，浏览器先将你的<strong>域名解析成相应的IP地址</strong>或者直接根据你的IP地址向对应的Web服务器发送一个 <strong>HTTP请求</strong> 。这一过程首先要通过<strong>TCP协议的三次握手</strong>建立与目标Web服务器的连接，然后HTTP协议生成针对目标Web服务器的<strong>HTTP请求报文</strong>，通过<strong>TCP、IP等协议</strong>发送到目标服务器上。</p>
<br>

<br>

<br>

<h3 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h3><p><strong>简介</strong></p>
<p><strong>超文本传输协议</strong>（Hypertext Transfer Protocol，HTTP）是一个简单的 <strong>请求-响应</strong> 协议，它通常运行在 TCP 之上。</p>
<ul>
<li>它指定了客户端可能发送给服务器<strong>什么样的消息</strong>以及得到<strong>什么样的响应</strong>。</li>
<li>请求和响应消息的<strong>头</strong>以 ASCII 形式给出；而<strong>消息内容</strong>则具有一个类似 MIME 的格式。</li>
<li>HTTP是万维网的数据通信的基础。</li>
</ul>
<p><strong>概述</strong></p>
<p>HTTP 是一个客户端终端（用户）和服务器端（网站）请求和应答的标准（TCP）。</p>
<ul>
<li>通过使用网页浏览器、网络爬虫或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口（默认端口为80）。我们称这个<strong>客户端</strong>为<strong>用户代理程序</strong>（user agent）。</li>
<li>应答的服务器上存储着一些资源，比如 HTML 文件和图像。我们称这个<strong>应答服务器</strong>为<strong>源服务器</strong>（origin server）。在用户代理和源服务器中间可能存在多个“<strong>中间层</strong>”，比如<strong>代理服务器</strong>、<strong>网关</strong>或者<strong>隧道</strong>（tunnel）。</li>
<li>尽管 TCP&#x2F;IP 协议是互联网上最流行的应用，HTTP 协议中，并没有规定必须使用它或它支持的层。事实上，HTTP可以在任何互联网协议上，或其他网络上实现。<strong>HTTP 假定其下层协议提供可靠的传输</strong>。因此，任何能够提供这种保证的协议都可以被其使用。因此也就是其在  TCP&#x2F;IP 协议族使用 TCP 作为其传输层。</li>
</ul>
<p>通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的 TCP 连接。HTTP服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如”HTTP&#x2F;1.1 200 OK”，以及返回的内容，如请求的文件、错误消息、或者其它信息。</p>
<br>

<p><strong>工作原理</strong></p>
<p>HTTP 协议定义 Web 客户端如何从 Web 服务器请求 Web 页面，以及服务器如何把 Web 页面传送给客户端。HTTP 协议采用了<strong>请求&#x2F;响应模型</strong>。</p>
<ul>
<li>客户端向服务器发送一个<strong>请求报文</strong>，请求报文包含<strong>请求的方法</strong>、<strong>URL</strong>、<strong>协议版本</strong>、<strong>请求头部</strong>和<strong>请求数据</strong>。</li>
<li>服务器以一个<strong>状态行</strong>作为响应，响应的内容包括<strong>协议的版本</strong>、<strong>成功或者错误代码</strong>、<strong>服务器信息</strong>、<strong>响应头部</strong>和<strong>响应数据</strong>。</li>
</ul>
<p><strong>HTTP请求&#x2F;响应的步骤：</strong></p>
<ol>
<li>客户端连接到 Web服务器<ul>
<li>客户端比如浏览器，与Web服务器的HTTP端口(默认为<strong>80</strong>)建立一个TCP套接字连接</li>
</ul>
</li>
<li>客户端发送HTTP请求<ul>
<li>通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由 <strong>请求行</strong>、<strong>请求头部</strong>、<strong>空行</strong>和<strong>请求数据</strong> 4部分组成</li>
</ul>
</li>
<li>服务器接受请求并返回HTTP响应<ul>
<li>Web服务器<strong>解析请求</strong>，<strong>定位请求资源</strong>。</li>
<li>服务器<strong>将资源副本写到TCP套接字</strong>，由客户端读取。</li>
<li>一个响应由 <strong>状态行</strong>、<strong>响应头部</strong>、<strong>空行</strong>和<strong>响应数据</strong> 4部分组成</li>
</ul>
</li>
<li>释放连接 TCP 连接<ul>
<li>若 connection 模式为 <strong>close</strong> ，则服务器主动关闭 TCP 连接，客户端被动关闭连接，释放TCP连接；</li>
<li>若 connection 模式为 <strong>keepalive</strong> ，则该连接会保持一段时间，在该时间内可以继续接收请求；</li>
</ul>
</li>
<li>客户端浏览器解析 HTML 内容<ul>
<li>客户端浏览器<strong>首先解析状态行</strong>，查看表明请求是否成功的状态代码。<strong>然后解析每一个响应头</strong>，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口显示。</li>
</ul>
</li>
</ol>
<br>

<p>例如：在浏览器地址栏输入URL，按下回车之后</p>
<ol>
<li>浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的IP地址</li>
<li>解析出IP地址后，根据该IP地址和默认端口80，和服务器建立TCP连接</li>
<li>浏览器发出读取文件（URL中域名后面部分对应的文件）的HTTP请求，该请求报文作为TCP三次握手的第三个报文的数据发送给服务器</li>
<li>服务器对浏览器请求做出响应，并把对应的HTML文本发送给浏览器</li>
<li>释放TCP连接</li>
<li>浏览器将解析该HTML文本并显示内容</li>
</ol>
<br>

<img src="/2023/03/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20230304011652447.png" alt="image-20230304011652447" style="zoom:80%;">

<blockquote>
<p>HTTP协议规定，请求从客户端发出，最后服务端响应请求并返回。也即，是先从客户端开始建立通信的，<strong>服务端在没有接收到请求之前不会发送响应</strong>。</p>
</blockquote>
<br>

<br>

<br>

<h3 id="http报文格式"><a href="#http报文格式" class="headerlink" title="http报文格式"></a>http报文格式</h3><p><img src="/2023/03/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20230304015519816.png" alt="请求报文格式"></p>
<p><img src="/2023/03/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20230304015552413.png" alt="响应报文格式"></p>
<br>

<p>Web服务器要<strong>解析请求，并生成响应信息</strong></p>
<br>

<p>我们要了解各种<strong>请求头响应头</strong>的含义，以及<strong>状态码</strong>的含义</p>
<img src="/2023/03/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20230304020932915.png" alt="image-20230304020932915" style="zoom:80%;">

<br>

<p>HTTP请求的各种<strong>请求方法</strong>，这里主要用 GET 和 POST<br><img src="/2023/03/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20230304021118740.png" alt="image-20230304021118740" style="zoom:80%;"></p>
<br>

<br>

<br>

<h2 id="5-4-服务器编程基本框架"><a href="#5-4-服务器编程基本框架" class="headerlink" title="5.4 服务器编程基本框架"></a>5.4 服务器编程基本框架</h2><p>以及两种高效的<strong>事件处理模式</strong></p>
<br>

<h3 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h3><p>Web 服务器程序种类繁多，但基本框架都一样，不同之处在于逻辑处理。</p>
<img src="/2023/03/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20230304022023757.png" alt="image-20230304022023757" style="zoom:80%;">

<table>
<thead>
<tr>
<th>模块</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>I&#x2F;O 处理单元</td>
<td>处理客户连接，读写网络数据</td>
</tr>
<tr>
<td>逻辑单元</td>
<td>业务进程或线程</td>
</tr>
<tr>
<td>网络存储单元</td>
<td>数据库、文件或缓存</td>
</tr>
<tr>
<td>请求队列</td>
<td>各单元之间的通信方式</td>
</tr>
</tbody></table>
<ul>
<li><p><strong>I&#x2F;O处理单元</strong>是服务器管理客户连接的模块。它通常要完成一下工作：</p>
<ul>
<li>等待并接受新的客户链接</li>
<li>接收客户数据</li>
<li>将服务器响应数据返回给客户端</li>
</ul>
<p>但是数据的收发不一定在I&#x2F;O处理单元中执行，也可能在逻辑单元中执行，具体取决于事件处理模式</p>
</li>
<li><p>一个<strong>逻辑单元</strong>通常是一个进程或线程。它分析并处理客户数据，然后将结果<strong>传递给I&#x2F;O处理单元</strong>或者<strong>直接发送给客户端</strong>（取决于事件处理模式）。服务器通常拥有多个逻辑单元，以实现对多个客户任务的并发处理</p>
</li>
<li><p><strong>网络存储单元</strong>可以是数据库、缓存和文件，但不是必须的</p>
</li>
<li><p><strong>请求队列</strong>是个单元之间的通信方式的抽象。</p>
<ul>
<li>I&#x2F;O处理单元接收到客户请求时，需要以某种方式通知一个逻辑单元来处理该请求。</li>
<li>同样，多个逻辑单元同时访问一个存储单元时，也需要采用某种机制来协调处理竞态条件。</li>
<li>请求队列通常被实现为<strong>池(进程池、线程池)的一部分</strong>。</li>
</ul>
</li>
</ul>
<br>

<br>

<h3 id="两种高效的事件处理模式"><a href="#两种高效的事件处理模式" class="headerlink" title="两种高效的事件处理模式"></a>两种高效的事件处理模式</h3><p>服务器程序通常需要处理三类事件：</p>
<ul>
<li>I&#x2F;O事件</li>
<li>信号</li>
<li>定时事件</li>
</ul>
<br>

<p>两种高效的事件处理模式：</p>
<ul>
<li><strong>Reactor</strong>   (一般用同步I&#x2F;O模型实现)</li>
<li><strong>Proactor</strong>  (一般用异步I&#x2F;O模型实现，或者用同步I&#x2F;O模型模拟)</li>
</ul>
<br>

<h4 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h4><ul>
<li><p>要求<strong>主线程</strong>(<strong>I&#x2F;O处理单元</strong>)只负责<u>监听文件描述符上是否有事件发生</u>，有的话就立即将该事件通知<strong>工作线程</strong>（<strong>逻辑单元</strong>），将socket可读可写事件放入<strong>请求队列</strong>，交给工作线程处理。除此之外，主线程不做任何其他实质性的工作。</p>
</li>
<li><p><u>读写数据，接受新的连接，以及处理客户请求</u>均在<strong>工作线程</strong>中完成。</p>
</li>
</ul>
<br>

<p>使用同步I&#x2F;O(epoll_wait为例)实现的Reactor模式的工作流程：</p>
<ol>
<li>主线程往epoll内核事件表中注册socket上的读就绪事件</li>
<li>主线程调用epoll_wait等待socket上有数据可读</li>
<li>当socket上有数据可读时，epoll_wait通知主线程。主线程则将socket可读事件放入请求队列</li>
<li>睡眠在请求队列上的某个工作线程被唤醒，它从socket读取数据，并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件</li>
<li>主线程调用epoll_wait等待socket可写</li>
<li>当socket可写时，epoll_wait通知主线程。主线程将socket可写事件放入请求队列</li>
<li>睡眠在请求队列上的某个工作线程被唤醒，他往socket上写入服务器处理客户请求的结果</li>
</ol>
<br>

<img src="/2023/03/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20230304030515214.png" alt="image-20230304030515214" style="zoom:90%;">

<br>

<br>

<h4 id="Proactor"><a href="#Proactor" class="headerlink" title="Proactor"></a>Proactor</h4><ul>
<li>将所有的<strong>I&#x2F;O操作</strong>都交给<strong>主线程和内核</strong>来处理(进行读、写)，<strong>工作线程仅仅负责业务逻辑</strong>。</li>
</ul>
<br>

<p>使用异步I&#x2F;O模型实现的Proactor模式的工作流程：（以 aio_read 和 aio_wirte 为例)</p>
<ol>
<li><strong>主线程</strong>调用 aio_read 函数向内核注册socket上的<strong>读完成事件</strong>，并告诉内核用户<strong>读缓冲区的位置</strong>，以及读操作完成时<strong>如何通知应用程序</strong>(这里以信号为例)</li>
<li>主线程继续处理其他逻辑</li>
<li>当socket上的数据被读入缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据已经可用</li>
<li><strong>应用程序</strong>预先定义好的<strong>信号处理函数</strong>选择一个工作线程来处理客户请求。<br><strong>工作线程</strong>处理完客户请求后，调用 aio_write 函数向内核注册socket上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序。</li>
<li>主线程继续处理其他逻辑</li>
<li>当用户数据被写入socket之后，内核将向应用程序发送以一个信号，以通知应用程序数据已经发送完毕</li>
<li>应用程序预先定义好的信号处理函数选择一个工作线程来做善后工作，比如决定是否关闭socket</li>
</ol>
<br>

<img src="/2023/03/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20230304032743438.png" alt="image-20230304032743438" style="zoom:90%;">



<br>

<br>

<h4 id="模拟Proactor模式"><a href="#模拟Proactor模式" class="headerlink" title="模拟Proactor模式"></a>模拟Proactor模式</h4><p>使用<strong>同步I&#x2F;O</strong>方式模拟Procator模式。</p>
<p><strong>原理</strong>：主线程执行数据读写操作，读写完成之后，主线程向工作线程通知这一”完成事件”。从工作线程的角度看，它们就直接获得了数据读写的结果，接下来要做的只是对读写的结果进行逻辑处理。</p>
<br>

<p>使用同步I&#x2F;O模型(epoll_wait为例)模拟Proactor模式的工作流程：</p>
<ol>
<li>主线程往epoll内核事件表中注册socket上的读就绪事件</li>
<li>主线程调用epoll_wait等待socket上有数据可读</li>
<li>当socket上有数据可读时，epoll_wait通知主线程。主线程从socket循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列</li>
<li>睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往epoll内核事件表中注册socket上的写就绪事件</li>
<li>主线程调用epoll_wait等待socket可写</li>
<li>当socket可写时，epoll_wait通知主线程。主线程往socket上写入服务器处理客户请求的结果</li>
</ol>
<br>

<img src="/2023/03/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20230304033941878.png" alt="image-20230304033941878" style="zoom:90%;">

<br>

<br>

<br>

<br>

<h2 id="5-5-线程同步机制类封装及线程池实现"><a href="#5-5-线程同步机制类封装及线程池实现" class="headerlink" title="5.5 线程同步机制类封装及线程池实现"></a>5.5 线程同步机制类封装及线程池实现</h2><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>线程池是由服务器预先创建的一组子线程，线程池中的线程数量应该和 CPU 数量差不多。</p>
<ul>
<li>线程池中的所有子线程都运行着相同的代码。</li>
<li>当有新的任务到来时，主线程将通过某种方式选择线程池中的某一个子线程来为之服务。</li>
<li>相于与动态的创建子线程，选择一个已经存在的子线程的代价显然要小得多。</li>
<li>至于主线程选择哪个子线程来为新任务服务，则有多种方式：<ul>
<li>主线程使用<strong>某种算法</strong>来主动选择子线程。最简单、最常用的算法是随机算法和 Round Robin（轮流选取）算法，但更优秀、更智能的算法将使任务在各个工作线程中更均匀地分配，从而减轻服务器的整体压力。</li>
<li>主线程和所有子线程通过一个<strong>共享的工作队列</strong>来同步，子线程都睡眠在该工作队列上。当有新的任务到来时，主线程将任务添加到工作队列中。这将唤醒正在等待任务的子线程，不过只有一个子线程将获得新任务的”接管权“，它可以从工作队列中取出任务并执行之，而其他子线程将继续睡眠在工作队列上。</li>
</ul>
</li>
</ul>
<br>

<p><img src="/2023/03/03/%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20230304143320886.png" alt="线程池模型"></p>
<br>

<p><strong>线程数量</strong></p>
<p>线程池中的<strong>线程数量最直接的限制因素</strong>是中央处理器(CPU)的处理器(processors&#x2F;cores)的数量N ：如果你的CPU是4-cores的，对于<strong>CPU密集型</strong>的任务(如视频剪辑等消耗CPU计算资源的任务)来说，那线程池中的线程数量最好也设置为4（或者+1防止其他因素造成的线程阻塞）；对于<strong>IO密集型</strong>的任务，一般要多于CPU的核数，因为线程间竞争的不是CPU的计算资源而是IO，IO的处理一般较慢，多于cores数的线程将为CPU争取更多的任务，不至在线程处理IO的过程造成CPU空闲导致资源浪费。</p>
<p>还可以动态控制线程池中的线程数量。</p>
<br>

<p><strong>线程池的特点</strong></p>
<ul>
<li><strong>空间换时间</strong>，浪费服务器的硬件资源，换取运行效率。</li>
<li>池是一组资源的集合，这组资源在服务器启动之初就被完全创建好并初始化，这称为<strong>静态资源</strong>。</li>
<li>当服务器进入正式运行阶段，开始处理客户请求的时候，如果它需要相关的资源，可以直接从池中获取，<strong>无需动态分配</strong>。</li>
<li>当服务器处理完一个客户连接后，可以把相关的资源放回池中，<strong>无需执行系统调用释放资源</strong>。</li>
</ul>
<br>

<br>

<br>

<br>

<br>

<br>

<br>

<h2 id="5-6-其他内容"><a href="#5-6-其他内容" class="headerlink" title="5.6 其他内容"></a>5.6 其他内容</h2><p><strong>EPOLLONESHOT事件</strong></p>
<ul>
<li>即使可以使用 ET 模式，一个socket 上的某个事件还是可能被触发多次。这在并发程序中就会引起一个问题。比如一个线程在读取完某个 socket 上的数据后开始处理这些数据，而在数据的处理过程中该socket 上又有新数据可读（EPOLLIN 再次被触发），此时另外一个线程被唤醒来读取这些新的数据。于是就出现了两个线程同时操作一个 socket 的局面。一个socket连接在任一时刻都只被一个线程处理，可以使用 epoll 的 EPOLLONESHOT 事件实现。</li>
<li>对于注册了 EPOLLONESHOT 事件的文件描述符，操作系统最多触发其上注册的一个可读、可写或者异常事件，且只触发一次，除非我们使用 epoll_ctl 函数重置该文件描述符上注册的 EPOLLONESHOT 事件。这样，当一个线程在处理某个 socket 时，其他线程是不可能有机会操作该 socket 的。但反过来思考，注册了 EPOLLONESHOT 事件的 socket 一旦被某个线程处理完毕， 该线程就应该立即重置这个socket 上的 EPOLLONESHOT 事件，以确保这个 socket 下一次可读时，其 EPOLLIN 事件能被触发，进而让其他工作线程有机会继续处理这个 socket。</li>
</ul>
<br>

<br>

<br>

<p><strong>有限状态机</strong></p>
<ol>
<li>有限状态机：逻辑单元内部的一种高效编程方法：有限状态机（finite state machine）。有的应用层协议头部包含数据包类型字段，每种类型可以映射为逻辑单元的一种执行状态，服务器可以根据它来编写相应的处理逻辑。如下是一种状态独立的有限状态机：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">STATE_MACHINE</span>( Package _pack )</span><br><span class="line">&#123;</span><br><span class="line">	PackageType _type = _pack.<span class="built_in">GetType</span>();</span><br><span class="line">	<span class="keyword">switch</span>( _type )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> type_A:</span><br><span class="line">			<span class="built_in">process_package_A</span>( _pack );</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> type_B:</span><br><span class="line">			<span class="built_in">process_package_B</span>( _pack );</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;<span class="comment">// 上面是一个简单的有限状态机，只不过该状态机的每个状态都是相互独立的，即状态之间没有相互转移。</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>状态之间的转移是需要状态机内部驱动，如下代码：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">STATE_MACHINE</span>()</span><br><span class="line">&#123;</span><br><span class="line">	State cur_State = type_A;</span><br><span class="line">	<span class="keyword">while</span>( cur_State != type_C )</span><br><span class="line">	&#123;</span><br><span class="line">		Package _pack = <span class="built_in">getNewPackage</span>();</span><br><span class="line">		<span class="keyword">switch</span>( cur_State )</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> type_A:</span><br><span class="line">                <span class="built_in">process_package_state_A</span>( _pack );</span><br><span class="line">                cur_State = type_B;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> type_B:</span><br><span class="line">                <span class="built_in">process_package_state_B</span>( _pack );</span><br><span class="line">                cur_State = type_C;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该状态机包含三种状态：type_A、type_B 和 type_C，其中 type_A 是状态机的开始状态，type_C 是状态机的结束状态。状态机的当前状态记录在 cur_State 变量中。在一趟循环过程中，状态机先通getNewPackage 方法获得一个新的数据包，然后根据 cur_State 变量的值判断如何处理该数据包。数据包处理完之后，状态机通过给 cur_State 变量传递目标状态值来实现状态转移。那么当状态机进入下一趟循环时，它将执行新的状态对应的逻辑。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++开发</category>
        <category>高性能服务器</category>
      </categories>
      <tags>
        <tag>web服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>邮件服务实现思路</title>
    <url>/2024/01/05/%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<h2 id="Mail-Server"><a href="#Mail-Server" class="headerlink" title="Mail Server"></a>Mail Server</h2><ul>
<li>管理玩家的邮箱数据，包括从数据库（数据库代理服务器）加载、修改并保存到数据库<ul>
<li>与数据库代理的交互，会有监控机制监控操作是否成功，若不成功则会进行重试</li>
<li>重试次数会有上限，或者限流，防止压垮数据库</li>
</ul>
</li>
<li>向GS请求验证玩家是否满足接受邮件的条件</li>
<li>向GS请求验证玩家是否满足领取附件的条件</li>
<li>向GS通知玩家领取附件</li>
<li>与客户端直接进行交互（由GS转发）<ul>
<li>客户端视角：<ul>
<li>获取所有邮件</li>
<li>设置已读</li>
<li>删除邮件</li>
<li>领取附件</li>
</ul>
</li>
<li>Mail Server 视角：<ul>
<li>同步邮箱</li>
<li>同步新邮件</li>
<li>数据增删查改</li>
<li>邮件过期通知</li>
</ul>
</li>
</ul>
</li>
</ul>
<span id="more"></span>

<h2 id="Game-Server"><a href="#Game-Server" class="headerlink" title="Game Server"></a>Game Server</h2><ul>
<li>注册到 Mail Server 后，Mail Server 同步过来该服（所在group）的所有邮件</li>
<li>验证玩家是否符合接收邮件的条件，并将符合的邮件及其对应的玩家告知 Mail Server，Mail Server更新邮件数据</li>
<li>验证玩家是否符合接受附件的条件，符合则在GS这边更新玩家的附件内容，并告知 Mail Server 附件条件符合的玩家情况，Mail Server 更新玩家邮件附件领取状态</li>
<li>GS发送广播邮件过程<ul>
<li>GS 先向 Mail Server 通知要发送广播邮件</li>
<li>Mail Server 更新 GS 的广播邮件数据，并发给 GS 验证广播邮件的请求</li>
<li>GS 分帧验证符合接收邮件条件的在线玩家，并将符合情况发给 Mail Server</li>
<li>Mail Server 更新各个在线玩家的邮件数据，并给对应的在线玩家发送该广播邮件（由GS转发）</li>
</ul>
</li>
<li>GS发送单播邮件过程<ul>
<li>GS 先向 Mail Server 通知要发送单播邮件给某个玩家</li>
<li>Mail Server 更新玩家数据，并给对应玩家发送该广播邮件（由GS转发）</li>
</ul>
</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="GS广播邮件时不在线的玩家，在其上线后如何收到邮件"><a href="#GS广播邮件时不在线的玩家，在其上线后如何收到邮件" class="headerlink" title="GS广播邮件时不在线的玩家，在其上线后如何收到邮件"></a>GS广播邮件时不在线的玩家，在其上线后如何收到邮件</h3><ul>
<li>首先，Mail Server 记录有每个玩家已接收的最新邮件序号，记录有 GS（所在group）上的所有邮件</li>
<li>可以推测，每当 Mail Server 向 GS 请求验证完玩家收取邮件的条件后，若玩家能够接收邮件，Mail Server 会更新其收到的最新邮件序号</li>
<li>于是，不在线的玩家的最新邮件序号可能是过时的，当玩家登陆时，Mail Server 要向GS请求验证该玩家的邮件接收</li>
<li>GS 的做法是，从玩家的最新邮件序号开始，遍历自己同步到的邮件列表，验证每一个序号大于玩家当前最新邮件序号的邮件，并将符合的邮件的序号加入到回包中，发回给 Mail Server</li>
<li>Mail Server 根据验证情况，更新玩家的邮件数据和最新邮件序号</li>
</ul>
<h3 id="客户端的视角"><a href="#客户端的视角" class="headerlink" title="客户端的视角"></a>客户端的视角</h3><ul>
<li>客户端登陆后，Mail Server 会收到玩家上线通知，并加载玩家的邮箱数据</li>
<li>Mail Server 加载完成后，通知客户端加载完成（但不立即同步邮箱数据）</li>
<li>客户端通过 UI 交互触发同步邮箱数据请求，Mail Server 发送邮箱同步数据</li>
<li>客户端之后可以通过检查邮箱数据请求，与 Mail Server 校对邮箱数据是否是最新的（通过最新邮件序号）<ul>
<li>不是最新的的话，Mail Server 需要发送同步数据给客户都</li>
</ul>
</li>
<li>客户端可以进行邮件的读取、删除、领取附件的请求</li>
<li>客户端在线时，若有新的邮件，Mail Server 会发送单个邮件同步数据过来</li>
</ul>
<h3 id="Mail-Server-的性能考虑"><a href="#Mail-Server-的性能考虑" class="headerlink" title="Mail Server 的性能考虑"></a>Mail Server 的性能考虑</h3><ul>
<li>数据结构：邮件数据以有序的形式组织</li>
<li>用户量：只有当玩家上线或者需要给玩家发送邮件时，才从数据库中加载玩家的邮箱数据</li>
<li>过期处理：仅对在线玩家做实时的过期判断</li>
<li>每帧限制处理数量，防止卡帧丢帧</li>
</ul>
]]></content>
      <categories>
        <category>游戏开发</category>
        <category>服务端</category>
      </categories>
      <tags>
        <tag>邮件服务</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux多进程</title>
    <url>/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="2-Linux多进程开发"><a href="#2-Linux多进程开发" class="headerlink" title="2.Linux多进程开发"></a>2.Linux多进程开发</h1><hr>
<br>

<h2 id="2-1-进程概述"><a href="#2-1-进程概述" class="headerlink" title="2.1 进程概述"></a>2.1 进程概述</h2><p><strong>程序和进程</strong></p>
<span id="more"></span>

<blockquote>
<p><strong>程序</strong></p>
<p>程序是包含一系列信息的文件，这些文件描述了如何在运行时创建一个进程。</p>
<p>包含内容：</p>
<ul>
<li>二进制格式标识：每个程序文件都包含用于描述可执行文件格式的元信息。内核利用此信息来解释文件中的其他信息。（ELF可执行链接格式）</li>
<li>机器语言指令：对程序算法进行编码。</li>
<li>程序入口地址：标识程序开始执行时的起始指令位置。</li>
<li>数据：程序文件包含的变量初始值和程序使用的字面量值（如字符串）。</li>
<li>符号表及重定位表：描述程序中函数和变量的位置及名称。这些表格有多重用途，其中包括调试和运行时的符号解析（动态链接）。</li>
<li>共享库和动态链接信息：程序文件所包含的一些字段，列出了程序运行时需要使用的共享库，以及加载共享库的动态链接器的路径名。</li>
<li>其他信息：程序文件还包含其他信息，用来描述如何创建进程。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>进程</strong></p>
<ul>
<li>进程是正在运行的程序的实例。<ul>
<li>是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。</li>
<li>是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。</li>
</ul>
</li>
<li>可以用一个程序来创建多个进程，进程是由内核定义的抽象实体，并为该实体分配用以执行程序的各项系统资源。<ul>
<li>从内核的角度看，进程由用户内存空间和一些列的内核数据结构组成，其中用户内存空间包含了程序代码及代码所使用的变量，而内核数据结构则用于维护进程状态信息。</li>
<li>记录在内核数据结构中的信息包括许多与进程相关的标识号（IDs）、虚拟内存表、打开文件的描述符表，信号传递及处理的有关信息、进程资源使用及限制、当前工作目录和大量的其他信息。</li>
</ul>
</li>
</ul>
</blockquote>
<br>

<p><strong>单道、多道程序设计</strong></p>
<p>单道程序：在计算机内存中只允许一个的程序运行。</p>
<p>多道程序：计算机内存中同时存放多道相互独立的程序使它们在管理程序控制下，相互穿插运行，两个或两个以上程序在计算机系统中处于开始到结束之间的状态，这些车程序共享计算机资源。（提高CPU的利用率）</p>
<ul>
<li>对于单CPU系统而言，宏观上可以使多个程序像是同时运行，实际上任意时刻CPU上运行的程序只有一个。</li>
<li>在多道程序设计模型中，多个程序轮流使用CPU。</li>
</ul>
<br>

<p><strong>时间片</strong></p>
<p>时间片 timeslice 又称为“量子 quantum”或“处理器片processor slice”，是操作系统分配给每个正在运行的进程微观上的一段CPU时间。</p>
<p>时间片由操作系统内核的调度程序分配给每个进程。</p>
<br>

<p><strong>并行和并发</strong></p>
<p>并行（parallel）：指在同一时刻，有多条指令在多个处理器上同时执行。</p>
<p>并发（concurrency）：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。</p>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230204223514971-16759624275181.png" alt="image-20230204223514971"></p>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230204223803946-16759624275193.png" alt="image-20230204223803946"></p>
 <br>

<p><strong>进程控制块 PCB</strong></p>
<p>内核为每个进程分配以一个 PCB 进程控制块，维护进程相关的信息，Linux内核的进程控制块是 task_struct 结构体。</p>
<p>在 &#x2F;usr&#x2F;src&#x2F;linux-headers-xxx&#x2F;include&#x2F;linux&#x2F;sched.h 文件中可以查看 struct task_struct 结构体定义，其部分内部成员如下：</p>
<ul>
<li>进程id：系统中每个进程有唯一的 id ，用 pid_t 类型表示，是一个非负整数</li>
<li>进程的状态：就绪、运行、挂起、停止等状态</li>
<li>进程切换时需要保存和恢复的一些CPU寄存器信息</li>
<li>描述虚拟地址空间的信息</li>
<li>描述控制终端的信息</li>
<li>当前工作目录</li>
<li>umask掩码</li>
<li>文件描述符表，包含很多执行file结构体的指针</li>
<li>和信号相关的信息</li>
<li>用户id和组id</li>
<li>会话（session）和进程组</li>
<li>进程可以使用的资源上限（可用ulimit指令查看系统内核资源上限）</li>
</ul>
<p><br><br><br></p>
<h2 id="2-2-进程状态转换"><a href="#2-2-进程状态转换" class="headerlink" title="2.2 进程状态转换"></a>2.2 进程状态转换</h2><h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><p>进程状态反映进程执行过程的变化。</p>
<p><code>三态模型</code>中，进程状态分为三个基本状态 —— 就绪态、运行态、阻塞态。</p>
<blockquote>
<p><strong>运行态</strong>：进程占有处理器正在运行。</p>
<p><strong>就绪态</strong>：进程具备运行条件，等待系统分配处理器以便运行。当进程分配到除CPU外的所有必要资源后，只要再获得CPU，便可立即执行。多个就绪进程排成队列，称为就绪队列。</p>
<p><strong>阻塞态</strong>：又称为 等待态(wait) 或 睡眠态(sleep)，指进程不具备运行条件，正在等待某个事件的完成。</p>
</blockquote>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230204225943684-16759624275192.png" alt="image-20230204225943684"></p>
<p><code>五态模型</code>中，进程状态分为 ——  新建态、就绪态、运行态、阻塞态、终止态。</p>
<blockquote>
<p><strong>新建态</strong>：进程刚被创建时的状态，尚未进入就绪队列</p>
<p><strong>终止态</strong>：进程完成任务达到正常结束点，或出现无法克服的错误而异常终止，或被操作系统及有终止权的进程所终止时所处的状态。进入终止态的进程不再执行，但依然保留再操作系统中等待善后。一旦其他进程完成了对终止态进程的信息抽取之后，操作系统将删除该进程。</p>
</blockquote>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230204230502376-16759624275195.png" alt="image-20230204230502376"></p>
<br>

<h3 id="进程相关指令"><a href="#进程相关指令" class="headerlink" title="进程相关指令"></a>进程相关指令</h3><p><strong>查看进程</strong></p>
<p><code>ps aux/ajx</code></p>
<p>a：显示终端上的所有进程，包括其他用户的进程</p>
<p>u：显示进程的详细信息</p>
<p>x：显示没有控制终端的进程</p>
<p>j：列出与作业控制相关的进程</p>
<br>

<blockquote>
<p>stat标识</p>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230204232608821-16759624275196.png" alt="image-20230204232608821"></p>
</blockquote>
<br>

<p><strong>实时显示进程状态</strong></p>
<p><code>top</code></p>
<p>可以在 top 命令后加 -d 来指定显示信息更新的时间间隔</p>
<p>在 top 命令执行后，可以按一下按键对显示结果进行排序</p>
<ul>
<li>M 根据内存使用量</li>
<li>P 根据CPU占有率</li>
<li>T 根据进程运行时间长短</li>
<li>U 根据用户名筛选</li>
<li>K 输入指定的 PID 杀死进程</li>
</ul>
<br>

<p><strong>杀死进程</strong></p>
<p><code>kill [-signal] pid</code></p>
<p><code>kill -l</code>列出所有signal信号(信号宏)</p>
<p>比如：</p>
<ul>
<li><p><code>kill -SIGKILL 进程ID</code></p>
</li>
<li><p><code>kill -9 进程ID</code> </p>
</li>
<li><p><code>killall name</code> 根据进程名杀死进程</p>
</li>
</ul>
<br>

<p><strong>进程号和相关函数</strong></p>
<ul>
<li><p>每个进程都由<strong>进程号</strong>来表示，其类型为 pid_t（整型），进程号范围：0~32767。</p>
</li>
<li><p>任何进程（除init进程）都是由另一个进程创建，即父进程， PPID 为父进程号</p>
</li>
<li><p><strong>进程组</strong>是一个或多个进程的集合。他们相互关联，进程组可以接收同一终端的各种信号，关联的进程有一个进程组号 PGID 。默认情况下，当前的进程号会当做当前的进程组号。</p>
</li>
</ul>
<p>相关函数：</p>
<ul>
<li><code>pid_t getpid(void);</code></li>
<li><code>pid_t getppid(void);</code></li>
<li><code>pid_t getpgid(pid_t pid);</code></li>
</ul>
<br>

<br>

<h2 id="2-3-进程创建与调试"><a href="#2-3-进程创建与调试" class="headerlink" title="2.3 进程创建与调试"></a>2.3 进程创建与调试</h2><p>系统允许一个进程创建新进程，即紫禁城，子进程还可以创建新的子进程，形成树结构模型。</p>
<h3 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a>fork函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建子进程</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		- 成功：子进程中返回0，父进程中返回子进程 ID </span></span><br><span class="line"><span class="comment">		- 失败：子进程不被创建，父进程中返回-1，并设置errno</span></span><br><span class="line"><span class="comment">		失败的两个主要原因：</span></span><br><span class="line"><span class="comment">		1. 当前系统的进程数已经达到了系统规定的上限，这时 errno 的值被设置为 EAGAIN</span></span><br><span class="line"><span class="comment">		2. 系统内存不足，这是 errno 的值被设置为 ENOMEM</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<br>

<p>用法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//父进程要执行的内容</span></span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//子进程要执行的内容</span></span><br><span class="line">    	...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//都会执行的内容</span></span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<h3 id="父、子进程虚拟地址空间情况"><a href="#父、子进程虚拟地址空间情况" class="headerlink" title="父、子进程虚拟地址空间情况"></a>父、子进程虚拟地址空间情况</h3><p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230205003125065-16759624275194.png" alt="image-20230205003125065"></p>
<p>进程的实际pid在内核空间</p>
<p>变量pid的值在栈空间</p>
<br>

<blockquote>
<p>fork() 是通过 写时拷贝（copy-on-write） 实现。</p>
<p>写时拷贝时一钟可以推迟甚至避免拷贝数据的技术。内核此时并不复制整个进程的地址空间，而是让父子进程共享一个地址空间。</p>
<p>只有在需要写入的时候才会复制地址空间，从而使得各个进程拥有各自的地址空间，在此之前只有以只读方式共享。</p>
<p>注意：fork后父子进程共享文件</p>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230205011611597-16759624275197.png" alt="image-20230205011611597"></p>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230205011543783-167596242752027.png" alt="image-20230205011543783"></p>
</blockquote>
<br>

<blockquote>
<p>不同的进程访问同样的逻辑地址（虚拟地址）而对应的物理地址不同，是由于各自页表的不同。</p>
<p>linux系统下每个进程都拥有自己的页表，父进程fork出新的子进程时，子进程拷贝一份父进程的页表，且父子进程将页表状态修改为写保护。当父进程或子进程发生写操作时将会发生缺页异常，缺页异常处理函数将会为子进程分配新的物理地址。</p>
</blockquote>
<br>

<br>

<h3 id="父子进程关系"><a href="#父子进程关系" class="headerlink" title="父子进程关系"></a>父子进程关系</h3><p><strong>不同点</strong></p>
<ol>
<li>fork()函数的返回值不同<ul>
<li>父进程中：&gt;0 返回子进程的ID</li>
<li>子进程中：&#x3D;0</li>
</ul>
</li>
<li>PCB中的一些数据<ul>
<li>当前进程的id pid</li>
<li>当前进程的父进程id ppid</li>
<li>信号集</li>
</ul>
</li>
</ol>
<br>

<p><strong>共同点</strong></p>
<p>某些状态下：子进程刚被创建出来，还没有执行任何的写数据的操作</p>
<pre><code>- 用户区的数据
- 文件描述符表
</code></pre>
<p>父子进程对变量是不是共享的？</p>
<ul>
<li>刚开始是共享的，如果数据发生修改则不共享</li>
<li>读时共享，写时拷贝</li>
</ul>
<br>

<h3 id="GDB多进程调试"><a href="#GDB多进程调试" class="headerlink" title="GDB多进程调试"></a>GDB多进程调试</h3><p>GDB默认只能跟踪一个进程，可以在fork函数调用前，通过指令设置 GDB 调试工具跟踪父进程或者是子进程，默认跟踪父进程。</p>
<br>

<ul>
<li>设置调试父进程或子进程：</li>
</ul>
<p><code>set follow-fork-mod [parent(default) | child]</code></p>
<ul>
<li>设置调试模式：</li>
</ul>
<p><code>set detach-on-fork [on(default) | off]</code></p>
<p>​	on：调试当前进程时，其他进程继续运行</p>
<p>​	off：调试当前进程时，其他进程被 GDB 挂起</p>
<ul>
<li>查看调试的进程：</li>
</ul>
<p><code>info inferiors</code></p>
<ul>
<li>切换当前调试的进程：</li>
</ul>
<p><code>inferior 编号</code>（若切换的进程被挂起，切换后先 c ）</p>
<ul>
<li>使进程脱离 GDB 调试：</li>
</ul>
<p><code>detach inferiors id</code></p>
<br>

<p><br><br></p>
<br>

<h2 id="2-4-exec函数族"><a href="#2-4-exec函数族" class="headerlink" title="2.4 exec函数族"></a>2.4 exec函数族</h2><p>c++有函数重载，c语言没有；</p>
<p>函数族即一系列功能相似的函数。</p>
<br>

<ul>
<li>exec 函数族的作用是根据指定文件名找到可执行文件，并用它来取代调用进程的内容，换句话说，就是在调用进程内部执行一个可执行文件。（实际应用时一般在子进程中执行 exec函数族）</li>
<li>exec 函数族的函数执行成功后不会返回，因为调用进程的实体，包括代码段、数据段和堆栈等都已经被新的内容取代，只留下进程ID等一些表面上的信息仍保持原样。只有调用失败了，才会返回－１，从原程序的调用点接着往下执行。</li>
</ul>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230205022237610-16759624275198.png" alt="image-20230205022237610"></p>
<br>

<p><strong>exec函数族</strong></p>
<blockquote>
<p>exec后的字母表示传参方式和搜索规则</p>
<ul>
<li><p>l(list)	参数地址列表，以空指针结尾</p>
</li>
<li><p>v(vector)  存有个参数地址的指针数组的地址</p>
</li>
<li><p>p(path)	按 PATH 环境变量指定的目录搜索可执行文件</p>
</li>
<li><p>e(environment) 存有环境变量字符串地址的指针数组的地址</p>
</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ...<span class="comment">/* (char *) NULL */</span>)</span>；</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- path：需要指定的执行文件的路径或名称（相对路径或绝对路径）（推荐使用绝对路径）</span></span><br><span class="line"><span class="comment">		- arg：可执行文件的参数列表（第一个参数一般没什么作用，为了方便，一般写的是执行程序的名称，从第二个参数开始往后，就是程序执行所需的参数列表，并以 NULL 结尾（哨兵））</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		只有调用失败，才有返回值-1，并设置errno。</span></span><br><span class="line"><span class="comment">		调用成功没有返回值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg, ...<span class="comment">/* (char *) NULL */</span>)</span>；</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	会到环境变量中查找指定的可执行文件，如果找到了就执行，找不到就执行原程序</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- file：需要执行的可执行文件的文件名</span></span><br><span class="line"><span class="comment">		- arg：可执行文件的参数列表（第一个参数一般没什么作用，为了方便，一般写的是执行程序的名称，从第二个参数开始往后，就是程序执行所需的参数列表，并以 NULL 结尾（哨兵））</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		只有调用失败，才有返回值-1，并设置errno。</span></span><br><span class="line"><span class="comment">		调用成功没有返回值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ...<span class="comment">/*, (char *) NULL, char *const envp[] */</span>)</span>；</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *<span class="type">const</span> argv[])</span>；</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">用例：</span></span><br><span class="line"><span class="comment">	char * argv[] = &#123;&quot;ps&quot;, &quot;aux&quot;, NULL&#125;;</span></span><br><span class="line"><span class="comment">	execv(&quot;/bin/ps&quot;, arg);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[])</span>；</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">execvpe</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>；</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>；</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">用例：</span></span><br><span class="line"><span class="comment">	char * argv[] = &#123;&quot;ps&quot;, &quot;aux&quot;, NULL&#125;;</span></span><br><span class="line"><span class="comment">	char * envp[] = &#123;&quot;/home/nowcoder&quot;, &quot;/home/aaa&quot;, &quot;/home/bbb&quot;&#125;;</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	execve(&quot;ps&quot;, arg, envp);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<p><br><br></p>
<h2 id="2-5-进程控制"><a href="#2-5-进程控制" class="headerlink" title="2.5 进程控制"></a>2.5 进程控制</h2><h3 id="进程退出"><a href="#进程退出" class="headerlink" title="进程退出"></a>进程退出</h3><p><strong>exit函数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#incldue <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> _exit(<span class="type">int</span> status);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- status：进程退出时的一个状态信息。父进程回收子进程资源的时候可以获取到。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	exit是标准C库的函数，比_exit多做了</span></span><br><span class="line"><span class="comment">	1.调用退出处理函数</span></span><br><span class="line"><span class="comment">	2.刷新I/O缓存</span></span><br><span class="line"><span class="comment">	3.关闭文件描述符</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230205024702546-16759624275209.png" alt="image-20230205024702546"></p>
<p><br><br></p>
<h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h3><p>父进程运行结束，但子进程还在运行，这样的子进程就成为孤儿进程（Orphan Process）</p>
<br>

<p>每当出现一个孤儿进程时，内核就把孤儿进程的父进程设置为init进程，而init进程会循环地 wait() 它的已经退出的子进程。（init进程会回收运行结束的孤儿进程）</p>
<br>

<p>没什么危害</p>
<br>

<h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><p>每个进程结束之后，会释放自己地址空间中的用户区数据，内核去的PCB则需要父进程去释放</p>
<p>子进程终止后，父进程尚未将其回收，子进程残留资源（PCB）存放于内核中，变成僵尸进程</p>
<ul>
<li>僵尸进程不能被 kill -9 杀死</li>
<li>如果父进程不调用 wait() 或 waitpid() ，那么保留的信息就不会释放，进程号会一直被占用</li>
<li>危害：系统的进程号有限，如果出现大量僵尸进程，会导致系统无法产生新的进程</li>
</ul>
<br>

<h3 id="进程回收"><a href="#进程回收" class="headerlink" title="进程回收"></a>进程回收</h3><p>在每个进程退出的时候，内核释放该进程所有的资源、包括打开的文件、占用的内存等。但是仍为其保留一定的信息，这些信息主要指 PCB 的信息（包括进程号、退出状态、运行时间等）</p>
<p>父进程可以通过 wait() 或 waitpid()得到子进程的退出状态，并彻底清除掉这个进程</p>
<ul>
<li>wait() 或 waitpid() 功能一样，区别在于： 	wait() 会阻塞；<br>waitpid() 可以设置不阻塞，且可以指定等待哪个子进程结束；</li>
<li>一次wait或waitpid调用只能清理一个子进程，清理多个子进程应该使用循环</li>
</ul>
<br>

<h4 id="wait函数"><a href="#wait函数" class="headerlink" title="wait函数"></a>wait函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *wstatus)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	功能：等待任意一个子进程结束，如果任意一个子进程结束了，此函数会回收子进程的资源。</span></span><br><span class="line"><span class="comment">	参数：int *wstatus</span></span><br><span class="line"><span class="comment">		进程退出时的状态信息，传入的是一个int指针，是一个传出参数</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		成功：返回被回收的子进程的id</span></span><br><span class="line"><span class="comment">		失败：返回-1（所有的子进程都结束了，调用函数失败）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	调用wait函数的进程会被挂起（阻塞），知道它的一个子进程退出或者收到一个不能被忽略的信号时才被唤醒（相当于继续往下执行）</span></span><br><span class="line"><span class="comment">	如果没有子进程了/子进程都结束了，函数立刻返回，返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<p><strong>退出信息相关宏函数</strong></p>
<ul>
<li><p>​	函数					返回值</p>
<hr>
</li>
<li><p>WIFEXITED(status)	非0，进程正常退出</p>
</li>
<li><p>WEXITSTATUS(status)  如果上宏为真，获取进程退出的状态（exit的参数）</p>
</li>
<li><p>WIFSIGNALED(status)  非0，进程异常终止</p>
</li>
<li><p>WTERMSIG(status)     如果上宏为真，获取使进程终止的信号编号</p>
</li>
<li><p>WIFSTOPPED(status)   非0，进程处于暂停状态</p>
</li>
<li><p>WSTOPSIG(status)     如果上宏为真，获取使进程暂停的信号编号</p>
</li>
<li><p>WIFCONTINUED(status) 非0，进程暂停后已经继续运行</p>
</li>
</ul>
<br>

<br>

<h4 id="waitpid函数"><a href="#waitpid函数" class="headerlink" title="waitpid函数"></a>waitpid函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *wstatus, <span class="type">int</span> options)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	功能：回收指定进程号的子进程；可以设置是否阻塞。</span></span><br><span class="line"><span class="comment">	wait(&amp;wstatus); 等价于 waitpid(-1, &amp;wstatus, 0);</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- pid：指定子进程的id</span></span><br><span class="line"><span class="comment">			&gt; 0  ：某个子进程的id</span></span><br><span class="line"><span class="comment">			  0  ：回收当前进程组的所有子进程</span></span><br><span class="line"><span class="comment">			  -1 ：回收所有的子进程	（最常用）</span></span><br><span class="line"><span class="comment">			&lt; -1 ：某个进程组组id的绝对值，回收指定进程组中的子进程</span></span><br><span class="line"><span class="comment">		- wstatus：进程退出时的状态信息，传入的是一个int指针，是一个传出参数</span></span><br><span class="line"><span class="comment">		- options：设置阻塞或非阻塞</span></span><br><span class="line"><span class="comment">			0    ：阻塞</span></span><br><span class="line"><span class="comment">			宏值  ：WNOHANG 非阻塞（没有子进程退出的话立即返回）</span></span><br><span class="line"><span class="comment">				   WUNTRACED</span></span><br><span class="line"><span class="comment">				   WCONTINUED</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		&gt; 0 ：返回被回收的子进程的id</span></span><br><span class="line"><span class="comment">		= 0 ：options=WNOHANG时，表示还有子进程没有退出</span></span><br><span class="line"><span class="comment">		= -1：错误，或者没有子进程了</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	调用wait函数的进程会被挂起（阻塞），知道它的一个子进程退出或者收到一个不能被忽略的信号时才被唤醒（相当于继续往下执行）</span></span><br><span class="line"><span class="comment">	如果没有子进程了/子进程都结束了，函数立刻返回，返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<br>

<h2 id="2-6-进程间通信"><a href="#2-6-进程间通信" class="headerlink" title="2.6 进程间通信"></a>2.6 进程间通信</h2><h3 id="2-6-1-进程间通信简介"><a href="#2-6-1-进程间通信简介" class="headerlink" title="2.6.1 进程间通信简介"></a>2.6.1 进程间通信简介</h3><p>不同的进程需要进行信息的交互和状态的传递等，因此需要进程间通信（IPC：Inter Processes Communication</p>
<p><strong>进程通信目的：</strong></p>
<ul>
<li>数据传输：一个进程需要将它的数据发送给另一个进程</li>
<li>通知事件：一个进程需要向另一个或一组进程发送信息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）</li>
<li>资源共享：多个进程之间共享同样的资源。（需要用到内核提供的互斥和同步机制）</li>
<li>进程控制：有些进程希望完全控制另一个进程的运行（如 Debug 进程gdb），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道其状态改变</li>
</ul>
<br>

<p><strong>Linux进程间通信的方式：</strong></p>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230205232903586-167596242752010.png" alt="image-20230205232903586"></p>
<br>

<br>

<br>

<h3 id="2-6-2-匿名管道"><a href="#2-6-2-匿名管道" class="headerlink" title="2.6.2 匿名管道"></a>2.6.2 匿名管道</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>管道 也叫匿名管道。是 UNIX 系统 IPC 的最古老形式，所有的 UNIX 系统都支持这种通信机制。</p>
<br>

<p><strong>案例解析：</strong></p>
<p>​	统计一个目录中文件的数目命令：<code>ls | wc -l</code>	（管道符 | ）</p>
<p>为了执行该命令，shell 创建了两个进程分别执行 ls 和 wc</p>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230205233552602-167596242752011.png" alt="image-20230205233552602"></p>
<p>ls进程的标准输出 stdout 指向管道写入端</p>
<p>wc进程的标准输入 stdin 指向管道读取端</p>
<br>

<p><strong>特点</strong></p>
<ul>
<li>管道 其实是一个在<code>内核内存中</code>维护的缓冲器，这个缓冲器的存储能力是有限的，不同操作系统中可能不同</li>
<li>管道拥有文件的特质：读操作、写操作，<u>匿名管道没有文件实体，有名管道有文件实体，但不存储数据。</u>可以按照操作文件的方式操作管道</li>
<li>一个管道是一个<code>字节流</code>，使用管道时不存在消息或者消息边界的概念，从管道读取数据的进程可以读取任意大小的数据块，而不管写入进程写入管道的数据库的大小是多少</li>
<li>通过管道传递的数据是顺序的</li>
<li>在管道中的数据的传递方向是单向的，一端写入，一端读取，是半双工的（有两个传递方向，同一时刻内只能通一个方向）</li>
<li>从管道读取数据是一次性操作，数据一旦被读走，就从管道中被抛弃，释放空间以便写更多的数据，在管道中无法使用lseek()来随机访问数据</li>
<li>匿名管道只能在具有公共祖先的进程之间使用（父子进程共享文件描述符表，有相同的管道）</li>
</ul>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230206013639551-167596242752012.png" alt="image-20230206013639551"></p>
<br>

<p><strong>管道的数据结构</strong></p>
<p>环形队列（重复利用节点空间）</p>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230206014318131-167596242752013.png" alt="image-20230206014318131"></p>
<br>

<h4 id="管道的使用"><a href="#管道的使用" class="headerlink" title="管道的使用"></a>管道的使用</h4><ul>
<li><p>创建匿名管道</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	创建一个匿名管道，用于进程间通信</span></span><br><span class="line"><span class="comment">	参数： int pipefd[2]：传出参数</span></span><br><span class="line"><span class="comment">			pipefd[0] 管道的读端</span></span><br><span class="line"><span class="comment">			pipefd[1] 管道的写端</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		成功 0</span></span><br><span class="line"><span class="comment">		失败 -1</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	管道默认是阻塞的：</span></span><br><span class="line"><span class="comment">		如果管道中没有数据，read阻塞；</span></span><br><span class="line"><span class="comment">		如果管道满了，write阻塞；</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	注意：匿名管道只能用于具有关系的进程之间的通信（父子进程，兄弟进程...）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现：子进程发送数据给父进程，父进程读取到数据输出</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在fork之前创建管道</span></span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> ret = pipe(pipefd);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="comment">// 从管道的读取端读取数据</span></span><br><span class="line">        close(pipefd[<span class="number">1</span>]);</span><br><span class="line">        </span><br><span class="line">    	<span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> len = read(pipefd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent recv : %s, pid: %d\n&quot;</span>, buf, getpid());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        close(pipefd[<span class="number">0</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="type">char</span> *str = <span class="string">&quot;hello, i am child&quot;</span>;</span><br><span class="line">        write(pipefd[<span class="number">1</span>], str, <span class="built_in">strlen</span>(str));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看管道缓冲大小命令:<code>ulimit -a</code></p>
</li>
<li><p>查看管道缓冲大小函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">fpathconf</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> name)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	获取文件的配置信息值</span></span><br><span class="line"><span class="comment">	参数 name：宏值，表明要查看的内容</span></span><br><span class="line"><span class="comment">		_PC_PIPE_BUF</span></span><br><span class="line"><span class="comment">		更多参数参考文档</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<br></li>
</ul>
<blockquote>
<p>规定：</p>
<ul>
<li>使用匿名管道实际开发时，父子进程不相互收发数据，而是规定好一个进程读一个进程写</li>
<li>读的进程关闭写端；写的进程关闭读端；</li>
</ul>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230206022417540-167596242752014.png" alt="image-20230206022417540"></p>
</blockquote>
<br>

<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>实现<code>ps aux | grep xxx</code></p>
<p>父子进程间通信</p>
<ul>
<li><p>子进程：ps aux，结束后将数据发送给父进程</p>
</li>
<li><p>父进程：获取数据，并过滤</p>
<p>pipe()</p>
<p>execlp()</p>
<p>dup2() 子进程将标准输出 stdout_fileno 重定向到管道的写端</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建管道</span></span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> ret = pipe(fd);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="comment">// 关闭写端</span></span><br><span class="line">        close(fd[<span class="number">1</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从管道中读取</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> len = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>((len = read(fd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf)<span class="number">-1</span>)) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="comment">// 过滤数据并输出  过滤功能还没写          </span></span><br><span class="line">        	<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf); </span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="comment">// 子进程</span></span><br><span class="line">        <span class="comment">// 关闭读端</span></span><br><span class="line">        close(fd[<span class="number">0</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 文件描述符的重定向 stdout_fileno -&gt; fd[1]</span></span><br><span class="line">        dup2(fd[<span class="number">1</span>], STDOUT_FILENO);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 执行 ps aux</span></span><br><span class="line">        execlp(<span class="string">&quot;ps&quot;</span>, <span class="string">&quot;ps&quot;</span>, <span class="string">&quot;aux&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        perror(<span class="string">&quot;execlp&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   	<span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<h4 id="管道读写特点和非阻塞的设置"><a href="#管道读写特点和非阻塞的设置" class="headerlink" title="管道读写特点和非阻塞的设置"></a>管道读写特点和非阻塞的设置</h4><p><strong>读写特点（阻塞I&#x2F;O下）</strong></p>
<ol>
<li>如果所有的指向 管道写端 的文件描述符都关闭了<code>（写端引用计数为0）</code>，有进程从管道的读端读数据，<code>那么管道中剩余的数据被读取以后，再次read会返回 0</code>，就像读到文件末尾一样。</li>
<li>如果有指向 管道写端 的文件描述符没有关闭<code>（写端引用计数大于0）</code>，而持有管道写端的进程也<code>没有往管道中写数据</code>，这时有进程从管道的读端读数据，<code>那么管道中剩余的数据被读取以后，再次read会阻塞</code>，直到管道中有数据可以读了才读取数据并返回。</li>
<li>如果所有的指向 管道读端 的文件描述符都关闭了<code>（读端引用计数为0）</code>，这个时候向管道中写数据，那么该进程会收到一个信号 SIGPIPE ，通常会导致进程异常终止。</li>
<li>如果有指向 管道读端 的文件描述符没有关闭<code>（读端引用计数大于0）</code>，而持有管道读端的进程也<code>没有往管道中读数据</code>，这时有进程从管道的写端写数据，<code>那么管道被写满的时候，再次调用write会阻塞</code>，直到管道中有空位置才能再次写入数据并返回。</li>
</ol>
<blockquote>
<p><strong>总结：</strong></p>
<p>​	读管道：</p>
<p>​		管道中有数据，read读取数据，返回实际读到的字节数。</p>
<p>​		管道中无数据：</p>
<p>​			写端被全部关闭，read返回0（相当于读到文件的末尾）<br>​			写端没有完全关闭，read阻塞等待</p>
<p>​	</p>
<p>​	写管道：</p>
<p>​		管道读端全部被关闭，进程异常终止（进程收到 SIGPIPE 信号）</p>
<p>​		管道读端没有全部关闭：</p>
<p>​			管道已满，write阻塞<br>​			管道未满，write将数据写入，返回实际写入的字节数</p>
</blockquote>
<br>

<br>

<p><strong>非阻塞设置</strong></p>
<p>fcntl函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> flags = fcntl(fd[<span class="number">0</span>], F_GETFL); <span class="comment">// 获取原来的flag</span></span><br><span class="line">flags |= O_NONBLOCK;			 <span class="comment">// 修改flag</span></span><br><span class="line">fcntl(fd[<span class="number">0</span>], F_SETFL, flags)；	<span class="comment">// 设置新的flag</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<h3 id="2-6-3-有名管道"><a href="#2-6-3-有名管道" class="headerlink" title="2.6.3 有名管道"></a>2.6.3 有名管道</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><ul>
<li>匿名管道由于无名，只能用于亲缘关系的进程间通信。为了扩大应用，提出了 有名管道 （FIFO），也叫命名管道，FIFO文件。</li>
<li>有名管道（FIFO）不同于匿名管道之处，<u>在于它提供了一个路径名与之关联</u>，以FIFO的文件形式存在于文件系统中，并且打开方式与普通文件相同。只要可以访问该路径，就能彼此通过有名管道相互通信，使得不相关的进程也能通信。</li>
</ul>
<br>

<p><strong>与匿名管道的不同之处：</strong></p>
<ol>
<li>FIFO 在文件系统中作为一个特殊文件存在，但 FIFO 中的内容却存放在内核区的内存中。</li>
<li>当使用 FIFO 的进程推出后，FIFO 文件将保存在文件系统中以便以后调用。</li>
<li>FIFO 有名，不相关的进程可以通过打开有名管道进行通信。</li>
</ol>
<br>

<h4 id="有名管道的使用"><a href="#有名管道的使用" class="headerlink" title="有名管道的使用"></a>有名管道的使用</h4><ul>
<li><p>通过命令创建：<code>mkfifo name</code></p>
</li>
<li><p>通过函数创建</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys.types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys.stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- pathname：管道名称的路径</span></span><br><span class="line"><span class="comment">		- mode：文件权限，和 open 的 mode 一样。</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		成功 0，失败 -1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>一旦使用 mkfifo 创建了一个 FIFO ，就可以使用 open 打开，以及使用常见的 I&#x2F;O 函数，如：read，write，unlink，close…</p>
</li>
<li><p>FIFO 严格遵循先进先出，读操作 总是从开始处返回数据，写操作 则把数据添加到末尾。所以不支持 lseek()等文件定位操作。</p>
</li>
</ul>
<br>

<h4 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h4><p><strong>基本使用</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 向管道中写数据</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断文件是否存在</span></span><br><span class="line">    <span class="type">int</span> ret = access(<span class="string">&quot;test&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">// 管道还未创建</span></span><br><span class="line">        ret = mkfifo(<span class="string">&quot;test&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打开管道（只写方式）</span></span><br><span class="line">    <span class="type">int</span> fd = open)<span class="string">&quot;test&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 写数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(buf,<span class="string">&quot;hello %d\n&quot;</span>, i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;write data: %s\n&quot;</span>, buf);</span><br><span class="line">        write(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    close(fd);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从管道中读取数据</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main1</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打开管道文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;test&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="type">int</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取数据</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> len = read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 写端断开连接了</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv buf: %s\n&quot;</span>,buf);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    close(fd);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<blockquote>
<p>open 注意事项：</p>
<ol>
<li>一个为只读而打开一个管道的进程会阻塞，直到另外一个进程为只写打开管道</li>
<li>一个为只写而打开一个管道的进程会阻塞，直到另外一个进程为只读打开管道</li>
</ol>
</blockquote>
<blockquote>
<p><strong>读管道：</strong></p>
<p>​	管道中有数据，read发怒hi实际督导的字节数</p>
<p>​	管道中无数据：<br>​		管道写端被全部关闭，read返回0 （相当于读到文件末尾）<br>​		管道写端没有全部关闭，read阻塞等待</p>
<p><strong>写管道：</strong></p>
<p>​	管道读端被全部关闭，进程异常终止（收到 SIGPIPE 信号）</p>
<p>​	管道读端没有全部关闭：<br>​		管道已满，write会阻塞<br>​		管道未满，write写入数据，返回实际写入的字节数</p>
</blockquote>
<br>

<br>

<p><strong>有名管道实现简单聊天</strong></p>
<p>只能交替地接收和发送</p>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230206212504676-167596242752015.png" alt="image-20230206212504676"></p>
<br>

<p>进程A</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.判断有名管道文件是否存在</span></span><br><span class="line">    <span class="type">int</span> ret = access(<span class="string">&quot;fifo1&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">// 文件不存在则创建</span></span><br><span class="line">        ret = mkfifo(<span class="string">&quot;fifo1&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">    	<span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">			perror(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">	ret = access(<span class="string">&quot;fifo2&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">// 文件不存在则创建</span></span><br><span class="line">        ret = mkfifo(<span class="string">&quot;fifo2&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">    	<span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">			perror(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 以只写方式打开管道 fifo1</span></span><br><span class="line">    <span class="type">int</span> fdw = open(<span class="string">&quot;fifo1&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span>(fdw == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开管道fifo1成功，等待写入...\n&quot;</span>)；</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 以只读方式打开管道 fifo2</span></span><br><span class="line">    <span class="type">int</span> fdr = open(<span class="string">&quot;fifo2&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fdr == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开管道fifo2成功，等待读取...\n&quot;</span>)；</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 循环写读数据</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line">    	<span class="comment">// 获取标准输入的数据    </span></span><br><span class="line">        fgets(buf, <span class="number">128</span>, <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="comment">// 发送信息，写入数据</span></span><br><span class="line">        ret = write(fdw, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 接收信息，读取数据</span></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line">        ret = read(fdr, buf, <span class="number">128</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">           	<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;buf: %s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    close(fdr);</span><br><span class="line">    close(fdw);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<p>进程B </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.判断有名管道文件是否存在</span></span><br><span class="line">    <span class="type">int</span> ret = access(<span class="string">&quot;fifo1&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">// 文件不存在则创建</span></span><br><span class="line">        ret = mkfifo(<span class="string">&quot;fifo1&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">    	<span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">			perror(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">	ret = access(<span class="string">&quot;fifo2&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">// 文件不存在则创建</span></span><br><span class="line">        ret = mkfifo(<span class="string">&quot;fifo2&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">    	<span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">			perror(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 以只读方式打开管道 fifo1</span></span><br><span class="line">    <span class="type">int</span> fdw = open(<span class="string">&quot;fifo1&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fdw == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开管道fifo1成功，等待读取...\n&quot;</span>)；</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 以只写方式打开管道 fifo2</span></span><br><span class="line">    <span class="type">int</span> fdr = open(<span class="string">&quot;fifo2&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span>(fdr == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开管道fifo2成功，等待写入...\n&quot;</span>)；</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 循环读写数据</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 接收信息，读取数据</span></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line">        ret = read(fdr, buf, <span class="number">128</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">           	<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;buf: %s\n&quot;</span>, buf);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line">    	<span class="comment">// 获取标准输入的数据    </span></span><br><span class="line">        fgets(buf, <span class="number">128</span>, <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="comment">// 发送信息，写入数据</span></span><br><span class="line">        ret = write(fdw, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    close(fdr);</span><br><span class="line">    close(fdw);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="2-6-4-内存映射"><a href="#2-6-4-内存映射" class="headerlink" title="2.6.4 内存映射"></a>2.6.4 内存映射</h3><p>内存映射 Memory-mapped I&#x2F;O ,是将磁盘文件的数据映射到内存，用户通过修改内存就能修改磁盘文件。</p>
<p>映射的是进程的虚拟地址空间，映射位置是共享库的位置</p>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230207021339909-167596242752017.png" alt="image-20230207021339909"></p>
<br>

<p><strong>相关系统调用</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	将一个文件或设备的数据映射到内存当中</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- addr：传入NULL，由内核决定后续处理</span></span><br><span class="line"><span class="comment">		- length：要映射的数据长度，不能为0.建议使用文件的长度	（使用 stat 或 lseek 可以获取文件长度）</span></span><br><span class="line"><span class="comment">		- prot：对申请的内存映射区的操作权限（不能与打开的文件有权限冲突）</span></span><br><span class="line"><span class="comment">			PROT_NONE 无权限</span></span><br><span class="line"><span class="comment">			PROT_EXEC 可执行</span></span><br><span class="line"><span class="comment">			PROT_READ 可读</span></span><br><span class="line"><span class="comment">			PROT_WRITE 可写</span></span><br><span class="line"><span class="comment">			（要操作映射内存，必须有读权限）</span></span><br><span class="line"><span class="comment">		- flags：</span></span><br><span class="line"><span class="comment">			MAP_SHARED	映射区的数据会自动和磁盘文件进行同步，进程间通信，必须设置该选项</span></span><br><span class="line"><span class="comment">			MAP_PRIVATE	不同步，内存映射区的数据改变不会修改源文件，而会创建一个新的文件 （copy on write）</span></span><br><span class="line"><span class="comment">		- fd：需要映射的文件的文件描述符，通过 open 得到的。 注意：文件大小要大于0，且 open 指定的权限不能和 prot 冲突。</span></span><br><span class="line"><span class="comment">		- offset：偏移量，文件数据的起始位置偏移，一般不使用（必须是4k的整数倍，0表示不偏移）</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		成功，返回映射到的内存首地址（虚拟地址）</span></span><br><span class="line"><span class="comment">		失败，返回 MAP_FAILED 即（void *) -1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	释放内存映射</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- addr：要释放的内存的首地址</span></span><br><span class="line"><span class="comment">		- length：要释放的内存大小，要和mmap函数中的length参数值一致</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<p><strong>实现进程间通信</strong></p>
<p>父子进程之间</p>
<blockquote>
<ul>
<li>在还没有子进程的时候<ul>
<li>通过唯一的父进程，先创建内存映射区</li>
</ul>
</li>
<li>有了内存映射区后，创建子进程</li>
<li>父子进程共享创建的内存映射区</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打开一个文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;test.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取文件大小</span></span><br><span class="line">    <span class="type">int</span> size = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建内存映射区</span></span><br><span class="line">    <span class="type">void</span> *ptr = mmap(<span class="literal">NULL</span>, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ptr == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(buf, (<span class="type">char</span> *)ptr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read data:%s\n&quot;</span>, buf);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">strcpy</span>((<span class="type">char</span> *)ptr, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关闭内存映射区</span></span><br><span class="line">    munmap(ptr, size);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<p>无关系的进程之间</p>
<blockquote>
<ul>
<li>准备一个大小不是0的磁盘文件</li>
<li>进程1 通过磁盘文件创建内存映射区</li>
<li>得到一个操作这块内存的指针</li>
<li>进程2 通过磁盘文件创建内存映射区</li>
<li>到到一个操作这块内存的指针</li>
<li>使用内存映射区通信</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main1</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打开一个文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;test.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取文件大小</span></span><br><span class="line">    <span class="type">int</span> size = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建内存映射区</span></span><br><span class="line">    <span class="type">void</span> *ptr = mmap(<span class="literal">NULL</span>, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ptr == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过获取文件数据</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(buf, (<span class="type">char</span> *)ptr);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;read data:%s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭内存映射区</span></span><br><span class="line">    munmap(ptr, size);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main2</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打开一个文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;test.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取文件大小</span></span><br><span class="line">    <span class="type">int</span> size = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建内存映射区</span></span><br><span class="line">    <span class="type">void</span> *ptr = mmap(<span class="literal">NULL</span>, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ptr == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 写入内存，修改文件</span></span><br><span class="line">    <span class="built_in">strcpy</span>((<span class="type">char</span> *)ptr, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关闭内存映射区</span></span><br><span class="line">    munmap(ptr, size);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<p><strong>思考问题</strong></p>
<ol>
<li>如果对mmap的返回值 (ptr) 做++操作 (ptr++) ，munmap能否成功</li>
</ol>
<blockquote>
<p>可以 ptr++; 但 munmap 会失败，只能通过首地址释放（提前保存）</p>
</blockquote>
<ol start="2">
<li>如果 open 时 O_RDONLY ，mmap 时 prot 参数指定 PROT_READ | PROT_WRITE 会怎样</li>
</ol>
<blockquote>
<p>错误，会返回MAP_FAILED。</p>
<p>open 函数中的权限要满足 mmap，即 prot &lt;&#x3D; open 的权限参数</p>
</blockquote>
<ol start="3">
<li>如果文件偏移量为1000会怎样</li>
</ol>
<blockquote>
<p>偏移量必须是 4k 的整数倍，否则会返回 MAP_FAILED</p>
</blockquote>
<ol start="4">
<li>mmap什么情况下会调用失败</li>
</ol>
<blockquote>
<ul>
<li>第二个参数：length &#x3D; 0</li>
<li>第三个参数：prot</li>
<li>没有指定读权限</li>
<li>参数 fd 在 open 时的权限不满足当前 prot</li>
</ul>
</blockquote>
<ol start="5">
<li>可以oepn的时候O_CREAT一个新文件来创建映射区吗</li>
</ol>
<blockquote>
<p>可以，但是创建的文件大小如果为 0 ，则不行</p>
<p>可以对新的文件进行拓展</p>
<pre><code>- lseek()
- truncate()
</code></pre>
</blockquote>
<ol start="6">
<li>mmap后关闭文件描述符，对mmap映射有没有影响</li>
</ol>
<blockquote>
<p>​	int fd &#x3D; open(“xxx”);</p>
<p>​	mmap(…, fd, …);</p>
<p>​	close(fd);</p>
<p>映射区还存在，创建的映射区的fd被关闭，没有任何影响</p>
</blockquote>
<ol start="7">
<li>对ptr越界操作会怎样</li>
</ol>
<blockquote>
<p>​	void * ptr &#x3D; mmap(NULL, 100, …);</p>
<p>越界操作会引发段错误</p>
</blockquote>
<br>

<br>

<p>除了进程间通信，还可以用来实现 <strong>文件复制</strong></p>
<ol>
<li>对原始的文件进行内存映射</li>
<li>创建新文件（并拓展</li>
<li>把新文件的数据映射到内存中</li>
<li>通过内存拷贝将第一个文件的数据拷贝到新的文件内存中</li>
<li>释放资源</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mmap.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对原始的文件进行内存映射</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;ori.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取原始文件大小</span></span><br><span class="line">    <span class="type">int</span> len = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个新的文件</span></span><br><span class="line">	<span class="type">int</span> fd1 = open(<span class="string">&quot;cpy.txt&quot;</span>, O_RDWR | O_CREAT, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd1 == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对新创建的文件进行拓展</span></span><br><span class="line">    truncate(<span class="string">&quot;cpy.txt&quot;</span>, len);</span><br><span class="line">    write(fd1, <span class="string">&quot; &quot;</span>, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分别做内存映射</span></span><br><span class="line">    <span class="type">void</span> *ptr = mmap(<span class="literal">NULL</span>,len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="type">void</span> *ptr1 = mmap(<span class="literal">NULL</span>,len, PROT_READ | PROT_WRITE, MAP_SHARED, fd1, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ptr == MAP_FAILED || ptr1 == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 内存拷贝</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr1, ptr, len);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放资源	（习惯上，先打开的后释放）</span></span><br><span class="line">    munmap(ptr1, len);</span><br><span class="line">    munmap(ptr, len);    </span><br><span class="line">    </span><br><span class="line">    close(fd1);</span><br><span class="line">    close(fd);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<p><strong>匿名映射</strong>(用于通信)</p>
<p>不需要文件实体进行内存映射，只能用于有关系的进程之间。</p>
<p>mmap 需要打开 <code>MAP_ANONYMOUS</code> 选项</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mmap.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建匿名内存映射区</span></span><br><span class="line">    <span class="type">int</span> len = <span class="number">4096</span>;</span><br><span class="line">    <span class="type">void</span> *ptr = mmap(<span class="literal">NULL</span>, len, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS，<span class="number">-1</span>， <span class="number">0</span>)；</span><br><span class="line">    <span class="keyword">if</span>(ptr == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 父子进程通信</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">strcpy</span>((<span class="type">char</span> *)ptr, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, (<span class="type">char</span> *)ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="type">int</span> ret = munmap(ptr, len);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;munmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<blockquote>
<p>与直接修改文件相比，在内存修改速度更快 </p>
</blockquote>
<br>

<h3 id="2-6-5-信号"><a href="#2-6-5-信号" class="headerlink" title="2.6.5 信号"></a>2.6.5 信号</h3><h4 id="信号概述"><a href="#信号概述" class="headerlink" title="信号概述"></a>信号概述</h4><p>信号是 Linux 进程通信最古老的方式之一，是事件发生时对进程的通知机制，有时又称为 <code>软件中断</code> ，它是在软件层次上对中断机制的一种模拟，是一种 <code>异步</code> 通信的方式。</p>
<p>信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断，转而处理某一个突发事件。</p>
<br>

<p>发往进程的诸多信号，通常都是源于<code>内核</code>。引发内核为进程产生信号的各类事件如下：</p>
<ul>
<li>对于前台进程，用户可以通过输入特殊的终端字符来发送信号。比如 Ctrl+C 通常会给进程发送一个中断信号。</li>
<li>硬件发生异常，即硬件检测到一个错误条件并通知内核，随机再由内核发送相应信号给相关进程。比如执行一条异常的机器语言指令，如除以0，或者引用了无法访问的内存区域。</li>
<li>系统状态的变化，比如 alarm 定时器到期将引起 SIGALRM 信号、进程执行的CPU时间超限、或者该进程的某个子进程退出。</li>
<li>运行 kill 命令或调用 kill 函数。</li>
</ul>
<br>

<p><strong>使用信号的两个目的</strong></p>
<ul>
<li>让进程知道已经发生了一个特定的事情</li>
<li>强迫进程执行它自己代码中的信号处理程序</li>
</ul>
<br>

<p><strong>特点</strong>：</p>
<ul>
<li>简单</li>
<li>不能携带大量信息</li>
<li>满足某个特定条件才发送</li>
<li>优先级比较高</li>
</ul>
<br>

<p>查看系统定义的信号列表：<code>kill -l</code></p>
<blockquote>
<p>前31个信号为常规信号，其余为实时信号</p>
</blockquote>
<br>

<p>查看信号的详细信息：<code>man 7 signal</code></p>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230207074413475-167596242752016.png" alt="image-20230207074413475"></p>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230207074659817-167596242752019.png" alt="image-20230207074659817"></p>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230207074814071-167596242752018.png" alt="image-20230207074814071"></p>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230207074951533-167596242752020.png" alt="image-20230207074951533"></p>
<br>

<p>进程的5个<strong>默认处理动作</strong></p>
<ul>
<li><p>Term 终止进程</p>
</li>
<li><p>Ign 当前进程忽略掉这个信号</p>
</li>
<li><p>Core 终止进程，并生成一个Core文件（保存进程异常退出的错误信息）</p>
<blockquote>
<p>通过 unlimit -c xxx 设置 core 文件生成</p>
<p>通过 gdb 打开生成的 core 文件</p>
</blockquote>
</li>
<li><p>Stop 暂停当前进程</p>
</li>
<li><p>Cont 继续执行当前被暂停的进程</p>
</li>
</ul>
<br>

<p>信号的3种<strong>状态</strong>：产生、未决、递达</p>
<br>

<blockquote>
<p>SIGKILL 和 SIGSTOP 信号不能被捕捉、阻塞或者忽略，只能执行默认动作</p>
</blockquote>
<br>

<br>

<h4 id="kill、raise、abort-函数"><a href="#kill、raise、abort-函数" class="headerlink" title="kill、raise、abort 函数"></a>kill、raise、abort 函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	给某个进程pid，发送某个信号sig</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- pid ：目标进程的 id</span></span><br><span class="line"><span class="comment">			&gt; 0 : 将信号发送给指定进程</span></span><br><span class="line"><span class="comment">			= 0 : 将信号发送给当前进程的进程组</span></span><br><span class="line"><span class="comment">			= -1 : 将信号发生给每一个有权限接收这个信号的进程</span></span><br><span class="line"><span class="comment">			&lt; -1 : 这个pid=某个进程组的gid取反</span></span><br><span class="line"><span class="comment">		- sig ：需要发送的信号编号或宏值，0表示不发送任何信号</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">raise</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	给当前进程发送某个信号sig</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- sig ：需要发送的信号编号或宏值，0表示不发送任何信号</span></span><br><span class="line"><span class="comment">		返回值：成功 0 ，失败 非 0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">abort</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	发送 SIGABRT 信号给当前进程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<h4 id="alarm-函数"><a href="#alarm-函数" class="headerlink" title="alarm 函数"></a>alarm 函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(unsigner <span class="type">int</span> seconds)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	设置定时器（闹钟）。函数调用后开始倒计时，当计时为0时，函数会给当前进程发送一个 SIGALARM 信号。</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- seconds：倒计时的时常，单位秒。若为0，则定时器无效（可以用 alarm(0); 取消定时器）</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		- 之前没有定时器，返回0</span></span><br><span class="line"><span class="comment">		- 之前有定时器，返回定时器剩余的时间</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	SIGALARM ： 默认终止当前的进程。</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	每一个进程都有且只有唯一的一个定时器。</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<blockquote>
<p>程序运行的实际时间 &#x3D; 内核时间 + 用户时间 + 切换、文件IO等消耗的时间</p>
</blockquote>
<blockquote>
<p>定时器与进程的状态无关。（采用自然定时法，无论进程出于什么状态，alarm都会计时）</p>
</blockquote>
<br>

<h4 id="setitimer-定时器函数"><a href="#setitimer-定时器函数" class="headerlink" title="setitimer 定时器函数"></a>setitimer 定时器函数</h4><p>周期性的定时</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时器值结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">it_interval</span>;</span>	<span class="comment">// 每个间隔的时间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">it_value</span>;</span>	<span class="comment">// 延迟多长时间启动定时器</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 时间值结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">    <span class="type">time_t</span> tv_sec;		<span class="comment">// seconds s</span></span><br><span class="line">    <span class="type">suseconds_t</span> tv_usec;	<span class="comment">// microseconds us</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setitimer</span><span class="params">(<span class="type">int</span> which, <span class="type">const</span> <span class="keyword">struct</span> itimerval *new_val, <span class="keyword">struct</span> itimerval *old_value)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	设置定时器（闹钟），替代 alarm 函数。精度微妙us，周期性计时。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- which : 定时器以什么时间计时</span></span><br><span class="line"><span class="comment">			ITIMER_REAL : 真实时间，时间到则发送SIGALARM ，常用</span></span><br><span class="line"><span class="comment">			ITIMER_VIRTUAL : 用户时间，时间到则发送 SIGVTALRM</span></span><br><span class="line"><span class="comment">			ITIMER_PROF : 以该进程在用户态和内核态下所消耗的时间来计算，时间到则发送 SIGPROF</span></span><br><span class="line"><span class="comment">			</span></span><br><span class="line"><span class="comment">		- new_val : 设置定时器的属性</span></span><br><span class="line"><span class="comment">		- old_value : 记录上一次的定时的时间参数，一般不使用，指定 NULL</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		成功 0 ，失败 -1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<h4 id="signal-信号捕捉函数"><a href="#signal-信号捕捉函数" class="headerlink" title="signal 信号捕捉函数"></a>signal 信号捕捉函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	设置某个信号的捕捉行为</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- signum ： 要捕捉的信号</span></span><br><span class="line"><span class="comment">		- handler ： 捕捉到信号后的处理</span></span><br><span class="line"><span class="comment">			可以是：</span></span><br><span class="line"><span class="comment">			SIG_IGN : 忽略</span></span><br><span class="line"><span class="comment">			SIG_DEL : 使用信号默认的行为</span></span><br><span class="line"><span class="comment">			回调函数 ： 由内核调用，程序员负责实现其功能</span></span><br><span class="line"><span class="comment">		回调函数：</span></span><br><span class="line"><span class="comment">			- 由程序员实现，提前准备好的，函数的类型根据实际需求，和函数指针的定义</span></span><br><span class="line"><span class="comment">			- 不是程序员调用，而是当信号产生，由内核调用</span></span><br><span class="line"><span class="comment">			- 函数指针是实现回调的手段，函数实现之后，将函数名放到函数指针的位置即可</span></span><br><span class="line"><span class="comment">			</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		成功，返回上一次注册的信号处理函数的地址，若是第一次则返回 NULL</span></span><br><span class="line"><span class="comment">		失败，返回 SIG_ERR ，并设置errno</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<blockquote>
<p>SIGKILL 和 SIGSTOP 信号不能被捕捉、阻塞或者忽略，只能执行默认动作</p>
</blockquote>
<br>

<p><strong>案例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myalarm</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sss\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//延迟3秒后启动间隔为2秒的定时器,启动时也会发送信号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册信号捕捉</span></span><br><span class="line">    <span class="comment">// signal(SIGALARM, SIG_IGN);</span></span><br><span class="line">    <span class="comment">// signal(SIGALARM, SIG_DEL);</span></span><br><span class="line">    <span class="comment">// void (* sighandler_t)(int); 函数指针</span></span><br><span class="line">    <span class="type">sighandler_t</span> ret1 = signal(SIGALARM, myalarm);</span><br><span class="line">    <span class="keyword">if</span>(ret1 == SIG_ERR) &#123;</span><br><span class="line">        perror(<span class="string">&quot;signal&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>)；</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">new_val</span>;</span></span><br><span class="line">    <span class="comment">// 间隔时间</span></span><br><span class="line">    new_val.it_interval.tv_sec = <span class="number">2</span>;</span><br><span class="line">    new_val.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 延迟时间</span></span><br><span class="line">    new_val.it_value.tv_sec = <span class="number">3</span>;</span><br><span class="line">    new_val.it.value.tv_usec = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> ret2 = setitimer(ITIMER_REAL, &amp;new_value, <span class="literal">NULL</span>);		<span class="comment">// 非阻塞的</span></span><br><span class="line">    <span class="keyword">if</span>(ret2 == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;setitimer&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<h4 id="信号集及相关函数"><a href="#信号集及相关函数" class="headerlink" title="信号集及相关函数"></a>信号集及相关函数</h4><p><strong>信号集</strong></p>
<ul>
<li>许多信号相关的系统调用都需要能表示一组不同的信号，多个信号可使用一个称之为信号集的数据结构来表示，其系统数据类型为 sigset_t</li>
<li>在 PCB 中有两个非常重要的信号集。一个称之为“阻塞信号集”，另一个称之为“未决信号集”。这两个信号集都是内核使用位图机制来实现的，但操作系统不允许我们直接对这两个信号集进行位操作，而需自定义另外一个集合，借助信号集操作函数来对 PCB 中的两个信号集进行修改。</li>
<li>”未决“，是一种状态，指的是<u>从信号的产生到信号被处理前</u>的这一段时间。</li>
<li>”阻塞“，是一个开关动作，指的是阻止信号被处理，但不是阻止信号产生。  </li>
<li>信号的阻塞就是让系统暂时保留信号，留待以后发送。由于另外有办法让系统忽略信号，所以一般情况下信号的阻塞只是暂时的，只是为了防止信号打断敏感的操作。</li>
</ul>
<br>

<p><strong>默认</strong></p>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230207122515067-167596242752021.png" alt="image-20230207122515067"></p>
<br>

<p><strong>操作信号集的函数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">//以下信号集相关的函数都是对自定义的信号集（参数set）进行操作</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	清空信号集中的数据，将所有标志位置 0</span></span><br><span class="line"><span class="comment">	参数：	set 要操作的信号集</span></span><br><span class="line"><span class="comment">	返回值：成功0，失败-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	将信号集中的所有标志位置 1</span></span><br><span class="line"><span class="comment">	参数：	set 要操作的信号集</span></span><br><span class="line"><span class="comment">	返回值：成功0，失败-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	设置信号集中的某一个信号对应得标志位为 1 ，表示阻塞这个信号</span></span><br><span class="line"><span class="comment">	参数：	</span></span><br><span class="line"><span class="comment">		- set 要操作的信号集</span></span><br><span class="line"><span class="comment">		- signum 需要设置的信号</span></span><br><span class="line"><span class="comment">	返回值：成功0，失败-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigdelset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	设置信号集中的某一个信号对应得标志位为 0 ，表示不阻塞这个信号</span></span><br><span class="line"><span class="comment">	参数：	</span></span><br><span class="line"><span class="comment">		- set 要操作的信号集</span></span><br><span class="line"><span class="comment">		- signum 需要设置的信号</span></span><br><span class="line"><span class="comment">	返回值：成功0，失败-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	判断某个信号是否阻塞</span></span><br><span class="line"><span class="comment">	参数：	</span></span><br><span class="line"><span class="comment">		- set 要操作的信号集</span></span><br><span class="line"><span class="comment">		- signum 需要判断的信号</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		- 1 ，signum被阻塞</span></span><br><span class="line"><span class="comment">		- 0 ，signum不阻塞</span></span><br><span class="line"><span class="comment">		- -1，调用失败</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<h4 id="sigprocmask-函数"><a href="#sigprocmask-函数" class="headerlink" title="sigprocmask 函数"></a>sigprocmask 函数</h4><p>将自己设置好的信号集应用到内核信号集中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oldset)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	将自定义信号集中的数据设置到内核中（设置阻塞，解除阻塞，替换）</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- how  如何对内和阻塞信号集进行处理</span></span><br><span class="line"><span class="comment">			SIG_BLOCK：将用户设置的阻塞信号集添加到内核中，内核中原来的数据不变	（假设内核中默认的阻塞信号集是mask，则令 mask | set ）</span></span><br><span class="line"><span class="comment">			SIG_UNBLOCK：根据用户设置的数据，对内核中的数据进行解除阻塞  （ mask &amp;= ~set ）</span></span><br><span class="line"><span class="comment">			SIG_SETMASK: 覆盖内核中原来的值</span></span><br><span class="line"><span class="comment">		- set  已经初始化的用户自定义的信号集</span></span><br><span class="line"><span class="comment">		- oldset  保存设置之前的内核中的阻塞信号集的状态，可以是NULL</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		成功 0</span></span><br><span class="line"><span class="comment">		失败 -1</span></span><br><span class="line"><span class="comment">			设置错误号：EFAULT、EINVAL</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigpending</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	获取内核中的未决信号集</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	参数 : set  传出参数，保存的是内存中的未决信号集的信息</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	返回值：成功0，失败-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<h4 id="sigaction-信号捕捉函数"><a href="#sigaction-信号捕捉函数" class="headerlink" title="sigaction 信号捕捉函数"></a>sigaction 信号捕捉函数</h4><p>跟 signal 函数作用类似</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> (*sa_handler)(<span class="type">int</span>);	<span class="comment">// 函数指针，指向的函数就是回调函数</span></span><br><span class="line">    <span class="type">void</span> (*sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span> *, <span class="type">void</span> *);		<span class="comment">// 不常用，需要就看看查文档</span></span><br><span class="line">    <span class="type">sigset_t</span> sa_mask;	<span class="comment">// 临时阻塞信号集，在信号捕捉函数执行过程中，临时阻塞某些信号</span></span><br><span class="line">    <span class="type">int</span> sa_flags;	<span class="comment">// 决定使用哪一个信号处理函数（ 0 表示使用 sa_handler，SA_SIGINFO 表示使用sa_sigaction</span></span><br><span class="line">    <span class="type">void</span> (*sa_restorer)(<span class="type">void</span>);	<span class="comment">// 废弃</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction *act, <span class="keyword">struct</span> sigaction *oldact)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	检查或改变信号的处理。信号捕捉</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- signum  指定的信号（ 除了SIGKILL 和 SIGSTOP ）</span></span><br><span class="line"><span class="comment">		- act  捕捉到信号后相应的处理动作</span></span><br><span class="line"><span class="comment">		- oldact  上一次对信号捕捉设置的处理动作，一般不使用，传递 NULL</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		成功 0</span></span><br><span class="line"><span class="comment">		失败 -1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<blockquote>
<p>由于编程标准原因，尽量使用 sigaction</p>
</blockquote>
<br>

<p>如果在回调函数执行过程中又收到信号，则会阻塞回调函数优先处理信号（解决方案：设置临时阻塞信号集）</p>
<br>

<p><strong>内核实现信号捕捉的过程</strong></p>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230207223806887-167596242752026.png" alt="image-20230207223806887"></p>
<blockquote>
<p>内核态的 do_signal() 和 sys_sigreturn()</p>
</blockquote>
<br>

<br>

<h4 id="SIGCHLD-信号"><a href="#SIGCHLD-信号" class="headerlink" title="SIGCHLD 信号"></a>SIGCHLD 信号</h4><p>产生条件：</p>
<ul>
<li>子进程终止时</li>
<li>子进程接收到 SIGSTOP 信号并停止时</li>
<li>子进程处在停止态，接收到 SIGCONT 信号唤醒时</li>
</ul>
<p>以上情况会由内核给父进程发送 SIGCHLD 信号，父进程默认忽略。</p>
<br>

<p><strong>解决僵尸进程问题</strong></p>
<ul>
<li>利用子进程终止时发送 SIGCHLD 信号</li>
<li>创建子进程前，先阻塞 SIGCHLD ，等回调函数注册完之后再解除阻塞</li>
</ul>
<br>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子进程资源回收 回调函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">myFun</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;捕捉信号 %d\n&quot;</span>, num);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> ret = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG);</span><br><span class="line">        <span class="keyword">if</span>(ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child die %d\n&quot;</span>, ret);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 还有子进程存活</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="comment">// 没有子进程了，回收完毕</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打开阻塞</span></span><br><span class="line">    <span class="type">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>. SIGCHLD);</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;<span class="built_in">set</span>, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">        act.sa_flags = <span class="number">0</span>;</span><br><span class="line">        act.sa_handler = myFun;</span><br><span class="line">        sigemptyset(&amp;act.sa_mask);</span><br><span class="line">        sigaction(SIGCHLD, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 解除阻塞</span></span><br><span class="line">        sigprocmask(SIG_UNBLOCK, &amp;<span class="built_in">set</span>, <span class="literal">NULL</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child %d\n&quot;</span>, getpid());</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><br><br></p>
<h3 id="2-6-6-共享内存"><a href="#2-6-6-共享内存" class="headerlink" title="2.6.6 共享内存"></a>2.6.6 共享内存</h3><p>效率最高的进程间通信方式</p>
<p>（内存映射需要用到文件）</p>
<br>

<ul>
<li>共享内存允许两个或多个进程共享<code>物理内存</code>的同一块区域（通常称为 段 )。由于一个共享内存段会被称为一个进程用户空间的一部分，因此这种 IPC 机制无需内核介入（实际上还是会用到系统调用，但相对较少）。所有需要做的就是让一个进程将数据复制进共享内存中，并且这部分数据会对其他所有共享同一个段的进程可用。</li>
<li>与管道等要求 发送进程 将数据从用户空间的缓冲区复制进内核内存 和 接收进程 将数据从内核内存复制进用户空间的缓冲区 的做法相比，共享内存方式速度更快。</li>
</ul>
<br>

<p><strong>使用步骤</strong></p>
<ol>
<li>调用 shmget() 创建一个新共享内存段或区的一个既有共享内存段的标识符（即由其他进程创建的共享内存段）。这个调用将返回后续调用中需要用到的共享内存标识符。</li>
<li>使用 shmat() 来附上共享内存段，也就是使该段成为调用进程的虚拟内存的一部分。</li>
<li>此刻在程序中可以像对待其他可用内存那样对待这个共享内存段。为引用这块共享内存，程序需要使用由 shmat() 调用返回的 addr 值，它是一个指向进程的虚拟地址空间中该共享内存段的起点的指针</li>
<li>调用 shmdt() 来分离共享内存段。调用后，进程就无法再引用这块共享内存。（这一步是可选的，并且在进程终止时会自动完成）</li>
<li>调用 shmctl() 来删除共享内存段。只有当当前所有附加内存段的进程都与之分离之后内存段才会销毁。（只有一个进程需要执行这一步）</li>
</ol>
<p><br><br></p>
<p><strong>函数接口</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	创建一个新的共享内存段，或者获取一个既有的共享内存段的标识</span></span><br><span class="line"><span class="comment">	新创建的内存段中的数据都会被初始化为0</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- key	key_t时整型，通过这个参数找到或者创建一个共享内存。一般使用16进制表示，非0值</span></span><br><span class="line"><span class="comment">		- size	共享内存的大小（实际按页划分）</span></span><br><span class="line"><span class="comment">		- shmflg 属性</span></span><br><span class="line"><span class="comment">			- 访问权限</span></span><br><span class="line"><span class="comment">			- 附加属性：创建/判断共享内存是否存在</span></span><br><span class="line"><span class="comment">				- 创建：IPC_CREAT</span></span><br><span class="line"><span class="comment">				- 判断共享内存是否存在：IPC_EXCL，需要和IPC_CREAT一起使用</span></span><br><span class="line"><span class="comment">				如 IPC_CREAT | IPC_EXCL | 0664</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		失败 -1，设置错误号</span></span><br><span class="line"><span class="comment">		成功 &gt;0,返回共享内存的引用 ID ，后面操作共享内存即通过这个值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">shmat</span><span class="params">(<span class="type">int</span> shmid, consst <span class="type">void</span> *shmaddr, <span class="type">int</span> shmflg)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	和当前的进程进行关联</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- shmid：共享内存的标识id，由shmget返回值获取</span></span><br><span class="line"><span class="comment">		- shmaddr：申请的共享内存的起始地址，指定NULL，由内核决定</span></span><br><span class="line"><span class="comment">		- shmflg：对共享内存的操作</span></span><br><span class="line"><span class="comment">			读：SHM_RDONLY，必须要有读权限</span></span><br><span class="line"><span class="comment">			读写：0</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		成功 返回共享内存的首地址</span></span><br><span class="line"><span class="comment">		失败 （void*)-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *shmaddr)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	解除当前进程和共享内存的关联</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- shmaddr：共享内存的首地址</span></span><br><span class="line"><span class="comment">	返回值：成功0，失败-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmctl</span><span class="params">(<span class="type">int</span> shmid, <span class="type">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	对共享内存进行操作（共享内存需要删除才会消失，创建共享内存的进程被销毁了对共享内存是没有影响的）</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">		- shmid：共享内存id</span></span><br><span class="line"><span class="comment">		- cmd：要做的操作</span></span><br><span class="line"><span class="comment">			IPC_STAT 获取共享内存的当前状态</span></span><br><span class="line"><span class="comment">			IPC_SET 设置共享内存的状态</span></span><br><span class="line"><span class="comment">			IPC_RMID 标记共享内存被销毁</span></span><br><span class="line"><span class="comment">		- buf：需要设置或者获取的共享内存的属性信息</span></span><br><span class="line"><span class="comment">			IPC_STAT：buf存储数据，传出参数</span></span><br><span class="line"><span class="comment">			IPC_SET：buf中需要初始化数据，设置到内核中，传入参数</span></span><br><span class="line"><span class="comment">			IPC_RMID：没有用，NULL</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<blockquote>
<p>shmid_ds结构体</p>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230208120249528-167596242752025.png" alt="image-20230208120249528"></p>
</blockquote>
<br>

<p><strong>案例</strong></p>
<p>write.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个共享内存</span></span><br><span class="line">    <span class="type">int</span> shmid = shmget(<span class="number">100</span>, <span class="number">0</span>, IPC_CREAT);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 和当前进程进行关联</span></span><br><span class="line">    <span class="type">void</span> *ptr = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 写数据</span></span><br><span class="line">    <span class="type">char</span> *str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, str, <span class="built_in">strlen</span>(str)+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 暂停一下</span></span><br><span class="line">    getchar();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解除关联</span></span><br><span class="line">    shmdt(ptr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除共享内存</span></span><br><span class="line">    shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<p>read.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取一个共享内存</span></span><br><span class="line">    <span class="type">int</span> shmid = shmget(<span class="number">100</span>, <span class="number">4096</span>, IPC_CREAT | <span class="number">0664</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 和当前进程进行关联</span></span><br><span class="line">    <span class="type">void</span> *ptr = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,(<span class="type">char</span> *)ptr);</span><br><span class="line">    <span class="comment">// 暂停一下</span></span><br><span class="line">    getchar();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解除关联</span></span><br><span class="line">    shmdt(ptr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除共享内存</span></span><br><span class="line">    shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<blockquote>
<p><strong>删除机制</strong></p>
<p>shmctl(shmid, IPC_RMID, NULL);</p>
<p>当关联进程数 &gt;&#x3D; 1 时，调用上面的函数删除共享内存并不会直接删除，而是把 key 值置为0，标记删除；</p>
<p>当关联进程数 &#x3D; 0 时，共享内存才会真正删除。</p>
</blockquote>
<br>

<br>

<p><strong>ftok函数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">key_t</span> <span class="title function_">ftok</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> proj_id)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	根据指定的路径名和 int 值，生成一个共享内存的 key ，可以作为shmget函数的参数</span></span><br><span class="line"><span class="comment">    参数：</span></span><br><span class="line"><span class="comment">		- pathname：指定一个存在的路径</span></span><br><span class="line"><span class="comment">		- proj_id：int类型的值（4B），但这个系统调用指挥使用其中1个字节</span></span><br><span class="line"><span class="comment">				   范围：0~255，一般指定一个字符 &#x27;a&#x27;</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<br>

<p><strong>问题</strong></p>
<ol>
<li>系统如何知道一块共享内存被多少个进程关联？<ul>
<li>共享内存维护了一个 shmid_ds 结构体，该结构体的成员 shm_nattach 记录了关联进程数</li>
</ul>
</li>
<li>可不可以对共享内存进行多次删除<ul>
<li>可以，当还有关联进程的时候，共享内存只是标记删除。而直到没有关联进程才会被真正删除。</li>
<li>key 为 0 ：被标记删除，不再能被关联</li>
</ul>
</li>
<li>共享内存与内存映射的区别<ul>
<li>共享内存可以直接创建，内存映射需要磁盘文件（匿名映射除外）</li>
<li>共享内存效率更高</li>
<li><strong>内存：</strong><br>共享内存，所有进程操作的是同一块共享内存（物理）；<br>内存映射，每个进程再自己的虚拟地址空间中有一个独立的内存。</li>
<li><strong>数据安全：</strong><ul>
<li>进程突然退出<br>共享内存还存在，内存映射区消失。</li>
<li>电脑突然宕机<br>共享内存中的数据消失，内存映射区的数据在磁盘文件中仍存在。</li>
</ul>
</li>
<li><strong>生命周期：</strong><ul>
<li>共享内存：进程退出，共享内存仍存在，需要手动删除或关机（进程退出会自动取消关联）</li>
<li>内存映射区：进程退出，映射区销毁</li>
</ul>
</li>
</ul>
</li>
</ol>
<br>

<p><strong>一些操作命令</strong>（System V）</p>
<p><code>ipcs</code></p>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230208122145744-167596242752022.png" alt="image-20230208122145744"></p>
<p><code>ipcrm</code></p>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230208122153825-167596242752023.png" alt="image-20230208122153825"></p>
<p><br><br></p>
<h3 id="补充：2-6-7-消息队列"><a href="#补充：2-6-7-消息队列" class="headerlink" title="补充：2.6.7 消息队列"></a>补充：2.6.7 消息队列</h3><p><br><br><br></p>
<h2 id="2-7-守护进程"><a href="#2-7-守护进程" class="headerlink" title="2.7 守护进程"></a>2.7 守护进程</h2><h3 id="终端、进程组、会话"><a href="#终端、进程组、会话" class="headerlink" title="终端、进程组、会话"></a>终端、进程组、会话</h3><p><strong>终端</strong></p>
<ul>
<li>在 UNIX 系统中，用户通过 终端 登陆到系统后得到一个 shell 进程，这个终端进程为 shell 进程的 控制终端 （Controlling Termianl) ，进程中，控制终端是保存在 PCB 中的信息，而 fork() 会复制 PCB 中的信息，因此由 shell 进程启动的其他进程的控制终端也是这个终端。</li>
<li>默认情况下（没有重定向），每个进程的标准输入、标准输出和标准错误输出（文件描述符）都指向控制终端，进程从标准输入读也就是读用户的键盘输入，进程往标准输出或标准错误输出写也就是输出到显示器上。</li>
<li>在控制终端输入一些特殊的控制键可以给前台进程发送信号，例如 Ctrl+C 会产生 SIGINT 信号，Ctrl+\ 会产生 SIGQUIT 信号。</li>
</ul>
<br>

<p><strong>进程组</strong></p>
<ul>
<li>进程组和会话在进程之间形成了一种两级层次关系：进程组是一组相关进程的集合，会话是一组相关进程组的集合。</li>
<li>进程组和会话是为支持 <u>shell作业控制</u> 而定义的抽象概念，用户通过 shell 能够交互式地在前台或后台运行命令。</li>
</ul>
<br>

<ul>
<li>进程组由一个或多个共享同一进程组标识符（PGID）的进程组成。一个进程组拥有一个 进程组首进程 （组长），该进程是创建该组的进程，<u>其进程 ID 为该进程组的 ID</u> ，新进程会继承父进程所属的进程组 ID 。</li>
<li>进程组有一个生命周期，起开始时间为首进程创建组的时刻，结束时间为最后一个成员进程退出的时刻。一个进程可能会因为终止而退出进程组，也可能会因为加入另一个进程组而退出进程组。进程组首进程无需是最后一个离开的成员。</li>
</ul>
<br>



<p><strong>会话</strong></p>
<ul>
<li>会话是一组进程组的集合。会话首进程是创建该新会话的进程，其进程ID会成为会话ID。新进程会继承其父进程的会话ID。</li>
<li>一个会话中的所有进程共享单个控制终端。控制终端会在会话首进程首次打开一个终端设备时被建立。一个终端最多可能成为一个会话的控制终端。</li>
<li>在任意时刻，会话中的其中一个进程组会成为终端的前台进程组，其他进程会成为后台进程组。只有前台进程组中的进程才能从控制终端中读取输入。当用户在控制终端中输入终端字符生成信号后，该信号会被发送到前台进程组中的所有成员。</li>
<li>当控制终端的连接建立起来之后，会话首进程会成为该终端的控制进程。</li>
</ul>
<br>

<p><strong>三者关系图</strong></p>
<p>指令 </p>
<p><code>fing / 2 &gt; /dev/null | wc -l &amp;</code>( &amp; 后台运行指令 )</p>
<p><code>sort &lt; longlist | uniq -c</code></p>
<p><img src="/2023/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/image-20230208194637948-167596242752024.png" alt="image-20230208194637948"></p>
<blockquote>
<p>来自评论区：</p>
<p>为什么两条命令产生了两个新的进程组，并且不同于bach进程组:</p>
<p>关于find和wc为什么父进程是bash(400)，但是进程组ID确是658，而不是复制父进程的组ID。其实fork函数产生的子进程才是复制父进程的组ID。那通过这种命令产生的子进程，组ID是怎么确立的？在《Linux&#x2F;UNIX系统编程手册》2.13 中提到，“shell执行的每个程序都会在一个新进程内发起”，这句话解释了为什么find、wc、sort、uniq这四个都是一个单独的进程。“除了Bourne shell以外，几乎所有主流shell都提供了一种交互式特性，名为任务控制。该特性允许用户同时执行并操纵多条命令或管道。在支持任务控制的shell中，会将管道内所有进程置于一个新进程组或任务中。如果情况很简单，shell命令行只包含一条命令，那么就会创建一个只包含单个进程的新进程组。进程组中每个进程都具有相同的进程组标识符，其实就是进程组组长的ID”，这段话可以解释为什么两条命令产生了两个新的进程组，并且不同于bach进程组。这种shell命令创建子进程一定要和fork函数区分开来。</p>
</blockquote>
<br>

<br>

<p><strong>相关函数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取当前进程的进程组</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgrp</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// 获取指定进程的进程组</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br><span class="line"><span class="comment">// 设置指定进程的组id</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setpgid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">pid_t</span> pgid)</span>;</span><br><span class="line"><span class="comment">// 获取指定进程的会话id</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getsid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br><span class="line"><span class="comment">// 设置当前进程的会话id</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">setsid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><br><br></p>
<h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><p>守护进程( Daemon Process )，也就是通常说的 Daemon 进程（精灵进程），是Linux中的后台服务进程。其生存周期较长，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生地事件。进程名一般以 d 结尾。</p>
<br>

<p><strong>特征</strong></p>
<ul>
<li>生命周期长，守护进程会在系统启动的时候被创建并一直运行直至系统被关闭。</li>
<li>在后台运行并且不拥有控制终端。没有控制终端确保了内核永远不会为守护进程自动生成任何控制信号以及终端相关的信号（如 SIGINT、SIGQUIT）</li>
</ul>
<br>

<blockquote>
<p>Linux的大多数服务器就是用守护进程实现的，比如，Internet服务器 inetd ，Web服务器 httpd 等</p>
</blockquote>
<br>

<p><strong>创建步骤</strong></p>
<ul>
<li>*执行 fork()，然后父进程退出，子进程继续执行<ul>
<li>假设从命令行启动进程，父进程在退出后会使终端出现shell提示符；提前退出就不会出现了</li>
<li>子进程能确保自己不是进程组的首进程</li>
</ul>
</li>
<li>*子进程调用 setsid() 开启一个新会话（<ul>
<li>用setsid新建会话的首进程不能是进程组的首进程，否则导致组id重复</li>
<li>新建会话是为了控制终端，setsid() 新建的会话在终端连接建立之前默认无控制终端</li>
</ul>
</li>
<li>（非必须）清除进程的 umask 以确保当守护进程创建文件和目录时拥有所需的权限</li>
<li>（非必须）修改进程的当前工作目录，通常改为根目录（ &#x2F; ）</li>
<li>关闭守护进程从其父进程继承而来的所有打开着的文件描述符<ul>
<li>守护进程脱离了控制终端，但是没有脱离终端</li>
<li>避免守护进程通过标准输出等到终端读写数据</li>
<li>以及关闭其他继承过来的文件描述符，解除文件占用</li>
</ul>
</li>
<li>在关闭了文件描述符0、1、2之后，守护进程通常会打开 &#x2F;dev&#x2F;null 并使用 dup2() 使所有这些描述符指向这个设备<ul>
<li>某些系统调用会使用到0、1、2文件描述符，所以不能关闭</li>
<li>重定向后相当于丢弃掉数据</li>
</ul>
</li>
<li>*核心业务逻辑</li>
</ul>
<br>

<p><strong>案例</strong></p>
<p>写一个守护进程，每个2s获取一次系统时间，并将时间写入到磁盘文件中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">work</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="comment">// 捕捉到信号之后，获取系统时间并写入磁盘</span></span><br><span class="line">    <span class="type">time_t</span> ret = time(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> * <span class="title">loc</span> =</span> localtime(&amp;ret);</span><br><span class="line">    <span class="comment">// 转换格式</span></span><br><span class="line">    <span class="comment">// char buf[1024];</span></span><br><span class="line">    <span class="comment">// sprintf(buf, &quot;%d:%d:%d\n&quot;,loc-&gt;tm_hour,loc-&gt;tm_min,loc-&gt;tm_sec);</span></span><br><span class="line">    <span class="comment">// printf(&quot;%s\n&quot;,buf);</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *str = asctime(loc);</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;time.txt&quot;</span>, O_RDWR | O_CREAT | O_APPEND, <span class="number">0664</span>);</span><br><span class="line">    write(fd, str, <span class="built_in">strlen</span>(str));</span><br><span class="line">    write(fd, <span class="string">&quot;\n&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;\n&quot;</span>));    </span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建子进程，退出父进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子进程重新创建一个会话</span></span><br><span class="line">    setsid();</span><br><span class="line">    <span class="comment">// 设置掩码</span></span><br><span class="line">    umask(<span class="number">022</span>);</span><br><span class="line">    <span class="comment">// 更改工作目录</span></span><br><span class="line">    chdir(<span class="string">&quot;/root/user&quot;</span>);</span><br><span class="line">    <span class="comment">// 关闭、重定向文件描述符</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/dev/null&quot;</span>,O_RDWR);</span><br><span class="line">    dup2(fd,STDIN_FILENO);</span><br><span class="line">    dup2(fd,STDOUT_FILENO);</span><br><span class="line">    dup2(fd,STDERR_FILENO);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 业务逻辑</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册信号捕捉</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    act.sa_handler = work;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    sigaction(SIGALRM, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建定时器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">val</span>;</span></span><br><span class="line">    val.it_value.tv_sec = <span class="number">2</span>;</span><br><span class="line">    val.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">    val.it_interval.tv_sec = <span class="number">2</span>;</span><br><span class="line">    val.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    setitimer(ITIMER_REAL, &amp;val, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<br>

<p>第二章完结！</p>
]]></content>
      <categories>
        <category>C++开发</category>
        <category>高性能服务器项目</category>
      </categories>
      <tags>
        <tag>多进程</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux网络编程</title>
    <url>/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<br>

<h1 id="第四章-Linux网络编程"><a href="#第四章-Linux网络编程" class="headerlink" title="第四章 Linux网络编程"></a>第四章 Linux网络编程</h1><hr>
<br>

<h2 id="4-1-计算机网络相关知识"><a href="#4-1-计算机网络相关知识" class="headerlink" title="4.1 计算机网络相关知识"></a>4.1 计算机网络相关知识</h2><br>

<h3 id="4-1-1-网络结构模式"><a href="#4-1-1-网络结构模式" class="headerlink" title="4.1.1 网络结构模式"></a>4.1.1 网络结构模式</h3><h4 id="C-x2F-S结构"><a href="#C-x2F-S结构" class="headerlink" title="C&#x2F;S结构"></a>C&#x2F;S结构</h4><span id="more"></span>

<p><strong>简介</strong></p>
<ul>
<li>服务器 - 客户机，即 Client - Server（C&#x2F;S）结构。<strong>C&#x2F;S 结构通常采取两层结构。服务器负责数据的管理，客户机负责完成与用户的交互任务。</strong>客户机是因特网上访问别人信息的机器，服务器则是提供信息供人访问的计算机。</li>
<li><strong>客户机通过局域网与服务器相连，接受用户的请求，并通过网络向服务器提出请求，对数据库进行操作。服务器接受客户机的请求，将数据提交给客户机，客户机将数据进行计算并将结果呈现给用户。</strong>服务器还要提供完善安全保护及对数据完整性的处理等操作，并允许多个客户机同时访问服务器，这就对服务器的硬件处理数据能力提出了很高的要求。</li>
<li>在C&#x2F;S结构中，<strong>应用程序分为两部分：服务器部分和客户机部分。</strong>服务器部分是多个用户共享的信息与功能，执行后台服务，如控制共享数据库的操作等；客户机部分为用户所专有，负责执行前台功能，在出错提示、在线帮助等方面都有强大的功能，并且可以在子程序间自由切换。</li>
</ul>
<br>

<p><strong>优点</strong></p>
<ol>
<li>能充分发挥客户端 PC 的处理能力，<strong>很多工作可以在客户端处理后再提交给服务器，</strong>所以 C&#x2F;S 结构<strong>客户端响应速度快</strong>；</li>
<li>操作界面漂亮、形式多样，可以充分满足客户自身的<strong>个性化</strong>要求；</li>
<li>C&#x2F;S 结构的<strong>管理信息系统具有较强的事务处理能力</strong>，能实现复杂的业务流程；</li>
<li><strong>安全性较高</strong>，C&#x2F;S 一般面向相对固定的用户群，<strong>程序更加注重流程</strong>，它可以<strong>对权限进行多层次校验</strong>，提供了更安全的存取模式，对信息安全的控制能力很强，一般<strong>高度机密</strong>的信息系统采用 C&#x2F;S 结构适宜。</li>
</ol>
<br>

<p><strong>缺点</strong></p>
<ol>
<li><strong>客户端需要安装专用的客户端软件</strong>。首先涉及到安装的工作量，其次任何一台电脑出问题，如病毒、硬件损坏，都需要进行安装或维护。系统软件升级时，每一台客户机需要重新安装，其维护和升级成本非常高；</li>
<li><strong>对客户端的操作系统一般也会有限制，不能够跨平台</strong></li>
</ol>
<br>

<br>

<h4 id="B-x2F-S-结构"><a href="#B-x2F-S-结构" class="headerlink" title="B&#x2F;S 结构"></a>B&#x2F;S 结构</h4><p><strong>简介</strong></p>
<ul>
<li>B&#x2F;S 结构（Browser&#x2F;Server，浏览器&#x2F;服务器模式），<strong>是WEB兴起后的一种网络结构模式，WEB浏览器是客户端最主要的应用软件。</strong>这种模式<strong>统一了客户端</strong>，将系统功能实现的<strong>核心部分集中到服务器上</strong>，简化了系统的开发、维护和使用。客户机上只要安装一个浏览器，如 Firefox 或 InternetExplorer，服务器安装 SQL Server、Oracle、MySQL 等数据库。浏览器通过 Web Server 同数据库进行数据交互</li>
</ul>
<br>

<p><strong>优点</strong></p>
<ul>
<li>B&#x2F;S 架构最大的优点是总体拥有<strong>成本低、维护方便、 分布性强、开发简单</strong>，可以不用安装任何专门的软件就能实现在任何地方进行操作，客户端零维护，系统的扩展非常容易，只要有一台能上网的电脑就能使用。</li>
</ul>
<br>

<p><strong>缺点</strong></p>
<ol>
<li><strong>通信开销大、系统和数据的安全性较难保障;</strong></li>
<li>个性特点明显降低，无法实现具有个性化的功能要求；</li>
<li>协议一般是<strong>固定</strong>的：<strong>http&#x2F;https</strong>（无法输出大数据）</li>
<li>客户端服务器端的交互是<strong>请求-响应模式</strong>，通常<strong>动态刷新</strong>页面，<strong>响应速度明显降低</strong>。</li>
</ol>
<br>

<br>

<br>

<h3 id="4-1-2-MAC、IP、端口"><a href="#4-1-2-MAC、IP、端口" class="headerlink" title="4.1.2 MAC、IP、端口"></a>4.1.2 MAC、IP、端口</h3><h4 id="网卡"><a href="#网卡" class="headerlink" title="网卡"></a>网卡</h4><p>（网卡分为 以太网卡 和 无线网卡 ）</p>
<ul>
<li>网卡是一块被设计用来允许计算机在计算机网络上进行通讯的计算机硬件，又称为 <strong>网络适配器</strong> 或 <strong>网络接口卡NIC</strong> 。</li>
<li>其<strong>拥有 MAC 地址</strong>，属于 OSI 模型的<strong>第 2 层</strong>，它使得用户可以通过电缆或无线相互连接。</li>
<li>每一个网卡都有一个被称为 MAC 地址的独一无二的 <strong>48 位</strong>串行号。</li>
<li>网卡的主要功能：<ul>
<li>数据的封装与解封装</li>
<li>链路管理</li>
<li>数据编码与译码</li>
</ul>
</li>
</ul>
<br>

<h4 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h4><ul>
<li>Media Access Control Address</li>
<li>直译为 <strong>媒体存取控制位址</strong> ，也称为 <strong>局域网地址</strong>、<strong>以太网地址</strong>、<strong>物理地址</strong> 或 <strong>硬件地址</strong> ，它是一个用来确认网络设备位置的位址，由网络设备制造商生产时烧录在网卡中</li>
<li>在 OSI 模型中，<strong>第三层网络层负责IP地址，第二层数据链路层则负责MAC位址</strong> </li>
<li>MAC 地址用于在网络中<strong>唯一标识一个网卡</strong>。一台设备若有一或多个网卡，则每个网卡都需要并会有一个唯一的 MAC 地址。</li>
<li>MAC 地址的长度为 <strong>48 位（6个字节）</strong>，通常表示为 12 个 16 进制数，如：00-16-EA-AE-3C-40 就是一个MAC 地址。<ul>
<li>其中前 3 个字节，16 进制数 00-16-EA 代表网络硬件制造商的编号，它由IEEE（电气与电子工程师协会）分配</li>
<li>而后 3 个字节，16进制数 AE-3C-40 代表该制造商所制造的某个网络产品（如网卡）的系列号。</li>
<li>只要不更改自己的 MAC 地址，MAC 地址在世界是唯一的。形象地说，MAC 地址就如同身份证上的身份证号码，具有唯性。</li>
</ul>
</li>
</ul>
<br>

<h4 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h4><p><strong>简介</strong></p>
<p>​	IP（Internet Protocol）协议是为计算机网络相互连接进行通信而设计的协议。在 <strong>因特网</strong> 中，它是能使连接到网上的所有计算机网络实现相互通信的一套规则，规定了计算机在因特网上进行通信时应当遵守的规则。任何厂家生产的计算机系统，只要遵守IP协议就可以与因特网互连互通。</p>
<p>​	各个厂家生产的网络系统和设备，如以太网、分组交换网等，它们相互之间不能互通，不能互通的主要原因是因为它们所传送数据的基本单元（技术上称之为“帧”）的格式不同。IP 协议实际上是一套由软件程序组成的协议软件，它把各种不同“<strong>帧</strong>”统一转换成“<strong>IP 数据报</strong>”格式，这种转换是因特网的一个最重要的特点，使所有各种计算机都能在因特网上实现互通，即具有“开放性”的特点。正是因为有了 IP 协议，因特网才得以迅速发展成为世界上最大的、开放的计算机通信网络。因此，IP 协议也可以叫做“<strong>因特网协议</strong>”。</p>
<br>

<ul>
<li><p><strong>IP地址</strong>（Internet Protocol Address）是指<strong>互联网协议地址</strong>，又译为<strong>网际协议地址</strong>。IP 地址是IP协议提供的一种统一的地址格式，<strong>它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异</strong></p>
</li>
<li><p>IP 地址是一个 <strong>32 位的二进制数</strong>，通常被分割为 <strong>4 个“ 8 位二进制数”</strong>（也就是 4 个字节）。</p>
</li>
</ul>
<br>

<p><strong>IP地址类型</strong></p>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230210225815319.png" alt="image-20230210225815319"></p>
<p>补充：</p>
<ul>
<li>D类IP地址：D 类 IP 地址在历史上被叫做多播地址（multicast address），即组播地址。在以太网中，多播地址命名了一组应该在这个网络中应用接收到一个分组的站点。多播地址的最高位必须是 “1110”，范围从224.0.0.0 - 239.255.255.255。</li>
<li><strong>特殊的网址</strong>（E类）：<ul>
<li>每一个字节都为 0 的地址（ “0.0.0.0” ）对应于当前主机；</li>
<li>IP 地址中的每一个字节都为 1 的 IP 地址（ “255.255.255.255” ）是当前子网的广播地址；</li>
<li>IP 地址中凡是以 “11110” 开头的 E 类 IP 地址都保留用于将来和实验使用。</li>
<li>IP地址中不能以十进制 “127” 作为开头，该类地址中数字 127.0.0.1 到 127.255.255.255 用于回路测试，如：127.0.0.1可以代表本机IP地址</li>
</ul>
</li>
</ul>
<br>

<p><strong>子网掩码</strong></p>
<ul>
<li>子网掩码（subnet mask）又叫网络掩码、地址掩码、子网络遮罩，它是一种用来指明一个 IP 地址的哪些位标识的是主机所在的子网，以及哪些位标识的是主机的位掩码。子网掩码不能单独存在，它必须结合 IP 地址一起用。子网掩码只有一个作用，就是<strong>将某个 IP 地址划分成 网络地址 和 主机地址 两部分</strong>。</li>
<li>子网掩码是一个 32 位地址，用于屏蔽 IP 地址的一部分以区别网络标识和主机标识，并说明该 IP地址是在局域网上，还是在广域网上。</li>
<li>子网掩码是在 IPv4 地址资源紧缺的背景下为了解决 IP 地址分配而产生的虚拟 IP 技术，通过子网掩码将A、B、C 三类地址划分为若干子网，从而显著提高了 IP 地址的分配效率，有效解决了 IP 地址资源紧张的局面。另一方面，在企业内网中为了更好地管理网络，网管人员也利用子网掩码的作用，人为地将一个较大的企业内部网络划分为更多个小规模的子网，再利用三层交换机的路由功能实现子网互联，从而有效解决了网络广播风暴和网络病毒等诸多网络管理方面的问题。</li>
</ul>
<br>

<br>

<h4 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h4><blockquote>
<p>端口 就是一块缓冲区，有 读缓冲 和 写缓冲 </p>
</blockquote>
<p><strong>简介</strong></p>
<ul>
<li>端口 是英文 port 的意译，可以认为是设备与外界通讯交流的出口。端口可分为 <strong>虚拟端口</strong> 和 <strong>物理端口</strong> ，<ul>
<li><strong>虚拟端口</strong> 指<strong>计算机内部或交换机路由器内的端口</strong>，<strong>不可见</strong>，是特指<strong>TCP&#x2F;IP协议中的端口</strong>，是<strong>逻辑意义上</strong>的端口。例如计算机中的 80 端口、21 端口、23 端口等。</li>
<li><strong>物理端口</strong> 又称为<strong>接口</strong>，<strong>是可见端口</strong>，计算机背板的 RJ45 网口，交换机路由器集线器等 RJ45 端口。电话使用 RJ11 插口也属于物理端口的范畴。</li>
</ul>
</li>
<li>如果把 IP 地址比作一间房子，端口就是出入这间房子的门。真正的房子只有几个门，但是一个 IP地址的端口可以有 <strong>65536</strong>（即：2^16）个之多！端口是通过端口号来标记的，端口号只有整数，范围是从 <strong>0 到 65535</strong>（2^16-1）。</li>
</ul>
<br>

<p><strong>端口类型</strong></p>
<ul>
<li><p><strong>周知端口</strong> Well Known Ports ：</p>
<ul>
<li>也叫知名端口、公认端口或者常用端口，范围从 <strong>0 到 1023</strong>，它们紧密绑定于一些特定的服务。</li>
<li>例如 <strong>80 端口分配给 WWW 服务，21 端口分配给 FTP 服务，23 端口分配给Telnet服务</strong>等等。</li>
<li>网络服务是可以使用其他端口号的，比如使用“8080” 作为 WWW服务的端口；但是有些系统协议使用固定的端口号，比如 139 端口专门用于 NetBIOS 与 TCP&#x2F;IP 之间的通信</li>
</ul>
</li>
<li><p><strong>注册端口</strong> Registered Ports ：</p>
<ul>
<li>端口号从 <strong>1024 到 49151</strong>，它们松散地绑定于一些服务，<strong>分配给用户进程或应用程序</strong>。</li>
<li>这些端口在没有被服务器资源占用的时候，可以给用户端动态选用为源端口。</li>
</ul>
</li>
<li><p><strong>动态端口</strong> &#x2F; <strong>私有端口</strong> Dynamic Ports&#x2F;Private Ports ：</p>
<ul>
<li>动态端口的范围是从 <strong>49152 到 65535</strong>。之所以称为动态端口，是因为它一般不固定分配某种服务，而是<strong>动态分配</strong>。</li>
</ul>
</li>
</ul>
<br>

<br>

<br>

<br>

<h3 id="4-1-3-网络模型"><a href="#4-1-3-网络模型" class="headerlink" title="4.1.3 网络模型"></a>4.1.3 网络模型</h3><h4 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h4><p>Open System Interconnection</p>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230210233638076.png" alt="image-20230210233638076"></p>
<p><strong>物理层</strong>：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输，到达目的地后再转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做比特。</p>
<br>

<p><strong>数据链路层</strong>：建立逻辑连接、进行硬件地址寻址、差错校验等功能。定义了如何让格式化数据以帧为单位进行传输，以及如何让控制对物理介质的访问。将比特组合成字节进而组合成帧，用MAC地址访问介质。</p>
<br>

<p><strong>网络层</strong>：进行逻辑地址寻址，在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。</p>
<br>

<p><strong>传输层</strong>：定义了一些传输数据的协议和端口号（ WWW 端口 80 等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与TCP 特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如 QQ 聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做段。</p>
<br>

<p><strong>会话层</strong>：通过传输层（端口号：传输端口与接收端口）建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求。</p>
<br>

<p><strong>表示层</strong>：<strong>数据的表示、安全、压缩。</strong>主要是进行对接收的数据进行解释、加密与解密、压缩与解压缩等（也就是把计算机能够识别的东西转换成人能够能识别的东西（如图片、声音等）。</p>
<br>

<p><strong>应用层</strong>：网络服务与最终用户的一个接口。这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务</p>
<br>

<br>

<h4 id="TCP-x2F-IP-四层模型"><a href="#TCP-x2F-IP-四层模型" class="headerlink" title="TCP&#x2F;IP 四层模型"></a>TCP&#x2F;IP 四层模型</h4><p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230210233916419.png" alt="image-20230210233916419"></p>
<p>现在 Internet（因特网）使用的<strong>主流协议族是 TCP&#x2F;IP 协议族</strong>，它是一个分层、多协议的通信体系。TCP&#x2F;IP协议族是一个四层协议系统，<strong>自底而上分别是数据链路层、网络层、传输层和应用层</strong>。</p>
<br>

<p><strong>简化OSI七层模型</strong></p>
<ol>
<li><strong>应用层、表示层、会话层</strong> 三个层次提供的服务相差不是很大，所以在 TCP&#x2F;IP 协议中，它们被合并为 <strong>应用层</strong> 一个层次。</li>
<li>由于 <strong>传输层、网络层</strong> 在网络协议中的地位十分重要，所以在 TCP&#x2F;IP 协议中它们被作为<strong>独立</strong>的两个层次。</li>
<li>因为 <strong>数据链路层、物理层</strong> 的内容相差不多，所以在 TCP&#x2F;IP 协议中它们被归并在 <strong>网络接口层</strong> 一个层次里。</li>
</ol>
<br>

<p><strong>四层介绍</strong></p>
<ul>
<li><strong>应用层</strong>：应用层是 TCP&#x2F;IP 协议的第一层，是直接为应用进程提供服务的。<ul>
<li>对不同种类的应用程序它们会根据自己的需要来使用应用层的不同协议，邮件传输应用使用了 SMTP 协议、万维网应用使用了 HTTP 协议、远程登录服务应用使用了有 TELNET 协议。</li>
<li>应用层还能<strong>加密、解密、格式化数据</strong>。</li>
<li>应用层可以<strong>建立或解除与其他节点的联系</strong>，这样可以充分节省网络资源。</li>
</ul>
</li>
<li><strong>传输层</strong>：作为 TCP&#x2F;IP 协议的第二层，运输层在整个 TCP&#x2F;IP 协议中起到了中流砥柱的作用。且在运输层中， <strong>TCP 和 UDP</strong> 也同样起到了中流砥柱的作用。</li>
<li><strong>网络层</strong>：网络层在 TCP&#x2F;IP 协议中的位于第三层。在 TCP&#x2F;IP 协议中网络层可以进行<strong>网络连接的建立和终止</strong>以及 <strong>IP 地址的寻找</strong>等功能。</li>
<li><strong>网络接口层</strong>：在 TCP&#x2F;IP 协议中，网络接口层位于第四层。由于网络接口层兼并了物理层和数据链路层所以，网络接口层既是<strong>传输数据的物理媒介</strong>，也可以为网络层<strong>提供一条准确无误的线路</strong>。</li>
</ul>
<br>

<br>

<p><strong>比较</strong></p>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230210235626139.png" alt="image-20230210235626139"></p>
<br>

<br>

<br>

<br>

<h3 id="4-1-4-协议"><a href="#4-1-4-协议" class="headerlink" title="4.1.4 协议"></a>4.1.4 协议</h3><p><strong>简介</strong></p>
<p>​	<strong>协议</strong>，网络协议的简称，网络协议是通信计算机双方必须共同遵从的一组约定。</p>
<ul>
<li>如怎么样建立连接、怎么样互相识别等。只有遵守这个约定，计算机之间才能相互通信交流。</li>
<li>它的三要素是：<strong>语法、语义、时序</strong>。</li>
<li>为了使数据在网络上从源到达目的，网络通信的参与方必须遵循相同的规则，这套规则称为协议（protocol），它最终体现为在网络上传输的<strong>数据包的格式</strong>。协议往往分成几个层次进行定义，<strong>分层定义</strong>是为了<u>使某一层协议的改变不影响其他层次的协议</u>。</li>
</ul>
<br>

<p><strong>常见协议</strong></p>
<ul>
<li><p>应用层：</p>
<ul>
<li>FTP协议（File Transfer Protocol 文件传输协议）</li>
<li>HTTP协议（Hyper Text Transfer Protocol 超文本传输协议）</li>
<li>NFS（Network File System 网络文件系统）。（SSH协议端口号是22）</li>
</ul>
</li>
<li><p>传输层：</p>
<ul>
<li>TCP协议（Transmission Control Protocol 传输控制协议）</li>
<li>UDP协议（User Datagram Protocol 用户数据报协议）。</li>
</ul>
</li>
<li><p>网络层：</p>
<ul>
<li>IP 协议（Internet Protocol 因特网互联协议）</li>
<li>ICMP 协议（Internet Control Message Protocol 因特网控制报文协议）</li>
<li>IGMP 协议（Internet Group Management Protocol 因特网组管理协议）。</li>
</ul>
</li>
<li><p>网络接口层：</p>
<ul>
<li>ARP协议（Address Resolution Protocol 地址解析协议）</li>
<li>RARP协议<br>（Reverse Address Resolution Protocol 反向地址解析协议）</li>
</ul>
</li>
</ul>
<br>

<br>

<h4 id="UDP报"><a href="#UDP报" class="headerlink" title="UDP报"></a>UDP报</h4><p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230211001006533.png" alt="image-20230211001006533"></p>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230211003426471.png" alt="image-20230211003426471"></p>
<br>

<h4 id="TCP报"><a href="#TCP报" class="headerlink" title="TCP报"></a>TCP报</h4><p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230211001202108.png" alt="image-20230211001202108"></p>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230211003839373.png" alt="image-20230211003839373"></p>
<p>flag：<br><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230211004511396.png" alt="image-20230211004511396"></p>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230211004527855.png" alt="image-20230211004527855"></p>
<br>

<h4 id="IP报"><a href="#IP报" class="headerlink" title="IP报"></a>IP报</h4><p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230211003610812.png" alt="image-20230211003610812"></p>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230211005238765.png" alt="image-20230211005238765"></p>
<br>

<h4 id="以太网帧"><a href="#以太网帧" class="headerlink" title="以太网帧"></a>以太网帧</h4><p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230211003524443.png" alt="image-20230211003524443"></p>
<p>类型：0x800 IP，0x806 ARP，0x835 RARP</p>
<br>

<h4 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h4><p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230211003731026.png" alt="image-20230211003731026"></p>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230211003742083.png" alt="image-20230211003742083"></p>
<br>

<br>

<h4 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程"></a>通信过程</h4><p><strong>封装</strong></p>
<p>​	应用程序数据在发送到物理网络上之前，将沿着协议栈从上往下依次传递。每层协议都将在上层数据的基础上加上自己的头部信息（有时还包括尾部信息），以实现该层的功能，这个过程就称为封装。</p>
<blockquote>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230211010042659.png" alt="封装"></p>
</blockquote>
<br>

<p><strong>分用</strong></p>
<p>​	当帧到达目的主机时，将沿着协议栈自底向上依次传递。各层协议依次处理帧中本层负责的头部数据，以获取所需的信息，并最终将处理后的帧交给目标应用程序。这个过程称为分用（demultiplexing）。分用是依靠头部信息中的类型字段实现的。</p>
<blockquote>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230211010337835.png" alt="分用"></p>
</blockquote>
<br>

<p><strong>封装与解封装案例</strong></p>
<p>（数据链路层还有 帧尾 的校验码）</p>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230211010845923.png" alt="封装与解封装"></p>
<br>

<br>

<h4 id="ARP协议的分析"><a href="#ARP协议的分析" class="headerlink" title="ARP协议的分析"></a>ARP协议的分析</h4><p>封装过程中，从网络层到数据链路层，需要添加的以太网帧头含有 <strong>目的mac地址</strong> 字段</p>
<p><strong>问题</strong>：目前知道 目的IP地址 ，要从何获取目的mac地址？ —— 利用ARP协议（通过 IP 获取 mac）</p>
<p>先查找本地 地址解析表 ，如果没有就如下：</p>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230211011936900.png" alt="arp"></p>
<ul>
<li>广播发送</li>
<li>单播应答</li>
</ul>
<br>

<p><strong>帧结构</strong></p>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230211020206256.png" alt="ARP报文"></p>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230211020650494.png" alt="加上帧头（请求包）"></p>
<blockquote>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230211003731026.png" alt="image-20230211003731026"></p>
</blockquote>
<br>

<br>

<h3 id="4-1-5-Socket套接字"><a href="#4-1-5-Socket套接字" class="headerlink" title="4.1.5 Socket套接字"></a>4.1.5 Socket套接字</h3><p><strong>socket</strong>（套接字），就是对 <strong>网络中不同主机上的应用进程之间</strong> 进行<strong>双向通信</strong>的<strong>端点</strong>的抽象。一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制。从所处的地位来讲，套接字上联应用进程，下联网络协议栈，是应用程序通过网络协议进行通信和交互的接口。</p>
<br>

<p>socket 可以看成是两个网络<strong>应用程序</strong>进行通信时，各自<strong>通信连接中的端点</strong>，这是一个<strong>逻辑上的概念</strong>。它是网络环境中进程间通信的 API，也是可以 <strong>被命名</strong> 和 <strong>寻址</strong> 的通信端点，使用中的每一个套接字都有其类型和一个与之相连进程。通信时其中一个网络应用程序将要传输的一段信息写入它所在主机的 socket 中，该 socket 通过与网络接口卡（NIC）相连的传输介质将这段信息送到另外一台主机的 socket 中，使对方能够接收到这段信息。socket 是由 <strong>IP</strong> 和 <strong>端口</strong> 结合的，提供<strong>向应用层进程传送数据包</strong>的机制。</p>
<br>

<p>socket 本身有“<strong>插座</strong>”的意思，在 Linux 环境下，用于表示进程间网络通信的特殊文件类型。本质为内核借助 <strong>缓冲区</strong> 形成的 <strong>伪文件</strong> 。既然是文件，那么理所当然的，我们可以使用 <strong>文件描述符</strong> 引用套接字。与管道类似的，<u>Linux 系统将其封装成文件的目的是为了统一接口</u>，使得读写套接字和读写文件的操作一致。<u>区别是管道主要应用于本地进程间通信，而套接字多应用于网络进程间数据的传递。</u></p>
<br>

<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230211023108406.png" alt="image-20230211023108406"></p>
<br>

<p>套接字通信分两部分：</p>
<ul>
<li><strong>服务器端</strong>：被动接受连接，一般不会主动发起连接</li>
<li><strong>客户端</strong>：主动向服务器发起连接</li>
</ul>
<blockquote>
<p>socket是一套通信的接口，Linux 和 Windows 都有，但是有一些细微的差别</p>
</blockquote>
<br>

<br>

<h3 id="4-1-6-字节序"><a href="#4-1-6-字节序" class="headerlink" title="4.1.6 字节序"></a>4.1.6 字节序</h3><blockquote>
<p>现代 CPU 的累加器一次都能装载（至少）4 字节（这里考虑 32 位机），即一个整数。</p>
<p>这 4 字节在内存中排列的顺序将影响它被累加器装载成的整数的值，这就是字节序问题。</p>
<p>通信双方交流的信息单元（比特、字节、字、双字等等）应该以什么样的顺序进行传送。</p>
</blockquote>
<br>

<p>字节序分为大端字节序（Big-Endian） 和小端字节序（Little-Endian）。</p>
<ul>
<li><p><strong>大端</strong> 字节序是指 一个整数 的 <strong>最高位字节</strong>（0x后面最左边的数字）存储在 <strong>内存</strong> 的 <strong>低地址</strong> 处 ，低位字节（0 ~ 7 bit）存储在内存的高地址处；<br><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230212223224461.png" alt="image-20230212223224461"></p>
</li>
<li><p><strong>小端</strong> 字节序则是指整数的高位字节存储在内存的高地址处，而低位字节则存储在内存的低地址处。</p>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230212223233439.png" alt="image-20230212223233439"></p>
</li>
</ul>
<br>

<p><strong>大部分计算机采用小端序</strong></p>
<br>

<h4 id="检测主机字节序"><a href="#检测主机字节序" class="headerlink" title="检测主机字节序"></a>检测主机字节序</h4><p>利用 union</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过代码检测当前主机的字节序</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 定义联合体</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">short</span> value;    <span class="comment">// 2字节</span></span><br><span class="line">        <span class="type">char</span> bytes[<span class="keyword">sizeof</span>(<span class="type">short</span>)];  <span class="comment">// char[2]</span></span><br><span class="line">    &#125; test;</span><br><span class="line"></span><br><span class="line">    test.value = <span class="number">0x0102</span>;</span><br><span class="line">    <span class="keyword">if</span>((test.bytes[<span class="number">0</span>] == <span class="number">1</span>) &amp;&amp; (test.bytes[<span class="number">1</span>] == <span class="number">2</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;大端字节序\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>((test.bytes[<span class="number">0</span>] == <span class="number">2</span>) &amp;&amp; (test.bytes[<span class="number">1</span>] == <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;小端字节序\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;未知\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<h4 id="字节序转换"><a href="#字节序转换" class="headerlink" title="字节序转换"></a>字节序转换</h4><p>当格式化的数据在两台使用不同字节序的主机之间直接传递时：</p>
<p><strong>发送端总是把要发送的数据转换成大端字节序数据后再发送，</strong>而接收端知道对方传送过来的数据总是采用大端字节序，所以接收端可以根据自身采用的字节序决定是否对接收到的数据进行转换。</p>
<br>

<p><strong>网络字节顺序</strong>：</p>
<p> TCP&#x2F;IP 中规定好的一种数据表示格式，它与具体的 CPU 类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释，<strong>网络字节顺序采用大端排序方式</strong>。</p>
<br>

<p>BSD Socket提供了封装好的转换接口，方便程序员使用。包括</p>
<ul>
<li><p>从主机字节序 到 网络字节序 的转换函数htons、htonl；</p>
</li>
<li><p>从网络字节序到主机字节序的转换函数：ntohs、ntohl。</p>
</li>
</ul>
<br>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	h - host 主机，主机字节序</span></span><br><span class="line"><span class="comment">	to - 转换成什么</span></span><br><span class="line"><span class="comment">	n - network 网络字节序</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	s - short unsigned short	，端口 </span></span><br><span class="line"><span class="comment">	l - long unsigned int	，IP</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 端口	short unsigned short</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">htons</span><span class="params">(<span class="type">uint16_t</span> hostshort)</span>; <span class="comment">// 主机字节序 - 网络字节序</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ntohs</span><span class="params">(<span class="type">uint16_t</span> netshort)</span>; <span class="comment">// 网络字节序 - 主机字节序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IP long unsigned int</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">htonl</span><span class="params">(<span class="type">uint32_t</span> hostlong)</span>; <span class="comment">// 主机字节序 - 网络字节序</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ntohl</span><span class="params">(<span class="type">uint32_t</span> netlong)</span>; <span class="comment">// 网络字节序 - 主机字节序</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><br><br></p>
<br>

<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// htons 转换端口</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> a = <span class="number">0x0102</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a : %x\n&quot;</span>, a);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> b = htons(a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b : %x\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;=======================\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// htonl  转换IP</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">4</span>] = &#123;<span class="number">192</span>, <span class="number">168</span>, <span class="number">1</span>, <span class="number">100</span>&#125;;</span><br><span class="line">    <span class="type">int</span> num = *(<span class="type">int</span> *)buf;  <span class="comment">// 先取数组地址，在对其进行int类型转换，再解引用</span></span><br><span class="line">    <span class="type">int</span> sum = htonl(num);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *p = (<span class="type">char</span> *)&amp;sum;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>, *p, *(p+<span class="number">1</span>), *(p+<span class="number">2</span>), *(p+<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;=======================\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ntohl</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buf1[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">168</span>, <span class="number">192</span>&#125;;</span><br><span class="line">    <span class="type">int</span> num1 = *(<span class="type">int</span> *)buf1;</span><br><span class="line">    <span class="type">int</span> sum1 = ntohl(num1);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *p1 = (<span class="type">unsigned</span> <span class="type">char</span> *)&amp;sum1;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>, *p1, *(p1+<span class="number">1</span>), *(p1+<span class="number">2</span>), *(p1+<span class="number">3</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ntohs</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> c = <span class="number">0x0201</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a : %x\n&quot;</span>, c);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> d = ntohs(c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b : %x\n&quot;</span>, d);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><br><br></p>
<br>

<h3 id="4-1-7-socket-地址"><a href="#4-1-7-socket-地址" class="headerlink" title="4.1.7 socket 地址"></a>4.1.7 socket 地址</h3><p>socket地址其实是一个结构体，封装端口号和IP等信息</p>
<h4 id="通用socket地址"><a href="#通用socket地址" class="headerlink" title="通用socket地址"></a>通用socket地址</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">	<span class="type">sa_family_t</span> sa_family;</span><br><span class="line">	<span class="type">char</span> sa_data[<span class="number">14</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="type">sa_family_t</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<br>

<p><strong>sa_family</strong> 成员是 地址族类型（sa_family_t）的变量。地址族类型通常与协议族类型对应。常见的协议族（protocol family，也称 domain）和对应的地址族入下所示：</p>
<table>
<thead>
<tr>
<th>协议族</th>
<th>地址族</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>PF_UNIX</td>
<td>AF_UNIX</td>
<td>UNIX本地域协议族</td>
</tr>
<tr>
<td>PF_INET</td>
<td>AF_INET</td>
<td>TCP&#x2F;IPv4协议族</td>
</tr>
<tr>
<td>PF_INET6</td>
<td>AF_INET6</td>
<td>TCP&#x2F;IPv6协议族</td>
</tr>
</tbody></table>
<blockquote>
<p>（宏 PF_* 和 AF_* 都定义在 bits&#x2F;socket.h 头文件中，且后者与前者有完全相同的值，所以二者通常混用）</p>
</blockquote>
<br>

<p><strong>sa_data</strong> 成员用于存放 <strong>socket 地址值</strong>。但是，不同的协议族的地址值具有不同的含义和长度，如下所示：</p>
<table>
<thead>
<tr>
<th align="left">协议族</th>
<th>地址值含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">PF_UNIX</td>
<td>文件的路径名，长度可达108字节</td>
</tr>
<tr>
<td align="left">PF_INET</td>
<td>16 bit 端口号 和 32 bit IPv4地址</td>
</tr>
<tr>
<td align="left">PF_INET6</td>
<td>16 bit 端口号，32 bit 流标识，128 bit IPv6 地址，32 bit 范围 ID  （共26字节）</td>
</tr>
</tbody></table>
<br>

<p>由上表可知，14 字节的 sa_data 根本无法容纳多数协议族的地址值。因此，Linux 定义了下面这个<strong>新的通用的 socket 地址结构体，这个结构体不仅提供了足够大的空间用于存放地址值，而且是内存对齐的</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">sa_family_t</span> sa_family;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> __ss_align;</span><br><span class="line">    <span class="comment">//	用来对其内存</span></span><br><span class="line">	<span class="type">char</span> __ss_padding[ <span class="number">128</span> - <span class="keyword">sizeof</span>(__ss_align) ];	<span class="comment">//	具体地址数据</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="type">sa_family_t</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<h4 id="专用socket地址"><a href="#专用socket地址" class="headerlink" title="专用socket地址"></a>专用socket地址</h4><p>很多网络编程函数诞生早于 IPv4 协议，那时候都使用的是 struct sockaddr 结构体，为了向前兼容，现sockaddr 退化成了（void *）的作用，传递一个地址给函数，至于是 sockaddr_in 还是sockaddr_in6，由地址族确定，然后函数内部再强制类型转化为所需的地址类型。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TCP/IP 协议族有 sockaddr_in 和 sockaddr_in6 两个专用的 socket 地址结构体，它们分别用于 IPv4 和 IPv6：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">sa_family_t</span> sin_family;	<span class="comment">// 地址族</span></span><br><span class="line">	<span class="type">in_port_t</span> sin_port; 	<span class="comment">// 端口</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">// IP</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">/* 对其内存用 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> sin_zero[<span class="keyword">sizeof</span> (<span class="keyword">struct</span> sockaddr) - __SOCKADDR_COMMON_SIZE - <span class="keyword">sizeof</span> (<span class="type">in_port_t</span>) - <span class="keyword">sizeof</span> (<span class="keyword">struct</span> in_addr)];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">in_addr_t</span> s_addr;	<span class="comment">//typedef uint32_t in_addr_t;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//	IPv6</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">sa_family_t</span> sin6_family;</span><br><span class="line">	<span class="type">in_port_t</span> sin6_port; <span class="comment">/* Transport layer port # */</span></span><br><span class="line">	<span class="type">uint32_t</span> sin6_flowinfo; <span class="comment">/* IPv6 flow information */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span> <span class="comment">/* IPv6 address */</span></span><br><span class="line">	<span class="type">uint32_t</span> sin6_scope_id; <span class="comment">/* IPv6 scope-id */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">uint16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">uint32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint16_t</span> <span class="type">in_port_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">in_addr_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SOCKADDR_COMMON_SIZE (sizeof (unsigned short int))</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230213070943568.png" alt="image-20230213070943568"></p>
<p><strong>所有专用 socket 地址（以及 sockaddr_storage）类型的变量在实际使用时都需要转化为通用 socket 地址类型 sockaddr（强制转化即可）</strong>，因为所有 socket 编程接口使用的地址参数类型都是 sockaddr</p>
<br>

<br>

<br>

<h3 id="4-1-8-IP地址转换"><a href="#4-1-8-IP地址转换" class="headerlink" title="4.1.8 IP地址转换"></a>4.1.8 IP地址转换</h3><p><strong>点分十进制字符串</strong> 表示的 <strong>IPv4</strong> 地址和用 <strong>网络字节序整数</strong> 表示的 <strong>IPv4</strong> 地址之间的转换：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 地址字符串 转 网络字节序整数</span></span><br><span class="line"><span class="type">in_addr_t</span> <span class="title function_">inet_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 地址字符串 转 网络字节序整数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_aton</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cp, <span class="keyword">struct</span> in_addr *inp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 网络字节序整数 转 地址字符串</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr in)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<p><strong>新版的函数接口</strong>：IPv4，IPv6</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// p:点分十进制的IP字符串，n:表示network，网络字节序的整数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 地址字符串 转 网络字节序整数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span>;</span><br><span class="line">af:地址族： AF_INET AF_INET6</span><br><span class="line">src:需要转换的点分十进制的IP字符串</span><br><span class="line">dst:转换后的结果保存在这个里面</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 网络字节序整数 转 地址字符串</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">char</span> *dst, <span class="type">socklen_t</span> size)</span>;</span><br><span class="line">af:地址族： AF_INET AF_INET6</span><br><span class="line">src: 要转换的ip的整数的地址</span><br><span class="line">dst: 转换成IP地址字符串保存的地方</span><br><span class="line">size：第三个参数的大小（数组的大小）</span><br><span class="line">返回值：返回转换后的数据的地址（字符串），和 dst 是一样的</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<p><strong>案例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个ip字符串,点分十进制的IP地址字符串</span></span><br><span class="line">    <span class="type">char</span> buf[] = <span class="string">&quot;192.168.1.4&quot;</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将点分十进制的IP字符串转换成网络字节序的整数</span></span><br><span class="line">    inet_pton(AF_INET, buf, &amp;num);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> * p = (<span class="type">unsigned</span> <span class="type">char</span> *)&amp;num;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>, *p, *(p+<span class="number">1</span>), *(p+<span class="number">2</span>), *(p+<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将网络字节序的IP整数转换成点分十进制的IP字符串</span></span><br><span class="line">    <span class="type">char</span> ip[<span class="number">16</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> * str =  inet_ntop(AF_INET, &amp;num, ip, <span class="number">16</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str : %s\n&quot;</span>, str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ip : %s\n&quot;</span>, ip);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ip == str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<p><br><br></p>
<br>

<h2 id="4-2-TCP通信"><a href="#4-2-TCP通信" class="headerlink" title="4.2 TCP通信"></a>4.2 TCP通信</h2><blockquote>
<p>UDP于TCP对比</p>
<hr>
<p><strong>UDP</strong>:<br>    <strong>用户数据报</strong> 协议，面向<strong>无连接</strong>，可以<strong>单播，多播，广播</strong>， 面向数据报，不可靠</p>
<p><strong>TCP</strong>:<br>    <strong>传输控制</strong> 协议，面向<strong>连接</strong>的，可靠的，基于<strong>字节流</strong>，仅支持<strong>单播</strong>传输</p>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th align="center">UDP</th>
<th align="center">TCP</th>
</tr>
</thead>
<tbody><tr>
<td>是否创建连接</td>
<td align="center">无连接</td>
<td align="center">面向连接</td>
</tr>
<tr>
<td>是否可靠</td>
<td align="center">不可靠</td>
<td align="center">可靠的</td>
</tr>
<tr>
<td>连接对象个数</td>
<td align="center">一对一、一对多、多对一、多对多</td>
<td align="center">一对一</td>
</tr>
<tr>
<td>传输的方式</td>
<td align="center">面向数据报</td>
<td align="center">面向字节流</td>
</tr>
<tr>
<td>首部开销</td>
<td align="center">8个字节</td>
<td align="center">最少20个字节</td>
</tr>
<tr>
<td>适用场景</td>
<td align="center">实时应用（视频会议，直播）</td>
<td align="center">可靠性高的应用（文件传输）</td>
</tr>
</tbody></table>
<br>

<br>

<h3 id="4-2-1-TCP通信流程"><a href="#4-2-1-TCP通信流程" class="headerlink" title="4.2.1 TCP通信流程"></a>4.2.1 TCP通信流程</h3><p><strong>服务器端</strong> （被动接受连接的角色）</p>
<ol>
<li>创建一个 <strong>用于监听</strong> 的套接字<ul>
<li>监听：监听有客户端的连接</li>
<li>套接字：这个套接字其实就是一个文件描述符</li>
</ul>
</li>
<li>将这个监听文件描述符和本地的IP和端口绑定（IP和端口就是服务器的地址信息）<ul>
<li>客户端连接服务器的时候使用的就是这个IP和端口</li>
</ul>
</li>
<li>设置监听，监听的fd开始工作</li>
<li>阻塞等待，当有客户端发起连接，解除阻塞，接受客户端的连接，会得到一个和客户端通信的套接字（fd）</li>
<li>通信<ul>
<li>接收数据</li>
<li>发送数据</li>
</ul>
</li>
<li>通信结束，断开连接</li>
</ol>
<br>

<p><strong>客户端</strong></p>
<ol>
<li>创建一个用于通信的套接字（fd）</li>
<li>连接服务器，需要指定连接的服务器的 IP 和 端口</li>
<li>连接成功了，客户端可以直接和服务器通信<ul>
<li>接收数据</li>
<li>发送数据</li>
</ul>
</li>
<li>通信结束，断开连接</li>
</ol>
<br>

<blockquote>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230213082358002.png" alt="image-20230213082358002"></p>
</blockquote>
<br>

<br>

<h3 id="4-2-2-Socket函数"><a href="#4-2-2-Socket函数" class="headerlink" title="4.2.2 Socket函数"></a>4.2.2 Socket函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span> <span class="comment">// 包含了这个头文件，上面两个就可以省略</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建套接字</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br><span class="line">	- 功能：创建一个套接字</span><br><span class="line">	- 参数：</span><br><span class="line">		- domain: 协议族</span><br><span class="line">			AF_INET : ipv4</span><br><span class="line">			AF_INET6 : ipv6</span><br><span class="line">			AF_UNIX, AF_LOCAL : 本地套接字通信（进程间通信）</span><br><span class="line">		- type: 通信过程中使用的协议类型</span><br><span class="line">			SOCK_STREAM : 流式协议 TCP</span><br><span class="line">			SOCK_DGRAM : 报式协议  UDP</span><br><span class="line">		- protocol : 具体的一个协议。一般写 <span class="number">0</span></span><br><span class="line">			- SOCK_STREAM : 流式协议默认使用 TCP</span><br><span class="line">			- SOCK_DGRAM : 报式协议默认使用 UDP</span><br><span class="line">	- 返回值：</span><br><span class="line">		- 成功：返回文件描述符，操作的就是内核缓冲区。</span><br><span class="line">		- 失败：<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将IP、端口绑定到套接字</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>; <span class="comment">// socket命名</span></span><br><span class="line">	- 功能：绑定，将 fd 和本地的IP + 端口进行绑定</span><br><span class="line">	- 参数：</span><br><span class="line">		- sockfd : 通过socket函数得到的文件描述符</span><br><span class="line">		- addr : 需要绑定的socket地址，这个地址封装了ip和端口号的信息</span><br><span class="line">		- addrlen : 第二个参数结构体占的内存大小</span><br><span class="line">            </span><br><span class="line"><span class="comment">// 套接字启动监听</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>; <span class="comment">// /proc/sys/net/core/somaxconn</span></span><br><span class="line">	- 功能：监听这个socket上的连接</span><br><span class="line">	- 参数：</span><br><span class="line">		- sockfd : 通过socket()函数得到的文件描述符</span><br><span class="line">		- backlog : 最大连接数， <span class="number">5</span>即可</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line"><span class="comment">// 接收连接，默认是阻塞的</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br><span class="line">	- 功能：接收客户端连接，默认是一个阻塞的函数，阻塞等待客户端连接</span><br><span class="line">	- 参数：</span><br><span class="line">		- sockfd : 用于监听的文件描述符</span><br><span class="line">		- addr : 传出参数，记录了连接成功后客户端的地址信息（ip，port）</span><br><span class="line">		- addrlen : 指定第二个参数的对应的内存大小</span><br><span class="line">	- 返回值：</span><br><span class="line">		- 成功 ：用于通信的文件描述符</span><br><span class="line">		- <span class="number">-1</span> ： 失败</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line"><span class="comment">// 客户端发起连接（参数有点像 bind ）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line">	- 功能： 客户端连接服务器</span><br><span class="line">	- 参数：</span><br><span class="line">		- sockfd : 用于通信的文件描述符</span><br><span class="line">		- addr : 客户端要连接的服务器的地址信息</span><br><span class="line">		- addrlen : 第二个参数的内存大小</span><br><span class="line">	- 返回值：成功 <span class="number">0</span>， 失败 <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>; <span class="comment">// 写数据</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>; <span class="comment">// 读数据</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<br>

<br>

<br>

<h3 id="4-2-3-三次握手"><a href="#4-2-3-三次握手" class="headerlink" title="4.2.3 三次握手"></a>4.2.3 三次握手</h3><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230214004936804.png" alt="image-20230214004936804" style="zoom:80%;">

<br>

<ul>
<li><p>TCP 是一种<strong>面向连接的单播协议</strong>，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的<strong>“连接”</strong>，其实是<strong>客户端和服务器的内存里保存的一份关于对方的信息</strong>，如 IP 地址、端口号等。</p>
</li>
<li><p>TCP 可以看成是一种<strong>字节流</strong>，它会处理 <strong>IP 层或以下的层</strong> 的 <strong>丢包、重复以及错误</strong> 问题。</p>
</li>
<li><p>在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在 TCP 头部。</p>
</li>
<li><p>TCP 提供了一种可靠、面向连接、字节流、传输层的服务，采用 三次握手建立一个连接 。采用 四次挥手来关闭一个连接 。 三次握手的目的是 <strong>保证双方互相之间建立了连接</strong> 。</p>
</li>
<li><p>三次握手发生在客户端连接的时候，当 <strong>调用connect()</strong> ，底层会通过TCP协议进行三次握手。</p>
</li>
</ul>
<br>

<p><strong>TCP 头</strong></p>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230214002211867.png" alt="image-20230214002211867"></p>
<br>

<ul>
<li><strong>16 位端口号</strong>（port number）：告知主机报文段是来自哪里（<strong>源端口</strong>）以及传给哪个上层协议或应用程序（<strong>目的端口</strong>）的。进行 TCP 通信时，客户端通常使用系统自动选择的临时端口号。</li>
<li><strong>32 位序号</strong>（sequence number）：一次 TCP 通信（从 TCP 连接建立到断开）过程中某一个传输方向上的字节流的每个字节的编号。假设主机 A 和主机 B 进行 TCP 通信，A 发送给 B 的第一个TCP 报文段中，序号值被系统初始化为某个随机值 ISN（Initial Sequence Number，初始序号值）。那么在该传输方向上（从 A 到 B），后续的 TCP 报文段中序号值将被系统设置成 ISN 加上该报文段所携带数据的第一个字节在整个字节流中的偏移。例如，某个 TCP 报文段传送的数据是字节流中的第 1025 ~ 2048 字节，那么该报文段的序号值就是 ISN + 1025。另外一个传输方向（从B 到 A）的 TCP 报文段的序号值也具有相同的含义。</li>
<li><strong>32 位确认号</strong>（acknowledgement number）：用作对另一方发送来的 TCP 报文段的响应。其值是收到的 TCP 报文段的序号值 + 标志位长度（SYN，FIN） + 数据长度 。假设主机 A 和主机 B 进行TCP 通信，那么 A 发送出的 TCP 报文段不仅携带自己的序号，而且包含对 B 发送来的 TCP 报文段的确认号。反之，B 发送出的 TCP 报文段也同样携带自己的序号和对 A 发送来的报文段的确认序</li>
<li><strong>4 位头部长度</strong>（head length）：标识该 TCP 头部有多少个 32 bit(4 字节)。因为 4 位最大能表示15，所以 TCP 头部最长是60 字节。</li>
<li><strong>6 位标志位</strong>包含如下几项：<ul>
<li>URG 标志，表示紧急指针（urgent pointer）是否有效。</li>
<li>ACK 标志，表示确认号是否有效。我们称携带 ACK 标志的 TCP 报文段为确认报文段。</li>
<li>PSH 标志，提示接收端应用程序应该立即从 TCP 接收缓冲区中读走数据，为接收后续数据腾出空间（如果应用程序不将接收到的数据读走，它们就会一直停留在 TCP 接收缓冲区中）。</li>
<li>RST 标志，表示要求对方重新建立连接。我们称携带 RST 标志的 TCP 报文段为 <strong>复位</strong> 报文段。</li>
<li>SYN 标志，表示请求建立一个连接。我们称携带 SYN 标志的 TCP 报文段为 <strong>同步</strong> 报文段。</li>
<li>FIN 标志，表示通知对方本端要关闭连接了。我们称携带 FIN 标志的 TCP 报文段为 <strong>结束</strong> 报文段。</li>
</ul>
</li>
<li><strong>16 位窗口大小</strong>（window size）：是 TCP 流量控制的一个手段。这里说的窗口，指的是 <strong>接收通告窗口</strong> （Receiver Window，RWND）。它告诉对方本端的 TCP 接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。</li>
<li><strong>16 位校验和</strong>（TCP checksum）：由发送端填充，接收端对 TCP 报文段执行 CRC 算法以校验TCP 报文段在传输过程中是否损坏。注意，这个校验不仅包括 TCP 头部，也包括数据部分。这也是 TCP 可靠传输的一个重要保障。</li>
<li><strong>16 位紧急指针</strong>（urgent pointer）：是一个正的偏移量。它和序号字段的值相加表示最后一个紧急数据的下一个字节的序号。因此，确切地说，这个字段是紧急指针相对当前序号的偏移，不妨称之为紧急偏移。TCP 的紧急指针是发送端向接收端发送紧急数据的方法。</li>
</ul>
<br>

<p><strong>三次握手</strong></p>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230214004856526.png" alt="image-20230214004856526"></p>
<p><strong>传输数据</strong></p>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230214004912780.png" alt="image-20230214004912780"></p>
<br>

<p><strong>小结</strong></p>
<p>第一次握手：<br>    1.客户端将SYN标志位置为1<br>    2.生成一个随机的32位的序号seq&#x3D;J ， 这个序号后边是可以携带数据（数据的大小）<br>第二次握手：<br>    1.服务器端接收客户端的连接： ACK&#x3D;1<br>    2.服务器会回发一个确认序号： ack &#x3D; 客户端的序号 + 数据长度 + SYN&#x2F;FIN(按一个字节算)<br>    3.服务器端会向客户端发起连接请求： SYN&#x3D;1<br>    4.服务器会生成一个随机序号：seq &#x3D; K<br>第三次握手：<br>    1.客户单应答服务器的连接请求：ACK&#x3D;1<br>    2.客户端回复收到了服务器端的数据：ack&#x3D;服务端的序号 + 数据长度 + SYN&#x2F;FIN(按一个字节算)</p>
<p><br><br></p>
<h3 id="4-2-4-滑动窗口"><a href="#4-2-4-滑动窗口" class="headerlink" title="4.2.4 滑动窗口"></a>4.2.4 滑动窗口</h3><p><strong>滑动窗口</strong>（Sliding window）是一种 <strong>流量控制</strong> 技术。</p>
<blockquote>
<p>早期的网络通信中，通信双方不会考虑网络的拥挤情况直接发送数据。由于大家不知道网络拥塞状况，同时发送数据，导致中间节点阻塞掉包，谁也发不了数据，所以就有了滑动窗口机制来解决此问题。</p>
</blockquote>
<p>滑动窗口协议是用来 <strong>改善吞吐量</strong> 的一种技术，即<strong>容许发送方在接收任何应答之前传送附加的包</strong> 。<strong>接收方告诉发送方在某一时刻能送多少包</strong>（称 <strong>窗口尺寸</strong>）。</p>
<p>TCP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。<strong>发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据</strong>。当滑动窗口为 0 时，发送方一般不能再发送数据报。</p>
<blockquote>
<p>滑动窗口是 TCP 中实现诸如 <strong>ACK 确认</strong>、<strong>流量控制</strong>、<strong>拥塞控制</strong> 的承载结构。</p>
</blockquote>
<br>

<ul>
<li>滑动窗口的大小会随着发送数据和接收数据而变化。</li>
<li>通信的双方都有发送缓冲区和接收数据的缓冲区</li>
</ul>
<br>

<p><strong>图例</strong></p>
<img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230214235843054.png" alt="image-20230214235843054" style="zoom:80%;">

<img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230214235856918.png" alt="image-20230214235856918" style="zoom:80%;">

<br>

<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230215000000336.png" alt="image-20230215000000336"></p>
<blockquote>
<p>mss: Maximum Segment Size(一条数据的最大的数据量)</p>
<p>win: 滑动窗口</p>
</blockquote>
<br>

<br>

<br>

<h3 id="4-2-5-四次挥手"><a href="#4-2-5-四次挥手" class="headerlink" title="4.2.5 四次挥手"></a>4.2.5 四次挥手</h3><ul>
<li>四次挥手发生在断开连接的时候，在程序中当调用了 close() 会使用TCP协议进行四次挥手。 </li>
<li>客户端和服务器端都可以主动发起断开连接，<strong>谁先调用 close() 谁就是发起</strong>。 </li>
<li>因为在TCP连接的时候，采用三次握手建立的的<strong>连接是双向</strong>的，在断开的时候需要<strong>双向断开</strong>。</li>
</ul>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230215010511553.png" alt="image-20230215010511553"></p>
<br>

<img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230215010632884.png" alt="image-20230215010632884" style="zoom:80%;">



<blockquote>
<p>ack &#x3D; 客户端的序号 + 数据长度 + SYN&#x2F;FIN(按一个字节算)</p>
</blockquote>
<br>

<br>

<br>

<br>

<h3 id="4-2-6-TCP状态转换"><a href="#4-2-6-TCP状态转换" class="headerlink" title="4.2.6 TCP状态转换"></a>4.2.6 TCP状态转换</h3><p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230215160143516.png" alt="image-20230215160143516"></p>
<br>

<br>

<p><strong>三次握手</strong></p>
<ul>
<li>客户端 SYN_SENT （发送 SYN ）</li>
<li>服务端 LISTEN -&gt; SYN_RCVD (接收并发送 SYN 和 ACK 回应)</li>
<li>客户端 ESTABLISHED （接收并发送 ACK ）</li>
<li>服务端 ESTABLISHED （接收）</li>
</ul>
<p><strong>数据传输</strong></p>
<ul>
<li>读写</li>
</ul>
<p><strong>四次握手</strong></p>
<ul>
<li>A: FIN_WAIT_1 （发送 FIN ）</li>
<li>B: CLOSE_WAIT （接收并发送 ACK ）</li>
<li>A: FIN_WAIT_2 （接收）</li>
<li>B: LAST_ACK   （发送 FIN ）</li>
<li>A: TIME_WAIT  （接收并发送ACK）</li>
<li>B: （接收）</li>
</ul>
<br>

<br>

<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230215161044162.png" alt="image-20230215161044162"></p>
<ul>
<li>红色当作客户端</li>
<li>绿色虚线当作服务端</li>
<li>黑色是异常</li>
</ul>
<blockquote>
<ul>
<li>四次握手中，前两次握手完成后，中间还可以继续通信一段时间，再去完成第三第四次握手。</li>
<li>TIME_WAIT：最后一次握手（主动方发送ACK）之后，无法立即确定对方是否收到ACK，所以要等待一段时间（<strong>两倍报文段寿命</strong>）来确定（如果对方收到了ACK就不会重发FIN）</li>
<li>2MSL 两倍报文段寿命：主动断开连接的一方, 最后进入一个 TIME_WAIT 状态, 这个状态会持续: 2msl。官方建议: 2分钟, 实际是30s</li>
</ul>
</blockquote>
<br>

<br>

<br>

<br>

<h2 id="4-3-并发服务器"><a href="#4-3-并发服务器" class="headerlink" title="4.3 并发服务器"></a>4.3 并发服务器</h2><h3 id="多进程实现"><a href="#多进程实现" class="headerlink" title="多进程实现"></a>多进程实现</h3><blockquote>
<p>要实现TCP通信服务器处理并发的任务，使用多线程或者多进程来解决。 </p>
<p>思路： </p>
<ol>
<li>一个父进程，多个子进程 </li>
<li>父进程负责等待并接受客户端的连接 </li>
<li>子进程：完成通信，接受一个客户端连接，就创建一个子进程用于通信。</li>
</ol>
</blockquote>
<br>

<h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><p>注意看注释</p>
<p><strong>子进程处理数据收发</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">// 不断循环等待客户端连接</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">        <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">        <span class="comment">// 接受连接</span></span><br><span class="line">        <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;len);</span><br><span class="line">        <span class="keyword">if</span>(cfd == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">==================================================================</span><br><span class="line">        <span class="comment">// 每一个连接进来，创建一个子进程跟客户端通信</span></span><br><span class="line">        <span class="type">pid_t</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 子进程</span></span><br><span class="line">            <span class="comment">// 获取客户端的信息</span></span><br><span class="line">            <span class="type">char</span> cliIp[<span class="number">16</span>];</span><br><span class="line">            inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, cliIp, <span class="keyword">sizeof</span>(cliIp));</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">short</span> cliPort = ntohs(cliaddr.sin_port);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client ip is : %s, prot is %d\n&quot;</span>, cliIp, cliPort);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 接收客户端发来的数据</span></span><br><span class="line">            <span class="type">char</span> recvBuf[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">int</span> len = read(cfd, &amp;recvBuf, <span class="keyword">sizeof</span>(recvBuf));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;recv client : %s\n&quot;</span>, recvBuf);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client closed....\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 回声服务器</span></span><br><span class="line">                write(cfd, recvBuf, <span class="built_in">strlen</span>(recvBuf) + <span class="number">1</span>);  <span class="comment">// 加1的目的是加上结束符</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            close(cfd);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);    <span class="comment">// 退出当前子进程</span></span><br><span class="line">        &#125;</span><br><span class="line">===================================================================</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<p><strong>利用信号来回收子进程资源</strong></p>
<p>注册信号 ( SIGCHLD )</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">   act.sa_flags = <span class="number">0</span>;</span><br><span class="line">   sigemptyset(&amp;act.sa_mask);</span><br><span class="line">   act.sa_handler = recyleChild;</span><br><span class="line">   <span class="comment">// 注册信号捕捉</span></span><br><span class="line">   sigaction(SIGCHLD, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<p>回调函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">recyleChild</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> ret = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="comment">// 所有的子进程都回收了</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 还有子进程活着</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 被回收了</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;子进程 %d 被回收了\n&quot;</span>, ret);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<br>

<br>

<p><strong>完整</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">recyleChild</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> ret = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="comment">// 所有的子进程都回收了</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 还有子进程活着</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 被回收了</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;子进程 %d 被回收了\n&quot;</span>, ret);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    act.sa_handler = recyleChild;</span><br><span class="line">    <span class="comment">// 注册信号捕捉</span></span><br><span class="line">    sigaction(SIGCHLD, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    <span class="type">int</span> ret = bind(lfd,(<span class="keyword">struct</span> sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不断循环等待客户端连接</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">        <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">        <span class="comment">// 接受连接</span></span><br><span class="line">        <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;len);</span><br><span class="line">        <span class="keyword">if</span>(cfd == <span class="number">-1</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;           <span class="comment">// 子进程的信号引发了软中断后，父进程中的accept会失败并设置错误号 EINTR，这时候不能让父进程（监听连接）退出</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每一个连接进来，创建一个子进程跟客户端通信</span></span><br><span class="line">        <span class="type">pid_t</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 子进程</span></span><br><span class="line">            <span class="comment">// 获取客户端的信息</span></span><br><span class="line">            <span class="type">char</span> cliIp[<span class="number">16</span>];</span><br><span class="line">            inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, cliIp, <span class="keyword">sizeof</span>(cliIp));</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">short</span> cliPort = ntohs(cliaddr.sin_port);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client ip is : %s, prot is %d\n&quot;</span>, cliIp, cliPort);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 接收客户端发来的数据</span></span><br><span class="line">            <span class="type">char</span> recvBuf[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">int</span> len = read(cfd, &amp;recvBuf, <span class="keyword">sizeof</span>(recvBuf));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;recv client : %s\n&quot;</span>, recvBuf);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client closed....\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                write(cfd, recvBuf, <span class="built_in">strlen</span>(recvBuf) + <span class="number">1</span>);  <span class="comment">// 加1的目的是加上结束符</span></span><br><span class="line">            &#125;</span><br><span class="line">            close(cfd);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);    <span class="comment">// 退出当前子进程</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<br>

<p><br><br></p>
<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TCP通信的客户端</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建套接字</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.连接服务器端</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span>;</span></span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;192.168.193.128&quot;</span>, &amp;serveraddr.sin_addr.s_addr);</span><br><span class="line">    serveraddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    <span class="type">int</span> ret = connect(fd, (<span class="keyword">struct</span> sockaddr *)&amp;serveraddr, <span class="keyword">sizeof</span>(serveraddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 通信</span></span><br><span class="line">    <span class="type">char</span> recvBuf[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">sprintf</span>(recvBuf, <span class="string">&quot;data : %d\n&quot;</span>, i++);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 给服务器端发送数据</span></span><br><span class="line">        write(fd, recvBuf, <span class="built_in">strlen</span>(recvBuf)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> len = read(fd, recvBuf, <span class="keyword">sizeof</span>(recvBuf));</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv server : %s\n&quot;</span>, recvBuf);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 表示服务器端断开连接</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;server closed...&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭连接</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<p><strong>注意</strong>：</p>
<p>如果客户端或者服务端进程提前终止，没有调用close(fd)，那么后续的数据传输会引发错误</p>
<p>比如</p>
<br>

<br>

<br>

<br>

<h3 id="多线程实现"><a href="#多线程实现" class="headerlink" title="多线程实现"></a>多线程实现</h3><p><strong>服务端</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockInfo</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> fd; <span class="comment">// 通信的文件描述符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;  <span class="comment">// 线程号</span></span><br><span class="line">    <span class="type">int</span> pos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockInfo</span> <span class="title">sockinfos</span>[128];</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">working</span><span class="params">(<span class="type">void</span> * arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 子线程和客户端通信   cfd 客户端的信息 线程号</span></span><br><span class="line">    <span class="comment">// 获取客户端的信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockInfo</span> * <span class="title">pinfo</span> =</span> (<span class="keyword">struct</span> sockInfo *)arg;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> cliIp[<span class="number">16</span>];</span><br><span class="line">    inet_ntop(AF_INET, &amp;pinfo-&gt;addr.sin_addr.s_addr, cliIp, <span class="keyword">sizeof</span>(cliIp));</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> cliPort = ntohs(pinfo-&gt;addr.sin_port);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client ip is : %s, prot is %d\n&quot;</span>, cliIp, cliPort);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收客户端发来的数据</span></span><br><span class="line">    <span class="type">char</span> recvBuf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> len = read(pinfo-&gt;fd, &amp;recvBuf, <span class="keyword">sizeof</span>(recvBuf));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv client : %s\n&quot;</span>, recvBuf);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client closed....\n&quot;</span>);</span><br><span class="line">            sockinfos[pinfo-&gt;pos].fd = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        write(pinfo-&gt;fd, recvBuf, <span class="built_in">strlen</span>(recvBuf) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(pinfo-&gt;fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    <span class="type">int</span> ret = bind(lfd,(<span class="keyword">struct</span> sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化数据</span></span><br><span class="line">    <span class="type">int</span> max = <span class="keyword">sizeof</span>(sockinfos) / <span class="keyword">sizeof</span>(sockinfos[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">        bzero(&amp;sockinfos[i], <span class="keyword">sizeof</span>(sockinfos[i]));</span><br><span class="line">        sockinfos[i].fd = <span class="number">-1</span>;</span><br><span class="line">        sockinfos[i].tid = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环等待客户端连接，一旦一个客户端连接进来，就创建一个子线程进行通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">        <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">        <span class="comment">// 接受连接</span></span><br><span class="line">        <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;len);</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockInfo</span> * <span class="title">pinfo</span>;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">            <span class="comment">// 从这个数组中找到一个可以用的sockInfo元素</span></span><br><span class="line">            <span class="keyword">if</span>(sockinfos[i].fd == <span class="number">-1</span>) &#123;</span><br><span class="line">                pinfo = &amp;sockinfos[i];</span><br><span class="line">                pinfo-&gt;pos = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i == max - <span class="number">1</span>) &#123;</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">                i = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pinfo-&gt;fd = cfd;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;pinfo-&gt;addr, &amp;cliaddr, len);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建子线程</span></span><br><span class="line">        pthread_create(&amp;pinfo-&gt;tid, <span class="literal">NULL</span>, working, pinfo);</span><br><span class="line"></span><br><span class="line">        pthread_detach(pinfo-&gt;tid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<br>

<p><br><br></p>
<br>

<br>

<p><br><br></p>
<br>

<br>

<h2 id="4-4-复用"><a href="#4-4-复用" class="headerlink" title="4.4 复用"></a>4.4 复用</h2><h3 id="4-4-1-半关闭、端口复用、IO多路复用"><a href="#4-4-1-半关闭、端口复用、IO多路复用" class="headerlink" title="4.4.1 半关闭、端口复用、IO多路复用"></a>4.4.1 半关闭、端口复用、IO多路复用</h3><h4 id="半关闭"><a href="#半关闭" class="headerlink" title="半关闭"></a>半关闭</h4><ul>
<li><strong>主动关闭方</strong> 从发送 FIN 并收到 ACK 后，到收到对方的 FIN 之前，处于 <strong>半关闭</strong> 状态。</li>
<li>此时还可以接收对方发送的数据，但不能够再向对方发送数据。</li>
</ul>
<br>

<p>半关闭不使用 close 实现，而是使用 shutdown ：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shutdown</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> how)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//	sockfd: 需要关闭的socket的描述符</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//	how: 允许为shutdown操作选择以下几种方式:</span></span><br><span class="line"><span class="comment">//		- SHUT_RD(0): 关闭sockfd上的 读 功能，此选项将不允许sockfd进行读操作。该套接字不再接收数据，任何当前在套接字接受缓冲区的数据将被无声的丢弃掉。</span></span><br><span class="line"><span class="comment">//		- SHUT_WR(1): 关闭sockfd的 写 功能，此选项将不允许sockfd进行写操作。进程不能对此套接字发出写操作。</span></span><br><span class="line"><span class="comment">//		- SHUT_RDWR(2): 关闭sockfd的读写功能。相当于调用shutdown两次：首先是以SHUT_RD,然后以SHUT_WR。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>close 中止一个连接，但它只是<strong>减少描述符的引用计数</strong>，并不直接关闭连接，只有<strong>当描述符的引用计数为 0 时才关闭连接</strong>。</li>
<li>shutdown 不考虑描述符的引用计数，<strong>直接关闭描述符</strong>。也<strong>可选择中止一个方向的连接</strong>，只中止读或只中止写。</li>
</ul>
<blockquote>
<p><strong>注意:</strong></p>
<ul>
<li>如果有多个进程共享一个套接字，close 每被调用一次，计数减 1 ，直到计数为 0 时，也就是所用进程都调用了 close，套接字将被释放。</li>
<li>在多进程中如果一个进程调用了 shutdown(sfd, SHUT_RDWR) 后，其它的进程将无法进行通信。<u>但如果一个进程 close(sfd) 将不会影响到其它进程。</u></li>
</ul>
</blockquote>
<br>

<br>

<h4 id="端口复用"><a href="#端口复用" class="headerlink" title="端口复用"></a>端口复用</h4><p>最常用的用途:</p>
<ul>
<li>防止服务器重启时之前绑定的端口还未释放</li>
<li>程序突然退出而系统没有释放端口</li>
</ul>
<blockquote>
<p>常看网络相关信息的命令:<code>netstat</code><br>参数：<br>    -a 所有的socket<br>    -p 显示正在使用socket的程序的名称<br>    -n 直接使用IP地址，而不通过域名服务器</p>
<p>​	…</p>
</blockquote>
<br>

<p><strong>setsockopt函数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置套接字的属性（不仅仅能设置端口复用）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">const</span> <span class="type">void</span> *optval, <span class="type">socklen_t</span> optlen)</span>;</span><br><span class="line">	参数（在UNP（Unix网络编程）书籍中使用）：</span><br><span class="line">		- sockfd : 要操作的文件描述符</span><br><span class="line">		- level : 级别 SOL_SOCKET (使用端口复用的级别)</span><br><span class="line">		- optname : 选项的名称</span><br><span class="line">			- SO_REUSEADDR	IP重用</span><br><span class="line">			- SO_REUSEPORT	端口复用</span><br><span class="line">		- optval : 端口复用的值（整型）</span><br><span class="line">			- <span class="number">1</span> : 可以复用</span><br><span class="line">			- <span class="number">0</span> : 不可以复用</span><br><span class="line">		- optlen : optval参数的大小</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line"><span class="comment">// 端口复用，设置的时机是在服务器绑定端口之前</span></span><br><span class="line">	setsockopt();</span><br><span class="line"></span><br><span class="line">	bind();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<br>

<h4 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h4><p>又称 <strong>IO多路转接</strong></p>
<ul>
<li>不是传统意义上的文件IO，而是对套接字读写缓冲区的IO管理</li>
<li>I&#x2F;O 多路复用使得程序能 <strong>同时监听多个文件描述符</strong> ，能够提高程序的性能，Linux 下实现 I&#x2F;O 多路复用的系统调用主要有 <strong>select、poll 和 epoll</strong>。</li>
</ul>
<br>

<p><strong>等待模型</strong></p>
<ol>
<li><strong>阻塞等待</strong>（阻塞IO模型即 <strong>BIO模型</strong> ）</li>
</ol>
<p>优点：不占用CPU宝贵的时间片</p>
<p>缺点：<br>    同一时刻只能处理一个操作，效率低（单进程&#x2F;单线程）<br>    线程或进程的创建消耗系统资源，调度消耗CPU资源（多线程&#x2F;多进程）</p>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230215175146862.png" alt="image-20230215175146862"></p>
<br>

<ol start="2">
<li><strong>非阻塞</strong>，<strong>忙轮询</strong>（非阻塞模型即 <strong>NIO模型</strong> ）</li>
</ol>
<p>优点：提高了程序的执行效率</p>
<p>缺点：占有更多的CPU和系统资源</p>
<p>使用 <strong>IO多路复用</strong>（select，poll，epoll） 来解决这里的缺点,</p>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230215175852729.png" alt="image-20230215175852729"></p>
<br>

<br>

<ul>
<li>第一种IO多路复用技术（select&#x2F;poll）<br><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230215180146018.png" alt="image-20230215180146018"></li>
<li>第二种IO多路复用技术（epoll）<br><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230215180630626.png" alt="image-20230215180630626"></li>
</ul>
<br>

<br>

<br>

<h3 id="4-4-2-Select"><a href="#4-4-2-Select" class="headerlink" title="4.4.2 Select"></a>4.4.2 Select</h3><p><strong>主要思路：</strong></p>
<ol>
<li>首先要构造一个<strong>关于文件描述符的列表</strong>，将要监听的文件描述符添加到该列表中。</li>
<li>调用一个系统函数（即select），<strong>监听该列表中的文件描述符</strong>，<u>直到这些描述符中的一个或者多个进行I&#x2F;O操作时，该函数才返回</u>。<ul>
<li>这个函数是<strong>阻塞的</strong></li>
<li>函数对文件描述符的检测的操作是由<strong>内核完成的</strong></li>
</ul>
</li>
<li>在返回时，它会告诉进程<strong>有多少（哪些）描述符</strong>要进行I&#x2F;O操作。</li>
</ol>
<br>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">fd_set 就是文件描述符的 位集，用 位 来表示各个描述符的状态</span><br><span class="line"><span class="comment">// sizeof(fd_set) = 128个字节 1024位</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 委托内核监听列表中的文件描述符</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span>;</span><br><span class="line">	- 参数：</span><br><span class="line">		- nfds : 委托内核检测的最大文件描述符的值 + <span class="number">1</span></span><br><span class="line">		- readfds : 要检测的文件描述符的读的集合，委托内核检测哪些文件描述符的读的属性</span><br><span class="line">			- 一般检测读操作</span><br><span class="line">			- 对应的是对方发送过来的数据，因为读是被动的接收数据，检测的就是读缓冲区</span><br><span class="line">            - 是一个 传入传出参数</span><br><span class="line">		- writefds : 要检测的文件描述符的写的集合，委托内核检测哪些文件描述符的写的属性</span><br><span class="line">			- 委托内核检测写缓冲区是不是还可以写数据（不满的就可以写）</span><br><span class="line">		- exceptfds : 检测发生异常的文件描述符的集合</span><br><span class="line">		- timeout : 设置的超时时间</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">				<span class="type">long</span> tv_sec; <span class="comment">/* seconds */</span></span><br><span class="line">				<span class="type">long</span> tv_usec; <span class="comment">/* microseconds */</span></span><br><span class="line">			&#125;;</span><br><span class="line">			- <span class="literal">NULL</span> : 永久阻塞，直到检测到了文件描述符有变化</span><br><span class="line">			- tv_sec = <span class="number">0</span> tv_usec = <span class="number">0</span>， 不阻塞</span><br><span class="line">			- tv_sec &gt; <span class="number">0</span> tv_usec &gt; <span class="number">0</span>， 阻塞对应的时间</span><br><span class="line">	- 返回值 :</span><br><span class="line">		- <span class="number">-1</span> : 失败</span><br><span class="line">		- &gt;<span class="number">0</span>(n) : 检测的集合中有n个文件描述符发生了变化</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">对位集合的操作         </span><br><span class="line"><span class="comment">// 将参数文件描述符fd对应的标志位设置为0（clear）</span></span><br><span class="line"><span class="type">void</span> FD_CLR(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将参数文件描述符fd 对应的标志位，设置为1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fd_set一共有1024 bit, 全部初始化为0</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断fd对应的标志位是0还是1， 返回值 ： fd对应的标志位的值，如果是0返回0， 是1返回1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<br>

<br>

<p><strong>Select 工作流程</strong></p>
<img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230215204459693.png" alt="image-20230215204459693" style="zoom: 67%;">



<img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230215204514747.png" alt="image-20230215204514747" style="zoom: 67%;">

<img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230215220639318.png" alt="image-20230215220639318" style="zoom:80%;">

<br>

<p><strong>服务端</strong></p>
<ul>
<li>accept之前先设置好fdset并调用select</li>
<li>如果select检测出数据变动：<ul>
<li>如果是服务端的socketfd有变动，则表示有客户端连接可进行accept</li>
<li>然后再for循环文件描述符列表进行读写处理（如果需要的话）</li>
</ul>
</li>
<li>fdset用到两个，一个用来给select调用，一个用来维护文件描述符列表</li>
<li>注意需要维护一个最大文件描述符</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    bind(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    listen(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个fd_set的集合，存放的是需要检测的文件描述符</span></span><br><span class="line">    fd_set rdset, tmp;	<span class="comment">// tmp用来给内核检测，rdset用来维护存在的文件描述符</span></span><br><span class="line">    FD_ZERO(&amp;rdset);</span><br><span class="line">    FD_SET(lfd, &amp;rdset);  <span class="comment">// select调用前rdset的某位fd为1表示我们希望内核帮我们检测该fd对应的接收缓存。select调用后rdset对应的fd为1表示该接收缓存接收到数据了，为0表示没接收到数据</span></span><br><span class="line">    <span class="type">int</span> maxfd = lfd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        tmp = rdset;  <span class="comment">// 这里要记得</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用select系统函数，让内核帮检测哪些文件描述符有数据</span></span><br><span class="line">        <span class="type">int</span> ret = select(maxfd + <span class="number">1</span>, &amp;tmp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;select&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 说明检测到了有文件描述符的对应的缓冲区的数据发生了改变</span></span><br><span class="line">            <span class="keyword">if</span>(FD_ISSET(lfd, &amp;tmp)) &#123;</span><br><span class="line">                <span class="comment">// 表示有新的客户端连接进来了</span></span><br><span class="line">                <span class="keyword">struct</span> sockaddr_in cliaddr;</span><br><span class="line">                <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">                <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;cliaddr, &amp;len);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将新的文件描述符加入到集合中</span></span><br><span class="line">                FD_SET(cfd, &amp;rdset);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 更新最大的文件描述符</span></span><br><span class="line">                maxfd = maxfd &gt; cfd ? maxfd : cfd;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = lfd + <span class="number">1</span>; i &lt;= maxfd; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(FD_ISSET(i, &amp;tmp)) &#123;</span><br><span class="line">                    <span class="comment">// 说明这个文件描述符对应的客户端发来了数据</span></span><br><span class="line">                    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                    <span class="type">int</span> len = read(i, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                    <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">                        perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;client closed...\n&quot;</span>);</span><br><span class="line">                        close(i);</span><br><span class="line">                        FD_CLR(i, &amp;rdset);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, buf);</span><br><span class="line">                        write(i, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<p><strong>客户端</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> fd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">seraddr</span>;</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;seraddr.sin_addr.s_addr);</span><br><span class="line">    seraddr.sin_family = AF_INET;</span><br><span class="line">    seraddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接服务器</span></span><br><span class="line">    <span class="type">int</span> ret = connect(fd, (<span class="keyword">struct</span> sockaddr *)&amp;seraddr, <span class="keyword">sizeof</span>(seraddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">char</span> sendBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">sprintf</span>(sendBuf, <span class="string">&quot;send data %d&quot;</span>, num++);</span><br><span class="line">        write(fd, sendBuf, <span class="built_in">strlen</span>(sendBuf) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收</span></span><br><span class="line">        <span class="type">int</span> len = read(fd, sendBuf, <span class="keyword">sizeof</span>(sendBuf));</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, sendBuf);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;服务器已经断开连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// sleep(1);</span></span><br><span class="line">        usleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<br>

<br>

<p><strong>Select 的缺点</strong></p>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230215221709493.png" alt="image-20230215221709493"></p>
<br>

<br>

<br>

<h3 id="4-4-3-poll"><a href="#4-4-3-poll" class="headerlink" title="4.4.3 poll"></a>4.4.3 poll</h3><p>select的改进版</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> fd; <span class="comment">/* 委托内核检测的文件描述符 */</span></span><br><span class="line">	<span class="type">short</span> events; <span class="comment">/* 委托内核检测文件描述符的什么事件 */</span></span><br><span class="line">	<span class="type">short</span> revents; <span class="comment">/* 文件描述符实际发生的事件 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">myfd</span>;</span></span><br><span class="line">	myfd.fd = <span class="number">5</span>;</span><br><span class="line">    myfd.events = POLLIN | POLLOUT;  同时委托内核进行读写操作</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span>;</span><br><span class="line">	- 参数：</span><br><span class="line">		- fds : 是一个<span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> 结构体数组，这是一个需要检测的文件描述符的集合</span></span><br><span class="line"><span class="class">		- <span class="title">nfds</span> :</span> 这个是第一个参数数组中最后一个有效元素的下标 + <span class="number">1</span></span><br><span class="line">		- timeout : 阻塞时长</span><br><span class="line">			<span class="number">0</span> : 不阻塞</span><br><span class="line">			<span class="number">-1</span> : 阻塞，当检测到需要检测的文件描述符有变化，解除阻塞</span><br><span class="line">			&gt;<span class="number">0</span> : 阻塞的时长</span><br><span class="line">	- 返回值：</span><br><span class="line">		<span class="number">-1</span> : 失败</span><br><span class="line">		&gt;<span class="number">0</span>（n） : 成功，n表示检测到集合中有n个文件描述符发生变化</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<p>short类型，表示发生事件</p>
<p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230215224613996.png" alt="image-20230215224613996"></p>
<br>

<p><strong>服务端</strong></p>
<ul>
<li><p>在到客户端连接时，在accept之后要在pollfd数组中找一个靠前的位置来记录；</p>
</li>
<li><p>其他的跟select类似。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    bind(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    listen(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化检测的文件描述符数组</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>[1024];</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++) &#123;</span><br><span class="line">        fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">        fds[i].events = POLLIN;</span><br><span class="line">    &#125;</span><br><span class="line">    fds[<span class="number">0</span>].fd = lfd;</span><br><span class="line">    <span class="type">int</span> nfds = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用poll系统函数，让内核帮检测哪些文件描述符有数据</span></span><br><span class="line">        <span class="type">int</span> ret = poll(fds, nfds + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;poll&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 说明检测到了有文件描述符的对应的缓冲区的数据发生了改变</span></span><br><span class="line">            <span class="keyword">if</span>(fds[<span class="number">0</span>].revents &amp; POLLIN) &#123;</span><br><span class="line">                <span class="comment">// 表示有新的客户端连接进来了</span></span><br><span class="line">                <span class="keyword">struct</span> sockaddr_in cliaddr;</span><br><span class="line">                <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">                <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;cliaddr, &amp;len);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将新的文件描述符加入到集合中</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1024</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(fds[i].fd == <span class="number">-1</span>) &#123;</span><br><span class="line">                        fds[i].fd = cfd;</span><br><span class="line">                        fds[i].events = POLLIN;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 更新最大的文件描述符的索引</span></span><br><span class="line">                nfds = nfds &gt; cfd ? nfds : cfd;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">			<span class="comment">// 最大的文件描述符 一定 大于等于它在数组中的下标。</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= nfds; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(fds[i].revents &amp; POLLIN) &#123;</span><br><span class="line">                    <span class="comment">// 说明这个文件描述符对应的客户端发来了数据</span></span><br><span class="line">                    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                    <span class="type">int</span> len = read(fds[i].fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                    <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">                        perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;client closed...\n&quot;</span>);</span><br><span class="line">                        close(fds[i].fd);</span><br><span class="line">                        fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, buf);</span><br><span class="line">                        write(fds[i].fd, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>





<br>

<br>

<br>

<h3 id="4-4-4-epoll"><a href="#4-4-4-epoll" class="headerlink" title="4.4.4 epoll"></a>4.4.4 epoll</h3><p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230215225908336.png" alt="image-20230215225908336"></p>
<ol>
<li>不用从用户态拷贝数据到内核，直接在内核中进行实例化和数据处理</li>
<li>采用了更高效的数据结构<ul>
<li>红黑树：存储所有fd，用来遍历检测哪些发生数据改变</li>
<li>双向链表：存放发生数据改变的fd的就绪列表</li>
</ul>
</li>
</ol>
<br>

<br>

<br>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新的epoll实例。在内核中创建了一个数据，这个数据中有两个比较重要的数据，一个是需要检测的文件描述符的信息（红黑树），还有一个是就绪列表，存放检测到数据发送改变的文件描述符信息（双向链表）。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br><span class="line">	- 参数：</span><br><span class="line">		size : 目前没有意义了。随便写一个数，必须大于<span class="number">0</span></span><br><span class="line">	- 返回值：</span><br><span class="line">		<span class="number">-1</span> : 失败</span><br><span class="line">		&gt; <span class="number">0</span> : 文件描述符，操作epoll实例的fd</span><br><span class="line">         </span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">	<span class="type">uint32_t</span> events; <span class="comment">/* Epoll events */</span></span><br><span class="line">	<span class="type">epoll_data_t</span> data; <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br><span class="line">常见的Epoll检测事件：</span><br><span class="line">	- EPOLLIN</span><br><span class="line">	- EPOLLOUT</span><br><span class="line">	- EPOLLERR</span><br><span class="line">	- EPOLLET  <span class="comment">// 边沿触发</span></span><br><span class="line">  	- ...</span><br><span class="line">    	</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span>	<span class="comment">// 是一个union</span></span><br><span class="line">	<span class="type">void</span> *ptr;</span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	<span class="type">uint32_t</span> u32;</span><br><span class="line">	<span class="type">uint64_t</span> u64;</span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 对epoll实例进行管理：添加文件描述符信息，删除信息，修改信息</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>;</span><br><span class="line">	- 参数：</span><br><span class="line">		- epfd : epoll实例对应的文件描述符</span><br><span class="line">		- op : 要进行什么操作</span><br><span class="line">			EPOLL_CTL_ADD: 添加</span><br><span class="line">			EPOLL_CTL_MOD: 修改</span><br><span class="line">			EPOLL_CTL_DEL: 删除</span><br><span class="line">		- fd : 要检测的文件描述符</span><br><span class="line">		- event : 检测文件描述符什么事情</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line"><span class="comment">// 检测函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br><span class="line">	- 参数：</span><br><span class="line">		- epfd : epoll实例对应的文件描述符</span><br><span class="line">		- events : 传出参数，一个epoll_event数组，保存了发生了变化的文件描述符</span><br><span class="line">		- maxevents : 第二个参数结构体数组的大小</span><br><span class="line">		- timeout : 阻塞时间</span><br><span class="line">			- <span class="number">0</span> : 不阻塞</span><br><span class="line">			- <span class="number">-1</span> : 阻塞，直到检测到fd数据发生变化，解除阻塞</span><br><span class="line">			- &gt; <span class="number">0</span> : 阻塞的时长（毫秒）</span><br><span class="line">	- 返回值：</span><br><span class="line">		- 成功，返回发送变化的文件描述符的个数 &gt; <span class="number">0</span></span><br><span class="line">		- 失败 <span class="number">-1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<br>

<p><strong>服务端</strong></p>
<p>根据监听读还是写事件来编写对应的处理</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    bind(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    listen(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用epoll_create()创建一个epoll实例</span></span><br><span class="line">    <span class="type">int</span> epfd = epoll_create(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将监听的文件描述符相关的检测信息添加到epoll实例中</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epev</span>;</span></span><br><span class="line">    epev.events = EPOLLIN;</span><br><span class="line">    epev.data.fd = lfd;</span><br><span class="line">    epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;epev);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epevs</span>[1024];</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ret = epoll_wait(epfd, epevs, <span class="number">1024</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>, ret);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; ret; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> curfd = epevs[i].data.fd;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(curfd == lfd) &#123;</span><br><span class="line">                <span class="comment">// 监听的文件描述符有数据达到，有客户端连接</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">                <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">                <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;cliaddr, &amp;len);</span><br><span class="line">				</span><br><span class="line">                <span class="comment">// 将客户端文件描述符相关的检测信息添加到epoll实例中</span></span><br><span class="line">                epev.events = EPOLLIN;</span><br><span class="line">                epev.data.fd = cfd;</span><br><span class="line">                epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;epev);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(epevs[i].events &amp; EPOLLOUT) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;   </span><br><span class="line">                <span class="comment">// 有数据到达，需要通信</span></span><br><span class="line">                <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="type">int</span> len = read(curfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client closed...\n&quot;</span>);</span><br><span class="line">                    epoll_ctl(epfd, EPOLL_CTL_DEL, curfd, <span class="literal">NULL</span>);</span><br><span class="line">                    close(curfd);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, buf);</span><br><span class="line">                    write(curfd, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(lfd);</span><br><span class="line">    close(epfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<br>

<h4 id="epoll-两种工作模式"><a href="#epoll-两种工作模式" class="headerlink" title="epoll 两种工作模式"></a>epoll 两种工作模式</h4><br>

<ul>
<li><strong>LT</strong> 模式（<strong>水平触发</strong>）<ul>
<li>假设委托内核检测读事件 -&gt; 检测fd的读缓冲区</li>
<li>读缓冲区有数据 -&gt; epoll检测到了会给用户通知<ul>
<li>用户不读数据，数据会一直在缓冲区，epoll会一直通知</li>
<li>用户只读了一部分数据，epoll会通知</li>
<li>用户读完数据，epoll不通知</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>能否一次读完得看缓冲区大小和每次读取的数量</p>
<blockquote>
<p>LT（level - triggered）是缺省（即默认）的工作方式，并且同时支持 <strong>block 和 no-block socket</strong>。在这种做法中，<strong>内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的 fd 进行 IO 操作</strong>。如果你不作任何操作，<strong>内核还是会继续通知你的</strong>。</p>
</blockquote>
<br>

<ul>
<li><strong>ET</strong> 模式（<strong>边缘触发</strong>）<ul>
<li>假设委托内核检测读事件 -&gt; 检测fd的读缓冲区</li>
<li>读缓冲区有数据 -&gt; epoll 检测到了会给用户通知<ul>
<li>用户不读数据，数据一致在缓冲区中，epoll下次检测时不通知</li>
<li>用户只读了一部分数据，epoll不通知</li>
<li>用户读完数据，epoll不通知</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li><p>ET（edge - triggered）是高速工作方式，<strong>只支持 no-block socket</strong>。</p>
</li>
<li><p>在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，<strong>直到你做了某些操作导致那个文件描述符不再为就绪状态了</strong>。但是请注意，如果一直不对这个 fd 作 IO 操作（从而导致它再次变成未就绪），内核不会发送更多的通知（only once）。</p>
</li>
<li><p>ET 模式在很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。</p>
</li>
<li><p>epoll工作在 ET 模式的时候，必须使用<strong>非阻塞</strong>套接口，<strong>以避免由于一个文件句柄的阻塞读&#x2F;阻塞写操作把处理多个文件描述符的任务饿死。</strong></p>
</li>
</ul>
</blockquote>
<br>

<br>

<p><strong>客户端</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> fd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">seraddr</span>;</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;seraddr.sin_addr.s_addr);</span><br><span class="line">    seraddr.sin_family = AF_INET;</span><br><span class="line">    seraddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接服务器</span></span><br><span class="line">    <span class="type">int</span> ret = connect(fd, (<span class="keyword">struct</span> sockaddr *)&amp;seraddr, <span class="keyword">sizeof</span>(seraddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">char</span> sendBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">// sprintf(sendBuf, &quot;send data %d&quot;, num++);</span></span><br><span class="line">        fgets(sendBuf, <span class="keyword">sizeof</span>(sendBuf), <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">        write(fd, sendBuf, <span class="built_in">strlen</span>(sendBuf) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收</span></span><br><span class="line">        <span class="type">int</span> len = read(fd, sendBuf, <span class="keyword">sizeof</span>(sendBuf));</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, sendBuf);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;服务器已经断开连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<br>

<p><strong>LT 服务端</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    bind(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    listen(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用epoll_create()创建一个epoll实例</span></span><br><span class="line">    <span class="type">int</span> epfd = epoll_create(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将监听的文件描述符相关的检测信息添加到epoll实例中</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epev</span>;</span></span><br><span class="line">    epev.events = EPOLLIN;</span><br><span class="line">    epev.data.fd = lfd;</span><br><span class="line">    epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;epev);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epevs</span>[1024];</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ret = epoll_wait(epfd, epevs, <span class="number">1024</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>, ret);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; ret; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> curfd = epevs[i].data.fd;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(curfd == lfd) &#123;</span><br><span class="line">                <span class="comment">// 监听的文件描述符有数据达到，有客户端连接</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">                <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">                <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;cliaddr, &amp;len);</span><br><span class="line"></span><br><span class="line">                epev.events = EPOLLIN;</span><br><span class="line">                epev.data.fd = cfd;</span><br><span class="line">                epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;epev);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(epevs[i].events &amp; EPOLLOUT) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;   </span><br><span class="line">                <span class="comment">// 有数据到达，需要通信</span></span><br><span class="line">                <span class="type">char</span> buf[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="type">int</span> len = read(curfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client closed...\n&quot;</span>);</span><br><span class="line">                    epoll_ctl(epfd, EPOLL_CTL_DEL, curfd, <span class="literal">NULL</span>);</span><br><span class="line">                    close(curfd);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, buf);</span><br><span class="line">                    write(curfd, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(lfd);</span><br><span class="line">    close(epfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<br>

<br>

<br>

<p><strong>ET 服务端</strong></p>
<ul>
<li>用fctnl设置连接客户端的文件描述符为非阻塞</li>
<li>设置客户端fd的epoll_event为边缘触发模式</li>
<li>读数据的时候用循环来读完</li>
<li>数据读完之后，在非阻塞的条件下，再去read对应的fd会引发<strong>EAGAIN</strong>，需要用条件判断避开</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    bind(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    listen(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用epoll_create()创建一个epoll实例</span></span><br><span class="line">    <span class="type">int</span> epfd = epoll_create(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将监听的文件描述符相关的检测信息添加到epoll实例中</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epev</span>;</span></span><br><span class="line">    epev.events = EPOLLIN;</span><br><span class="line">    epev.data.fd = lfd;</span><br><span class="line">    epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;epev);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epevs</span>[1024];</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ret = epoll_wait(epfd, epevs, <span class="number">1024</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>, ret);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; ret; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> curfd = epevs[i].data.fd;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(curfd == lfd) &#123;</span><br><span class="line">                <span class="comment">// 监听的文件描述符有数据达到，有客户端连接</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">                <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">                <span class="type">int</span> cfd = accept(lf d, (<span class="keyword">struct</span> sockaddr *)&amp;cliaddr, &amp;len);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 设置cfd属性非阻塞</span></span><br><span class="line">                <span class="type">int</span> flag = fcntl(cfd, F_GETFL);</span><br><span class="line">                flag |= O_NONBLOCK;</span><br><span class="line">                fcntl(cfd, F_SETFL, flag);</span><br><span class="line"></span><br><span class="line">                epev.events = EPOLLIN | EPOLLET;    <span class="comment">// 设置边沿触发</span></span><br><span class="line">                epev.data.fd = cfd;</span><br><span class="line">                epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;epev);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(epevs[i].events &amp; EPOLLOUT) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;  </span><br><span class="line"></span><br><span class="line">                <span class="comment">// 循环读取出所有数据</span></span><br><span class="line">                <span class="type">char</span> buf[<span class="number">5</span>];</span><br><span class="line">                <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>( (len = read(curfd, buf, <span class="keyword">sizeof</span>(buf))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 打印数据</span></span><br><span class="line">                    <span class="comment">// printf(&quot;recv data : %s\n&quot;, buf);</span></span><br><span class="line">                    write(STDOUT_FILENO, buf, len);</span><br><span class="line">                    write(curfd, buf, len);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client closed....&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(errno == EAGAIN) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;data over.....&quot;</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(lfd);</span><br><span class="line">    close(epfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<br>

<br>

<br>

<h2 id="4-5-UDP通信"><a href="#4-5-UDP通信" class="headerlink" title="4.5 UDP通信"></a>4.5 UDP通信</h2><h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><p><img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230216011718092.png" alt="image-20230216011718092"></p>
<p><strong>服务端</strong></p>
<ul>
<li>创建socket</li>
<li>绑定ip端口</li>
<li>通信</li>
<li>关闭socket</li>
</ul>
<p><strong>客户端</strong></p>
<ul>
<li>创建socket</li>
<li>通信</li>
<li>关闭socket</li>
</ul>
<br>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line">or</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *dest_addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line">	- 参数：</span><br><span class="line">		- sockfd : 通信的fd</span><br><span class="line">		- buf : 要发送的数据</span><br><span class="line">		- len : 发送数据的长度</span><br><span class="line">		- flags : <span class="number">0</span></span><br><span class="line">		- dest_addr : 传出参数，指定通信的另外一端的地址信息</span><br><span class="line">		- addrlen : 地址的内存大小</span><br><span class="line">           </span><br><span class="line">            </span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags, <span class="keyword">struct</span> sockaddr *src_addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br><span class="line">	- 参数：</span><br><span class="line">		- sockfd : 通信的fd</span><br><span class="line">		- buf : 接收数据的数组</span><br><span class="line">		- len : 数组的大小</span><br><span class="line">    	- flags : <span class="number">0</span></span><br><span class="line">		- src_addr : 传入参数，用来保存另外一端的地址信息，不需要可以指定为<span class="literal">NULL</span></span><br><span class="line">		- addrlen : 地址的内存大小</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<br>

<p><strong>服务端</strong></p>
<p>bind 绑定后不需要监听 listen</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建一个通信的socket</span></span><br><span class="line">    <span class="type">int</span> fd = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.绑定</span></span><br><span class="line">    <span class="type">int</span> ret = bind(fd, (<span class="keyword">struct</span> sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">char</span> recvbuf[<span class="number">128</span>];</span><br><span class="line">        <span class="type">char</span> ipbuf[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">        <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="type">int</span> num = recvfrom(fd, recvbuf, <span class="keyword">sizeof</span>(recvbuf), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;cliaddr, &amp;len);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client IP : %s, Port : %d\n&quot;</span>, </span><br><span class="line">            inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, ipbuf, <span class="keyword">sizeof</span>(ipbuf)),</span><br><span class="line">            ntohs(cliaddr.sin_port));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client say : %s\n&quot;</span>, recvbuf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        sendto(fd, recvbuf, <span class="built_in">strlen</span>(recvbuf) + <span class="number">1</span>, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;cliaddr, <span class="keyword">sizeof</span>(cliaddr));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<br>

<p><strong>客户端</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建一个通信的socket</span></span><br><span class="line">    <span class="type">int</span> fd = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务器的地址信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;saddr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 3.通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        <span class="type">char</span> sendBuf[<span class="number">128</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(sendBuf, <span class="string">&quot;hello , i am client %d \n&quot;</span>, num++);</span><br><span class="line">        sendto(fd, sendBuf, <span class="built_in">strlen</span>(sendBuf) + <span class="number">1</span>, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="type">int</span> num = recvfrom(fd, sendBuf, <span class="keyword">sizeof</span>(sendBuf), <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server say : %s\n&quot;</span>, sendBuf);</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<br>

<br>

<br>

<h3 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h3><p>向 <strong>子网</strong> 中多台计算机发送消息，并且子网中所有的计算机都可以接收到发送方发送的消息，每个广播消息都包含一个特殊的IP地址（<strong>广播地址</strong>），除了子网ip外的主机部分的二进制位都为1。</p>
<ul>
<li>只能在<strong>局域网</strong>中使用。</li>
<li><strong>客户端</strong>需要绑定<strong>服务器广播使用的端口</strong>，才可以接收到广播消息。</li>
</ul>
<br>

<p><strong>服务端</strong></p>
<ul>
<li>用setsockopt设置sockfd的广播属性</li>
<li>然后使用广播地址作为sendto的地址</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.设置广播属性</span></span><br><span class="line"><span class="type">int</span> op = <span class="number">1</span>;</span><br><span class="line">setsockopt(fd, SOL_SOCKET, SO_BROADCAST, &amp;op, <span class="keyword">sizeof</span>(op));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.创建一个广播的地址</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">cliaddr.sin_family = AF_INET;</span><br><span class="line">cliaddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">inet_pton(AF_INET, <span class="string">&quot;192.168.193.255&quot;</span>, &amp;cliaddr.sin_addr.s_addr);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<p><strong>客户端</strong></p>
<ul>
<li>sockfd 需要用 bind 绑定 本地IP和广播的端口</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.客户端绑定本地的IP和端口</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">addr.sin_family = AF_INET;</span><br><span class="line">addr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ret = bind(fd, (<span class="keyword">struct</span> sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<br>

<br>

<br>

<br>

<h3 id="组播-多播"><a href="#组播-多播" class="headerlink" title="组播(多播)"></a>组播(多播)</h3><ul>
<li>单播地址标识单个 IP 接口，广播地址标识某个子网的所有 IP 接口，多播地址标识一组 IP 接口。</li>
<li>单播和广播是寻址方案的两个极端（要么单个要么全部），多播则意在两者之间提供一种折中方案。</li>
<li>多播数据报只应该由对它感兴趣的接口接收，也就是说由<strong>运行相应多播会话应用系统的主机上的接口</strong>接收。</li>
<li>另外，<strong>广播一般局限于局域网内</strong>使用，而多播则既可以用于局域网，也可以跨广域网使用。<ul>
<li><strong>组播</strong>既可以用于<strong>局域网</strong>，也可以用于<strong>广域网</strong></li>
<li><strong>客户端</strong>需要加入<strong>多播组</strong>，才能接收到多播的数据</li>
</ul>
</li>
</ul>
<br>

<br>

<p><strong>组播地址</strong></p>
<p>IP 多播通信必须依赖于 IP 多播地址，在 IPv4 中它的范围从 <strong>224.0.0.0 到 239.255.255.255</strong> ，并被划分为 <strong>局部链接多播地址</strong>、 <strong>预留多播地址</strong> 和 <strong>管理权限多播地址</strong> 三类:</p>
<table>
<thead>
<tr>
<th align="center">IP地址</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">224.0.0.0~224.0.0.255</td>
<td align="center">局部链接多播地址：为路由协议和其他用途保留的地址，路由器并不转发属于此范围的IP包</td>
</tr>
<tr>
<td align="center">224.0.1.0~224.0.1.255</td>
<td align="center">预留多播地址：公用组播地址，可用于Internet；使用前需要申请</td>
</tr>
<tr>
<td align="center">224.0.2.0~238.255.255.255</td>
<td align="center">预留多播地址：用户可用组播地址（临时），全网范围有效</td>
</tr>
<tr>
<td align="center">239.0.0.0~239.255.255.255</td>
<td align="center">本地管理组播地址，可供组织内部使用，类似于私有IP地址，不能用于Internet，可限制多播范围</td>
</tr>
</tbody></table>
<br>

<br>

<p><strong>设置</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname,<span class="type">const</span> <span class="type">void</span> *optval, <span class="type">socklen_t</span> optlen)</span>;</span><br><span class="line">	<span class="comment">// 服务器设置多播的信息，外出接口</span></span><br><span class="line">	- level : IPPROTO_IP</span><br><span class="line">	- optname : IP_MULTICAST_IF</span><br><span class="line">	- optval : <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">	// 客户端加入到多播组：</span></span><br><span class="line"><span class="class">	- <span class="title">level</span> :</span> IPPROTO_IP</span><br><span class="line">	- optname : IP_ADD_MEMBERSHIP</span><br><span class="line">	- optval : <span class="class"><span class="keyword">struct</span> <span class="title">ip_mreq</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">        </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_mreq</span> &#123;</span></span><br><span class="line">	<span class="comment">/* IP multicast address of group. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">imr_multiaddr</span>;</span> <span class="comment">// 组播的IP地址</span></span><br><span class="line">	<span class="comment">/* Local IP address of interface. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">imr_interface</span>;</span> <span class="comment">// 本地的IP地址</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">	<span class="type">in_addr_t</span> s_addr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">in_addr_t</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<p><strong>服务端</strong></p>
<ul>
<li>setsockopt 设置 IPPROTO_IP 级别的 IP_MULTICAST_IF，传入组播的外出接口</li>
<li>将外出接口作为客户端地址信息，作为 sendto 指定的地址</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 2.设置多播的属性，设置外出接口</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">imr_multiaddr</span>;</span></span><br><span class="line"><span class="comment">// 初始化多播地址</span></span><br><span class="line">inet_pton(AF_INET, <span class="string">&quot;239.0.0.10&quot;</span>, &amp;imr_multiaddr.s_addr);</span><br><span class="line">setsockopt(fd, IPPROTO_IP, IP_MULTICAST_IF, &amp;imr_multiaddr, <span class="keyword">sizeof</span>(imr_multiaddr));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.初始化客户端的地址信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">cliaddr.sin_family = AF_INET;</span><br><span class="line">cliaddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">inet_pton(AF_INET, <span class="string">&quot;239.0.0.10&quot;</span>, &amp;cliaddr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通信</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<br>

<p><strong>客户端</strong></p>
<ul>
<li>bind 绑定端口</li>
<li>指定ip_mreq结构体中的本地地址和组播地址</li>
<li>setsockopt设置 IPPROTO_IP 级别的 IP_ADD_MEMBERSHIP ，传入上面（指定地址）的结构体</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">// 2.客户端绑定本地的IP和端口</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">   addr.sin_family = AF_INET;</span><br><span class="line">   addr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">   addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> ret = bind(fd, (<span class="keyword">struct</span> sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">   <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">       perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">       <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加入到多播组</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">ip_mreq</span> <span class="title">op</span>;</span></span><br><span class="line">   inet_pton(AF_INET, <span class="string">&quot;239.0.0.10&quot;</span>, &amp;op.imr_multiaddr.s_addr);</span><br><span class="line">   op.imr_interface.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">   setsockopt(fd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;op, <span class="keyword">sizeof</span>(op));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 3.通信</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<br>

<br>

<br>

<p><br><br></p>
<h2 id="4-6-本地套接字通信"><a href="#4-6-本地套接字通信" class="headerlink" title="4.6 本地套接字通信"></a>4.6 本地套接字通信</h2><p>本地套接字的作用：<strong>本地的进程间通信</strong></p>
<p>（本地套接字实现流程和网络套接字类似，一般采用 <strong>TCP 的通信流程</strong>）</p>
<ul>
<li><strong>有关系</strong>的进程间的通信</li>
<li><strong>没有关系</strong>的进程间的通信</li>
</ul>
<br>

<br>

<p><strong>struct sockaddr_un</strong></p>
<img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230216033138989.png" alt="image-20230216033138989" style="zoom:67%;">

<h3 id="通信流程"><a href="#通信流程" class="headerlink" title="通信流程"></a>通信流程</h3><p>本地套接字通信的流程 - tcp</p>
<img src="/2023/02/16/%E7%AC%AC%E5%9B%9B%E7%AB%A0Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20230216033448663.png" alt="image-20230216033448663" style="zoom:80%;">

<p><strong>服务器端</strong></p>
<ol>
<li>创建监听的套接字</li>
</ol>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> lfd = socket(AF_UNIX/AF_LOCAL, SOCK_STREAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>监听的套接字 绑定 <strong>本地的套接字文件</strong> -&gt; server端</li>
</ol>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">addr</span>;</span></span><br><span class="line"><span class="comment">// 绑定成功之后，指定的sun_path中的套接字文件会自动生成。</span></span><br><span class="line"></span><br><span class="line">bind(lfd, addr, len);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>监听</li>
</ol>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">listen(lfd, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>等待并接受连接请求</li>
</ol>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">cliaddr</span>;</span></span><br><span class="line"><span class="type">int</span> cfd = accept(lfd, &amp;cliaddr, len);</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>通信<br> 接收数据：read&#x2F;recv<br> 发送数据：write&#x2F;send</p>
</li>
<li><p>关闭连接<br>close();</p>
</li>
</ol>
<br>

<p><strong>客户端</strong></p>
<ol>
<li>创建通信的套接字</li>
</ol>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> fd = socket(AF_UNIX/AF_LOCAL, SOCK_STREAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>监听的套接字绑定本地的IP,端口</li>
</ol>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">addr</span>;</span></span><br><span class="line"><span class="comment">// 绑定成功之后，指定的sun_path中的套接字文件会自动生成。</span></span><br><span class="line"></span><br><span class="line">bind(lfd, addr, len);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>连接服务器</li>
</ol>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">serveraddr</span>;</span></span><br><span class="line"></span><br><span class="line">connect(fd, &amp;serveraddr, <span class="keyword">sizeof</span>(serveraddr));</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>通信<br> 接收数据：read&#x2F;recv<br> 发送数据：write&#x2F;send</p>
</li>
<li><p>关闭连接<br>close();</p>
</li>
</ol>
<br>

<br>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 头文件: sys/un.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNIX_PATH_MAX 108</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> &#123;</span></span><br><span class="line">	<span class="type">sa_family_t</span> sun_family; <span class="comment">// 地址族协议 af_local</span></span><br><span class="line">	<span class="type">char</span> sun_path[UNIX_PATH_MAX]; <span class="comment">// 套接字文件的路径, 这是一个伪文件, 大小永远=0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>

<br>

<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>注意使用 <strong>strcpy</strong> 来设置 sockaddr_un 结构体中的 <strong>sun_path</strong> 的内容</p>
<p><strong>服务端</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    unlink(<span class="string">&quot;server.sock&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建监听的套接字</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_LOCAL, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.绑定本地套接字文件</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sun_family = AF_LOCAL;</span><br><span class="line">    <span class="built_in">strcpy</span>(addr.sun_path, <span class="string">&quot;server.sock&quot;</span>);</span><br><span class="line">    <span class="type">int</span> ret = bind(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.等待客户端连接</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;cliaddr, &amp;len);</span><br><span class="line">    <span class="keyword">if</span>(cfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client socket filename: %s\n&quot;</span>, cliaddr.sun_path);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">        <span class="type">int</span> len = recv(cfd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client closed....\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client say : %s\n&quot;</span>, buf);</span><br><span class="line">            send(cfd, buf, len, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(cfd);</span><br><span class="line">    close(lfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<br>

<br>

<p><strong>客户端</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    unlink(<span class="string">&quot;client.sock&quot;</span>);	</span><br><span class="line">    <span class="comment">// 删除参数pathname 指定的文件. </span></span><br><span class="line">    <span class="comment">// 如果该文件名为最后连接点, 但有其他进程打开了此文件, 则在所有关于此文件的文件描述词皆关闭后才会删除. </span></span><br><span class="line">    <span class="comment">// 如果参数pathname 为一符号连接, 则此连接会被删除。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建套接字</span></span><br><span class="line">    <span class="type">int</span> cfd = socket(AF_LOCAL, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(cfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.绑定本地套接字文件</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sun_family = AF_LOCAL;</span><br><span class="line">    <span class="built_in">strcpy</span>(addr.sun_path, <span class="string">&quot;client.sock&quot;</span>);</span><br><span class="line">    <span class="type">int</span> ret = bind(cfd, (<span class="keyword">struct</span> sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.连接服务器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">seraddr</span>;</span></span><br><span class="line">    seraddr.sun_family = AF_LOCAL;</span><br><span class="line">    <span class="built_in">strcpy</span>(seraddr.sun_path, <span class="string">&quot;server.sock&quot;</span>);</span><br><span class="line">    ret = connect(cfd, (<span class="keyword">struct</span> sockaddr *)&amp;seraddr, <span class="keyword">sizeof</span>(seraddr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.通信</span></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;hello, i am client %d\n&quot;</span>, num++);</span><br><span class="line">        send(cfd, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client say : %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="type">int</span> len = recv(cfd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;server closed....\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;server say : %s\n&quot;</span>, buf);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(cfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<br>

<br>

]]></content>
      <categories>
        <category>C++开发</category>
        <category>高性能服务器项目</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>LearnOpenGL摘要（入门四）</title>
    <url>/2024/04/06/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    <content><![CDATA[<h1 id="模型加载"><a href="#模型加载" class="headerlink" title="模型加载"></a>模型加载</h1><p>模型通常都由3D艺术家在<a href="http://www.blender.org/">Blender</a>、<a href="http://www.autodesk.nl/products/3ds-max/overview">3DS Max</a>或者<a href="http://www.autodesk.com/products/autodesk-maya/overview">Maya</a>这样的工具中精心制作。</p>
<p>这些所谓的3D建模工具(3D Modeling Tool)可以让艺术家创建复杂的形状，并使用一种叫做UV映射(uv-mapping)的手段来应用贴图。</p>
<p>我们想要的是将这些模型(Model)<strong>导入</strong>(Import)到程序当中。</p>
<p>模型格式：.obj, XML等</p>
<span id="more"></span>



<h2 id="一、Assimp"><a href="#一、Assimp" class="headerlink" title="一、Assimp"></a>一、Assimp</h2><h3 id="模型加载库"><a href="#模型加载库" class="headerlink" title="模型加载库"></a>模型加载库</h3><p>一个非常流行的模型导入库是<a href="http://assimp.org/">Assimp</a>，开放的资产导入库（Open Asset Import Library）。</p>
<p>Assimp能够导入很多种不同的模型文件格式（并也能够导出部分的格式），它会将所有的模型数据加载至Assimp的通用数据结构中。</p>
<p>当Assimp加载完模型之后，我们就能够从Assimp的数据结构中提取我们所需的所有数据了。</p>
<p>当使用Assimp导入一个模型的时候，它通常会将整个模型加载进一个<strong>场景</strong>(Scene)对象，它会包含导入的模型&#x2F;场景中的所有数据。</p>
<p>Assimp会将场景载入为一系列的节点(Node)，每个节点包含了场景对象中所储存数据的索引，每个节点都可以有任意数量的子节点。</p>
<p>Assimp数据结构的（简化）模型如下：</p>
<p><img src="/2024/04/06/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%9B%9B%EF%BC%89/image-20240406155238130.png" alt="image-20240406155238130"></p>
<ul>
<li>和材质和网格(Mesh)一样，所有的场景&#x2F;模型数据都包含在Scene对象中。Scene对象也包含了场景根节点的引用。</li>
<li>场景的Root node（根节点）可能包含子节点（和其它的节点一样），它会有一系列指向场景对象中mMeshes数组中储存的网格数据的索引。Scene下的mMeshes数组储存了真正的Mesh对象，节点中的mMeshes数组保存的只是场景中网格数组的索引。</li>
<li>一个Mesh对象本身包含了渲染所需要的所有相关数据，像是顶点位置、法向量、纹理坐标、面(Face)和物体的材质。</li>
<li>一个网格包含了多个面。Face代表的是物体的渲染图元(Primitive)（三角形、方形、点）。一个面包含了组成图元的顶点的索引。由于顶点和索引是分开的，使用一个索引缓冲来渲染是非常简单的（见[你好，三角形](<a href="https://learnopengl-cn.github.io/01">https://learnopengl-cn.github.io/01</a> Getting started&#x2F;04 Hello Triangle&#x2F;)）。</li>
<li>最后，一个网格也包含了一个Material对象，它包含了一些函数能让我们获取物体的材质属性，比如说颜色和纹理贴图（比如漫反射和镜面光贴图）。</li>
</ul>
<p>所以，我们需要做的第一件事是将一个物体加载到Scene对象中，遍历节点，获取对应的Mesh对象（我们需要递归搜索每个节点的子节点），并处理每个Mesh对象来获取顶点数据、索引以及它的材质属性。</p>
<p>最终的结果是一系列的网格数据，我们会将它们包含在一个<code>Model</code>对象中。</p>
<blockquote>
<p><strong>网格</strong></p>
<p>当使用建模工具对物体建模的时候，艺术家通常不会用单个形状创建出整个模型。通常每个模型都由几个子模型&#x2F;形状组合而成。</p>
<p>组合模型的每个单独的形状就叫做一个网格(Mesh)。</p>
<p>比如说有一个人形的角色：艺术家通常会将头部、四肢、衣服、武器建模为分开的组件，并将这些网格组合而成的结果表现为最终的模型。</p>
<p>一个网格是我们在OpenGL中绘制物体所需的最小单位（顶点数据、索引和材质属性）。一个模型（通常）会包括多个网格。</p>
</blockquote>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>链接这个库的时候，我是把assimp.dll直接放在项目的程序生成所在的目录。</p>
<p><img src="/2024/04/06/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%9B%9B%EF%BC%89/image-20240406225812845.png" alt="image-20240406225812845"></p>
<p>而附加依赖项中只放assimp.lib</p>
<p><img src="/2024/04/06/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%9B%9B%EF%BC%89/image-20240406230206535.png" alt="image-20240406230206535"></p>
<p>放在自己指定的目录的时候总是用不了</p>
<ul>
<li>在VS的附加依赖项中加入assimp.dll时，链接的时候就会报错<code>LINK1107：无法读取assimp.dll的0x300地址处</code></li>
<li>不加的话，程序启动后又会提示找不到dll。</li>
</ul>
<h2 id="二、网格"><a href="#二、网格" class="headerlink" title="二、网格"></a>二、网格</h2><p>通过使用Assimp，我们可以加载不同的模型到程序中，但是载入后它们都被储存为Assimp的数据结构。我们最终仍要将这些数据转换为OpenGL能够理解的格式，这样才能渲染这个物体</p>
<p>网格(Mesh)代表的是单个的可绘制实体，我们现在先来定义一个我们自己的网格类。</p>
<h3 id="网格类"><a href="#网格类" class="headerlink" title="网格类"></a>网格类</h3><p>一个网格应该至少需要：</p>
<ul>
<li>一系列的顶点<ul>
<li>每个顶点包含一个位置向量、一个法向量和一个纹理坐标向量</li>
</ul>
</li>
<li>用于索引绘制的索引</li>
<li>纹理形式的材质数据（漫反射&#x2F;镜面光贴图）</li>
</ul>
<h4 id="类结构"><a href="#类结构" class="headerlink" title="类结构"></a>类结构</h4><p><strong>顶点类</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vertex</span> &#123;</span><br><span class="line">    glm::vec3 Position;</span><br><span class="line">    glm::vec3 Normal;</span><br><span class="line">    glm::vec2 TexCoords;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>纹理类</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Texture</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> id;</span><br><span class="line">    string type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>网格类</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mesh</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">/*  网格数据  */</span></span><br><span class="line">        vector&lt;Vertex&gt; vertices;</span><br><span class="line">        vector&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt; indices;</span><br><span class="line">        vector&lt;Texture&gt; textures;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/*  函数  */</span></span><br><span class="line">        <span class="built_in">Mesh</span>(vector&lt;Vertex&gt; vertices, vector&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt; indices, vector&lt;Texture&gt; textures);</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Draw</span><span class="params">(Shader shader)</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">/*  渲染数据  */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> VAO, VBO, EBO;</span><br><span class="line">        <span class="comment">/*  函数  */</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">setupMesh</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>





<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p><strong>构造函数</strong></p>
<ul>
<li>设置 顶点、索引、纹理数据</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Mesh</span>(vector&lt;Vertex&gt; vertices, vector&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt; indices, vector&lt;Texture&gt; textures)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;vertices = vertices;</span><br><span class="line">    <span class="keyword">this</span>-&gt;indices = indices;</span><br><span class="line">    <span class="keyword">this</span>-&gt;textures = textures;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setupMesh</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>初始化函数</strong></p>
<ul>
<li>创建顶点数组、顶点缓冲、索引缓冲对象</li>
<li>绑定和配置顶点缓冲对象的数据</li>
<li>设置顶点属性指针</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setupMesh</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建</span></span><br><span class="line">    <span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">    <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;EBO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定VAO，VBO</span></span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置顶点缓冲的顶点数据（我们用 Vertex 结构体存储一个顶点的数据，并且一个顶点结构体中的不同属性的数据在内存中是连续的）</span></span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, vertices.<span class="built_in">size</span>() * <span class="built_in">sizeof</span>(Vertex), &amp;vertices[<span class="number">0</span>], GL_STATIC_DRAW);  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定索引/元素缓冲 设置索引数据</span></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, indices.<span class="built_in">size</span>() * <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>), </span><br><span class="line">                 &amp;indices[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 顶点属性指针设置</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 顶点位置</span></span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);   </span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="built_in">sizeof</span>(Vertex), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 顶点法线</span></span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">1</span>);   </span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="built_in">sizeof</span>(Vertex), (<span class="type">void</span>*)<span class="built_in">offsetof</span>(Vertex, Normal));</span><br><span class="line">    <span class="comment">// 顶点纹理坐标</span></span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">2</span>);   </span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">2</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="built_in">sizeof</span>(Vertex), (<span class="type">void</span>*)<span class="built_in">offsetof</span>(Vertex, TexCoords));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解绑VAO</span></span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>



<blockquote>
<p>用结构体组织数据</p>
<ul>
<li><p>结构体中的不同属性的数据在内存中是连续的</p>
</li>
<li><p>预处理指令<code>offsetof(s, m)</code>，它的第一个参数是一个结构体，第二个参数是这个结构体中变量的名字。</p>
<ul>
<li><p>这个宏会返回那个变量距结构体头部的字节偏移量(Byte Offset)。这正好可以用在定义glVertexAttribPointer函数中的偏移参数（最后一个）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="built_in">sizeof</span>(Vertex), (<span class="type">void</span>*)<span class="built_in">offsetof</span>(Vertex, Normal)); </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>渲染</strong></p>
<ul>
<li>先绑定相应的纹理<ul>
<li>统一 uniform 纹理变量的命名规则：<ul>
<li>每个漫反射纹理被命名为<code>texture_diffuseN</code></li>
<li>每个镜面光纹理应该被命名为<code>texture_specularN</code></li>
</ul>
</li>
</ul>
</li>
<li>调用<code>glDrawElements</code>函数绘制</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Draw</span><span class="params">(Shader shader)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> diffuseNr = <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> specularNr = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; textures.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glActiveTexture</span>(GL_TEXTURE0 + i); <span class="comment">// 在绑定之前激活相应的纹理单元</span></span><br><span class="line">        <span class="comment">// 获取纹理序号（diffuse_textureN 中的 N）</span></span><br><span class="line">        string number;</span><br><span class="line">        string name = textures[i].type;</span><br><span class="line">        <span class="keyword">if</span>(name == <span class="string">&quot;texture_diffuse&quot;</span>)</span><br><span class="line">            number = std::<span class="built_in">to_string</span>(diffuseNr++);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(name == <span class="string">&quot;texture_specular&quot;</span>)</span><br><span class="line">            number = std::<span class="built_in">to_string</span>(specularNr++);</span><br><span class="line"></span><br><span class="line">        shader.<span class="built_in">setInt</span>((<span class="string">&quot;material.&quot;</span> + name + number).<span class="built_in">c_str</span>(), i);</span><br><span class="line">        <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, textures[i].id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">glActiveTexture</span>(GL_TEXTURE0);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制网格</span></span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line">    <span class="built_in">glDrawElements</span>(GL_TRIANGLES, indices.<span class="built_in">size</span>(), GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="三、模型"><a href="#三、模型" class="headerlink" title="三、模型"></a>三、模型</h2><h3 id="模型类"><a href="#模型类" class="headerlink" title="模型类"></a>模型类</h3><ul>
<li>数据成员：<ul>
<li>一组网格的数据</li>
<li>模型文件所在目录（我们假定把模型文件、纹理贴图都放在同一目录下）<ul>
<li>模型文件会给出其纹理贴图的相对路径，且是相对于模型文件所在的目录（一般来说，有些模型文件中给出的是绝对路径）</li>
</ul>
</li>
</ul>
</li>
<li>方法：<ul>
<li>构造函数：加载模型</li>
<li>模型加载（处理Node，Mesh，纹理加载）</li>
<li>模型绘制：遍历网格，调用draw</li>
</ul>
</li>
</ul>
<p><strong>加载模型</strong></p>
<ul>
<li><p>Assimp::Importer::ReadFile函数的参数：路径，后期处理选项</p>
</li>
<li><p>后期处理选项：</p>
<ul>
<li><p>aiProcess_Triangulate：我们告诉Assimp，如果模型不是（全部）由三角形组成，它需要将模型所有的图元形状变换为三角形。</p>
</li>
<li><p>aiProcess_FlipUVs：将在处理的时候翻转y轴的纹理坐标。</p>
</li>
<li><p>aiProcess_GenNormals：如果模型不包含法向量的话，就为每个顶点创建法线。</p>
</li>
<li><p>aiProcess_SplitLargeMeshes：将比较大的网格分割成更小的子网格，如果你的渲染有最大顶点数限制，只能渲染较小的网格，那么它会非常有用。</p>
</li>
<li><p>aiProcess_OptimizeMeshes：和上个选项相反，它会将多个小网格拼接为一个大的网格，减少绘制调用从而进行优化。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Model::loadModel</span><span class="params">(std::string path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Assimp::Importer importer;</span><br><span class="line">    <span class="comment">// 参数：文件路径，后期处理(Post-processing)的选项</span></span><br><span class="line">    <span class="type">const</span> aiScene* scene = importer.<span class="built_in">ReadFile</span>(path, aiProcess_Triangulate | aiProcess_FlipUVs);</span><br><span class="line">    <span class="keyword">if</span>(!scene || scene-&gt;mFlags &amp; AI_SCENE_FLAGS_INCOMPLETE || !scene-&gt;mRootNode) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ERROR::ASSIMP::&quot;</span> &lt;&lt; importer.<span class="built_in">GetErrorString</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    directory = path.<span class="built_in">substr</span>(<span class="number">0</span>, path.<span class="built_in">find_last_of</span>(<span class="string">&#x27;/&#x27;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">processNode</span>(scene-&gt;mRootNode, scene);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>递归处理得到的节点</strong></p>
<ul>
<li>每个节点包含了一系列的网格索引，每个索引指向场景对象中的那个特定网格</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">processNode</span><span class="params">(aiNode *node, <span class="type">const</span> aiScene *scene)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 处理节点所有的网格（如果有的话）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; node-&gt;mNumMeshes; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        aiMesh *mesh = scene-&gt;mMeshes[node-&gt;mMeshes[i]]; </span><br><span class="line">        meshes.<span class="built_in">push_back</span>(<span class="built_in">processMesh</span>(mesh, scene));         </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 接下来对它的子节点重复这一过程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; node-&gt;mNumChildren; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">processNode</span>(node-&gt;mChildren[i], scene);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解析assimp库Mesh对象</strong></p>
<ul>
<li>顶点数据<ul>
<li>顶点位置、法线、纹理坐标</li>
</ul>
</li>
<li>索引数据<ul>
<li>以面 face 为单位，每个面代表了一个图元</li>
<li>使用了aiProcess_Triangulate选项则是三角形面</li>
<li>一个面包含了多个索引，它们定义了在每个图元中，我们应该绘制哪个顶点，并以什么顺序绘制</li>
</ul>
</li>
<li>材质数据<ul>
<li>加载各种纹理贴图，并将纹理id保存到Texture结构</li>
<li>一个材质对象的内部对每种纹理类型都存储了一个纹理位置数组<ul>
<li>不同的纹理类型都以<code>aiTextureType_</code>为前缀</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Mesh <span class="title">processMesh</span><span class="params">(aiMesh *mesh, <span class="type">const</span> aiScene *scene)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;Vertex&gt; vertices;</span><br><span class="line">    vector&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt; indices;</span><br><span class="line">    vector&lt;Texture&gt; textures;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理顶点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; mesh-&gt;mNumVertices; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Vertex vertex;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理顶点位置、法线和纹理坐标</span></span><br><span class="line">        glm::vec3 vector; </span><br><span class="line">        </span><br><span class="line">        vector.x = mesh-&gt;mVertices[i].x;</span><br><span class="line">        vector.y = mesh-&gt;mVertices[i].y;</span><br><span class="line">        vector.z = mesh-&gt;mVertices[i].z; </span><br><span class="line">        vertex.Position = vector;</span><br><span class="line">        </span><br><span class="line">        vector.x = mesh-&gt;mNormals[i].x;</span><br><span class="line">        vector.y = mesh-&gt;mNormals[i].y;</span><br><span class="line">        vector.z = mesh-&gt;mNormals[i].z;</span><br><span class="line">        vertex.Normal = vector;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Assimp允许一个模型在一个顶点上有最多8个不同的纹理坐标，我们不会用到那么多，我们只关心第一组纹理坐标。</span></span><br><span class="line">        <span class="keyword">if</span>(mesh-&gt;mTextureCoords[<span class="number">0</span>]) <span class="comment">// 网格是否有纹理坐标？</span></span><br><span class="line">        &#123;</span><br><span class="line">            glm::vec2 vec;</span><br><span class="line">            vec.x = mesh-&gt;mTextureCoords[<span class="number">0</span>][i].x; </span><br><span class="line">            vec.y = mesh-&gt;mTextureCoords[<span class="number">0</span>][i].y;</span><br><span class="line">            vertex.TexCoords = vec;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            vertex.TexCoords = glm::<span class="built_in">vec2</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        vertices.<span class="built_in">push_back</span>(vertex);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理索引</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; mesh-&gt;mNumFaces; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        aiFace face = mesh-&gt;mFaces[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> j = <span class="number">0</span>; j &lt; face.mNumIndices; j++)</span><br><span class="line">            indices.<span class="built_in">push_back</span>(face.mIndices[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理材质</span></span><br><span class="line">    <span class="keyword">if</span>(mesh-&gt;mMaterialIndex &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        aiMaterial *material = scene-&gt;mMaterials[mesh-&gt;mMaterialIndex];</span><br><span class="line">        vector&lt;Texture&gt; diffuseMaps = <span class="built_in">loadMaterialTextures</span>(material, aiTextureType_DIFFUSE, <span class="string">&quot;texture_diffuse&quot;</span>);</span><br><span class="line">        textures.<span class="built_in">insert</span>(textures.<span class="built_in">end</span>(), diffuseMaps.<span class="built_in">begin</span>(), diffuseMaps.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;Texture&gt; specularMaps = <span class="built_in">loadMaterialTextures</span>(material, aiTextureType_SPECULAR, <span class="string">&quot;texture_specular&quot;</span>);</span><br><span class="line">        textures.<span class="built_in">insert</span>(textures.<span class="built_in">end</span>(), specularMaps.<span class="built_in">begin</span>(), specularMaps.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Mesh</span>(vertices, indices, textures);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>纹理读入和加载</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::vector&lt;Texture&gt; <span class="title">Model::loadMaterialTextures</span><span class="params">(aiMaterial* mat, aiTextureType type, std::string typeName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;Texture&gt; textures;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; mat-&gt;<span class="built_in">GetTextureCount</span>(type); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取模型文件中定义的纹理文件路径</span></span><br><span class="line">        aiString str;</span><br><span class="line">        mat-&gt;<span class="built_in">GetTexture</span>(type, i, &amp;str);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置纹理</span></span><br><span class="line">        Texture texture;</span><br><span class="line">        texture.id = <span class="built_in">TextureFromFile</span>(str.<span class="built_in">C_Str</span>(), directory);</span><br><span class="line">        texture.type = typeName;</span><br><span class="line">        texture.path = str.<span class="built_in">C_Str</span>();</span><br><span class="line">        textures.<span class="built_in">push_back</span>(texture);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> textures;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">Model::TextureFromFile</span><span class="params">(std::string fileName, std::string dict)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> texture;</span><br><span class="line">    <span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;texture);</span><br><span class="line">    <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture);</span><br><span class="line">    <span class="comment">// 设置延申方式</span></span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); <span class="comment">// note that we set the container wrapping method to GL_CLAMP_TO_EDGE</span></span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br><span class="line">    <span class="comment">// 设置纹理过滤方式</span></span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST); <span class="comment">// set texture filtering to nearest neighbor to clearly see the texels/pixels</span></span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> width, height, nrChannels;</span><br><span class="line">    std::string path = dict + fileName;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;texture path: %s\n&quot;</span>, path.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *data = <span class="built_in">stbi_load</span>(path.<span class="built_in">c_str</span>(), &amp;width, &amp;height, &amp;nrChannels, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将纹理数据加载到纹理对象</span></span><br><span class="line"></span><br><span class="line">        std::string addr = fileName.<span class="built_in">substr</span>(fileName.<span class="built_in">find</span>(<span class="string">&#x27;.&#x27;</span>));</span><br><span class="line">        <span class="keyword">if</span> (addr == <span class="string">&quot;png&quot;</span>) &#123;</span><br><span class="line">            <span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGBA, width, height, <span class="number">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (addr == <span class="string">&quot;jpg&quot;</span>) &#123;</span><br><span class="line">            <span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">glGenerateMipmap</span>(GL_TEXTURE_2D);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to load texture&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">stbi_image_free</span>(data);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stbi_image_free</span>(data);</span><br><span class="line">    <span class="keyword">return</span> texture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>在我们当前的实现中，即便同样的纹理已经被加载过很多遍了，对每个网格仍会加载并生成一个新的纹理。</p>
<ul>
<li>记录已加载的纹理</li>
<li>后续给各个网格加载纹理时，先通过纹理文件名判断是否已加载过<ul>
<li>已加载则直接使用加载过的纹理id</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Texture</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> id;</span><br><span class="line">    string type;</span><br><span class="line">    aiString path;  <span class="comment">// 我们储存纹理的路径用于与其它纹理进行比较</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">model</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">    vector&lt;Texture&gt; textures_loaded;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;Texture&gt; <span class="title">loadMaterialTextures</span><span class="params">(aiMaterial *mat, aiTextureType type, string typeName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;Texture&gt; textures;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; mat-&gt;<span class="built_in">GetTextureCount</span>(type); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        aiString str;</span><br><span class="line">        mat-&gt;<span class="built_in">GetTexture</span>(type, i, &amp;str);</span><br><span class="line">        <span class="type">bool</span> skip = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 遍历检查是否已加载过</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> j = <span class="number">0</span>; j &lt; textures_loaded.<span class="built_in">size</span>(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(std::<span class="built_in">strcmp</span>(textures_loaded[j].path.<span class="built_in">C_Str</span>(), str.<span class="built_in">C_Str</span>()) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                textures.<span class="built_in">push_back</span>(textures_loaded[j]);</span><br><span class="line">                skip = <span class="literal">true</span>; </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!skip)</span><br><span class="line">        &#123;   <span class="comment">// 如果纹理还没有被加载，则加载它</span></span><br><span class="line">            Texture texture;</span><br><span class="line">            texture.id = <span class="built_in">TextureFromFile</span>(str.<span class="built_in">C_Str</span>(), directory);</span><br><span class="line">            texture.type = typeName;</span><br><span class="line">            texture.path = str.<span class="built_in">C_Str</span>();</span><br><span class="line">            textures.<span class="built_in">push_back</span>(texture);</span><br><span class="line">            textures_loaded.<span class="built_in">push_back</span>(texture); <span class="comment">// 添加到已加载的纹理中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> textures;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><ul>
<li><p>又是因为载入纹理的地方出错，导致浪费了很多时间</p>
<ul>
<li>漏掉了一个点，比较处应该是”.png”而不是”png”</li>
</ul>
<p><img src="/2024/04/06/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%9B%9B%EF%BC%89/image-20240406224150063.png" alt="image-20240406224150063"></p>
</li>
<li><p>用更好的代码替代：</p>
</li>
</ul>
<p><img src="/2024/04/06/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%9B%9B%EF%BC%89/image-20240406224449627.png" alt="image-20240406224449627"></p>
<h3 id="基础版"><a href="#基础版" class="headerlink" title="基础版"></a>基础版</h3><p><img src="/2024/04/06/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%9B%9B%EF%BC%89/image-20240406224657963.png" alt="image-20240406224657963"></p>
<h3 id="高级版"><a href="#高级版" class="headerlink" title="高级版"></a>高级版</h3><p><img src="/2024/04/06/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%9B%9B%EF%BC%89/image-20240406224732477.png" alt="image-20240406224732477"></p>
<p><img src="/2024/04/06/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%9B%9B%EF%BC%89/image-20240406224753832.png" alt="image-20240406224753832"></p>
<p><img src="/2024/04/06/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%9B%9B%EF%BC%89/image-20240406224813695.png" alt="image-20240406224813695"></p>
<h3 id="黑金版"><a href="#黑金版" class="headerlink" title="黑金版"></a>黑金版</h3><p><img src="/2024/04/06/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%9B%9B%EF%BC%89/image-20240406225120222.png" alt="image-20240406225120222"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;public.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ShaderMgr.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;camera.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;part1.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Model.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">MyCamera g_camera;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> mixValue;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="comment">// positions          // normals           // texture coords</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mixValue = <span class="number">0.2f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GLFW 窗口初始化</span></span><br><span class="line">    GLFWwindow* window = <span class="built_in">init_GLFW_window</span>(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;LearnOpenGL&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (window == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to initialize GLFW&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GLAD 函数地址初始化</span></span><br><span class="line">    <span class="keyword">if</span> (GL_FALSE == <span class="built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 相机初始化</span></span><br><span class="line">    g_camera.<span class="built_in">Init</span>(glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">3.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启深度缓冲</span></span><br><span class="line">    <span class="built_in">glEnable</span>(GL_DEPTH_TEST);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 顶点缓冲设置</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> VBO;</span><br><span class="line">    <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">    <span class="comment">// 把之前定义的顶点数据复制到缓冲的内存</span></span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 箱子顶点数组生成</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> VAO;</span><br><span class="line">    <span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">8</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">8</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)(<span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>)));</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">2</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">8</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)(<span class="number">6</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>)));</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 生成和绑定纹理对象，并载入纹理数据</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> texture1;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* data1 = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">int</span> width1, height1, nrChannels1;</span><br><span class="line">    texture1 = <span class="built_in">GenAndLoadTexture</span>(<span class="string">&quot;resource/container2.png&quot;</span>, &amp;width1, &amp;height1, &amp;nrChannels1, data1, GL_RGBA);</span><br><span class="line">    <span class="keyword">if</span> (texture1 == <span class="number">-1</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;load texture failed1\n&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stbi_image_free</span>(data1);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> texture2;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* data2 = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">int</span> width2, height2, nrChannels2;</span><br><span class="line">    texture2 = <span class="built_in">GenAndLoadTexture</span>(<span class="string">&quot;resource/container2_specular.png&quot;</span>, &amp;width2, &amp;height2, &amp;nrChannels2, data2, GL_RGBA);</span><br><span class="line">    <span class="keyword">if</span> (texture2 == <span class="number">-1</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;load texture failed2\n&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stbi_image_free</span>(data2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 灯光物体的顶点数组和属性设置</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> lightVAO;</span><br><span class="line">    <span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;lightVAO);</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(lightVAO);</span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">8</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 光源位置</span></span><br><span class="line">    <span class="function">glm::vec3 <span class="title">dirLightPos</span><span class="params">(<span class="number">1.2f</span>, <span class="number">1.0f</span>, <span class="number">2.0f</span>)</span></span>;</span><br><span class="line">    glm::vec3 pointLightPositions[] = &#123;</span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">2.7f</span>,  <span class="number">0.2f</span>,  <span class="number">2.0f</span>),</span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">0.3f</span>, <span class="number">-3.3f</span>, <span class="number">-4.0f</span>),</span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">-4.0f</span>,  <span class="number">2.0f</span>, <span class="number">-12.0f</span>),</span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">-3.0f</span>)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 光物体的着色器</span></span><br><span class="line">    <span class="function">Shader <span class="title">lightShader</span><span class="params">(<span class="string">&quot;./ColorVShader.glsl&quot;</span>, <span class="string">&quot;./MaterialFShader_Light.glsl&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模型着色器</span></span><br><span class="line">    <span class="function">Shader <span class="title">shader</span><span class="params">(<span class="string">&quot;./ModelVShader.glsl&quot;</span>, <span class="string">&quot;./ModelFShader.glsl&quot;</span>)</span></span>;</span><br><span class="line">    shader.<span class="built_in">use</span>();</span><br><span class="line">    shader.<span class="built_in">setVec3</span>(<span class="string">&quot;viewPos&quot;</span>, g_camera.<span class="built_in">GetPos</span>());</span><br><span class="line">    shader.<span class="built_in">setFloat</span>(<span class="string">&quot;material.shininess&quot;</span>, <span class="number">32.0f</span>);</span><br><span class="line"></span><br><span class="line">    shader.<span class="built_in">setVec3</span>(<span class="string">&quot;dirLight.ambient&quot;</span>, glm::<span class="built_in">vec3</span>(<span class="number">0.2f</span>, <span class="number">0.2f</span>, <span class="number">0.2f</span>));</span><br><span class="line">    shader.<span class="built_in">setVec3</span>(<span class="string">&quot;dirLight.diffuse&quot;</span>, glm::<span class="built_in">vec3</span>(<span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.5f</span>)); <span class="comment">// 将光照调暗了一些以搭配场景</span></span><br><span class="line">    shader.<span class="built_in">setVec3</span>(<span class="string">&quot;dirLight.specular&quot;</span>, glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>));</span><br><span class="line">    shader.<span class="built_in">setVec3</span>(<span class="string">&quot;dirLight.direction&quot;</span>, glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        std::string name = <span class="string">&quot;pointLights[&quot;</span>;</span><br><span class="line">        name += std::<span class="built_in">to_string</span>(i);</span><br><span class="line">        std::string after;</span><br><span class="line">        after = <span class="string">&quot;].constant&quot;</span>;</span><br><span class="line">        shader.<span class="built_in">setFloat</span>(name + after, <span class="number">1.0f</span>);</span><br><span class="line">        after = <span class="string">&quot;].linear&quot;</span>;</span><br><span class="line">        shader.<span class="built_in">setFloat</span>(name + after, <span class="number">0.09f</span>);</span><br><span class="line">        after = <span class="string">&quot;].quadratic&quot;</span>;</span><br><span class="line">        shader.<span class="built_in">setFloat</span>(name + after, <span class="number">0.032f</span>);</span><br><span class="line">        after = <span class="string">&quot;].ambient&quot;</span>;</span><br><span class="line">        shader.<span class="built_in">setVec3</span>(name + after, glm::<span class="built_in">vec3</span>(<span class="number">0.2f</span>, <span class="number">0.2f</span>, <span class="number">0.2f</span>));</span><br><span class="line">        after = <span class="string">&quot;].diffuse&quot;</span>;</span><br><span class="line">        shader.<span class="built_in">setVec3</span>(name + after, glm::<span class="built_in">vec3</span>(<span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.5f</span>)); <span class="comment">// 将光照调暗了一些以搭配场景</span></span><br><span class="line">        after = <span class="string">&quot;].specular&quot;</span>;</span><br><span class="line">        shader.<span class="built_in">setVec3</span>(name + after, glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    shader.<span class="built_in">setFloat</span>(<span class="string">&quot;spotLight.constant&quot;</span>, <span class="number">1.0f</span>);</span><br><span class="line">    shader.<span class="built_in">setFloat</span>(<span class="string">&quot;spotLight.linear&quot;</span>, <span class="number">0.09f</span>);</span><br><span class="line">    shader.<span class="built_in">setFloat</span>(<span class="string">&quot;spotLight.quadratic&quot;</span>, <span class="number">0.032f</span>);</span><br><span class="line">    shader.<span class="built_in">setFloat</span>(<span class="string">&quot;spotLight.cutOff&quot;</span>, glm::<span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(<span class="number">12.5f</span>)));</span><br><span class="line">    shader.<span class="built_in">setFloat</span>(<span class="string">&quot;spotLight.outerCutOff&quot;</span>, glm::<span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(<span class="number">17.5f</span>)));</span><br><span class="line">    shader.<span class="built_in">setVec3</span>(<span class="string">&quot;spotLight.ambient&quot;</span>, glm::<span class="built_in">vec3</span>(<span class="number">0.2f</span>, <span class="number">0.2f</span>, <span class="number">0.2f</span>));</span><br><span class="line">    shader.<span class="built_in">setVec3</span>(<span class="string">&quot;spotLight.diffuse&quot;</span>, glm::<span class="built_in">vec3</span>(<span class="number">0.75f</span>, <span class="number">0.75f</span>, <span class="number">0.75f</span>)); <span class="comment">// 将光照调暗了一些以搭配场景</span></span><br><span class="line">    shader.<span class="built_in">setVec3</span>(<span class="string">&quot;spotLight.specular&quot;</span>, glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 箱子着色器</span></span><br><span class="line">    <span class="function">Shader <span class="title">boxShader</span><span class="params">(<span class="string">&quot;./MultiLightVShader.glsl&quot;</span>, <span class="string">&quot;./MultiLightFShader.glsl&quot;</span>)</span></span>;</span><br><span class="line">    boxShader.<span class="built_in">use</span>();</span><br><span class="line">    boxShader.<span class="built_in">setInt</span>(<span class="string">&quot;material.diffuse&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    boxShader.<span class="built_in">setInt</span>(<span class="string">&quot;material.specular&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    boxShader.<span class="built_in">setFloat</span>(<span class="string">&quot;material.shininess&quot;</span>, <span class="number">32.0f</span>);</span><br><span class="line">    <span class="comment">// 平行光</span></span><br><span class="line">    boxShader.<span class="built_in">setVec3</span>(<span class="string">&quot;dirLight.ambient&quot;</span>, glm::<span class="built_in">vec3</span>(<span class="number">0.2f</span>, <span class="number">0.2f</span>, <span class="number">0.2f</span>));</span><br><span class="line">    boxShader.<span class="built_in">setVec3</span>(<span class="string">&quot;dirLight.diffuse&quot;</span>, glm::<span class="built_in">vec3</span>(<span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.5f</span>)); <span class="comment">// 将光照调暗了一些以搭配场景</span></span><br><span class="line">    boxShader.<span class="built_in">setVec3</span>(<span class="string">&quot;dirLight.specular&quot;</span>, glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>));</span><br><span class="line">    boxShader.<span class="built_in">setVec3</span>(<span class="string">&quot;dirLight.direction&quot;</span>, glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>));</span><br><span class="line">    <span class="comment">// 点光源</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        std::string name = <span class="string">&quot;pointLights[&quot;</span>;</span><br><span class="line">        name += std::<span class="built_in">to_string</span>(i);</span><br><span class="line">        std::string after;</span><br><span class="line">        after = <span class="string">&quot;].constant&quot;</span>;</span><br><span class="line">        boxShader.<span class="built_in">setFloat</span>(name + after, <span class="number">1.0f</span>);</span><br><span class="line">        after = <span class="string">&quot;].linear&quot;</span>;</span><br><span class="line">        boxShader.<span class="built_in">setFloat</span>(name + after, <span class="number">0.09f</span>);</span><br><span class="line">        after = <span class="string">&quot;].quadratic&quot;</span>;</span><br><span class="line">        boxShader.<span class="built_in">setFloat</span>(name + after, <span class="number">0.032f</span>);</span><br><span class="line">        after = <span class="string">&quot;].ambient&quot;</span>;</span><br><span class="line">        boxShader.<span class="built_in">setVec3</span>(name + after, glm::<span class="built_in">vec3</span>(<span class="number">0.2f</span>, <span class="number">0.2f</span>, <span class="number">0.2f</span>));</span><br><span class="line">        after = <span class="string">&quot;].diffuse&quot;</span>;</span><br><span class="line">        boxShader.<span class="built_in">setVec3</span>(name + after, glm::<span class="built_in">vec3</span>(<span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.5f</span>)); <span class="comment">// 将光照调暗了一些以搭配场景</span></span><br><span class="line">        after = <span class="string">&quot;].specular&quot;</span>;</span><br><span class="line">        boxShader.<span class="built_in">setVec3</span>(name + after, glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 聚光灯</span></span><br><span class="line">    boxShader.<span class="built_in">setFloat</span>(<span class="string">&quot;spotLight.constant&quot;</span>, <span class="number">1.0f</span>);</span><br><span class="line">    boxShader.<span class="built_in">setFloat</span>(<span class="string">&quot;spotLight.linear&quot;</span>, <span class="number">0.09f</span>);</span><br><span class="line">    boxShader.<span class="built_in">setFloat</span>(<span class="string">&quot;spotLight.quadratic&quot;</span>, <span class="number">0.032f</span>);</span><br><span class="line">    boxShader.<span class="built_in">setFloat</span>(<span class="string">&quot;spotLight.cutOff&quot;</span>, glm::<span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(<span class="number">12.5f</span>)));</span><br><span class="line">    boxShader.<span class="built_in">setFloat</span>(<span class="string">&quot;spotLight.outerCutOff&quot;</span>, glm::<span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(<span class="number">17.5f</span>)));</span><br><span class="line">    boxShader.<span class="built_in">setVec3</span>(<span class="string">&quot;spotLight.ambient&quot;</span>, glm::<span class="built_in">vec3</span>(<span class="number">0.2f</span>, <span class="number">0.2f</span>, <span class="number">0.2f</span>));</span><br><span class="line">    boxShader.<span class="built_in">setVec3</span>(<span class="string">&quot;spotLight.diffuse&quot;</span>, glm::<span class="built_in">vec3</span>(<span class="number">0.75f</span>, <span class="number">0.75f</span>, <span class="number">0.75f</span>)); <span class="comment">// 将光照调暗了一些以搭配场景</span></span><br><span class="line">    boxShader.<span class="built_in">setVec3</span>(<span class="string">&quot;spotLight.specular&quot;</span>, glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function">Model <span class="title">renderModel</span><span class="params">(<span class="string">&quot;./resource/nanosuit/nanosuit.obj&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染循环</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))	<span class="comment">// 检查是否被要求退出窗口</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 输入处理</span></span><br><span class="line">        <span class="built_in">processInput</span>(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 帧渲染时间</span></span><br><span class="line">        <span class="type">float</span> deltaTime;</span><br><span class="line">        <span class="type">float</span> lastFrame = <span class="number">0</span>;</span><br><span class="line">        <span class="type">float</span> currentFrame = <span class="built_in">glfwGetTime</span>();</span><br><span class="line">        deltaTime = currentFrame - lastFrame;</span><br><span class="line">        lastFrame = currentFrame;</span><br><span class="line"></span><br><span class="line">        g_camera.<span class="built_in">SetSpeed</span>(deltaTime);</span><br><span class="line"></span><br><span class="line">        <span class="type">float</span> angle = <span class="number">2.0f</span> * (<span class="type">float</span>)<span class="built_in">glfwGetTime</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重置颜色缓冲和深度缓冲</span></span><br><span class="line">        <span class="built_in">glClearColor</span>(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算mvp变换矩阵</span></span><br><span class="line">        glm::mat4 view = g_camera.<span class="built_in">GetLookAt</span>();</span><br><span class="line">        glm::mat4 projection = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">        projection = glm::<span class="built_in">perspective</span>(glm::<span class="built_in">radians</span>(g_camera.<span class="built_in">GetFov</span>()), <span class="number">800.0f</span> / <span class="number">600.0f</span>, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绘制点光源光照立方体</span></span><br><span class="line">        &#123;</span><br><span class="line">            lightShader.<span class="built_in">use</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                glm::mat4 light_model = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">                light_model = glm::<span class="built_in">translate</span>(light_model, pointLightPositions[i]);</span><br><span class="line">                <span class="comment">// 光源绕圈移动（模型变换修改）</span></span><br><span class="line">                light_model = glm::<span class="built_in">translate</span>(light_model, glm::<span class="built_in">vec3</span>(<span class="built_in">sin</span>(angle), <span class="built_in">cos</span>(angle), <span class="number">0</span>));</span><br><span class="line">                light_model = glm::<span class="built_in">scale</span>(light_model, glm::<span class="built_in">vec3</span>(<span class="number">0.2f</span>));</span><br><span class="line"></span><br><span class="line">                lightShader.<span class="built_in">setMat4</span>(<span class="string">&quot;model&quot;</span>, light_model);</span><br><span class="line">                lightShader.<span class="built_in">setMat4</span>(<span class="string">&quot;view&quot;</span>, view);</span><br><span class="line">                lightShader.<span class="built_in">setMat4</span>(<span class="string">&quot;projection&quot;</span>, projection);</span><br><span class="line">                lightShader.<span class="built_in">setVec3</span>(<span class="string">&quot;lightColor&quot;</span>, glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>));</span><br><span class="line"></span><br><span class="line">                <span class="built_in">glBindVertexArray</span>(lightVAO);</span><br><span class="line">                <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line">                <span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绘制立方体</span></span><br><span class="line">        &#123;</span><br><span class="line">            shader.<span class="built_in">use</span>();</span><br><span class="line">            glm::mat4 model = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">            model = glm::<span class="built_in">rotate</span>(model, glm::<span class="built_in">radians</span>(angle), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">            shader.<span class="built_in">setMat4</span>(<span class="string">&quot;model&quot;</span>, model);</span><br><span class="line">            shader.<span class="built_in">setMat4</span>(<span class="string">&quot;view&quot;</span>, view);</span><br><span class="line">            shader.<span class="built_in">setMat4</span>(<span class="string">&quot;projection&quot;</span>, projection);</span><br><span class="line">            shader.<span class="built_in">setVec3</span>(<span class="string">&quot;viewPos&quot;</span>, g_camera.<span class="built_in">GetPos</span>());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 点光源位置</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                std::string name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                name += <span class="string">&quot;pointLights[&quot;</span>;</span><br><span class="line">                name += std::<span class="built_in">to_string</span>(i);</span><br><span class="line">                name += <span class="string">&quot;].position&quot;</span>;</span><br><span class="line">                shader.<span class="built_in">setVec3</span>(name, pointLightPositions[i] + glm::<span class="built_in">vec3</span>(<span class="built_in">sin</span>(angle), <span class="built_in">cos</span>(angle), <span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 聚光灯位置和方向</span></span><br><span class="line">            shader.<span class="built_in">setVec3</span>(<span class="string">&quot;spotLight.position&quot;</span>, g_camera.<span class="built_in">GetPos</span>());</span><br><span class="line">            shader.<span class="built_in">setVec3</span>(<span class="string">&quot;spotLight.direction&quot;</span>, g_camera.<span class="built_in">GetFront</span>());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 绘制模型</span></span><br><span class="line">            renderModel.<span class="built_in">Draw</span>(shader);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绘制箱子</span></span><br><span class="line">        &#123;</span><br><span class="line">            boxShader.<span class="built_in">use</span>();</span><br><span class="line">            glm::mat4 smodel = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">            smodel = glm::<span class="built_in">rotate</span>(smodel, glm::<span class="built_in">radians</span>(angle), glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">0.3f</span>, <span class="number">0.5f</span>));</span><br><span class="line">            boxShader.<span class="built_in">setMat4</span>(<span class="string">&quot;model&quot;</span>, smodel);</span><br><span class="line">            boxShader.<span class="built_in">setMat4</span>(<span class="string">&quot;view&quot;</span>, view);</span><br><span class="line">            boxShader.<span class="built_in">setMat4</span>(<span class="string">&quot;projection&quot;</span>, projection);</span><br><span class="line">            boxShader.<span class="built_in">setVec3</span>(<span class="string">&quot;viewPos&quot;</span>, g_camera.<span class="built_in">GetPos</span>());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                std::string name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                name += <span class="string">&quot;pointLights[&quot;</span>;</span><br><span class="line">                name += std::<span class="built_in">to_string</span>(i);</span><br><span class="line">                name += <span class="string">&quot;].position&quot;</span>;</span><br><span class="line">                boxShader.<span class="built_in">setVec3</span>(name, pointLightPositions[i] + glm::<span class="built_in">vec3</span>(<span class="built_in">sin</span>(angle), <span class="built_in">cos</span>(angle), <span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            boxShader.<span class="built_in">setVec3</span>(<span class="string">&quot;spotLight.position&quot;</span>, g_camera.<span class="built_in">GetPos</span>());</span><br><span class="line">            boxShader.<span class="built_in">setVec3</span>(<span class="string">&quot;spotLight.direction&quot;</span>, g_camera.<span class="built_in">GetFront</span>());</span><br><span class="line"></span><br><span class="line">            <span class="built_in">glActiveTexture</span>(GL_TEXTURE0);</span><br><span class="line">            <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture1);</span><br><span class="line">            <span class="built_in">glActiveTexture</span>(GL_TEXTURE1);</span><br><span class="line">            <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture2);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line">            <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line">            <span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 交换颜色缓冲，输出显示到屏幕</span></span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">        <span class="comment">// 检查有没有触发什么事件（比如键盘输入、鼠标移动等）、更新窗口状态，并调用对应的回调函数</span></span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="model-cpp"><a href="#model-cpp" class="headerlink" title="model.cpp"></a>model.cpp</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Model.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Mesh::<span class="built_in">Mesh</span>(std::vector&lt;Vertex&gt; vertices, std::vector&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt; indices, std::vector&lt;Texture&gt; textures)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;vertices = vertices;</span><br><span class="line">    <span class="keyword">this</span>-&gt;indices = indices;</span><br><span class="line">    <span class="keyword">this</span>-&gt;textures = textures;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setupMesh</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Mesh::Draw</span><span class="params">(Shader&amp; shader)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    shader.<span class="built_in">use</span>();</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> diffuseNr = <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> specularNr = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; textures.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glActiveTexture</span>(GL_TEXTURE0 + i); <span class="comment">// 在绑定之前激活相应的纹理单元</span></span><br><span class="line">        <span class="comment">// 获取纹理序号（diffuse_textureN 中的 N）</span></span><br><span class="line">        std::string number;</span><br><span class="line">        std::string name = textures[i].type;</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="string">&quot;texture_diffuse&quot;</span>)</span><br><span class="line">            number = std::<span class="built_in">to_string</span>(diffuseNr++);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (name == <span class="string">&quot;texture_specular&quot;</span>)</span><br><span class="line">            number = std::<span class="built_in">to_string</span>(specularNr++);</span><br><span class="line"></span><br><span class="line">        <span class="function">std::string <span class="title">target</span><span class="params">(<span class="string">&quot;material.&quot;</span> + name + number)</span></span>;</span><br><span class="line">        shader.<span class="built_in">setInt</span>(target, i);</span><br><span class="line">        <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, textures[i].id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">glActiveTexture</span>(GL_TEXTURE0);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制网格</span></span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line">    <span class="built_in">glDrawElements</span>(GL_TRIANGLES, indices.<span class="built_in">size</span>(), GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Mesh::setupMesh</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">    <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;EBO);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, vertices.<span class="built_in">size</span>() * <span class="built_in">sizeof</span>(Vertex), &amp;vertices[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, indices.<span class="built_in">size</span>() * <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>),</span><br><span class="line">        &amp;indices[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 顶点位置</span></span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="built_in">sizeof</span>(Vertex), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 顶点法线</span></span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="built_in">sizeof</span>(Vertex), (<span class="type">void</span>*)<span class="built_in">offsetof</span>(Vertex, Normal));</span><br><span class="line">    <span class="comment">// 顶点纹理坐标</span></span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">2</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="built_in">sizeof</span>(Vertex), (<span class="type">void</span>*)<span class="built_in">offsetof</span>(Vertex, TexCoords));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Model::Draw</span><span class="params">(Shader&amp; shader)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; meshes.<span class="built_in">size</span>(); i++)</span><br><span class="line">        meshes[i].<span class="built_in">Draw</span>(shader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Model::loadModel</span><span class="params">(std::string path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Assimp::Importer importer;</span><br><span class="line">    <span class="comment">// 参数：文件路径，后期处理(Post-processing)的选项</span></span><br><span class="line">    <span class="type">const</span> aiScene* scene = importer.<span class="built_in">ReadFile</span>(path, aiProcess_Triangulate | aiProcess_FlipUVs);</span><br><span class="line">    <span class="keyword">if</span> (!scene || scene-&gt;mFlags &amp; AI_SCENE_FLAGS_INCOMPLETE || !scene-&gt;mRootNode)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ERROR::ASSIMP::&quot;</span> &lt;&lt; importer.<span class="built_in">GetErrorString</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    directory = path.<span class="built_in">substr</span>(<span class="number">0</span>, path.<span class="built_in">find_last_of</span>(<span class="string">&#x27;/&#x27;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">processNode</span>(scene-&gt;mRootNode, scene);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Model::processNode</span><span class="params">(aiNode* node, <span class="type">const</span> aiScene* scene)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 处理节点所有的网格（如果有的话）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; node-&gt;mNumMeshes; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        aiMesh* mesh = scene-&gt;mMeshes[node-&gt;mMeshes[i]];</span><br><span class="line">        meshes.<span class="built_in">push_back</span>(<span class="built_in">processMesh</span>(mesh, scene));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 接下来对它的子节点重复这一过程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; node-&gt;mNumChildren; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">processNode</span>(node-&gt;mChildren[i], scene);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Mesh <span class="title">Model::processMesh</span><span class="params">(aiMesh* mesh, <span class="type">const</span> aiScene* scene)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;Vertex&gt; vertices;</span><br><span class="line">    std::vector&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt; indices;</span><br><span class="line">    std::vector&lt;Texture&gt; textures;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理顶点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; mesh-&gt;mNumVertices; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Vertex vertex;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理顶点位置、法线和纹理坐标</span></span><br><span class="line">        glm::vec3 vector;</span><br><span class="line"></span><br><span class="line">        vector.x = mesh-&gt;mVertices[i].x;</span><br><span class="line">        vector.y = mesh-&gt;mVertices[i].y;</span><br><span class="line">        vector.z = mesh-&gt;mVertices[i].z;</span><br><span class="line">        vertex.Position = vector;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mesh-&gt;<span class="built_in">HasNormals</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            vector.x = mesh-&gt;mNormals[i].x;</span><br><span class="line">            vector.y = mesh-&gt;mNormals[i].y;</span><br><span class="line">            vector.z = mesh-&gt;mNormals[i].z;</span><br><span class="line">            vertex.Normal = vector;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Assimp允许一个模型在一个顶点上有最多8个不同的纹理坐标，我们不会用到那么多，我们只关心第一组纹理坐标。</span></span><br><span class="line">        <span class="keyword">if</span> (mesh-&gt;mTextureCoords[<span class="number">0</span>]) <span class="comment">// 网格是否有纹理坐标？</span></span><br><span class="line">        &#123;</span><br><span class="line">            glm::vec2 vec;</span><br><span class="line">            vec.x = mesh-&gt;mTextureCoords[<span class="number">0</span>][i].x;</span><br><span class="line">            vec.y = mesh-&gt;mTextureCoords[<span class="number">0</span>][i].y;</span><br><span class="line">            vertex.TexCoords = vec;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            vertex.TexCoords = glm::<span class="built_in">vec2</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vertices.<span class="built_in">push_back</span>(vertex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理索引</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; mesh-&gt;mNumFaces; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        aiFace face = mesh-&gt;mFaces[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> j = <span class="number">0</span>; j &lt; face.mNumIndices; j++)</span><br><span class="line">            indices.<span class="built_in">push_back</span>(face.mIndices[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理材质</span></span><br><span class="line">    <span class="keyword">if</span> (mesh-&gt;mMaterialIndex &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        aiMaterial* material = scene-&gt;mMaterials[mesh-&gt;mMaterialIndex];</span><br><span class="line"></span><br><span class="line">        std::vector&lt;Texture&gt; diffuseMaps = <span class="built_in">loadMaterialTextures</span>(material, aiTextureType_DIFFUSE, <span class="string">&quot;texture_diffuse&quot;</span>);</span><br><span class="line">        textures.<span class="built_in">insert</span>(textures.<span class="built_in">end</span>(), diffuseMaps.<span class="built_in">begin</span>(), diffuseMaps.<span class="built_in">end</span>());</span><br><span class="line">        </span><br><span class="line">        std::vector&lt;Texture&gt; specularMaps = <span class="built_in">loadMaterialTextures</span>(material, aiTextureType_SPECULAR, <span class="string">&quot;texture_specular&quot;</span>);</span><br><span class="line">        textures.<span class="built_in">insert</span>(textures.<span class="built_in">end</span>(), specularMaps.<span class="built_in">begin</span>(), specularMaps.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Mesh</span>(vertices, indices, textures);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;Texture&gt; <span class="title">Model::loadMaterialTextures</span><span class="params">(aiMaterial* mat, aiTextureType type, std::string typeName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;Texture&gt; textures;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; mat-&gt;<span class="built_in">GetTextureCount</span>(type); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        aiString str;</span><br><span class="line">        mat-&gt;<span class="built_in">GetTexture</span>(type, i, &amp;str);</span><br><span class="line">        <span class="type">bool</span> skip = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 遍历检查是否已加载过</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> j = <span class="number">0</span>; j &lt; textures_loaded.<span class="built_in">size</span>(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (std::<span class="built_in">strcmp</span>(textures_loaded[j].path.<span class="built_in">C_Str</span>(), str.<span class="built_in">C_Str</span>()) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                textures.<span class="built_in">push_back</span>(textures_loaded[j]);</span><br><span class="line">                skip = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!skip)</span><br><span class="line">        &#123;   <span class="comment">// 如果纹理还没有被加载，则加载它</span></span><br><span class="line">            Texture texture;</span><br><span class="line">            texture.id = <span class="built_in">TextureFromFile</span>(str.<span class="built_in">C_Str</span>(), directory);</span><br><span class="line">            texture.type = typeName;</span><br><span class="line">            texture.path = str.<span class="built_in">C_Str</span>();</span><br><span class="line">            textures.<span class="built_in">push_back</span>(texture);</span><br><span class="line">            textures_loaded.<span class="built_in">push_back</span>(texture); <span class="comment">// 添加到已加载的纹理中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> textures;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">Model::TextureFromFile</span><span class="params">(std::string fileName, std::string dict)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> texture;</span><br><span class="line">    <span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;texture);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> width, height, nrChannels;</span><br><span class="line">    std::string path = dict + <span class="string">&quot;/&quot;</span> + fileName;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *data = <span class="built_in">stbi_load</span>(path.<span class="built_in">c_str</span>(), &amp;width, &amp;height, &amp;nrChannels, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (data)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        GLenum format = GL_RED;</span><br><span class="line">        <span class="keyword">if</span> (nrChannels == <span class="number">1</span>)</span><br><span class="line">            format = GL_RED;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nrChannels == <span class="number">3</span>)</span><br><span class="line">            format = GL_RGB;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nrChannels == <span class="number">4</span>)</span><br><span class="line">            format = GL_RGBA;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture);</span><br><span class="line">        <span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, format, width, height, <span class="number">0</span>, format, GL_UNSIGNED_BYTE, data);</span><br><span class="line">        <span class="built_in">glGenerateMipmap</span>(GL_TEXTURE_2D);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); <span class="comment">// note that we set the container wrapping method to GL_CLAMP_TO_EDGE</span></span><br><span class="line">        <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br><span class="line">        <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR); <span class="comment">// set texture filtering to nearest neighbor to clearly see the texels/pixels</span></span><br><span class="line">        <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to load texture&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">stbi_image_free</span>(data);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stbi_image_free</span>(data);</span><br><span class="line">    <span class="keyword">return</span> texture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="片段着色器"><a href="#片段着色器" class="headerlink" title="片段着色器"></a>片段着色器</h4><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="meta">#define NR_POINT_LIGHTS 4</span></span><br><span class="line"></span><br><span class="line">struct Material &#123;</span><br><span class="line">    <span class="comment">// vec3 ambient;</span></span><br><span class="line">    <span class="comment">// vec3 diffuse;</span></span><br><span class="line">    <span class="comment">// vec3 specular;</span></span><br><span class="line">    <span class="type">sampler2D</span> texture_diffuse1;</span><br><span class="line">    <span class="type">sampler2D</span> texture_diffuse2;</span><br><span class="line">    <span class="type">sampler2D</span> texture_diffuse3;</span><br><span class="line">    <span class="type">sampler2D</span> texture_diffuse4;</span><br><span class="line"></span><br><span class="line">    <span class="type">sampler2D</span> texture_specular1;</span><br><span class="line">    <span class="type">sampler2D</span> texture_specular2;</span><br><span class="line">    <span class="type">sampler2D</span> texture_specular3;</span><br><span class="line">    <span class="type">sampler2D</span> texture_specular4;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> shininess;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 定向光</span></span><br><span class="line">struct DirLight &#123;</span><br><span class="line">    <span class="type">vec3</span> direction;</span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> ambient;</span><br><span class="line">    <span class="type">vec3</span> diffuse;</span><br><span class="line">    <span class="type">vec3</span> specular;</span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 点光源</span></span><br><span class="line">struct PointLight &#123;</span><br><span class="line">    <span class="type">vec3</span> position;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> constant;</span><br><span class="line">    <span class="type">float</span> linear;</span><br><span class="line">    <span class="type">float</span> quadratic;</span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> ambient;</span><br><span class="line">    <span class="type">vec3</span> diffuse;</span><br><span class="line">    <span class="type">vec3</span> specular;</span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 聚光灯</span></span><br><span class="line">struct SpotLight &#123;</span><br><span class="line">    <span class="type">vec3</span> position;    </span><br><span class="line">    <span class="type">vec3</span> direction;</span><br><span class="line">    <span class="type">float</span> cutOff;</span><br><span class="line">    <span class="type">float</span> outerCutOff;</span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> ambient;</span><br><span class="line">    <span class="type">vec3</span> diffuse;</span><br><span class="line">    <span class="type">vec3</span> specular;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> constant;</span><br><span class="line">    <span class="type">float</span> linear;</span><br><span class="line">    <span class="type">float</span> quadratic;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> DirLight dirLight;</span><br><span class="line"><span class="keyword">uniform</span> PointLight pointLights[NR_POINT_LIGHTS];</span><br><span class="line"><span class="keyword">uniform</span> SpotLight spotLight;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> Material material;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> viewPos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec2</span> TexCoords;</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> Normal;</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> FragPos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="type">vec3</span> CalcDirLight(DirLight light, <span class="type">vec3</span> normal, <span class="type">vec3</span> viewDir);</span><br><span class="line"><span class="type">vec3</span> CalcPointLight(PointLight light, <span class="type">vec3</span> normal, <span class="type">vec3</span> fragPos, <span class="type">vec3</span> viewDir);</span><br><span class="line"><span class="type">vec3</span> CalcSpotLight(SpotLight light, <span class="type">vec3</span> norm, <span class="type">vec3</span> FragPos, <span class="type">vec3</span> viewDir);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="type">vec3</span> norm = <span class="built_in">normalize</span>(Normal);</span><br><span class="line">    <span class="type">vec3</span> viewDir = <span class="built_in">normalize</span>(viewPos - FragPos);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一阶段：定向光照</span></span><br><span class="line">    <span class="type">vec3</span> result = CalcDirLight(dirLight, norm, viewDir);</span><br><span class="line">    <span class="comment">// 第二阶段：点光源</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; NR_POINT_LIGHTS; i++)</span><br><span class="line">        result += CalcPointLight(pointLights[i], norm, FragPos, viewDir);    </span><br><span class="line">    <span class="comment">// 第三阶段：聚光</span></span><br><span class="line">    result += CalcSpotLight(spotLight, norm, FragPos, viewDir);    </span><br><span class="line"></span><br><span class="line">    FragColor = <span class="type">vec4</span>(result, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">vec3</span> CalcDirLight(DirLight light, <span class="type">vec3</span> normal, <span class="type">vec3</span> viewDir)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec3</span> df = <span class="type">vec3</span>(<span class="built_in">texture</span>(material.texture_diffuse1, TexCoords));</span><br><span class="line">    df *= <span class="type">vec3</span>(<span class="built_in">texture</span>(material.texture_diffuse2, TexCoords));</span><br><span class="line">    df *= <span class="type">vec3</span>(<span class="built_in">texture</span>(material.texture_diffuse3, TexCoords));</span><br><span class="line">    df *= <span class="type">vec3</span>(<span class="built_in">texture</span>(material.texture_diffuse4, TexCoords));</span><br><span class="line">    <span class="type">vec3</span> sp = <span class="type">vec3</span>(<span class="built_in">texture</span>(material.texture_specular1, TexCoords));</span><br><span class="line">    sp += <span class="type">vec3</span>(<span class="built_in">texture</span>(material.texture_specular2, TexCoords));</span><br><span class="line">    sp += <span class="type">vec3</span>(<span class="built_in">texture</span>(material.texture_specular3, TexCoords));</span><br><span class="line">    sp += <span class="type">vec3</span>(<span class="built_in">texture</span>(material.texture_specular4, TexCoords));</span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> lightDir = <span class="built_in">normalize</span>(-light.direction);</span><br><span class="line">    <span class="comment">// 漫反射着色</span></span><br><span class="line">    <span class="type">float</span> diff = <span class="built_in">max</span>(<span class="built_in">dot</span>(normal, lightDir), <span class="number">0.0</span>);</span><br><span class="line">    <span class="comment">// 镜面光着色</span></span><br><span class="line">    <span class="type">vec3</span> reflectDir = <span class="built_in">reflect</span>(-lightDir, normal);</span><br><span class="line">    <span class="type">float</span> spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(viewDir, reflectDir), <span class="number">0.0</span>), material.shininess);</span><br><span class="line">    <span class="comment">// 合并结果</span></span><br><span class="line">    <span class="type">vec3</span> ambient  = light.ambient  * <span class="type">vec3</span>(df);</span><br><span class="line">    <span class="type">vec3</span> diffuse  = light.diffuse  * diff * <span class="type">vec3</span>(df);</span><br><span class="line">    <span class="type">vec3</span> specular = light.specular * spec * <span class="type">vec3</span>(sp);</span><br><span class="line">    <span class="keyword">return</span> (ambient + diffuse + specular);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">vec3</span> CalcPointLight(PointLight light, <span class="type">vec3</span> normal, <span class="type">vec3</span> fragPos, <span class="type">vec3</span> viewDir)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec3</span> df = <span class="type">vec3</span>(<span class="built_in">texture</span>(material.texture_diffuse1, TexCoords));</span><br><span class="line">    df *= <span class="type">vec3</span>(<span class="built_in">texture</span>(material.texture_diffuse2, TexCoords));</span><br><span class="line">    df *= <span class="type">vec3</span>(<span class="built_in">texture</span>(material.texture_diffuse3, TexCoords));</span><br><span class="line">    df *= <span class="type">vec3</span>(<span class="built_in">texture</span>(material.texture_diffuse4, TexCoords));</span><br><span class="line">    <span class="type">vec3</span> sp = <span class="type">vec3</span>(<span class="built_in">texture</span>(material.texture_specular1, TexCoords));</span><br><span class="line">    sp += <span class="type">vec3</span>(<span class="built_in">texture</span>(material.texture_specular2, TexCoords));</span><br><span class="line">    sp += <span class="type">vec3</span>(<span class="built_in">texture</span>(material.texture_specular3, TexCoords));</span><br><span class="line">    sp += <span class="type">vec3</span>(<span class="built_in">texture</span>(material.texture_specular4, TexCoords));</span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> lightDir = <span class="built_in">normalize</span>(light.position - fragPos);</span><br><span class="line">    <span class="comment">// 漫反射着色</span></span><br><span class="line">    <span class="type">float</span> diff = <span class="built_in">max</span>(<span class="built_in">dot</span>(normal, lightDir), <span class="number">0.0</span>);</span><br><span class="line">    <span class="comment">// 镜面光着色</span></span><br><span class="line">    <span class="type">vec3</span> reflectDir = <span class="built_in">reflect</span>(-lightDir, normal);</span><br><span class="line">    <span class="type">float</span> spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(viewDir, reflectDir), <span class="number">0.0</span>), material.shininess);</span><br><span class="line">    <span class="comment">// 衰减</span></span><br><span class="line">    <span class="type">float</span> <span class="built_in">distance</span>    = <span class="built_in">length</span>(light.position - fragPos);</span><br><span class="line">    <span class="type">float</span> attenuation = <span class="number">1.0</span> / (light.constant + light.linear * <span class="built_in">distance</span> + </span><br><span class="line">                 light.quadratic * (<span class="built_in">distance</span> * <span class="built_in">distance</span>));    </span><br><span class="line">    <span class="comment">// 合并结果</span></span><br><span class="line">    <span class="type">vec3</span> ambient  = light.ambient  * <span class="type">vec3</span>(df);</span><br><span class="line">    <span class="type">vec3</span> diffuse  = light.diffuse  * diff * <span class="type">vec3</span>(df);</span><br><span class="line">    <span class="type">vec3</span> specular = light.specular * spec * <span class="type">vec3</span>(sp);</span><br><span class="line">    <span class="comment">// vec3 ambient  = light.ambient  * vec3(texture(material.texture_diffuse1, TexCoords));</span></span><br><span class="line">    <span class="comment">// vec3 diffuse  = light.diffuse  * diff * vec3(texture(material.texture_diffuse1, TexCoords));</span></span><br><span class="line">    <span class="comment">// vec3 specular = light.specular * spec * vec3(texture(material.texture_specular1, TexCoords));</span></span><br><span class="line">    ambient  *= attenuation;</span><br><span class="line">    diffuse  *= attenuation;</span><br><span class="line">    specular *= attenuation;</span><br><span class="line">    <span class="keyword">return</span> (ambient + diffuse + specular);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">vec3</span> CalcSpotLight(SpotLight light, <span class="type">vec3</span> norm, <span class="type">vec3</span> FragPos, <span class="type">vec3</span> viewDir) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec3</span> df = <span class="type">vec3</span>(<span class="built_in">texture</span>(material.texture_diffuse1, TexCoords));</span><br><span class="line">    df *= <span class="type">vec3</span>(<span class="built_in">texture</span>(material.texture_diffuse2, TexCoords));</span><br><span class="line">    df *= <span class="type">vec3</span>(<span class="built_in">texture</span>(material.texture_diffuse3, TexCoords));</span><br><span class="line">    df *= <span class="type">vec3</span>(<span class="built_in">texture</span>(material.texture_diffuse4, TexCoords));</span><br><span class="line">    <span class="type">vec3</span> sp = <span class="type">vec3</span>(<span class="built_in">texture</span>(material.texture_specular1, TexCoords));</span><br><span class="line">    sp += <span class="type">vec3</span>(<span class="built_in">texture</span>(material.texture_specular2, TexCoords));</span><br><span class="line">    sp += <span class="type">vec3</span>(<span class="built_in">texture</span>(material.texture_specular3, TexCoords));</span><br><span class="line">    sp += <span class="type">vec3</span>(<span class="built_in">texture</span>(material.texture_specular4, TexCoords));</span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> lightDir = <span class="built_in">normalize</span>(light.position - FragPos);</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> theta     = <span class="built_in">dot</span>(lightDir, <span class="built_in">normalize</span>(-light.direction));</span><br><span class="line">    <span class="type">float</span> epsilon   = light.cutOff - light.outerCutOff;</span><br><span class="line">    <span class="type">float</span> intensity = <span class="built_in">clamp</span>((theta - light.outerCutOff) / epsilon, <span class="number">0.0</span>, <span class="number">1.0</span>); </span><br><span class="line"></span><br><span class="line">    <span class="comment">//vec3 ambient  = light.ambient  * vec3(texture(material.texture_diffuse1, TexCoords));</span></span><br><span class="line">     <span class="type">vec3</span> ambient  = light.ambient  * <span class="type">vec3</span>(df);</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> diff = <span class="built_in">max</span>(<span class="built_in">dot</span>(norm, lightDir), <span class="number">0.0</span>); <span class="comment">// 是负数则认为是0</span></span><br><span class="line">    <span class="comment">// vec3 diffuse  = light.diffuse  * diff * vec3(texture(material.texture_diffuse1, TexCoords));</span></span><br><span class="line">    <span class="type">vec3</span> diffuse  = light.diffuse  * diff * <span class="type">vec3</span>(df);</span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> reflectDir = <span class="built_in">reflect</span>(-lightDir, norm);</span><br><span class="line">    <span class="type">float</span> spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(viewDir, reflectDir), <span class="number">0.0</span>), material.shininess);</span><br><span class="line">    <span class="comment">// vec3 specular = light.specular * spec * (vec3(texture(material.texture_specular1, TexCoords)));</span></span><br><span class="line">    <span class="type">vec3</span> specular = light.specular * spec * (<span class="type">vec3</span>(sp));</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> <span class="built_in">distance</span>    = <span class="built_in">length</span>(light.position - FragPos);</span><br><span class="line">    <span class="type">float</span> attenuation = <span class="number">1.0</span> / (light.constant + light.linear * <span class="built_in">distance</span> + </span><br><span class="line">                    light.quadratic * (<span class="built_in">distance</span> * <span class="built_in">distance</span>));</span><br><span class="line"></span><br><span class="line">    ambient  *= attenuation; </span><br><span class="line">    diffuse  *= attenuation * intensity;</span><br><span class="line">    specular *= attenuation * intensity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (ambient + diffuse + specular);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>图形学</category>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>LearnOpenGL摘要（入门五）</title>
    <url>/2024/04/10/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%BA%94%EF%BC%89/</url>
    <content><![CDATA[<h1 id="高级OpenGL（上）深度测试、模板测试、混合、面剔除、帧缓冲"><a href="#高级OpenGL（上）深度测试、模板测试、混合、面剔除、帧缓冲" class="headerlink" title="高级OpenGL（上）深度测试、模板测试、混合、面剔除、帧缓冲"></a>高级OpenGL（上）深度测试、模板测试、混合、面剔除、帧缓冲</h1><h2 id="一、深度测试"><a href="#一、深度测试" class="headerlink" title="一、深度测试"></a>一、深度测试</h2><p>前面我们运用了<code>深度缓冲(Depth Buffer)</code>，来防止被阻挡的面渲染到其它面的前面。</p>
<ul>
<li>深度缓冲（或z缓冲(z-buffer)）</li>
<li>深度值(Depth Value)</li>
</ul>
<p>OpenGL会执行深度测试</p>
<ul>
<li>如果这个测试通过了的话，深度缓冲将会更新为新的深度值</li>
<li>如果深度测试失败了，片段将会被丢弃。</li>
</ul>
<p>在片段着色器运行之后（以及模板测试(Stencil Testing)运行之后）在屏幕空间中运行的。</p>
<ul>
<li>屏幕空间坐标与通过OpenGL的glViewport所定义的视口密切相关</li>
<li>可以直接使用GLSL内建变量gl_FragCoord从片段着色器中直接访问<ul>
<li>gl_FragCoord的x和y分量代表了片段的屏幕空间坐标（其中(0, 0)位于左下角）</li>
<li>gl_FragCoord中也包含了一个z分量，它包含了片段真正的深度值。</li>
<li>z值就是需要与深度缓冲内容所对比的那个值。</li>
</ul>
</li>
</ul>
<span id="more"></span>



<blockquote>
<p>提前深度测试 Early Depth Testing</p>
<ul>
<li>允许深度测试在片段着色器之前运行</li>
<li>限制：在片段着色器中，不能再写入片段的深度值</li>
</ul>
</blockquote>
<h3 id="深度测试函数"><a href="#深度测试函数" class="headerlink" title="深度测试函数"></a>深度测试函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 启用深度测试</span></span><br><span class="line"><span class="built_in">glEnable</span>(GL_DEPTH_TEST);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空缓冲</span></span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置为只读的深度缓冲</span></span><br><span class="line"><span class="built_in">glDepthMask</span>(GL_FALSE);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置深度测试中的比较运算符</span></span><br><span class="line"><span class="built_in">glDepthFunc</span>(GL_LESS);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><img src="/2024/04/10/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%BA%94%EF%BC%89/image-20240408000701829.png" alt="image-20240408000701829"></p>
<h3 id="深度值精度"><a href="#深度值精度" class="headerlink" title="深度值精度"></a>深度值精度</h3><p>深度缓冲包含了一个介于0.0和1.0之间的深度值</p>
<ul>
<li><p>观察空间的z值可能是投影平截头体的<strong>近平面</strong>(Near)和<strong>远平面</strong>(Far)之间的任何值。</p>
</li>
<li><p>我们需要一种方式来将这些观察空间的z值变换到[0, 1]范围之间。</p>
<ul>
<li><p>线性变换（透视不正确）</p>
<ul>
<li><img src="/2024/04/10/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%BA%94%EF%BC%89/image-20240408103530872.png" alt="image-20240408103530872"></li>
</ul>
</li>
<li><p>非线性变换（在z值很小的时候提供非常高的精度，而在z值很大的时候提供更少的精度）</p>
<ul>
<li><img src="/2024/04/10/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%BA%94%EF%BC%89/image-20240408104759288.png" alt="image-20240408104759288"></li>
<li><img src="/2024/04/10/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%BA%94%EF%BC%89/image-20240408105153187.png" alt="image-20240408105153187" style="zoom:67%;"></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>​    </p>
<h3 id="深度缓冲可视化"><a href="#深度缓冲可视化" class="headerlink" title="深度缓冲可视化"></a>深度缓冲可视化</h3><p>片段着色器</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    FragColor = <span class="type">vec4</span>(<span class="type">vec3</span>(<span class="built_in">gl_FragCoord</span>.z), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>OpenGL默认是用非线性的方式计算深度值</li>
</ul>
<p><img src="/2024/04/10/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%BA%94%EF%BC%89/image-20240408131440932.png" alt="image-20240408131440932"></p>
<p>改为线性深度值</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> near = <span class="number">0.1</span>; </span><br><span class="line"><span class="type">float</span> far  = <span class="number">100.0</span>; </span><br><span class="line"></span><br><span class="line"><span class="type">float</span> LinearizeDepth(<span class="type">float</span> depth) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> z = depth * <span class="number">2.0</span> - <span class="number">1.0</span>; <span class="comment">// back to NDC </span></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">2.0</span> * near * far) / (far + near - z * (far - near));    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;             </span><br><span class="line">    <span class="type">float</span> depth = LinearizeDepth(<span class="built_in">gl_FragCoord</span>.z) / far; <span class="comment">// 为了演示除以 far</span></span><br><span class="line">    FragColor = <span class="type">vec4</span>(<span class="type">vec3</span>(depth), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/2024/04/10/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%BA%94%EF%BC%89/image-20240408132209083.png" alt="image-20240408132209083"></p>
<h3 id="深度冲突"><a href="#深度冲突" class="headerlink" title="深度冲突"></a>深度冲突</h3><p>深度冲突(Z-fighting)：一个很常见的视觉错误会在两个平面或者三角形非常紧密地平行排列在一起时会发生</p>
<ul>
<li>深度缓冲没有足够的精度来决定两个形状哪个在前面。</li>
<li>结果就是这两个形状不断地在切换前后顺序，这会导致很奇怪的花纹。</li>
<li>当物体在远处时效果会更明显（因为深度缓冲在z值比较大的时候有着更小的精度）。</li>
</ul>
<p>防止方法：</p>
<ul>
<li>不要把多个物体摆得太靠近</li>
<li>尽可能将<code>近平面</code>设置远一些</li>
<li>使用更高精度的深度缓冲(牺牲性能)</li>
</ul>
<h2 id="二、模板测试"><a href="#二、模板测试" class="headerlink" title="二、模板测试"></a>二、模板测试</h2><h3 id="模板测试"><a href="#模板测试" class="headerlink" title="模板测试"></a>模板测试</h3><ul>
<li><p>当片段着色器处理完一个片段之后，模板测试(Stencil Test)会开始执行。</p>
</li>
<li><p>和深度测试一样，它也可能会丢弃片段。</p>
</li>
<li><p>模板测试之后，被保留的片段会进入深度测试。</p>
</li>
</ul>
<h3 id="模板缓冲"><a href="#模板缓冲" class="headerlink" title="模板缓冲"></a>模板缓冲</h3><ul>
<li><p>一个模板缓冲中，（通常）每个模板值(Stencil Value)是8位的。所以每个像素&#x2F;片段一共能有256种不同的模板值。</p>
</li>
<li><p>我们可以将这些模板值设置为我们想要的值，然后当某一个片段有某一个模板值的时候，我们就可以选择丢弃或是保留这个片段了。</p>
</li>
<li><p>我们可以在渲染循环中更新模板缓冲</p>
</li>
</ul>
<blockquote>
<p>每个窗口库都需要为你配置一个模板缓冲。GLFW自动做了这件事，所以我们不需要告诉GLFW来创建一个，但其它的窗口库可能不会默认给你创建一个模板库，所以记得要查看库的文档。</p>
</blockquote>
<p><img src="/2024/04/10/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%BA%94%EF%BC%89/image-20240408133644746.png" alt="image-20240408133644746"></p>
<h3 id="模板测试操作流程"><a href="#模板测试操作流程" class="headerlink" title="模板测试操作流程"></a>模板测试操作流程</h3><ul>
<li>启用模板缓冲的写入。</li>
<li>渲染物体，更新模板缓冲的内容。</li>
<li>禁用模板缓冲的写入。</li>
<li>渲染（其它）物体，这次根据模板缓冲的内容丢弃特定的片段。</li>
</ul>
<p>通过使用模板缓冲，我们可以根据场景中已绘制的其它物体的片段，来决定是否丢弃特定的片段。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 启用</span></span><br><span class="line"><span class="built_in">glEnable</span>(GL_STENCIL_TEST);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除</span></span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 掩码设置（与将要写入缓冲的模板值进行与 AND 运算）</span></span><br><span class="line"><span class="built_in">glStencilMask</span>(<span class="number">0xFF</span>); <span class="comment">// 每一位写入模板缓冲时都保持原样</span></span><br><span class="line"><span class="built_in">glStencilMask</span>(<span class="number">0x00</span>); <span class="comment">// 每一位在写入模板缓冲时都会变成0（禁用写入）</span></span><br><span class="line"><span class="comment">// 大部分情况下你都只会使用0x00或者0xFF作为模板掩码(Stencil Mask)，但是知道有选项可以设置自定义的位掩码总是好的。</span></span><br></pre></td></tr></table></figure>





<h3 id="模板函数"><a href="#模板函数" class="headerlink" title="模板函数"></a>模板函数</h3><p>我们对模板缓冲应该通过还是失败，以及它应该如何影响模板缓冲，也是有一定控制的。</p>
<h4 id="glStencilFunc"><a href="#glStencilFunc" class="headerlink" title="glStencilFunc"></a>glStencilFunc</h4><p>设置如何比较模板值（如何进行模板测试）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glStencilFunc</span>(GLenum func, GLint ref, GLuint mask);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>func</code>：设置模板测试函数(Stencil Test Function)。这个测试函数将会应用到已储存的模板值上和glStencilFunc函数的<code>ref</code>值上。可用的选项有：<ul>
<li>GL_NEVER、GL_LESS、GL_LEQUAL、GL_GREATER、GL_GEQUAL、GL_EQUAL、GL_NOTEQUAL和GL_ALWAYS。</li>
<li>9它们的语义和深度缓冲的函数类似。</li>
</ul>
</li>
<li><code>ref</code>：设置了模板测试的参考值(Reference Value)。模板缓冲的内容将会与这个值进行比较。</li>
<li><code>mask</code>：设置一个掩码，它将会与参考值和储存的模板值在测试比较它们之前进行与(AND)运算。初始情况下所有位都为1。</li>
</ul>
<p>比如 <code>glStencilFunc(GL_EQUAL, 1, 0xFF)</code> 告诉OpenGL，只要一个片段的模板值等于(<code>GL_EQUAL</code>)参考值1，片段将会通过测试并被绘制，否则会被丢弃。</p>
<h4 id="glStencilOp"><a href="#glStencilOp" class="headerlink" title="glStencilOp"></a>glStencilOp</h4><p>设置何时更新模板缓冲</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">glStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>sfail</code>：模板测试失败时采取的行为。</li>
<li><code>dpfail</code>：模板测试通过，但深度测试失败时采取的行为。</li>
<li><code>dppass</code>：模板测试和深度测试都通过时采取的行为。</li>
</ul>
<p>每个选项都可以选用以下的其中一种行为：</p>
<p><img src="/2024/04/10/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%BA%94%EF%BC%89/image-20240408213132515.png" alt="image-20240408213132515"></p>
<ul>
<li>默认情况下glStencilOp是设置为<code>(GL_KEEP, GL_KEEP, GL_KEEP)</code>的，所以不论任何测试的结果是如何，模板缓冲都会保留它的值。</li>
<li>如果你想写入模板缓冲的话，你需要至少对其中一个选项设置不同的值。</li>
</ul>
<h3 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h3><ul>
<li>实现物体轮廓效果</li>
<li>边缘检测</li>
</ul>
<img src="/2024/04/10/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%BA%94%EF%BC%89/image-20240408220354364.png" alt="image-20240408220354364" style="zoom:67%;">

<p>实现步骤：</p>
<ol>
<li>在绘制（需要添加轮廓的）物体之前，将模板函数设置为GL_ALWAYS，每当物体的片段被渲染时，将模板缓冲更新为1。</li>
<li>渲染物体。</li>
<li>禁用模板写入以及深度测试。</li>
<li>将每个物体缩放一点点。</li>
<li>使用一个不同的片段着色器，输出一个单独的（边框）颜色。</li>
<li>再次绘制物体，但只在它们片段的模板值不等于1时才绘制。</li>
<li>再次启用模板写入和深度测试。</li>
</ol>
<p>大概如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glEnable</span>(GL_DEPTH_TEST);</span><br><span class="line"><span class="built_in">glStencilOp</span>(GL_KEEP, GL_KEEP, GL_REPLACE);  </span><br><span class="line"></span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT); </span><br><span class="line"></span><br><span class="line"><span class="built_in">glStencilMask</span>(<span class="number">0x00</span>); <span class="comment">// 记得保证我们在绘制地板的时候不会更新模板缓冲</span></span><br><span class="line">normalShader.<span class="built_in">use</span>();</span><br><span class="line"><span class="built_in">DrawFloor</span>()  </span><br><span class="line"></span><br><span class="line"><span class="built_in">glStencilFunc</span>(GL_ALWAYS, <span class="number">1</span>, <span class="number">0xFF</span>); </span><br><span class="line"><span class="built_in">glStencilMask</span>(<span class="number">0xFF</span>); </span><br><span class="line"><span class="built_in">DrawTwoContainers</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">glStencilFunc</span>(GL_NOTEQUAL, <span class="number">1</span>, <span class="number">0xFF</span>);</span><br><span class="line"><span class="built_in">glStencilMask</span>(<span class="number">0x00</span>); </span><br><span class="line"><span class="built_in">glDisable</span>(GL_DEPTH_TEST);</span><br><span class="line">shaderSingleColor.<span class="built_in">use</span>(); </span><br><span class="line"><span class="built_in">DrawTwoScaledUpContainers</span>();</span><br><span class="line"><span class="built_in">glStencilMask</span>(<span class="number">0xFF</span>);</span><br><span class="line"><span class="built_in">glEnable</span>(GL_DEPTH_TEST);  </span><br></pre></td></tr></table></figure>



<blockquote>
<p>（想想策略游戏中，我们希望选择10个单位，合并边框通常是我们想需要的结果）。如果你想让每个物体都有一个完整的边框，你需要对每个物体都清空模板缓冲，并有创意地利用深度缓冲。</p>
<p>除了物体轮廓之外，模板测试还有很多用途，比如在一个后视镜中绘制纹理，让它能够绘制到镜子形状中，或者使用一个叫做阴影体积(Shadow Volume)的模板缓冲技术渲染实时阴影。</p>
</blockquote>
<p>结果：在大个的模型中的效果有点怪(估计因为模型的模型空间原点是在两脚中间，所以缩放之后是往两边和往上扩的)</p>
<p><img src="/2024/04/10/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%BA%94%EF%BC%89/image-20240408233530800.png" alt="image-20240408233530800"></p>
<p><img src="/2024/04/10/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%BA%94%EF%BC%89/image-20240408233824043.png" alt="image-20240408233824043"></p>
<h2 id="三、混合"><a href="#三、混合" class="headerlink" title="三、混合"></a>三、混合</h2><h3 id="透明"><a href="#透明" class="headerlink" title="透明"></a>透明</h3><p>OpenGL中，<code>混合(Blending)</code>通常是实现物体<code>透明度(Transparency)</code>的一种技术</p>
<p>透明就是指：一个物体（或者其中的一部分）不是纯色(Solid Color)的，它的颜色是物体本身的颜色和它背后其它物体的颜色的不同强度结合。</p>
<p>全透明 VS <strong>半透明玻璃</strong></p>
<img src="/2024/04/10/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%BA%94%EF%BC%89/image-20240408235407377.png" alt="image-20240408235407377" style="zoom:80%;">



<p><strong>Alpha值</strong></p>
<p>一个物体的透明度是通过它颜色的alpha值来决定的，即RGBA中的A。</p>
<p>当alpha值为0.5时，物体的颜色有50%是来自物体自身的颜色，50%来自背后物体的颜色。</p>
<h3 id="全透明"><a href="#全透明" class="headerlink" title="全透明"></a>全透明</h3><p>用纹理贴图来实现 草 （草的形状很不规则，但是纹理图片是一个四边形）</p>
<ul>
<li>对于不想显示的部分，透明度alpha值为 0.0；</li>
<li>对于草的部分，透明度alpha值为 1.0；</li>
</ul>
<img src="/2024/04/10/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%BA%94%EF%BC%89/image-20240409003050121.png" alt="image-20240409003050121" style="zoom:50%;">

<p>实现注意：</p>
<ul>
<li><p>纹理生成时使用RGBA模式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGBA, width, height, <span class="number">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, data);</span><br></pre></td></tr></table></figure>
</li>
<li><p>在片段着色器中采样四个分量，而不是三个</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// FragColor = vec4(vec3(texture(texture1, TexCoords)), 1.0);</span></span><br><span class="line">    FragColor = <span class="built_in">texture</span>(texture1, TexCoords);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用glsl中的 <code>discard</code> 命令丢弃片段</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec2</span> TexCoords;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> texture1;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;             </span><br><span class="line">    <span class="type">vec4</span> texColor = <span class="built_in">texture</span>(texture1, TexCoords);</span><br><span class="line">    <span class="keyword">if</span>(texColor.a &lt; <span class="number">0.1</span>)</span><br><span class="line">        <span class="keyword">discard</span>;</span><br><span class="line">    FragColor = texColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p><strong>四边形贴图边缘出现半透明的边框</strong></p>
<p>注意，当采样纹理的边缘的时候，OpenGL会对边缘的值和纹理下一个重复的值进行插值（因为我们将它的环绕方式设置为了GL_REPEAT。这通常是没问题的，但是由于我们使用了透明值，纹理图像的顶部将会与底部边缘的纯色值进行插值。这样的结果是一个半透明的有色边框，你可能会看见它环绕着你的纹理四边形。要想避免这个，每当你alpha纹理的时候，请将纹理的环绕方式设置为GL_CLAMP_TO_EDGE：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glTexParameteri</span>( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</span><br><span class="line"><span class="built_in">glTexParameteri</span>( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="半透明"><a href="#半透明" class="headerlink" title="半透明"></a>半透明</h3><h4 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h4><p>直接丢弃片段不能用来渲染半透明的图像，需要使用混合。</p>
<ul>
<li>启用<code>混合</code>blending</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glEnable</span>(GL_BLEND);</span><br></pre></td></tr></table></figure>

<ul>
<li>混合公式</li>
</ul>
<img src="/2024/04/10/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%BA%94%EF%BC%89/image-20240409005516841.png" alt="image-20240409005516841" style="zoom:80%;">

<ul>
<li><p>混合的执行时机：片段着色器运行完成后，并且所有的测试都通过之后，这个混合方程(Blend Equation)才会应用到片段颜色输出与当前颜色缓冲中的值（当前片段之前储存的之前片段的颜色）上。</p>
</li>
<li><p>设置混合的因子值</p>
<ul>
<li><p>源颜色和目标颜色将会由OpenGL自动设定，但源因子和目标因子的值可以由我们来决定。</p>
</li>
<li><p>一般源因子值设为纹理的alpha值，目标因子值设为(1 - 纹理的alpha值)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glBlendFunc</span>(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</span><br></pre></td></tr></table></figure>


</li>
<li><p><code>glBlendFunc(GLenum sfactor, GLenum dfactor)</code>函数接受两个参数，来设置源和目标因子。</p>
</li>
<li><p>设置选项：<img src="/2024/04/10/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%BA%94%EF%BC%89/image-20240409010100035.png" alt="image-20240409010100035"></p>
</li>
<li><p>设置 C constant ：<code>glBlendColor函数</code></p>
</li>
<li><p>也可以使用<code>glBlendFuncSeparate</code>为 RGB 和 alpha 通道分别设置不同的选项：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glBlendFuncSeparate</span>(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ZERO);</span><br></pre></td></tr></table></figure>
</li>
<li><p>改变运算符：<code>glBlendEquation(GLenum mode)</code><br><img src="/2024/04/10/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%BA%94%EF%BC%89/image-20240409010758405.png" alt="image-20240409010758405"></p>
</li>
</ul>
</li>
</ul>
<h4 id="实操-1"><a href="#实操-1" class="headerlink" title="实操"></a>实操</h4><p>全透明加上半透明</p>
<ul>
<li>由于开启了混合Blending，全透明的效果可以不用丢弃片段的方式实现，但是不推荐。</li>
<li>但是深度测试和混合一起使用的话会产生一些麻烦，绘制多个半透明物体需要从后往前绘制才能正常。</li>
</ul>
<p>草使用discard丢弃片段的方式</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec2</span> TexCoords;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> texture1;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;             </span><br><span class="line">    <span class="type">vec4</span> texColor = <span class="built_in">texture</span>(texture1, TexCoords);</span><br><span class="line">    <span class="keyword">if</span>(texColor.a &lt; <span class="number">0.1</span>)</span><br><span class="line">        <span class="keyword">discard</span>;</span><br><span class="line">    FragColor = texColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>窗户使用混合的方式</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec2</span> TexCoords;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> texture1;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;             </span><br><span class="line">    FragColor = <span class="built_in">texture</span>(texture1, TexCoords);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h5><ul>
<li>正确</li>
</ul>
<p><img src="/2024/04/10/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%BA%94%EF%BC%89/image-20240409021823787.png" alt="image-20240409021823787"></p>
<ul>
<li>错误</li>
</ul>
<img src="/2024/04/10/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%BA%94%EF%BC%89/image-20240409021742322.png" alt="image-20240409021742322">

<ul>
<li><p>发生这一现象的原因是，深度测试和混合一起使用的话会产生一些麻烦。</p>
<ul>
<li>当写入深度缓冲时，深度缓冲不会检查片段是否是透明的，所以透明的部分会和其它值一样写入到深度缓冲中。</li>
<li>结果就是窗户的整个四边形不论透明度都会进行深度测试。</li>
<li>即使透明的部分应该显示背后的窗户，深度测试仍然丢弃了它们。</li>
</ul>
</li>
<li><p>跟渲染顺序有关</p>
<ul>
<li>从前往后：如果先绘制了位于前面的窗户，之后在绘制后面的窗户时，深度测试会将后面的窗户的片段丢弃</li>
<li>从后往前：如果先绘制了后面的窗户，则他们一开始不会被丢弃，即颜色会被先存到颜色缓冲中。之后绘制前面的窗户时，则可以用颜色缓冲中的颜色进行混合。</li>
</ul>
</li>
</ul>
<blockquote>
<p>当绘制一个有不透明和透明物体的场景的时候，大体的原则如下：</p>
<ol>
<li>先绘制所有不透明的物体。</li>
<li>对所有透明的物体排序。</li>
<li>按顺序绘制所有透明的物体。</li>
</ol>
</blockquote>
<blockquote>
<p>排序物体的一种方式</p>
<ul>
<li>从观察者视角获取物体的距离</li>
<li>通过计算摄像机位置向量和物体的位置向量之间的距离所获得</li>
<li>map会自动根据键值(Key)对它的值排序</li>
<li>按反序（由远到近）进行渲染</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&gt;std::map&lt;<span class="type">float</span>, glm::vec3&gt; sorted;</span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; windows.<span class="built_in">size</span>(); i++)</span><br><span class="line">&gt;&#123;</span><br><span class="line">   <span class="type">float</span> distance = glm::<span class="built_in">length</span>(camera.Position - windows[i]);</span><br><span class="line">   sorted[distance] = windows[i];</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">for</span>(std::map&lt;<span class="type">float</span>,glm::vec3&gt;::reverse_iterator it = sorted.<span class="built_in">rbegin</span>(); it != sorted.<span class="built_in">rend</span>(); ++it) </span><br><span class="line">&gt;&#123;</span><br><span class="line">   model = glm::<span class="built_in">mat4</span>();</span><br><span class="line">   model = glm::<span class="built_in">translate</span>(model, it-&gt;second);              </span><br><span class="line">   shader.<span class="built_in">setMat4</span>(<span class="string">&quot;model&quot;</span>, model);</span><br><span class="line">   <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">6</span>);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>



<p>欠缺：</p>
<ul>
<li>并没有考虑旋转、缩放或者其它的变换，奇怪形状的物体需要一个不同的计量，而不是仅仅一个位置向量</li>
<li>在场景中排序物体是一个很困难的技术，很大程度上由你场景的类型所决定，更别说它额外需要消耗的处理能力了。</li>
</ul>
</blockquote>
<blockquote>
<p>更高级的技术</p>
<ul>
<li>次序无关透明度(Order Independent Transparency, OIT)</li>
</ul>
</blockquote>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;public.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ShaderMgr.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;camera.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;part1.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Model.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">MyCamera g_camera;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> mixValue;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="comment">// positions          // normals           // texture coords</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 四边形窗户</span></span><br><span class="line"><span class="type">float</span> verticesWindow[] = &#123;</span><br><span class="line">    <span class="comment">// positions        // texture coords</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mixValue = <span class="number">0.2f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GLFW 窗口初始化</span></span><br><span class="line">    GLFWwindow* window = <span class="built_in">init_GLFW_window</span>(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;LearnOpenGL&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (window == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to initialize GLFW&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GLAD 函数地址初始化</span></span><br><span class="line">    <span class="keyword">if</span> (GL_FALSE == <span class="built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 相机初始化</span></span><br><span class="line">    g_camera.<span class="built_in">Init</span>(glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">3.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启深度缓冲</span></span><br><span class="line">    <span class="built_in">glEnable</span>(GL_DEPTH_TEST);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启和设置混合</span></span><br><span class="line">    <span class="built_in">glEnable</span>(GL_BLEND);</span><br><span class="line">    <span class="built_in">glBlendFunc</span>(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Grass 和 Window 共用 VBO 和 VAO</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> windowVBO;</span><br><span class="line">    <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;windowVBO);</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, windowVBO);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(verticesWindow), verticesWindow, GL_STATIC_DRAW);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> windowVAO;</span><br><span class="line">    <span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;windowVAO);</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(windowVAO);</span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">5</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">5</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)(<span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>)));</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 各用各的纹理</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> textureGrass;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* data1 = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">int</span> width1, height1, nrChannels1;</span><br><span class="line">    textureGrass = <span class="built_in">GenAndLoadTexture</span>(<span class="string">&quot;resource/grass.png&quot;</span>, &amp;width1, &amp;height1, &amp;nrChannels1, data1, GL_RGBA);</span><br><span class="line">    <span class="keyword">if</span> (textureGrass == <span class="number">-1</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;load texture failed1\n&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stbi_image_free</span>(data1);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> textureWindow;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* data2 = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">int</span> width2, height2, nrChannels2;</span><br><span class="line">    textureWindow = <span class="built_in">GenAndLoadTexture</span>(<span class="string">&quot;resource/blending_transparent_window.png&quot;</span>, &amp;width2, &amp;height2, &amp;nrChannels2, data2, GL_RGBA);</span><br><span class="line">    <span class="keyword">if</span> (textureWindow == <span class="number">-1</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;load texture failed2\n&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stbi_image_free</span>(data2);</span><br><span class="line"></span><br><span class="line">    std::vector&lt;glm::vec3&gt; vegetation;</span><br><span class="line">    vegetation.<span class="built_in">push_back</span>(glm::<span class="built_in">vec3</span>(<span class="number">-1.5f</span>, <span class="number">0.0f</span>, <span class="number">-0.48f</span>));</span><br><span class="line">    vegetation.<span class="built_in">push_back</span>(glm::<span class="built_in">vec3</span>(<span class="number">1.5f</span>, <span class="number">0.0f</span>, <span class="number">0.51f</span>));</span><br><span class="line">    vegetation.<span class="built_in">push_back</span>(glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.7f</span>));</span><br><span class="line">    vegetation.<span class="built_in">push_back</span>(glm::<span class="built_in">vec3</span>(<span class="number">-0.3f</span>, <span class="number">0.0f</span>, <span class="number">-2.3f</span>));</span><br><span class="line">    vegetation.<span class="built_in">push_back</span>(glm::<span class="built_in">vec3</span>(<span class="number">0.5f</span>, <span class="number">0.0f</span>, <span class="number">-0.6f</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 各用各的着色器</span></span><br><span class="line">    <span class="function">Shader <span class="title">blendShader</span><span class="params">(<span class="string">&quot;./BlendingVShader.glsl&quot;</span>, <span class="string">&quot;./BlendingFShader.glsl&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Shader <span class="title">discardShader</span><span class="params">(<span class="string">&quot;./BlendingVShader.glsl&quot;</span>, <span class="string">&quot;./DiscardFShader.glsl&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染循环</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))	<span class="comment">// 检查是否被要求退出窗口</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 输入处理</span></span><br><span class="line">        <span class="built_in">processInput</span>(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 帧渲染时间</span></span><br><span class="line">        <span class="type">float</span> deltaTime;</span><br><span class="line">        <span class="type">float</span> lastFrame = <span class="number">0</span>;</span><br><span class="line">        <span class="type">float</span> currentFrame = <span class="built_in">glfwGetTime</span>();</span><br><span class="line">        deltaTime = currentFrame - lastFrame;</span><br><span class="line">        lastFrame = currentFrame;</span><br><span class="line"></span><br><span class="line">        g_camera.<span class="built_in">SetSpeed</span>(deltaTime);</span><br><span class="line"></span><br><span class="line">        <span class="type">float</span> angle = <span class="number">2.0f</span> * (<span class="type">float</span>)<span class="built_in">glfwGetTime</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重置颜色缓冲和深度缓冲</span></span><br><span class="line">        <span class="built_in">glClearColor</span>(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算mvp变换矩阵</span></span><br><span class="line">        glm::mat4 view = g_camera.<span class="built_in">GetLookAt</span>();</span><br><span class="line">        glm::mat4 projection = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">        projection = glm::<span class="built_in">perspective</span>(glm::<span class="built_in">radians</span>(g_camera.<span class="built_in">GetFov</span>()), <span class="number">800.0f</span> / <span class="number">600.0f</span>, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">float</span> nowTime = <span class="built_in">glfwGetTime</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">glBindVertexArray</span>(windowVAO);</span><br><span class="line">        <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, windowVBO);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绘制草</span></span><br><span class="line">        &#123;</span><br><span class="line">            discardShader.<span class="built_in">use</span>();</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; vec : vegetation) &#123;</span><br><span class="line">                glm::mat4 model = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">                model = glm::<span class="built_in">translate</span>(model, vec);</span><br><span class="line">                model = glm::<span class="built_in">rotate</span>(model, glm::<span class="built_in">radians</span>(i*<span class="number">10.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">                discardShader.<span class="built_in">setMat4</span>(<span class="string">&quot;model&quot;</span>, model);</span><br><span class="line">                discardShader.<span class="built_in">setMat4</span>(<span class="string">&quot;view&quot;</span>, view);</span><br><span class="line">                discardShader.<span class="built_in">setMat4</span>(<span class="string">&quot;projection&quot;</span>, projection);</span><br><span class="line">                i++;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">glActiveTexture</span>(GL_TEXTURE0);</span><br><span class="line">                <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, textureGrass);</span><br><span class="line">                <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绘制窗户 </span></span><br><span class="line">        &#123;</span><br><span class="line">            blendShader.<span class="built_in">use</span>();</span><br><span class="line"></span><br><span class="line">            <span class="built_in">glActiveTexture</span>(GL_TEXTURE0);</span><br><span class="line">            <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, textureWindow);</span><br><span class="line"></span><br><span class="line">            std::vector&lt;glm::vec3&gt; windows;</span><br><span class="line">            windows.<span class="built_in">push_back</span>(glm::<span class="built_in">vec3</span>(<span class="number">1.2f</span>, <span class="number">0.0f</span>, <span class="number">-0.7f</span>));</span><br><span class="line">            windows.<span class="built_in">push_back</span>(glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line"></span><br><span class="line">            std::map&lt;<span class="type">float</span>, glm::vec3&gt; sorted;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">float</span> distance = glm::<span class="built_in">length</span>(g_camera.<span class="built_in">GetPos</span>() - windows[i]);</span><br><span class="line">                sorted[distance] = windows[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (std::map&lt;<span class="type">float</span>, glm::vec3&gt;::reverse_iterator it = sorted.<span class="built_in">rbegin</span>(); it != sorted.<span class="built_in">rend</span>(); ++it)</span><br><span class="line">            &#123;</span><br><span class="line">                glm::mat4 model = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">                model = glm::<span class="built_in">translate</span>(model, it-&gt;second);</span><br><span class="line">                model = glm::<span class="built_in">rotate</span>(model, glm::<span class="built_in">radians</span>(angle * <span class="number">3</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">                blendShader.<span class="built_in">setMat4</span>(<span class="string">&quot;model&quot;</span>, model);</span><br><span class="line">                blendShader.<span class="built_in">setMat4</span>(<span class="string">&quot;view&quot;</span>, view);</span><br><span class="line">                blendShader.<span class="built_in">setMat4</span>(<span class="string">&quot;projection&quot;</span>, projection);</span><br><span class="line">                <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">6</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 交换颜色缓冲，输出显示到屏幕</span></span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">        <span class="comment">// 检查有没有触发什么事件（比如键盘输入、鼠标移动等）、更新窗口状态，并调用对应的回调函数</span></span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>注意检查顶点着色器的属性布局，此处只有位置和纹理坐标</p>
</blockquote>
<h2 id="四、面剔除"><a href="#四、面剔除" class="headerlink" title="四、面剔除"></a>四、面剔除</h2><p>尝试在脑子中想象一个3D立方体，数数你从任意方向最多能同时看到几个面。</p>
<ul>
<li>最多 3 个</li>
</ul>
<p>对于<code>闭合形状的物体</code>，如果我们能够以某种方式丢弃看不见的面，我们能省下超过50%的片段着色器执行数</p>
<ul>
<li>任何一个闭合形状，它的每一个面都有两侧，每一侧要么<strong>面向</strong>用户，要么背对用户</li>
<li>只绘制<strong>面向</strong>观察者的面</li>
</ul>
<p>OpenGL 的面剔除(Face Culling)</p>
<ul>
<li>OpenGL能够检查所有面向(Front Facing)观察者的面，并渲染它们</li>
<li>并丢弃那些背向(Back Facing)的面</li>
</ul>
<blockquote>
<p>对于上一节中的草之类的，需要禁用背面剔除，因为其两面应该是可见的</p>
</blockquote>
<h4 id="环绕顺序"><a href="#环绕顺序" class="headerlink" title="环绕顺序"></a>环绕顺序</h4><p>我们如何知道一个物体的某一个面不能从观察者视角看到呢？</p>
<ul>
<li><p>分析顶点数据的环绕顺序</p>
<ul>
<li><p>用右手螺旋判断：认为逆时针是指向屏幕（正向），顺时针是背向屏幕（逆向）</p>
</li>
<li><img src="/2024/04/10/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%BA%94%EF%BC%89/image-20240409185603211.png" alt="image-20240409185603211" style="zoom:67%;">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="comment">// 顺时针</span></span><br><span class="line">    vertices[<span class="number">0</span>], <span class="comment">// 顶点1</span></span><br><span class="line">    vertices[<span class="number">1</span>], <span class="comment">// 顶点2</span></span><br><span class="line">    vertices[<span class="number">2</span>], <span class="comment">// 顶点3</span></span><br><span class="line">    <span class="comment">// 逆时针   逆时针顶点所定义的三角形将会被处理为正向三角形。</span></span><br><span class="line">    vertices[<span class="number">0</span>], <span class="comment">// 顶点1</span></span><br><span class="line">    vertices[<span class="number">2</span>], <span class="comment">// 顶点3</span></span><br><span class="line">    vertices[<span class="number">1</span>]  <span class="comment">// 顶点2  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


</li>
<li><p>实际的环绕顺序是在光栅化阶段中处理的，是在顶点着色器运行之后。</p>
<ul>
<li>以逆时针顺序定义顶点并且背向观察者的三角形的渲染顺序是顺时针的，也正是我们想要剔除的面</li>
<li>以1、2、3的顺序在观察者当面的视野看，后面的三角形是顺时针的<img src="/2024/04/10/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%BA%94%EF%BC%89/image-20240409193128354.png" alt="image-20240409193128354" style="zoom:67%;"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="剔除"><a href="#剔除" class="headerlink" title="剔除"></a>剔除</h4><p>OpenGL能够丢弃那些渲染为背向三角形的三角形图元。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开启</span></span><br><span class="line"><span class="built_in">glEnable</span>(GL_CULL_FACE);</span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定剔除哪种面</span></span><br><span class="line"><span class="built_in">glCullFace</span>(GL_FRONT);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>GL_BACK</code>：只剔除背向面。</li>
<li><code>GL_FRONT</code>：只剔除正向面。</li>
<li><code>GL_FRONT_AND_BACK</code>：剔除正向面和背向面。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定如何定义正向面</span></span><br><span class="line"><span class="built_in">glFrontFace</span>(GL_CCW);</span><br><span class="line"></span><br><span class="line"><span class="comment">// GL_CCW 逆时针</span></span><br><span class="line"><span class="comment">// GL_CW 顺时针</span></span><br></pre></td></tr></table></figure>





<p>剔除背面：</p>
<p><img src="/2024/04/10/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%BA%94%EF%BC%89/image-20240409202625747.png" alt="image-20240409202625747"></p>
<p>剔除正面：</p>
<p><img src="/2024/04/10/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%BA%94%EF%BC%89/image-20240409202725299.png" alt="image-20240409202725299"></p>
<p><img src="/2024/04/10/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%BA%94%EF%BC%89/image-20240409202754552.png" alt="image-20240409202754552"></p>
<h2 id="五、帧缓冲"><a href="#五、帧缓冲" class="headerlink" title="五、帧缓冲"></a>五、帧缓冲</h2><h3 id="帧缓冲"><a href="#帧缓冲" class="headerlink" title="帧缓冲"></a>帧缓冲</h3><p>各种屏幕缓冲，称为帧缓冲(Framebuffer)：</p>
<ul>
<li><p>用于写入颜色值的颜色缓冲</p>
</li>
<li><p>用于写入深度信息的深度缓冲</p>
</li>
<li><p>允许我们根据一些条件丢弃特定片段的模板缓冲</p>
</li>
<li><p>帧缓冲储存在内存中</p>
</li>
<li><p>OpenGL允许自定义颜色缓冲，甚至是深度缓冲和模板缓冲</p>
</li>
<li><p>默认的帧缓冲在创建窗口的时候就生成和配置了（GLFW帮我们做了这些）</p>
</li>
</ul>
<h4 id="帧缓冲API"><a href="#帧缓冲API" class="headerlink" title="帧缓冲API"></a>帧缓冲API</h4><p>创建 帧缓冲对象(Framebuffer Object, FBO):</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> fbo;</span><br><span class="line"><span class="built_in">glGenFramebuffers</span>(<span class="number">1</span>, &amp;fbo);</span><br></pre></td></tr></table></figure>

<p>绑定 (绑定后，所有的<strong>读取</strong>和<strong>写入</strong>帧缓冲的操作将会影响当前绑定的帧缓冲)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, fbo);</span><br><span class="line"></span><br><span class="line">- GL_FRAMEBUFFER 读取和写入目标</span><br><span class="line">- GL_READ_FRAMEBUFFER 读取目标</span><br><span class="line">- GL_DRAW_FRAMEBUFFER 写入目标</span><br><span class="line"><span class="comment">// 绑定到GL_READ_FRAMEBUFFER的帧缓冲将会使用在所有像是glReadPixels的读取操作中，而绑定到GL_DRAW_FRAMEBUFFER的帧缓冲将会被用作渲染、清除等写入操作的目标。</span></span><br></pre></td></tr></table></figure>



<p>上面的步骤还不够，一个完整的帧缓冲需要满足以下的条件：</p>
<ul>
<li>附加至少一个缓冲（颜色、深度或模板缓冲）。</li>
<li>至少有一个颜色附件(Attachment)。</li>
<li>所有的附件都必须是完整的（保留了内存）。</li>
<li>每个缓冲都应该有相同的样本数。</li>
</ul>
<p>以及检查当前绑定的帧缓冲是否完整</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">glCheckFramebufferStatus</span>(GL_FRAMEBUFFER) == GL_FRAMEBUFFER_COMPLETE)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 之后所有的渲染操作将会渲染到当前绑定帧缓冲的附件中</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>渲染到非默认的帧缓冲时，渲染指令将不会对窗口的视觉输出有任何影响：</p>
<ul>
<li>渲染到一个不同的帧缓冲，称为<code>离屏渲染</code>(Off-screen Rendering)</li>
</ul>
<p>重新绑定到默认帧缓冲</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>



<p>删除自定义帧缓冲对象</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glDeleteFramebuffers</span>(<span class="number">1</span>, &amp;fbo);</span><br></pre></td></tr></table></figure>



<h4 id="帧缓冲附件"><a href="#帧缓冲附件" class="headerlink" title="帧缓冲附件"></a>帧缓冲附件</h4><p>附件是一个内存位置，它能够作为帧缓冲的一个存储空间，可以将它想象为一个图像。</p>
<p>当创建一个附件的时候我们有两个选项：</p>
<ul>
<li>纹理</li>
<li>渲染缓冲对象(Renderbuffer Object)</li>
</ul>
<h5 id="纹理附件"><a href="#纹理附件" class="headerlink" title="纹理附件"></a>纹理附件</h5><ul>
<li>所有的渲染指令将会写入到这个纹理中，就像它是一个普通的颜色&#x2F;深度或模板缓冲一样。</li>
<li>所有渲染操作的结果将会被储存在一个纹理图像中</li>
<li>可以在着色器中很方便地使用得到的纹理</li>
</ul>
<p>为帧缓冲创建纹理（和之前差不多）</p>
<ul>
<li>将纹理维度设置为了屏幕大小（尽管这不是必须的）</li>
<li>给纹理的<code>data</code>参数传递了<code>NULL</code>，仅仅分配了内存，在渲染的时候才填充数据</li>
<li>不关心环绕方式或多级渐远纹理</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> texture;</span><br><span class="line"><span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;texture);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, <span class="number">800</span>, <span class="number">600</span>, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br></pre></td></tr></table></figure>

<p>附加到帧缓冲上</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glFramebufferTexture2D</span>(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texture, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>target</code>：帧缓冲的目标（绘制、读取或者两者皆有）</p>
</li>
<li><p><code>attachment</code>：我们想要附加的附件类型。当前我们正在附加一个颜色附件。注意最后的<code>0</code>意味着我们可以附加多个颜色附件。我们将在之后的教程中提到。</p>
</li>
<li><p><code>textarget</code>：你希望附加的纹理类型</p>
</li>
<li><p><code>texture</code>：要附加的纹理本身</p>
</li>
<li><p><code>level</code>：多级渐远纹理的级别。我们将它保留为0。</p>
</li>
<li><p>深度缓冲、模板缓冲的相关设置：</p>
<ul>
<li><p>要附加深度缓冲的话，我们将附件类型设置为GL_DEPTH_ATTACHMENT。</p>
<ul>
<li>注意纹理的格式(Format)和内部格式(Internalformat)类型将变为GL_DEPTH_COMPONENT，来反映深度缓冲的储存格式。</li>
</ul>
</li>
<li><p>要附加模板缓冲的话，你要将第二个参数设置为GL_STENCIL_ATTACHMENT，并将纹理的格式设定为GL_STENCIL_INDEX。</p>
</li>
<li><p>也可以将深度缓冲和模板缓冲附加为一个单独的纹理：</p>
<ul>
<li><p>纹理的每32位数值将包含24位的深度信息和8位的模板信息。</p>
</li>
<li><p>使用GL_DEPTH_STENCIL_ATTACHMENT类型，并配置纹理的格式</p>
</li>
<li><p>案例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glTexImage2D</span>(</span><br><span class="line">  GL_TEXTURE_2D, <span class="number">0</span>, GL_DEPTH24_STENCIL8, <span class="number">800</span>, <span class="number">600</span>, <span class="number">0</span>, </span><br><span class="line">  GL_DEPTH_STENCIL, GL_UNSIGNED_INT_24_8, <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glFramebufferTexture2D</span>(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_TEXTURE_2D, texture, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>如果你想将你的屏幕渲染到一个更小或更大的纹理上，你需要（在渲染到你的帧缓冲之前）再次调用<code>glViewport</code>，使用纹理的新维度作为参数，否则只有一小部分的纹理或屏幕会被渲染到这个纹理上。</p>
</blockquote>
<h5 id="渲染缓冲对象附件"><a href="#渲染缓冲对象附件" class="headerlink" title="渲染缓冲对象附件"></a>渲染缓冲对象附件</h5><ul>
<li><p>和纹理图像一样，渲染缓冲对象是一个真正的缓冲，即一系列的字节、整数、像素等。</p>
</li>
<li><p>渲染缓冲对象附加的好处是，它会将数据储存为OpenGL原生的渲染格式，它是为离屏渲染到帧缓冲优化过的。</p>
</li>
<li><p>渲染缓冲对象直接将所有的渲染数据储存到它的缓冲中，不会做任何针对纹理格式的转换，让它变为一个更快的可写储存介质。</p>
</li>
<li><p>渲染缓冲对象通常都是只写的，所以你不能读取它们（比如使用纹理访问）。</p>
<ul>
<li>经常用于深度和模板附件，因为大部分时间我们都不需要从深度和模板缓冲中读取值（采样），只关心深度和模板测试。</li>
</ul>
</li>
<li><p>当然你仍然还是能够使用glReadPixels来读取它，这会从当前绑定的帧缓冲中返回特定区域的像素，而不是附件本身。</p>
</li>
</ul>
<p>当我们不需要从缓冲中采样的时候，通常都会选择渲染缓冲对象，因为它会更优化一点。</p>
<ul>
<li><p>渲染缓冲对象是专门被设计作为帧缓冲附件使用的，而不是纹理那样的通用数据缓冲(General Purpose Data Buffer)</p>
</li>
<li><p>通常的选择依据：</p>
<ul>
<li>如果你不需要从一个缓冲中采样数据，那么对这个缓冲使用渲染缓冲对象会是明智的选择。</li>
<li>如果你需要从缓冲中采样颜色或深度值等数据，那么你应该选择纹理附件。</li>
</ul>
</li>
</ul>
<p>创建和绑定渲染缓冲对象</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> rbo;</span><br><span class="line"><span class="built_in">glGenRenderbuffers</span>(<span class="number">1</span>, &amp;rbo);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBindRenderbuffer</span>(GL_RENDERBUFFER, rbo);</span><br></pre></td></tr></table></figure>

<p>创建一个深度和模板渲染缓冲对象</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glRenderbufferStorage</span>(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, <span class="number">800</span>, <span class="number">600</span>);</span><br></pre></td></tr></table></figure>





<h4 id="实操-2"><a href="#实操-2" class="headerlink" title="实操"></a>实操</h4><p>目标</p>
<ul>
<li>将场景渲染到一个附加到帧缓冲对象上的颜色纹理中</li>
<li>之后将在一个横跨整个屏幕的四边形上绘制这个纹理</li>
<li>看到的结果其实和直接绘制到默认帧缓冲是一样的</li>
</ul>
<p>步骤</p>
<ol>
<li>将新的帧缓冲绑定为激活的帧缓冲，和往常一样渲染场景</li>
<li>绑定默认的帧缓冲</li>
<li>绘制一个横跨整个屏幕的四边形，将帧缓冲的颜色缓冲作为它的纹理</li>
</ol>
<p>注意一些事情</p>
<ul>
<li>第一，由于我们使用的每个帧缓冲都有它自己一套缓冲，我们希望设置合适的位，调用glClear，清除这些缓冲。</li>
<li>第二，当绘制四边形时，我们将禁用深度测试，因为我们是在绘制一个简单的四边形，并不需要关系深度测试。在绘制普通场景的时候我们将会重新启用深度测试。</li>
</ul>
<p>渲染迭代的内容be like</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一处理阶段(Pass)</span></span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, framebuffer);</span><br><span class="line"><span class="built_in">glClearColor</span>(<span class="number">0.1f</span>, <span class="number">0.1f</span>, <span class="number">0.1f</span>, <span class="number">1.0f</span>);</span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); <span class="comment">// 我们现在不使用模板缓冲</span></span><br><span class="line"><span class="built_in">glEnable</span>(GL_DEPTH_TEST);</span><br><span class="line"><span class="built_in">DrawScene</span>();    </span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二处理阶段</span></span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, <span class="number">0</span>); <span class="comment">// 返回默认</span></span><br><span class="line"><span class="built_in">glClearColor</span>(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>); </span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">screenShader.<span class="built_in">use</span>();  </span><br><span class="line"><span class="built_in">glBindVertexArray</span>(quadVAO);</span><br><span class="line"><span class="built_in">glDisable</span>(GL_DEPTH_TEST);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, textureColorbuffer);</span><br><span class="line"><span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">6</span>);  </span><br></pre></td></tr></table></figure>



<p>主要代码：</p>
<p>VAO，VBO设置（注意调用顺序）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// VBO 和 VAO（先bind VAO，之后再bind VBO设置数据，以及设置顶点属性指针）</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> cubeVBO;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> cubeVAO;</span><br><span class="line"><span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;cubeVAO);</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;cubeVBO);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(cubeVAO);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, cubeVBO);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(cubeVertices), cubeVertices, GL_STATIC_DRAW);</span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">5</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">5</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)(<span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>)));</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> quadVBO;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> quadVAO;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;quadVBO);</span><br><span class="line"><span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;quadVAO);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(quadVAO);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, quadVBO);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(quadVertices), quadVertices, GL_STATIC_DRAW);</span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">5</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">5</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)(<span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>)));</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>



<p>渲染循环内</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一处理阶段(Pass)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 绑定到新的帧缓冲，后续渲染的内容会被写入到帧缓冲附件上</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, framebuffer);</span><br><span class="line">    <span class="built_in">glEnable</span>(GL_DEPTH_TEST);</span><br><span class="line">    <span class="built_in">glClearColor</span>(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">    <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); <span class="comment">// 我们现在不使用模板缓冲</span></span><br><span class="line">    <span class="comment">// 开启面剔除</span></span><br><span class="line">    <span class="built_in">glEnable</span>(GL_CULL_FACE);</span><br><span class="line">    <span class="built_in">glCullFace</span>(GL_BACK);</span><br><span class="line">    <span class="comment">// Draw Scene</span></span><br><span class="line">    &#123;</span><br><span class="line">        boxShader.<span class="built_in">use</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算mvp变换矩阵</span></span><br><span class="line">        glm::mat4 view = g_camera.<span class="built_in">GetLookAt</span>();</span><br><span class="line">        glm::mat4 projection = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">        projection = glm::<span class="built_in">perspective</span>(glm::<span class="built_in">radians</span>(g_camera.<span class="built_in">GetFov</span>()), <span class="number">800.0f</span> / <span class="number">600.0f</span>, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br><span class="line">        glm::mat4 model = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">        boxShader.<span class="built_in">setMat4</span>(<span class="string">&quot;model&quot;</span>, model);</span><br><span class="line">        boxShader.<span class="built_in">setMat4</span>(<span class="string">&quot;view&quot;</span>, view);</span><br><span class="line">        boxShader.<span class="built_in">setMat4</span>(<span class="string">&quot;projection&quot;</span>, projection);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">glActiveTexture</span>(GL_TEXTURE0);</span><br><span class="line">        <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, textureBox);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">glBindVertexArray</span>(cubeVAO);</span><br><span class="line">        <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line">        <span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二处理阶段(Pass)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 绑定默认帧缓冲，渲染真正要显示到屏幕的内容</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, <span class="number">0</span>); </span><br><span class="line">    <span class="built_in">glClearColor</span>(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">    <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glDisable</span>(GL_DEPTH_TEST);</span><br><span class="line">    <span class="built_in">glDisable</span>(GL_CULL_FACE);</span><br><span class="line"></span><br><span class="line">    viewportShader.<span class="built_in">use</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glActiveTexture</span>(GL_TEXTURE0);</span><br><span class="line">    <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texColorBuffer);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(quadVAO);</span><br><span class="line">    <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">6</span>);</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="后处理"><a href="#后处理" class="headerlink" title="后处理"></a>后处理</h3><p>既然整个场景都被渲染到了一个纹理上，我们可以简单地通过修改纹理数据创建出一些非常有意思的效果。</p>
<h4 id="反相"><a href="#反相" class="headerlink" title="反相"></a>反相</h4><p>用1.0减去颜色分量</p>
<p>片段着色器</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    FragColor = <span class="type">vec4</span>(<span class="type">vec3</span>(<span class="number">1.0</span> - <span class="built_in">texture</span>(screenTexture, TexCoords)), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><img src="/2024/04/10/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%BA%94%EF%BC%89/image-20240410051624761.png" alt="image-20240410051624761"></p>
<h4 id="灰度"><a href="#灰度" class="headerlink" title="灰度"></a>灰度</h4><p>移除场景中除了黑白灰以外所有的颜色，让整个图像灰度化(Grayscale)</p>
<ul>
<li><p>简单的实现方式:</p>
<ul>
<li><p>取所有的颜色分量，将它们平均化</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    FragColor = <span class="built_in">texture</span>(screenTexture, TexCoords);</span><br><span class="line">    <span class="type">float</span> average = (FragColor.r + FragColor.g + FragColor.b) / <span class="number">3.0</span>;</span><br><span class="line">    FragColor = <span class="type">vec4</span>(average, average, average, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/10/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%BA%94%EF%BC%89/image-20240410051919957.png" alt="image-20240410051919957"></p>
</li>
</ul>
</li>
<li><p>采用加权通道：</p>
<ul>
<li><p>人眼会对绿色更加敏感一些，而对蓝色不那么敏感。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    FragColor = <span class="built_in">texture</span>(screenTexture, TexCoords);</span><br><span class="line">    <span class="type">float</span> average = <span class="number">0.2126</span> * FragColor.r + <span class="number">0.7152</span> * FragColor.g + <span class="number">0.0722</span> * FragColor.b;</span><br><span class="line">    FragColor = <span class="type">vec4</span>(average, average, average, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/10/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%BA%94%EF%BC%89/image-20240410052108845.png" alt="image-20240410052108845"></p>
</li>
</ul>
</li>
</ul>
<h4 id="核效果"><a href="#核效果" class="headerlink" title="核效果"></a>核效果</h4><p>在一个纹理图像上做后期处理的另外一个好处是，我们可以从纹理的其它地方采样颜色值。</p>
<p>比如说我们可以在当前纹理坐标的周围取一小块区域，对当前纹理值周围的多个纹理值进行采样。</p>
<h5 id="核"><a href="#核" class="headerlink" title="核"></a>核</h5><p>核(Kernel)（或卷积矩阵(Convolution Matrix)）是一个类矩阵的数值数组，它的中心为当前的像素，它会用它的核值乘以周围的像素值，并将结果相加变成一个值。</p>
<p>比如：</p>
<ul>
<li><img src="/2024/04/10/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%BA%94%EF%BC%89/image-20240410052255365.png" alt="image-20240410052255365" style="zoom:80%;"></li>
<li>这个核取了8个周围像素值，将它们乘以2，而把当前的像素乘以-15</li>
</ul>
<blockquote>
<p>你在网上找到的大部分核将所有的权重加起来之后都应该会等于1，如果它们加起来不等于1，这就意味着最终的纹理颜色将会比原纹理值更亮或者更暗了。</p>
</blockquote>
<h5 id="锐化-Sharpen"><a href="#锐化-Sharpen" class="headerlink" title="锐化(Sharpen)"></a>锐化(Sharpen)</h5><p>片段着色器</p>
<ul>
<li>使用 3X3 的核</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="type">float</span> <span class="keyword">offset</span> = <span class="number">1.0</span> / <span class="number">300.0</span>;  </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> offsets[<span class="number">9</span>] = <span class="type">vec2</span>[](</span><br><span class="line">        <span class="type">vec2</span>(-<span class="keyword">offset</span>,  <span class="keyword">offset</span>), <span class="comment">// 左上</span></span><br><span class="line">        <span class="type">vec2</span>( <span class="number">0.0</span>f,    <span class="keyword">offset</span>), <span class="comment">// 正上</span></span><br><span class="line">        <span class="type">vec2</span>( <span class="keyword">offset</span>,  <span class="keyword">offset</span>), <span class="comment">// 右上</span></span><br><span class="line">        <span class="type">vec2</span>(-<span class="keyword">offset</span>,  <span class="number">0.0</span>f),   <span class="comment">// 左</span></span><br><span class="line">        <span class="type">vec2</span>( <span class="number">0.0</span>f,    <span class="number">0.0</span>f),   <span class="comment">// 中</span></span><br><span class="line">        <span class="type">vec2</span>( <span class="keyword">offset</span>,  <span class="number">0.0</span>f),   <span class="comment">// 右</span></span><br><span class="line">        <span class="type">vec2</span>(-<span class="keyword">offset</span>, -<span class="keyword">offset</span>), <span class="comment">// 左下</span></span><br><span class="line">        <span class="type">vec2</span>( <span class="number">0.0</span>f,   -<span class="keyword">offset</span>), <span class="comment">// 正下</span></span><br><span class="line">        <span class="type">vec2</span>( <span class="keyword">offset</span>, -<span class="keyword">offset</span>)  <span class="comment">// 右下</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> kernel[<span class="number">9</span>] = <span class="type">float</span>[](</span><br><span class="line">        <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>,</span><br><span class="line">        <span class="number">-1</span>,  <span class="number">9</span>, <span class="number">-1</span>,</span><br><span class="line">        <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> sampleTex[<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sampleTex[i] = <span class="type">vec3</span>(<span class="built_in">texture</span>(screenTexture, TexCoords.st + offsets[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">vec3</span> col = <span class="type">vec3</span>(<span class="number">0.0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">        col += sampleTex[i] * kernel[i];</span><br><span class="line"></span><br><span class="line">    FragColor = <span class="type">vec4</span>(col, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/10/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%BA%94%EF%BC%89/image-20240410053047060.png" alt="image-20240410053047060"></p>
<h5 id="模糊（Blur）"><a href="#模糊（Blur）" class="headerlink" title="模糊（Blur）"></a>模糊（Blur）</h5><p>片段着色器</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> kernel[<span class="number">9</span>] = <span class="type">float</span>[](</span><br><span class="line">    <span class="number">1.0</span> / <span class="number">16</span>, <span class="number">2.0</span> / <span class="number">16</span>, <span class="number">1.0</span> / <span class="number">16</span>,</span><br><span class="line">    <span class="number">2.0</span> / <span class="number">16</span>, <span class="number">4.0</span> / <span class="number">16</span>, <span class="number">2.0</span> / <span class="number">16</span>,</span><br><span class="line">    <span class="number">1.0</span> / <span class="number">16</span>, <span class="number">2.0</span> / <span class="number">16</span>, <span class="number">1.0</span> / <span class="number">16</span>  </span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/10/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%BA%94%EF%BC%89/image-20240410053152431.png" alt="image-20240410053152431"></p>
<h5 id="边缘检测"><a href="#边缘检测" class="headerlink" title="边缘检测"></a>边缘检测</h5><ul>
<li><p>与锐化的核很相似</p>
</li>
<li><p>这个核高亮了所有的边缘，而暗化了其它部分，在我们只关心图像的边角的时候是非常有用的。</p>
</li>
</ul>
<p><img src="/2024/04/10/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%BA%94%EF%BC%89/image-20240410053336498.png" alt="image-20240410053336498"></p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> kernel[<span class="number">9</span>] = <span class="type">float</span>[](</span><br><span class="line">    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">    <span class="number">1</span>, <span class="number">-8</span>, <span class="number">1</span>,</span><br><span class="line">    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/10/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%BA%94%EF%BC%89/image-20240410053533355.png" alt="image-20240410053533355"></p>
<p><img src="/2024/04/10/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E4%BA%94%EF%BC%89/image-20240410053709733.png" alt="image-20240410053709733"></p>
<blockquote>
<p>注意，核在对屏幕纹理的边缘进行采样的时候，由于还会对中心像素周围的8个像素进行采样，其实会取到纹理之外的像素。由于环绕方式默认是GL_REPEAT，所以在没有设置的情况下取到的是屏幕另一边的像素，而另一边的像素本不应该对中心像素产生影响，这就可能会在屏幕边缘产生很奇怪的条纹。为了消除这一问题，我们可以将屏幕纹理的环绕方式都设置为GL_CLAMP_TO_EDGE。这样子在取到纹理外的像素时，就能够重复边缘的像素来更精确地估计最终的值了</p>
</blockquote>
]]></content>
      <categories>
        <category>图形学</category>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>LearnOpenGL摘要（六）</title>
    <url>/2024/04/14/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%85%AD%EF%BC%89/</url>
    <content><![CDATA[<h1 id="高级OpenGL（下）立方体贴图、高级数据、高级GLSL、几何着色器、实例化、抗锯齿"><a href="#高级OpenGL（下）立方体贴图、高级数据、高级GLSL、几何着色器、实例化、抗锯齿" class="headerlink" title="高级OpenGL（下）立方体贴图、高级数据、高级GLSL、几何着色器、实例化、抗锯齿"></a>高级OpenGL（下）立方体贴图、高级数据、高级GLSL、几何着色器、实例化、抗锯齿</h1><h2 id="一、立方体贴图"><a href="#一、立方体贴图" class="headerlink" title="一、立方体贴图"></a>一、立方体贴图</h2><h3 id="立方体贴图"><a href="#立方体贴图" class="headerlink" title="立方体贴图"></a>立方体贴图</h3><p>将多个纹理组合起来映射到一张纹理上的一种纹理类型：<code>立方体贴图(Cube Map)</code>。</p>
<ul>
<li>立方体贴图就是一个包含了6个2D纹理的纹理</li>
<li>一个非常有用的特性：可以通过一个<code>方向向量</code>来进行索引&#x2F;采样。<img src="/2024/04/14/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%85%AD%EF%BC%89/image-20240410135127885.png" alt="image-20240410135127885" style="zoom:50%;"></li>
<li>如何确定方向向量：<ul>
<li>从模型空间的原点出发，到顶点位置的方向向量</li>
<li>非顶点位置的方向向量可以根据周围的顶点插值求得</li>
</ul>
</li>
<li>纹理坐标：<ul>
<li>由方向向量，确定与立方体相交的面，以及在这个面上的UV坐标</li>
</ul>
</li>
</ul>
<p><strong>创建和使用立方体贴图</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建和绑定</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> textureID;</span><br><span class="line"><span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;textureID);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_CUBE_MAP, textureID);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分别给6个面生成纹理</span></span><br><span class="line"><span class="type">int</span> width, height, nrChannels;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *data;  </span><br><span class="line"><span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; textures_faces.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    data = <span class="built_in">stbi_load</span>(textures_faces[i].<span class="built_in">c_str</span>(), &amp;width, &amp;height, &amp;nrChannels, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glTexImage2D</span>(</span><br><span class="line">        GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, </span><br><span class="line">        <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 环绕和过滤方式</span></span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制图像之前要先激活纹理单元和绑定纹理</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>片段着色器：</p>
<ul>
<li><code>samplerCube</code> 立方体纹理采样器</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> textureDir; <span class="comment">// 代表3D纹理坐标的方向向量</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">samplerCube</span> cubemap; <span class="comment">// 立方体贴图的纹理采样器</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;             </span><br><span class="line">    FragColor = <span class="built_in">texture</span>(cubemap, textureDir);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="天空盒"><a href="#天空盒" class="headerlink" title="天空盒"></a>天空盒</h3><p>加载纹理</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">loadCubemap</span><span class="params">(vector&lt;std::string&gt; faces)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> textureID;</span><br><span class="line">    <span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;textureID);</span><br><span class="line">    <span class="built_in">glBindTexture</span>(GL_TEXTURE_CUBE_MAP, textureID);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> width, height, nrChannels;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; faces.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> *data = <span class="built_in">stbi_load</span>(faces[i].<span class="built_in">c_str</span>(), &amp;width, &amp;height, &amp;nrChannels, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (data)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">glTexImage2D</span>(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, </span><br><span class="line">                         <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data</span><br><span class="line">            );</span><br><span class="line">            <span class="built_in">stbi_image_free</span>(data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Cubemap texture failed to load at path: &quot;</span> &lt;&lt; faces[i] &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">stbi_image_free</span>(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> textureID;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;std::string&gt; faces</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;right.jpg&quot;</span>,</span><br><span class="line">    <span class="string">&quot;left.jpg&quot;</span>,</span><br><span class="line">    <span class="string">&quot;top.jpg&quot;</span>,</span><br><span class="line">    <span class="string">&quot;bottom.jpg&quot;</span>,</span><br><span class="line">    <span class="string">&quot;front.jpg&quot;</span>,</span><br><span class="line">    <span class="string">&quot;back.jpg&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> cubemapTexture = <span class="built_in">loadCubemap</span>(faces);</span><br></pre></td></tr></table></figure>



<p>顶点着色器</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> TexCoords;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> projection;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> view;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    TexCoords = aPos;</span><br><span class="line">    <span class="built_in">gl_Position</span> = projection * view * <span class="type">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>片段着色器</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> TexCoords;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">samplerCube</span> skybox;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;    </span><br><span class="line">    FragColor = <span class="built_in">texture</span>(skybox, TexCoords);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><img src="/2024/04/14/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%85%AD%EF%BC%89/image-20240410150233280.png" alt="image-20240410150233280"></p>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><ul>
<li>上面的做法是先在关闭深度测试的情况下渲染天空盒，然后开启深度测试并渲染其他东西</li>
<li>屏幕上的每一个像素都要运行一遍天空盒的片段着色器，即便只有一小部分的天空盒最终是可见的</li>
</ul>
<p>使用<code>提前深度测试</code>(Early Depth Testing)，提前丢弃掉天空盒的片段，节省宝贵的带宽。</p>
<ul>
<li><p>最后渲染天空盒，以获得轻微的性能提升</p>
</li>
<li><p>问题：天空盒距离相机的距离可能比场景物体更近，挡到其他物体</p>
</li>
<li><p>解决：</p>
<ul>
<li><p>让天空盒所有片段的深度值为1.0（最大值），若深度缓冲中对应位置已有的深度值更小，则不渲染天空盒片段。</p>
</li>
<li><p>如何让深度值为1.0：</p>
<ul>
<li><p>在顶点着色器中设置pos中的 z 分量为 w 分量的值（顶点着色器之后的透视除法会将 x y z 都除以 w 来转换到标准化设备坐标）</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    TexCoords = aPos;</span><br><span class="line">    <span class="type">vec4</span> pos = projection * view * <span class="type">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line">    <span class="built_in">gl_Position</span> = pos.xyww;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>将深度测试的比较方式改为<code>glDepthFunc(GL_LEQUAL);</code>使得深度值为1.0的天空盒片段能通过并写入深度缓冲。</p>
</li>
</ul>
</li>
</ul>
<p>渲染循环：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Draw Cube</span></span><br><span class="line">&#123;</span><br><span class="line">    boxShader.<span class="built_in">use</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算mvp变换矩阵</span></span><br><span class="line">    glm::mat4 view = g_camera.<span class="built_in">GetLookAt</span>();</span><br><span class="line">    glm::mat4 projection = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">    projection = glm::<span class="built_in">perspective</span>(glm::<span class="built_in">radians</span>(g_camera.<span class="built_in">GetFov</span>()), <span class="number">800.0f</span> / <span class="number">600.0f</span>, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br><span class="line">    glm::mat4 model = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">    boxShader.<span class="built_in">setMat4</span>(<span class="string">&quot;model&quot;</span>, model);</span><br><span class="line">    boxShader.<span class="built_in">setMat4</span>(<span class="string">&quot;view&quot;</span>, view);</span><br><span class="line">    boxShader.<span class="built_in">setMat4</span>(<span class="string">&quot;projection&quot;</span>, projection);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glActiveTexture</span>(GL_TEXTURE0);</span><br><span class="line">    <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, textureBox);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(cubeVAO);</span><br><span class="line">    <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Draw Skybox</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">glDepthFunc</span>(GL_LEQUAL);</span><br><span class="line"></span><br><span class="line">    skyShader.<span class="built_in">use</span>();</span><br><span class="line">    glm::mat4 view = glm::<span class="built_in">mat4</span>(glm::<span class="built_in">mat3</span>(g_camera.<span class="built_in">GetLookAt</span>()));</span><br><span class="line">    glm::mat4 projection = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">    projection = glm::<span class="built_in">perspective</span>(glm::<span class="built_in">radians</span>(g_camera.<span class="built_in">GetFov</span>()), <span class="number">800.0f</span> / <span class="number">600.0f</span>, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br><span class="line">    skyShader.<span class="built_in">setMat4</span>(<span class="string">&quot;view&quot;</span>, view);</span><br><span class="line">    skyShader.<span class="built_in">setMat4</span>(<span class="string">&quot;projection&quot;</span>, projection);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(skyVAO);</span><br><span class="line">    <span class="built_in">glBindTexture</span>(GL_TEXTURE_CUBE_MAP, textureSky);</span><br><span class="line">    <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glDepthFunc</span>(GL_LESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="环境映射"><a href="#环境映射" class="headerlink" title="环境映射"></a>环境映射</h3><p>环境映射</p>
<ul>
<li><p>将整个环境映射到了一个纹理对象上</p>
</li>
<li><p>通过使用环境的立方体贴图，我们可以给物体<code>反射</code>和<code>折射</code>的属性</p>
</li>
</ul>
<h4 id="反射-reflect"><a href="#反射-reflect" class="headerlink" title="反射 reflect"></a>反射 reflect</h4><ul>
<li><p>反射这个属性表现为物体（或物体的一部分）反射它周围环境</p>
</li>
<li><p>即根据观察者的视角，物体的颜色或多或少等于它周围的环境</p>
</li>
<li><p>镜子就是一个反射性物体：它会根据观察者的视角反射它周围的环境。</p>
</li>
<li><p>计算反射向量，使用这个向量来从立方体贴图中采样</p>
<ul>
<li>使用GLSL内建的reflect函数来计算这个反射向量</li>
</ul>
</li>
</ul>
<img src="/2024/04/14/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%85%AD%EF%BC%89/image-20240411140256300.png" alt="image-20240411140256300" style="zoom:67%;">



<p>修改箱子的片段着色器</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> Normal;</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> Position;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> cameraPos;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">samplerCube</span> skybox;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;             </span><br><span class="line">    <span class="type">vec3</span> I = <span class="built_in">normalize</span>(Position - cameraPos);</span><br><span class="line">    <span class="type">vec3</span> R = <span class="built_in">reflect</span>(I, <span class="built_in">normalize</span>(Normal));</span><br><span class="line">    FragColor = <span class="type">vec4</span>(<span class="built_in">texture</span>(skybox, R).rgb, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/2024/04/14/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%85%AD%EF%BC%89/image-20240411141455998.png" alt="image-20240411141455998"></p>
<p><img src="/2024/04/14/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%85%AD%EF%BC%89/image-20240411142026894.png" alt="image-20240411142026894"></p>
<blockquote>
<p>现实中大部分的模型都不具有完全反射性</p>
<p>可以引入反射贴图(Reflection Map)，来给模型更多的细节</p>
<ul>
<li>它决定了片段的反射性</li>
<li>模型的哪些部分该以什么强度显示反射</li>
</ul>
</blockquote>
<h4 id="折射-refract"><a href="#折射-refract" class="headerlink" title="折射 refract"></a>折射 refract</h4><ul>
<li>折射是光线由于传播介质的改变而产生的方向变化</li>
<li>将你的半只胳膊伸进水里，观察出来的就是这种效果</li>
<li><a href="https://en.wikipedia.org/wiki/Snell's_law">斯涅尔定律</a>(Snell’s Law)</li>
</ul>
<img src="/2024/04/14/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%85%AD%EF%BC%89/image-20240411142249987.png" alt="image-20240411142249987" style="zoom:67%;">

<ul>
<li><p>折射计算：使用GLSL的内建refract函数</p>
<ul>
<li>一个法向量</li>
<li>一个观察方向</li>
<li>两个材质之间的折射率(Refractive Index)的比值。</li>
</ul>
</li>
<li><p>折射率</p>
<ul>
<li>决定了材质中光线弯曲的程度</li>
<li><img src="/2024/04/14/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%85%AD%EF%BC%89/image-20240411142500061.png" alt="image-20240411142500061"></li>
<li>比如光线&#x2F;视线从<strong>空气</strong>进入<strong>玻璃</strong>：比值为 1.00&#x2F;1.52 &#x3D; 0.658</li>
</ul>
</li>
</ul>
<p>修改片段着色器</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> Normal;</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> Position;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> cameraPos;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">samplerCube</span> skybox;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;             </span><br><span class="line">    <span class="type">float</span> ratio = <span class="number">1.00</span> / <span class="number">1.52</span>;</span><br><span class="line">    <span class="type">vec3</span> I = <span class="built_in">normalize</span>(Position - cameraPos);</span><br><span class="line">    <span class="type">vec3</span> R = <span class="built_in">refract</span>(I, <span class="built_in">normalize</span>(Normal), ratio);</span><br><span class="line">    FragColor = <span class="type">vec4</span>(<span class="built_in">texture</span>(skybox, R).rgb, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><img src="/2024/04/14/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%85%AD%EF%BC%89/image-20240411143620540.png" alt="image-20240411143620540"></p>
<p><img src="/2024/04/14/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%85%AD%EF%BC%89/image-20240411143649781.png" alt="image-20240411143649781"></p>
<h4 id="动态环境贴图"><a href="#动态环境贴图" class="headerlink" title="动态环境贴图"></a>动态环境贴图</h4><p>静态环境映射</p>
<ul>
<li>只映射天空盒。</li>
<li>如果我们有一个镜子一样的物体，周围还有多个物体，镜子中可见的只有天空盒，看起来就像它是场景中唯一一个物体一样。</li>
</ul>
<p>动态环境映射(Dynamic Environment Mapping)</p>
<ul>
<li><p>通过使用帧缓冲，我们能够为物体的6个不同角度创建出场景的纹理，并在每个渲染迭代中将它们储存到一个立方体贴图中。</p>
</li>
<li><p>之后我们就可以使用这个（动态生成的）立方体贴图来创建出更真实的，包含其它物体的，反射和折射表面了。</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li>我们需要为每个使用环境贴图的物体渲染场景6次，这是非常大的性能开销</li>
<li>现代的程序通常会尽可能使用天空盒，并在可能的时候使用预编译的立方体贴图，只要它们能产生一点动态环境贴图的效果。</li>
</ul>
<h2 id="二、高级数据"><a href="#二、高级数据" class="headerlink" title="二、高级数据"></a>二、高级数据</h2><ul>
<li>OpenGL中使用缓冲来储存数据</li>
<li>操作缓冲其实还有更有意思的方式</li>
<li>使用纹理将大量数据传入着色器也有更有趣的方法</li>
</ul>
<h3 id="缓冲操作"><a href="#缓冲操作" class="headerlink" title="缓冲操作"></a>缓冲操作</h3><h4 id="内存分配和数据填充"><a href="#内存分配和数据填充" class="headerlink" title="内存分配和数据填充"></a>内存分配和数据填充</h4><p>OpenGL中的缓冲只是一个管理特定内存块的对象</p>
<p>在我们将它绑定到一个缓冲目标(Buffer Target)时，我们才赋予了其意义</p>
<ul>
<li>绑定一个缓冲到GL_ARRAY_BUFFER时，它就是一个顶点数组缓冲</li>
<li>也可以绑定到GL_ELEMENT_ARRAY_BUFFER等</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;cubeVBO);    </span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, cubeVBO);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(data), data, GL_STATIC_DRAW);</span><br><span class="line"><span class="comment">// 分配一块内存，并将数据添加到这块内存中。</span></span><br><span class="line"><span class="comment">// 如果我们将它的data参数设置为NULL，那么这个函数将只会分配内存，但不进行填充。</span></span><br><span class="line"><span class="comment">// 可用于 预留(Reserve) 特定大小的内存</span></span><br></pre></td></tr></table></figure>

<p>填充数据到缓冲内存：</p>
<ul>
<li>方法一：<code>glBufferSubData</code>函数（需要先用<code>glBufferData</code>分配好内存）</li>
<li>方法二：<code>glMapBuffer</code>函数，获取指向缓冲内存的指针，直接设置内存数据</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glBufferSubData</span>(GL_ARRAY_BUFFER, <span class="number">24</span>, <span class="built_in">sizeof</span>(data), &amp;data); <span class="comment">// 填充范围： [24, 24 + sizeof(data)]</span></span><br><span class="line"><span class="comment">// 填充缓冲的特定区域</span></span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line">    </span><br><span class="line"><span class="type">float</span> data[] = &#123;</span><br><span class="line">  <span class="number">0.5f</span>, <span class="number">1.0f</span>, <span class="number">-0.35f</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, buffer);</span><br><span class="line"><span class="comment">// 获取指针</span></span><br><span class="line"><span class="type">void</span> *ptr = <span class="built_in">glMapBuffer</span>(GL_ARRAY_BUFFER, GL_WRITE_ONLY);</span><br><span class="line"><span class="comment">// 复制数据到内存</span></span><br><span class="line"><span class="built_in">memcpy</span>(ptr, data, <span class="built_in">sizeof</span>(data));</span><br><span class="line"><span class="comment">// 记得告诉OpenGL我们不再需要这个指针了</span></span><br><span class="line"><span class="built_in">glUnmapBuffer</span>(GL_ARRAY_BUFFER);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果要直接映射数据到缓冲，而不事先将其存储到临时内存中，glMapBuffer这个函数会很有用。</p>
<p>比如说，你可以从文件中读取数据，并直接将它们复制到缓冲内存中。</p>
</blockquote>
<h4 id="分批顶点属性"><a href="#分批顶点属性" class="headerlink" title="分批顶点属性"></a>分批顶点属性</h4><p>之前学的方法：</p>
<ul>
<li>通过使用glVertexAttribPointer，我们能够指定顶点数组缓冲内容的属性布局。在顶点数组缓冲中，我们对属性进行了交错(Interleave)处理，也就是说，我们将每一个顶点的位置、法线和&#x2F;或纹理坐标紧密放置在一起。</li>
</ul>
<p>新的方法：</p>
<ul>
<li>将每一种属性类型的向量数据打包(Batch)为一个大的区块，而不是对它们进行交错储存。</li>
<li>与交错布局123123123123不同，我们将采用分批(Batched)的方式111122223333。</li>
</ul>
<p>使用<code>glBufferSubData</code>函数实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> positions[] = &#123; ... &#125;;</span><br><span class="line"><span class="type">float</span> normals[] = &#123; ... &#125;;</span><br><span class="line"><span class="type">float</span> tex[] = &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充缓冲</span></span><br><span class="line"><span class="built_in">glBufferSubData</span>(GL_ARRAY_BUFFER, <span class="number">0</span>, <span class="built_in">sizeof</span>(positions), &amp;positions);</span><br><span class="line"><span class="built_in">glBufferSubData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(positions), <span class="built_in">sizeof</span>(normals), &amp;normals);</span><br><span class="line"><span class="built_in">glBufferSubData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(positions) + <span class="built_in">sizeof</span>(normals), <span class="built_in">sizeof</span>(tex), &amp;tex);</span><br></pre></td></tr></table></figure>

<p>以及更新顶点属性指针</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), <span class="number">0</span>);  </span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)(<span class="built_in">sizeof</span>(positions)));  </span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(</span><br><span class="line">  <span class="number">2</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">2</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)(<span class="built_in">sizeof</span>(positions) + <span class="built_in">sizeof</span>(normals)));</span><br></pre></td></tr></table></figure>



<h4 id="复制缓冲"><a href="#复制缓冲" class="headerlink" title="复制缓冲"></a>复制缓冲</h4><p>当你的缓冲已经填充好数据之后，你可能会想与其它的缓冲共享其中的数据，或者想要将缓冲的内容复制到另一个缓冲当中。</p>
<p><code>glCopyBufferSubData</code>函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">glCopyBufferSubData</span><span class="params">(GLenum readtarget, GLenum writetarget, GLintptr readoffset, GLintptr writeoffset, GLsizeiptr size)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>复制源和复制目标的缓冲目标：</p>
<ul>
<li>比如说，我们可以将VERTEX_ARRAY_BUFFER缓冲复制到VERTEX_ELEMENT_ARRAY_BUFFER缓冲，分别将这些缓冲目标设置为读和写的目标。</li>
<li>当前绑定到这些缓冲目标的缓冲将会被影响到。</li>
</ul>
</li>
<li><p>对于复制源和复制目标为同样类型的缓冲目标的情况：</p>
<ul>
<li>OpenGL提供给我们另外两个缓冲目标，叫做GL_COPY_READ_BUFFER和GL_COPY_WRITE_BUFFER</li>
<li>将需要的缓冲绑定到这两个缓冲目标上，并将这两个目标作为<code>readtarget</code>和<code>writetarget</code>参数。</li>
</ul>
</li>
<li><p>使用过程类似：</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> vertexData[] = &#123; ... &#125;;</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_COPY_READ_BUFFER, vbo1);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_COPY_WRITE_BUFFER, vbo2);</span><br><span class="line"><span class="built_in">glCopyBufferSubData</span>(GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">sizeof</span>(vertexData));</span><br></pre></td></tr></table></figure>

<ul>
<li>也可以只将<code>writetarget</code>缓冲绑定为新的缓冲目标类型之一：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> vertexData[] = &#123; ... &#125;;</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo1);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_COPY_WRITE_BUFFER, vbo2);</span><br><span class="line"><span class="built_in">glCopyBufferSubData</span>(GL_ARRAY_BUFFER, GL_COPY_WRITE_BUFFER, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">sizeof</span>(vertexData));</span><br></pre></td></tr></table></figure>





<h2 id="三、高级glsl"><a href="#三、高级glsl" class="headerlink" title="三、高级glsl"></a>三、高级glsl</h2><p>内容：</p>
<ul>
<li>在组合使用OpenGL和GLSL创建程序时的一些<strong>最好要知道的东西</strong>，一些<strong>会让你生活更加轻松的特性</strong></li>
<li>一些有趣的内建变量(Built-in Variable)</li>
<li>管理着色器输入和输出的新方式</li>
<li>一个叫做Uniform缓冲对象(Uniform Buffer Object)的有用工具。</li>
</ul>
<h3 id="GLSL内建变量"><a href="#GLSL内建变量" class="headerlink" title="GLSL内建变量"></a>GLSL内建变量</h3><p>GLSL定义了以<code>gl_</code>为前缀的变量，它们能提供给我们更多的方式来读取&#x2F;写入数据。</p>
<h4 id="顶点着色器变量"><a href="#顶点着色器变量" class="headerlink" title="顶点着色器变量"></a>顶点着色器变量</h4><p><code>gl_Position</code></p>
<ul>
<li>顶点着色器的裁剪空间输出位置向量</li>
</ul>
<p><code>gl_PointSize</code></p>
<ul>
<li><p>使用图元 GL_POINTS 绘制 每一个顶点都将是一个图元，都会被渲染为一个点</p>
</li>
<li><p>对每个顶点使用不同的点大小，会在<code>粒子生成</code>之类的技术中很有意思</p>
<ul>
<li>通过OpenGL的glPointSize函数来设置渲染出来的点的大小</li>
<li>或者在顶点着色器中使用 gl_PointSize 设置点的大小</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glEnable</span>(GL_PROGRAM_POINT_SIZE);</span><br></pre></td></tr></table></figure>

<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = projection * view * model * <span class="type">vec4</span>(aPos, <span class="number">1.0</span>);    </span><br><span class="line">    <span class="built_in">gl_PointSize</span> = <span class="built_in">gl_Position</span>.z;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>gl_VertexID</code></p>
<ul>
<li><p><strong>输入变量</strong> gl_VertexID。</p>
</li>
<li><p>gl_Position和gl_PointSize都是<strong>输出变量</strong>，因为它们的值是作为顶点着色器的输出被读取的。</p>
</li>
<li><p>整型变量gl_VertexID储存了正在绘制顶点的当前ID。</p>
<ul>
<li>当（使用glDrawElements）进行索引渲染的时候，这个变量会存储正在绘制顶点的当前索引。</li>
<li>当（使用glDrawArrays）不使用索引进行绘制的时候，这个变量会储存从渲染调用开始的已处理顶点数量。</li>
</ul>
</li>
</ul>
<h4 id="片段着色器变量"><a href="#片段着色器变量" class="headerlink" title="片段着色器变量"></a>片段着色器变量</h4><p><code>gl_FragCoord</code></p>
<ul>
<li>一个只读(Read-only)变量</li>
<li>gl_FragCoord的z分量等于对应片段的深度值</li>
<li>gl_FragCoord的x和y分量是片段的窗口空间(Window-space)坐标，其原点为窗口的左下角</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;             </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">gl_FragCoord</span>.x &lt; <span class="number">400</span>)</span><br><span class="line">        FragColor = <span class="type">vec4</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        FragColor = <span class="type">vec4</span>(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><code>gl_FrontFacing</code></p>
<ul>
<li>告诉我们当前片段是属于正向面的一部分还是背向面的一部分</li>
<li>正向面和背向面分别使用不同的而纹理</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec2</span> TexCoords;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> frontTexture;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> backTexture;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;             </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">gl_FrontFacing</span>)</span><br><span class="line">        FragColor = <span class="built_in">texture</span>(frontTexture, TexCoords);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        FragColor = <span class="built_in">texture</span>(backTexture, TexCoords);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>gl_FragDepth</code></p>
<ul>
<li>输出变量</li>
<li>在着色器内设置片段的深度值（0.0 ~ 1.0）</li>
<li>只要我们在片段着色器中对gl_FragDepth进行写入，OpenGL就会禁用所有的提前深度测试(Early Depth Testing)。<ul>
<li>OpenGL无法在片段着色器运行<strong>之前</strong>得知片段将拥有的深度值，因为片段着色器可能会完全修改这个深度值。</li>
<li>从OpenGL 4.2起，我们仍可以对两者进行一定的调和，在片段着色器的顶部使用深度条件(Depth Condition)重新声明gl_FragDepth变量：<ul>
<li><code>layout (depth_&lt;condition&gt;) out float gl_FragDepth;</code></li>
<li>限定写入的深度值的条件，使得提前深度测试能够进行。</li>
<li><img src="/2024/04/14/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%85%AD%EF%BC%89/image-20240413161257556.png" alt="image-20240413161257556"></li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 420 core // 注意GLSL的版本！</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">depth_greater</span>) <span class="keyword">out</span> <span class="type">float</span> <span class="built_in">gl_FragDepth</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;             </span><br><span class="line">    FragColor = <span class="type">vec4</span>(<span class="number">1.0</span>);</span><br><span class="line">    <span class="built_in">gl_FragDepth</span> = <span class="built_in">gl_FragCoord</span>.z + <span class="number">0.1</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>







<h3 id="接口块"><a href="#接口块" class="headerlink" title="接口块"></a>接口块</h3><p>之前的 in out 数据都是一个变量。考虑如何处理 in out 数组和结构体。</p>
<p>声明与结构体类似</p>
<ul>
<li>顶点着色器</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec2</span> aTexCoords;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> model;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> view;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> projection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> VS_OUT</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> TexCoords;</span><br><span class="line">&#125; vs_out;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = projection * view * model * <span class="type">vec4</span>(aPos, <span class="number">1.0</span>);    </span><br><span class="line">    vs_out.TexCoords = aTexCoords;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<ul>
<li>片段着色器</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> VS_OUT</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> TexCoords;</span><br><span class="line">&#125; fs_in;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> <span class="built_in">texture</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;             </span><br><span class="line">    FragColor = <span class="built_in">texture</span>(<span class="built_in">texture</span>, fs_in.TexCoords);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="Uniform-缓冲对象"><a href="#Uniform-缓冲对象" class="headerlink" title="Uniform 缓冲对象"></a>Uniform 缓冲对象</h3><p>当使用多于一个的着色器时，尽管大部分的uniform变量都是相同的，我们还是需要不断地设置它们，所以为什么要这么麻烦地重复设置它们呢？</p>
<p><strong>UBO</strong></p>
<p>OpenGL为我们提供了一个叫做Uniform缓冲对象(Uniform Buffer Object)的工具，它允许我们定义一系列在多个着色器中相同的<strong>全局</strong>Uniform变量。</p>
<ul>
<li>顶点着色器<ul>
<li><code>layout (std140)</code>：设置了Uniform块布局(Uniform Block Layout)</li>
<li>将 投影矩阵 和 观察矩阵 放到共享的 uniform接口块 里。</li>
</ul>
</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">std140</span>) <span class="keyword">uniform</span> Matrices</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">mat4</span> projection;</span><br><span class="line">    <span class="type">mat4</span> view;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> model;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = projection * view * model * <span class="type">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Uniform块布局"><a href="#Uniform块布局" class="headerlink" title="Uniform块布局"></a>Uniform块布局</h4><ul>
<li>Uniform块的内容是储存在一个缓冲对象中的，它实际上只是一块预留内存，不会保存它具体保存的是什么类型的数据。</li>
<li>块布局告诉OpenGL内存的哪一部分对应着着色器中的哪一个uniform变量。</li>
</ul>
<p>默认布局</p>
<ul>
<li>共享(Shared)布局</li>
<li>一旦硬件定义了偏移量，它们在多个程序中是<strong>共享</strong>并一致的</li>
<li>GLSL是可以为了优化而对uniform变量的位置进行变动的，只要变量的顺序保持不变</li>
<li>共享布局给了我们很多节省空间的优化，但是我们需要查询每个uniform变量的偏移量</li>
</ul>
<p>std140布局</p>
<ul>
<li>每个变量的偏移量都是由一系列规则所决定的，这<strong>显式地</strong>声明了每个变量类型的内存布局</li>
<li>可以手动计算出每个变量的偏移量</li>
<li>每个变量都有一个基准对齐量(Base Alignment)，它等于一个变量在Uniform块中所占据的空间（包括填充量(Padding)）</li>
<li>对每个变量，我们再计算它的对齐偏移量(Aligned Offset)，它是一个变量从块起始位置的字节偏移量。一个变量的对齐字节偏移量<strong>必须</strong>等于基准对齐量的倍数。</li>
</ul>
<p><img src="/2024/04/14/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%85%AD%EF%BC%89/image-20240413165008180.png" alt="image-20240413165008180"></p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">layout</span> (<span class="keyword">std140</span>) <span class="keyword">uniform</span> ExampleBlock</span><br><span class="line">&#123;</span><br><span class="line">                     <span class="comment">// 基准对齐量       // 对齐偏移量</span></span><br><span class="line">    <span class="type">float</span> value;     <span class="comment">// 4               // 0 </span></span><br><span class="line">    <span class="type">vec3</span> vector;     <span class="comment">// 16              // 16  (必须是16的倍数，所以 4-&gt;16)</span></span><br><span class="line">    <span class="type">mat4</span> matrix;     <span class="comment">// 16              // 32  (列 0)</span></span><br><span class="line">                     <span class="comment">// 16              // 48  (列 1)</span></span><br><span class="line">                     <span class="comment">// 16              // 64  (列 2)</span></span><br><span class="line">                     <span class="comment">// 16              // 80  (列 3)</span></span><br><span class="line">    <span class="type">float</span> values[<span class="number">3</span>]; <span class="comment">// 16              // 96  (values[0])</span></span><br><span class="line">                     <span class="comment">// 16              // 112 (values[1])</span></span><br><span class="line">                     <span class="comment">// 16              // 128 (values[2])</span></span><br><span class="line">    <span class="type">bool</span> boolean;    <span class="comment">// 4               // 144</span></span><br><span class="line">    <span class="type">int</span> integer;     <span class="comment">// 4               // 148</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>



<p>紧凑(Packed)布局</p>
<ul>
<li>不能保证这个布局在每个程序中保持不变的（即非共享）</li>
<li>允许编译器去将uniform变量从Uniform块中优化掉</li>
</ul>
<h4 id="使用Uniform缓冲"><a href="#使用Uniform缓冲" class="headerlink" title="使用Uniform缓冲"></a>使用Uniform缓冲</h4><ul>
<li><p>创建一个Uniform缓冲对象</p>
</li>
<li><p>绑定到GL_UNIFORM_BUFFER目标</p>
</li>
<li><p>分配足够的内存</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> uboExampleBlock;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;uboExampleBlock);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_UNIFORM_BUFFER, uboExampleBlock);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_UNIFORM_BUFFER, <span class="number">152</span>, <span class="literal">NULL</span>, GL_STATIC_DRAW); <span class="comment">// 分配152字节的内存</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_UNIFORM_BUFFER, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>对缓冲更新或者插入数据:</p>
<ul>
<li>绑定到UBO对象，并使用glBufferSubData来更新它的内存</li>
</ul>
</li>
<li><p>如何才能让OpenGL知道哪个Uniform缓冲对应的是哪个Uniform块呢？</p>
<ul>
<li>OpenGL上下文中定义了一些<code>绑定点(Binding Point)</code></li>
<li>可以将一个Uniform缓冲对象链接至一个绑定点，并将着色器中的Uniform块绑定到相同的绑定点<img src="/2024/04/14/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%85%AD%EF%BC%89/image-20240413171701192.png" alt="image-20240413171701192" style="zoom:80%;"></li>
</ul>
</li>
</ul>
<p>使用方法</p>
<ul>
<li><p>绑定 着色器的Uniform块 到绑定点</p>
<ul>
<li>第一个参数是一个程序对象</li>
<li>之后是一个 Uniform块索引 和 链接到的绑定点<ul>
<li>Uniform块索引(Uniform Block Index)是着色器中已定义Uniform块的位置值索引</li>
<li>通过调用glGetUniformBlockIndex来获取</li>
</ul>
</li>
<li>注意我们需要对<strong>每个</strong>着色器程序对象重复这一步骤。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> lights_index = <span class="built_in">glGetUniformBlockIndex</span>(shaderA.ID, <span class="string">&quot;Lights&quot;</span>);   </span><br><span class="line"></span><br><span class="line"><span class="built_in">glUniformBlockBinding</span>(shaderA.ID, lights_index, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>从OpenGL 4.2版本起，你也可以添加一个布局标识符，显式地将Uniform块的绑定点储存在着色器中，这样就不用再调用glGetUniformBlockIndex和glUniformBlockBinding了。</p>
<p>下面的代码显式地设置了Lights Uniform块的绑定点</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">layout</span>(<span class="keyword">std140</span>, <span class="keyword">binding</span> = <span class="number">2</span>) <span class="keyword">uniform</span> Lights &#123; ... &#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>绑定 Uniform缓冲对象 到绑定点</p>
<ul>
<li><code>glBindbufferBase</code>需要 一个目标，一个绑定点索引和一个Uniform缓冲对象 作为它的参数。</li>
<li><code>glBindBufferRange</code>需要 一个附加的偏移量和大小参数 ，这样子你可以绑定Uniform缓冲的特定一部分到绑定点中。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glBindBufferBase</span>(GL_UNIFORM_BUFFER, <span class="number">2</span>, uboExampleBlock); </span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="built_in">glBindBufferRange</span>(GL_UNIFORM_BUFFER, <span class="number">2</span>, uboExampleBlock, <span class="number">0</span>, <span class="number">152</span>);</span><br></pre></td></tr></table></figure>


</li>
<li><p>设置 Uniform缓冲对象的数据</p>
<ul>
<li>使用glBufferSubData函数</li>
<li>同样的步骤也能应用到Uniform块中其它的uniform变量上，但需要使用不同的范围参数</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glBindBuffer</span>(GL_UNIFORM_BUFFER, uboExampleBlock);</span><br><span class="line"><span class="type">int</span> b = <span class="literal">true</span>; <span class="comment">// GLSL中的bool是4字节的，所以我们将它存为一个integer</span></span><br><span class="line"><span class="built_in">glBufferSubData</span>(GL_UNIFORM_BUFFER, <span class="number">144</span>, <span class="number">4</span>, &amp;b); </span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_UNIFORM_BUFFER, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>



<h4 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h4><p>如果我们回头看看之前所有的代码例子，我们不断地在使用3个矩阵：投影、观察和模型矩阵。在所有的这些矩阵中，只有模型矩阵会频繁变动。如果我们有多个着色器使用了这同一组矩阵，那么使用Uniform缓冲对象可能会更好。</p>
<p>顶点着色器</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">std140</span>) <span class="keyword">uniform</span> Matrices</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">mat4</span> projection;</span><br><span class="line">    <span class="type">mat4</span> view;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> model;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = projection * view * model * <span class="type">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>初始化代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 箱子着色器</span></span><br><span class="line"><span class="function">Shader <span class="title">shaderRed</span><span class="params">(<span class="string">&quot;./MoreGLSLVShader.glsl&quot;</span>, <span class="string">&quot;./MoreGLSLFShaderRed.glsl&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">Shader <span class="title">shaderGreen</span><span class="params">(<span class="string">&quot;./MoreGLSLVShader.glsl&quot;</span>, <span class="string">&quot;./MoreGLSLFShaderGreen.glsl&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">Shader <span class="title">shaderBlue</span><span class="params">(<span class="string">&quot;./MoreGLSLVShader.glsl&quot;</span>, <span class="string">&quot;./MoreGLSLFShaderBlue.glsl&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">Shader <span class="title">shaderYellow</span><span class="params">(<span class="string">&quot;./MoreGLSLVShader.glsl&quot;</span>, <span class="string">&quot;./MoreGLSLFShaderYellow.glsl&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Shader <span class="title">skyShader</span><span class="params">(<span class="string">&quot;./SkyboxVShader.glsl&quot;</span>, <span class="string">&quot;./SkyboxFShader.glsl&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将着色器程序的 uniform块 绑定到 绑定点0</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> uniformBlockIndexRed = <span class="built_in">glGetUniformBlockIndex</span>(shaderRed.ID, <span class="string">&quot;Matrices&quot;</span>);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> uniformBlockIndexGreen = <span class="built_in">glGetUniformBlockIndex</span>(shaderGreen.ID, <span class="string">&quot;Matrices&quot;</span>);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> uniformBlockIndexBlue = <span class="built_in">glGetUniformBlockIndex</span>(shaderBlue.ID, <span class="string">&quot;Matrices&quot;</span>);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> uniformBlockIndexYellow = <span class="built_in">glGetUniformBlockIndex</span>(shaderYellow.ID, <span class="string">&quot;Matrices&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glUniformBlockBinding</span>(shaderRed.ID, uniformBlockIndexRed, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glUniformBlockBinding</span>(shaderGreen.ID, uniformBlockIndexGreen, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glUniformBlockBinding</span>(shaderBlue.ID, uniformBlockIndexBlue, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glUniformBlockBinding</span>(shaderYellow.ID, uniformBlockIndexYellow, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 UBO</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> uboMatrices;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;uboMatrices);</span><br><span class="line"><span class="comment">// 分配 UBO 的内存</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_UNIFORM_BUFFER, uboMatrices);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_UNIFORM_BUFFER, <span class="number">2</span> * <span class="built_in">sizeof</span>(glm::mat4), <span class="literal">NULL</span>, GL_STATIC_DRAW);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_UNIFORM_BUFFER, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 绑定 UBO 到 绑定点0</span></span><br><span class="line"><span class="built_in">glBindBufferRange</span>(GL_UNIFORM_BUFFER, <span class="number">0</span>, uboMatrices, <span class="number">0</span>, <span class="number">2</span> * <span class="built_in">sizeof</span>(glm::mat4));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>渲染循环内</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 计算变换矩阵</span></span><br><span class="line">glm::mat4 view = g_camera.<span class="built_in">GetLookAt</span>();</span><br><span class="line">glm::mat4 projection = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">projection = glm::<span class="built_in">perspective</span>(glm::<span class="built_in">radians</span>(g_camera.<span class="built_in">GetFov</span>()), <span class="number">800.0f</span> / <span class="number">600.0f</span>, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 投影变换 和 视图变换 的矩阵数据到 ubo</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_UNIFORM_BUFFER, uboMatrices);</span><br><span class="line"><span class="built_in">glBufferSubData</span>(GL_UNIFORM_BUFFER, <span class="number">0</span>, <span class="built_in">sizeof</span>(glm::mat4), glm::<span class="built_in">value_ptr</span>(projection));</span><br><span class="line"><span class="built_in">glBufferSubData</span>(GL_UNIFORM_BUFFER, <span class="built_in">sizeof</span>(glm::mat4), <span class="built_in">sizeof</span>(glm::mat4), glm::<span class="built_in">value_ptr</span>(view));</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_UNIFORM_BUFFER, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">glEnable</span>(GL_DEPTH_TEST);</span><br><span class="line">    <span class="built_in">glClearColor</span>(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">    <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Draw Cube</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glBindVertexArray</span>(cubeVAO);</span><br><span class="line"></span><br><span class="line">        glm::mat4 model;</span><br><span class="line"></span><br><span class="line">        shaderRed.<span class="built_in">use</span>();</span><br><span class="line">        model = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">        model = glm::<span class="built_in">translate</span>(model, glm::<span class="built_in">vec3</span>(<span class="number">-0.75f</span>, <span class="number">0.75f</span>, <span class="number">0.0f</span>));  </span><br><span class="line">        shaderRed.<span class="built_in">setMat4</span>(<span class="string">&quot;model&quot;</span>, model);</span><br><span class="line">        <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line"></span><br><span class="line">        shaderGreen.<span class="built_in">use</span>();</span><br><span class="line">        model = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">        model = glm::<span class="built_in">translate</span>(model, glm::<span class="built_in">vec3</span>(<span class="number">0.75f</span>, <span class="number">0.75f</span>, <span class="number">0.0f</span>));  </span><br><span class="line">        shaderGreen.<span class="built_in">setMat4</span>(<span class="string">&quot;model&quot;</span>, model);</span><br><span class="line">        <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line"></span><br><span class="line">        shaderBlue.<span class="built_in">use</span>();</span><br><span class="line">        model = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">        model = glm::<span class="built_in">translate</span>(model, glm::<span class="built_in">vec3</span>(<span class="number">0.75f</span>, <span class="number">-0.75f</span>, <span class="number">0.0f</span>));  </span><br><span class="line">        shaderBlue.<span class="built_in">setMat4</span>(<span class="string">&quot;model&quot;</span>, model);</span><br><span class="line">        <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line"></span><br><span class="line">        shaderYellow.<span class="built_in">use</span>();</span><br><span class="line">        model = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">        model = glm::<span class="built_in">translate</span>(model, glm::<span class="built_in">vec3</span>(<span class="number">-0.75f</span>, <span class="number">-0.75f</span>, <span class="number">0.0f</span>));  </span><br><span class="line">        shaderYellow.<span class="built_in">setMat4</span>(<span class="string">&quot;model&quot;</span>, model);</span><br><span class="line">        <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>





<p>结果</p>
<p><img src="/2024/04/14/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%85%AD%EF%BC%89/image-20240413221821026.png" alt="image-20240413221821026"></p>
<h2 id="四、几何着色器"><a href="#四、几何着色器" class="headerlink" title="四、几何着色器"></a>四、几何着色器</h2><p>在顶点和片段着色器之间有一个可选的<code>几何着色器(Geometry Shader)</code></p>
<ul>
<li><p>几何着色器的输入是<code>一个图元（如点或三角形）的一组顶点</code></p>
</li>
<li><p>在顶点发送到下一着色器阶段之前对它们随意变换</p>
</li>
<li><p>能够将（这一组）顶点变换为完全不同的图元</p>
</li>
<li><p>还能生成比原来更多的顶点</p>
</li>
</ul>
<h3 id="基本内容"><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h3><p>几何着色器案例：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">points</span>) <span class="keyword">in</span>;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">line_strip</span>, <span class="keyword">max_vertices</span> = <span class="number">2</span>) <span class="keyword">out</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;    </span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="built_in">gl_in</span>[<span class="number">0</span>].<span class="built_in">gl_Position</span> + <span class="type">vec4</span>(<span class="number">-0.1</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>); </span><br><span class="line">    <span class="built_in">EmitVertex</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="built_in">gl_in</span>[<span class="number">0</span>].<span class="built_in">gl_Position</span> + <span class="type">vec4</span>( <span class="number">0.1</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">    <span class="built_in">EmitVertex</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">EndPrimitive</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>声明从顶点着色器输入的图元类型：<code>layout (points) in;</code></p>
<ul>
<li><code>points</code>：绘制GL_POINTS图元时（1）</li>
<li><code>lines</code>：绘制GL_LINES或GL_LINE_STRIP时（2）</li>
<li><code>lines_adjacency</code>：GL_LINES_ADJACENCY或GL_LINE_STRIP_ADJACENCY（4）</li>
<li><code>triangles</code>：GL_TRIANGLES、GL_TRIANGLE_STRIP或GL_TRIANGLE_FAN（3）</li>
<li><code>triangles_adjacency</code>：GL_TRIANGLES_ADJACENCY或GL_TRIANGLE_STRIP_ADJACENCY（6）</li>
<li>括号内的数字表示的是一个图元所包含的最小顶点数</li>
</ul>
</li>
<li><p>指定几何着色器输出的图元类型，以及该几何着色器能够输出的最大的顶点数量：<code>layout (line_strip, max_vertices = 2) out;</code></p>
<ul>
<li><code>points</code></li>
<li><code>line_strip</code></li>
<li><code>triangle_strip</code></li>
</ul>
</li>
<li><p>用于传递顶点着色器输出的GLSL内建变量</p>
<ul>
<li>被声明为一个数组，因为大多数的渲染图元包含多于1个的顶点</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">in</span> <span class="built_in">gl_Vertex</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec4</span>  <span class="built_in">gl_Position</span>;</span><br><span class="line">    <span class="type">float</span> <span class="built_in">gl_PointSize</span>;</span><br><span class="line">    <span class="type">float</span> <span class="built_in">gl_ClipDistance</span>[];</span><br><span class="line">&#125; <span class="built_in">gl_in</span>[];</span><br></pre></td></tr></table></figure>
</li>
<li><p>2个几何着色器函数，<code>EmitVertex</code>和<code>EndPrimitive</code></p>
<ul>
<li>调用<code>EmitVertex</code>时，gl_Position中的向量会被添加到图元中</li>
<li>调用<code>EndPrimitive</code>时，所有发射出的(Emitted)顶点都会合成为指定的输出渲染图元</li>
<li>几何着色器希望你能够生成并输出至少一个定义为输出的图元。</li>
<li>在我们的例子中，我们需要至少生成一个线条图元。</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="built_in">gl_in</span>[<span class="number">0</span>].<span class="built_in">gl_Position</span> + <span class="type">vec4</span>(<span class="number">-0.1</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>); </span><br><span class="line">    <span class="built_in">EmitVertex</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="built_in">gl_in</span>[<span class="number">0</span>].<span class="built_in">gl_Position</span> + <span class="type">vec4</span>( <span class="number">0.1</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">    <span class="built_in">EmitVertex</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">EndPrimitive</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>效果</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glDrawArrays</span>(GL_POINTS, <span class="number">0</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<img src="/2024/04/14/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%85%AD%EF%BC%89/image-20240413234118641.png" alt="image-20240413234118641" style="zoom:80%;"></li>
</ul>
<h3 id="使用几何着色器"><a href="#使用几何着色器" class="headerlink" title="使用几何着色器"></a>使用几何着色器</h3><h4 id="传递-Pass-through-几何着色器"><a href="#传递-Pass-through-几何着色器" class="headerlink" title="传递(Pass-through)几何着色器"></a>传递(Pass-through)几何着色器</h4><ul>
<li><p>直接原封不动地将顶点着色器地数据，传递给片段着色器</p>
</li>
<li><p>定义</p>
</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">points</span>) <span class="keyword">in</span>;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">points</span>, <span class="keyword">max_vertices</span> = <span class="number">1</span>) <span class="keyword">out</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;    </span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="built_in">gl_in</span>[<span class="number">0</span>].<span class="built_in">gl_Position</span>; </span><br><span class="line">    <span class="built_in">EmitVertex</span>();</span><br><span class="line">    <span class="built_in">EndPrimitive</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>着色器代码编译<ul>
<li>使用GL_GEOMETRY_SHADER作为着色器类型</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">geometryShader = <span class="built_in">glCreateShader</span>(GL_GEOMETRY_SHADER);</span><br><span class="line"><span class="built_in">glShaderSource</span>(geometryShader, <span class="number">1</span>, &amp;gShaderCode, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">glCompileShader</span>(geometryShader);  </span><br><span class="line">...</span><br><span class="line"><span class="built_in">glAttachShader</span>(program, geometryShader);</span><br><span class="line"><span class="built_in">glLinkProgram</span>(program);</span><br></pre></td></tr></table></figure>



<h4 id="画三角形"><a href="#画三角形" class="headerlink" title="画三角形"></a>画三角形</h4><ul>
<li>将几何着色器的输出设置为 <code>triangle_strip</code><ul>
<li><code>triangle_strip</code>在第一个三角形绘制完之后，每个后续顶点将会在上一个三角形边上生成另一个三角形</li>
<li>需要按一定的顺序传入三角形顶点</li>
</ul>
</li>
<li>绘制三个三角形：其中两个组成一个正方形，另一个用作房顶。<img src="/2024/04/14/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%85%AD%EF%BC%89/image-20240414000146491.png" alt="image-20240414000146491" style="zoom:60%;"></li>
</ul>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">points</span>) <span class="keyword">in</span>;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">triangle_strip</span>, <span class="keyword">max_vertices</span> = <span class="number">5</span>) <span class="keyword">out</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> VS_OUT &#123;</span><br><span class="line">    <span class="type">vec3</span> color;</span><br><span class="line">&#125; gs_in[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> fColor;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> build_house(<span class="type">vec4</span> position)</span><br><span class="line">&#123;    </span><br><span class="line">    fColor = gs_in[<span class="number">0</span>].color; <span class="comment">// gs_in[0] 因为只有一个输入顶点</span></span><br><span class="line">    <span class="built_in">gl_Position</span> = position + <span class="type">vec4</span>(<span class="number">-0.2</span>, <span class="number">-0.2</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);    <span class="comment">// 1:左下  </span></span><br><span class="line">    <span class="built_in">EmitVertex</span>();   </span><br><span class="line">    <span class="built_in">gl_Position</span> = position + <span class="type">vec4</span>( <span class="number">0.2</span>, <span class="number">-0.2</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);    <span class="comment">// 2:右下</span></span><br><span class="line">    <span class="built_in">EmitVertex</span>();</span><br><span class="line">    <span class="built_in">gl_Position</span> = position + <span class="type">vec4</span>(<span class="number">-0.2</span>,  <span class="number">0.2</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);    <span class="comment">// 3:左上</span></span><br><span class="line">    <span class="built_in">EmitVertex</span>();</span><br><span class="line">    <span class="built_in">gl_Position</span> = position + <span class="type">vec4</span>( <span class="number">0.2</span>,  <span class="number">0.2</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);    <span class="comment">// 4:右上</span></span><br><span class="line">    <span class="built_in">EmitVertex</span>();</span><br><span class="line">    <span class="built_in">gl_Position</span> = position + <span class="type">vec4</span>( <span class="number">0.0</span>,  <span class="number">0.4</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);    <span class="comment">// 5:顶部</span></span><br><span class="line">    fColor = <span class="type">vec3</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    <span class="built_in">EmitVertex</span>();</span><br><span class="line">    <span class="built_in">EndPrimitive</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;    </span><br><span class="line">    build_house(<span class="built_in">gl_in</span>[<span class="number">0</span>].<span class="built_in">gl_Position</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>结果</p>
<p><img src="/2024/04/14/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%85%AD%EF%BC%89/image-20240414001840888.png" alt="image-20240414001840888"></p>
<h4 id="爆破物体"><a href="#爆破物体" class="headerlink" title="爆破物体"></a>爆破物体</h4><p>我们是要将每个三角形沿着法向量的方向移动一小段时间，使得整个物体看起来像是沿着每个三角形的法线向量<strong>爆炸</strong>一样。</p>
<p>几何着色器代码应该如此</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">triangles</span>) <span class="keyword">in</span>;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">triangle_strip</span>, <span class="keyword">max_vertices</span> = <span class="number">3</span>) <span class="keyword">out</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> VS_OUT &#123;</span><br><span class="line">    <span class="type">vec2</span> texCoords;</span><br><span class="line">&#125; gs_in[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec2</span> TexCoords; </span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> time;</span><br><span class="line"></span><br><span class="line"><span class="type">vec3</span> GetNormal()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">vec3</span> a = <span class="type">vec3</span>(<span class="built_in">gl_in</span>[<span class="number">0</span>].<span class="built_in">gl_Position</span>) - <span class="type">vec3</span>(<span class="built_in">gl_in</span>[<span class="number">1</span>].<span class="built_in">gl_Position</span>);</span><br><span class="line">   <span class="type">vec3</span> b = <span class="type">vec3</span>(<span class="built_in">gl_in</span>[<span class="number">2</span>].<span class="built_in">gl_Position</span>) - <span class="type">vec3</span>(<span class="built_in">gl_in</span>[<span class="number">1</span>].<span class="built_in">gl_Position</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">normalize</span>(<span class="built_in">cross</span>(a, b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">vec4</span> explode(<span class="type">vec4</span> position, <span class="type">vec3</span> normal)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> magnitude = <span class="number">2.0</span>;</span><br><span class="line">    <span class="type">vec3</span> direction = normal * ((<span class="built_in">sin</span>(time) + <span class="number">1.0</span>) / <span class="number">2.0</span>) * magnitude; </span><br><span class="line">    <span class="keyword">return</span> position + <span class="type">vec4</span>(direction, <span class="number">0.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;    </span><br><span class="line">    <span class="type">vec3</span> normal = GetNormal();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">gl_Position</span> = explode(<span class="built_in">gl_in</span>[<span class="number">0</span>].<span class="built_in">gl_Position</span>, normal);</span><br><span class="line">    TexCoords = gs_in[<span class="number">0</span>].texCoords;</span><br><span class="line">    <span class="built_in">EmitVertex</span>();</span><br><span class="line">    <span class="built_in">gl_Position</span> = explode(<span class="built_in">gl_in</span>[<span class="number">1</span>].<span class="built_in">gl_Position</span>, normal);</span><br><span class="line">    TexCoords = gs_in[<span class="number">1</span>].texCoords;</span><br><span class="line">    <span class="built_in">EmitVertex</span>();</span><br><span class="line">    <span class="built_in">gl_Position</span> = explode(<span class="built_in">gl_in</span>[<span class="number">2</span>].<span class="built_in">gl_Position</span>, normal);</span><br><span class="line">    TexCoords = gs_in[<span class="number">2</span>].texCoords;</span><br><span class="line">    <span class="built_in">EmitVertex</span>();</span><br><span class="line">    <span class="built_in">EndPrimitive</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>顶点着色器和片段着色器还是用的之前的，懒得改直接用了</p>
<p><img src="/2024/04/14/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%85%AD%EF%BC%89/image-20240414010913596.png" alt="image-20240414010913596"></p>
<p><img src="/2024/04/14/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%85%AD%EF%BC%89/image-20240414010947212.png" alt="image-20240414010947212"></p>
<h4 id="法向量可视化"><a href="#法向量可视化" class="headerlink" title="法向量可视化"></a>法向量可视化</h4><p>检测法向量是否正确的一个很好的方式就是对它们进行可视化，几何着色器正是实现这一目的非常有用的工具。</p>
<p>思路是这样的：</p>
<ul>
<li>我们首先不使用几何着色器正常绘制场景。</li>
<li>然后再次绘制场景，但这次只显示通过几何着色器生成法向量。</li>
<li>几何着色器接收一个三角形图元，并沿着法向量生成三条线——每个顶点一个法向量。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">shader.<span class="built_in">use</span>();</span><br><span class="line"><span class="built_in">DrawScene</span>();</span><br><span class="line">normalDisplayShader.<span class="built_in">use</span>();</span><br><span class="line"><span class="built_in">DrawScene</span>();</span><br></pre></td></tr></table></figure>



<p>顶点着色器</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec3</span> aNormal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> VS_OUT &#123;</span><br><span class="line">    <span class="type">vec3</span> normal;</span><br><span class="line">&#125; vs_out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> view;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> model;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = view * model * <span class="type">vec4</span>(aPos, <span class="number">1.0</span>); </span><br><span class="line">    <span class="type">mat3</span> normalMatrix = <span class="type">mat3</span>(<span class="built_in">transpose</span>(<span class="built_in">inverse</span>(view * model)));</span><br><span class="line">    vs_out.normal = <span class="built_in">normalize</span>(<span class="type">vec3</span>(<span class="type">vec4</span>(normalMatrix * aNormal, <span class="number">0.0</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>几何着色器</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">triangles</span>) <span class="keyword">in</span>;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">line_strip</span>, <span class="keyword">max_vertices</span> = <span class="number">6</span>) <span class="keyword">out</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> VS_OUT &#123;</span><br><span class="line">    <span class="type">vec3</span> normal;</span><br><span class="line">&#125; gs_in[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="type">float</span> MAGNITUDE = <span class="number">0.4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> projection;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> GenerateLine(<span class="type">int</span> <span class="keyword">index</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = projection * <span class="built_in">gl_in</span>[<span class="keyword">index</span>].<span class="built_in">gl_Position</span>;</span><br><span class="line">    <span class="built_in">EmitVertex</span>();</span><br><span class="line">    <span class="built_in">gl_Position</span> = projection * (<span class="built_in">gl_in</span>[<span class="keyword">index</span>].<span class="built_in">gl_Position</span> + </span><br><span class="line">                                <span class="type">vec4</span>(gs_in[<span class="keyword">index</span>].normal, <span class="number">0.0</span>) * MAGNITUDE);</span><br><span class="line">    <span class="built_in">EmitVertex</span>();</span><br><span class="line">    <span class="built_in">EndPrimitive</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    GenerateLine(<span class="number">0</span>); <span class="comment">// 第一个顶点法线</span></span><br><span class="line">    GenerateLine(<span class="number">1</span>); <span class="comment">// 第二个顶点法线</span></span><br><span class="line">    GenerateLine(<span class="number">2</span>); <span class="comment">// 第三个顶点法线</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>片段着色器</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    FragColor = <span class="type">vec4</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<p>结果</p>
<p><img src="/2024/04/14/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%85%AD%EF%BC%89/image-20240414012439135.png" alt="image-20240414012439135"></p>
<blockquote>
<p>这样的几何着色器也经常用于给物体添加毛发(Fur)。</p>
</blockquote>
<h2 id="五、实例化"><a href="#五、实例化" class="headerlink" title="五、实例化"></a>五、实例化</h2><p>假设你有一个绘制了很多模型的场景，而大部分的模型包含的是同一组顶点数据，只不过进行的是不同的世界空间变换。</p>
<p>如果我们需要渲染大量物体时，代码看起来会像这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; amount_of_models_to_draw; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">DoSomePreparations</span>(); <span class="comment">// 绑定VAO，绑定纹理，设置uniform等</span></span><br><span class="line">    <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, amount_of_vertices);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果像这样绘制模型的大量实例(Instance)，你很快就会因为绘制调用过多而达到性能瓶颈。<ul>
<li>与绘制顶点本身相比，使用glDrawArrays或glDrawElements函数告诉GPU去绘制你的顶点数据会消耗更多的性能</li>
<li>因为OpenGL在绘制顶点数据之前需要做很多准备工作<ul>
<li>比如告诉GPU该从哪个缓冲读取数据，从哪寻找顶点属性，而且这些都是在相对缓慢的CPU到GPU总线(CPU to GPU Bus)上进行的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="实例化-Instancing"><a href="#实例化-Instancing" class="headerlink" title="实例化(Instancing)"></a><strong>实例化(Instancing)</strong></h3><ul>
<li>将数据一次性发送给GPU，然后使用一个绘制函数让OpenGL利用这些数据绘制多个物体</li>
<li>使用一个渲染调用来绘制多个物体，来节省每次绘制物体时CPU -&gt; GPU的通信</li>
<li>将<code>glDrawArrays</code>和<code>glDrawElements</code>的渲染调用分别改为<code>glDrawArraysInstanced</code>和<code>glDrawElementsInstanced</code></li>
</ul>
<p>在实例化渲染方式中如何分辨不同实例</p>
<ul>
<li>GLSL在顶点着色器中嵌入了另一个内建变量 <code>gl_InstanceID</code></li>
<li>在使用实例化渲染调用时，gl_InstanceID会从0开始，在每个实例被渲染时递增1。</li>
</ul>
<p>案例：</p>
<ul>
<li><p>顶点着色器</p>
<ul>
<li>关注 <code>uniform vec2 offsets[100];</code> 和 <code>gl_InstanceID</code></li>
</ul>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec2</span> aPos;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec3</span> aColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> fColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec2</span> offsets[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> <span class="keyword">offset</span> = offsets[<span class="built_in">gl_InstanceID</span>];</span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(aPos + <span class="keyword">offset</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    fColor = aColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>片段着色器</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> fColor;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    FragColor = <span class="type">vec4</span>(fColor, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>其他代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置每个实例对应的数据</span></span><br><span class="line">glm::vec2 translations[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="type">float</span> offset = <span class="number">0.1f</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> y = <span class="number">-10</span>; y &lt; <span class="number">10</span>; y += <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">-10</span>; x &lt; <span class="number">10</span>; x += <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        glm::vec2 translation;</span><br><span class="line">        translation.x = (<span class="type">float</span>)x / <span class="number">10.0f</span> + offset;</span><br><span class="line">        translation.y = (<span class="type">float</span>)y / <span class="number">10.0f</span> + offset;</span><br><span class="line">        translations[index++] = translation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 并传递给着色器</span></span><br><span class="line">shader.<span class="built_in">use</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    stringstream ss;</span><br><span class="line">    string index;</span><br><span class="line">    ss &lt;&lt; i; </span><br><span class="line">    index = ss.<span class="built_in">str</span>(); </span><br><span class="line">    shader.<span class="built_in">setVec2</span>((<span class="string">&quot;offsets[&quot;</span> + index + <span class="string">&quot;]&quot;</span>).<span class="built_in">c_str</span>(), translations[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制实例</span></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(quadVAO);</span><br><span class="line"><span class="built_in">glDrawArraysInstanced</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">6</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="/2024/04/14/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%85%AD%EF%BC%89/image-20240414020654224.png" alt="image-20240414020654224"></p>
<h3 id="实例化数组"><a href="#实例化数组" class="headerlink" title="实例化数组"></a>实例化数组</h3><p>要渲染远超过100个实例的时候，我们最终会超过最大能够发送至着色器的uniform数据大小<a href="http://www.opengl.org/wiki/Uniform_(GLSL)#Implementation_limits">上限</a>；</p>
<p>采用实例化数组(Instanced Array)解决这个问题</p>
<ul>
<li>实例化数组被定义为一个顶点属性（能够让我们储存更多的数据），仅在顶点着色器渲染一个新的实例时才会更新。</li>
<li>顶点着色器的每次运行都会让GLSL获取新的一组适用于当前顶点的属性，而对于实例化数组这个属性，只有在渲染下一个实例（而不是下一个顶点）时才进行更新。</li>
</ul>
<p>设置顶点着色器</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec2</span> aPos;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec3</span> aColor;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">2</span>) <span class="keyword">in</span> <span class="type">vec2</span> aOffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> fColor;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(aPos + aOffset, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    fColor = aColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他代码</p>
<ul>
<li><code>glVertexAttribDivisor</code>函数告诉了OpenGL该<strong>什么时候</strong>更新顶点属性的内容至新一组数据<ul>
<li>第一个参数是需要的顶点属性，第二个参数是属性除数(Attribute Divisor)</li>
<li>默认情况下，属性除数是0，告诉OpenGL我们需要在顶点着色器的每次迭代时更新顶点属性。</li>
<li>将它设置为1时，我们告诉OpenGL我们希望在渲染一个新实例的时候更新顶点属性。</li>
<li>而设置为2时，我们希望每2个实例更新一次属性，以此类推。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">glm::vec2 translations[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="type">float</span> offset = <span class="number">0.1f</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">-10</span>; y &lt; <span class="number">10</span>; y += <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">-10</span>; x &lt; <span class="number">10</span>; x += <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        glm::vec2 translation;</span><br><span class="line">        translation.x = (<span class="type">float</span>)x / <span class="number">10.0f</span> + offset;</span><br><span class="line">        translation.y = (<span class="type">float</span>)y / <span class="number">10.0f</span> + offset;</span><br><span class="line">        translations[index++] = translation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将要传给实例化数组的数据映射到一个 instanceVBO</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> instanceVBO;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;instanceVBO);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, instanceVBO);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(glm::vec2) * <span class="number">100</span>, &amp;translations[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// VBO 和 VAO（先bind VAO，之后再bind VBO设置数据，以及设置顶点属性指针）</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> VBO;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> VAO;</span><br><span class="line"><span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;VAO);</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;VBO);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(quadVertices), quadVertices, GL_STATIC_DRAW);</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">5</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">5</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)(<span class="number">2</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>)));</span><br><span class="line"><span class="comment">// 设置instanceVBO的顶点属性指针，并启用顶点属性：</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, instanceVBO);</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">2</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">2</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glVertexAttribDivisor</span>(<span class="number">2</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>



<p><img src="/2024/04/14/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%85%AD%EF%BC%89/image-20240414023004222.png" alt="image-20240414023004222"></p>
<h3 id="小行星带"><a href="#小行星带" class="headerlink" title="小行星带"></a>小行星带</h3><p>懒得弄了…</p>
<p>主要是把每个小行星的 <code>uniform model矩阵</code> 抽离出来用实例化数组来存，即 <code>layout (location = 3) in mat4 instanceMatrix;</code></p>
<blockquote>
<p>实例化渲染通常会用于渲染草、植被、粒子，以及上面这样的场景，基本上只要场景中有很多重复的形状，都能够使用实例化渲染来提高性能。</p>
</blockquote>
<h2 id="六、抗锯齿"><a href="#六、抗锯齿" class="headerlink" title="六、抗锯齿"></a>六、抗锯齿</h2><p>锯齿边缘(Jagged Edges)的产生和光栅器将顶点数据转化为片段的方式有关。</p>
<img src="/2024/04/14/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%85%AD%EF%BC%89/image-20240414023907491.png" alt="image-20240414023907491" style="zoom:67%;">

<p>清楚看见形成边缘的像素，这种现象被称之为走样(Aliasing)。</p>
<p>抗锯齿（Anti-aliasing，也被称为反走样）的技术能够帮助我们缓解这种现象，从而产生更<strong>平滑</strong>的边缘。</p>
<ul>
<li>超采样抗锯齿(Super Sample Anti-aliasing, SSAA)<ul>
<li>使用比正常分辨率更高的分辨率（即超采样）来渲染场景</li>
<li>当图像输出在帧缓冲中更新时，分辨率会被下采样(Downsample)至正常的分辨率</li>
<li>由于比平时要绘制更多的片段，它会带来很大的性能开销。</li>
</ul>
</li>
<li>多重采样抗锯齿(Multisample Anti-aliasing, MSAA)<ul>
<li>借鉴了SSAA背后的理念，但却以更加高效的方式实现了抗锯齿</li>
</ul>
</li>
</ul>
<h3 id="多重采样"><a href="#多重采样" class="headerlink" title="多重采样"></a>多重采样</h3><p><strong>OpenGL光栅器的工作方式</strong></p>
<p>光栅器是位于最终处理过的顶点之后，到片段着色器之前，所经过的所有的算法与过程的总和。</p>
<ul>
<li>光栅器会将一个图元的所有顶点作为输入，并将它转换为一系列的片段</li>
<li>顶点坐标理论上可以取任意值，但片段不行，因为它们受限于你窗口的分辨率</li>
<li>顶点坐标与片段之间几乎永远也不会有一对一的映射，所以光栅器必须以某种方式来决定每个顶点最终所在的片段&#x2F;屏幕坐标</li>
</ul>
<p><img src="/2024/04/14/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%85%AD%EF%BC%89/image-20240414024456540.png" alt="image-20240414024456540"></p>
<p>这里我们可以看到一个屏幕像素的网格，每个像素的中心包含有一个<code>采样点(Sample Point)</code>，它会被用来决定这个三角形是否遮盖了某个像素。</p>
<ul>
<li>图中红色的采样点被三角形所遮盖，在每一个遮住的像素处都会生成一个片段.</li>
<li>虽然三角形边缘的一些部分也遮住了某些屏幕像素，但是这些像素的采样点并没有被三角形<strong>内部</strong>所遮盖，所以它们不会受到片段着色器的影响。</li>
</ul>
<p>完成渲染后：</p>
<ul>
<li>由于屏幕像素总量的限制，有些边缘的像素能够被渲染出来，而有些则不会。结果就是我们使用了不光滑的边缘来渲染图元，导致之前讨论到的锯齿边缘。</li>
</ul>
<p><img src="/2024/04/14/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%85%AD%EF%BC%89/image-20240414024602352.png" alt="image-20240414024602352"></p>
<p><strong>多重采样</strong></p>
<p>多重采样所做的正是将单一的采样点变为多个采样点（这也是它名称的由来）</p>
<ul>
<li>取而代之的是以特定图案排列的4个子采样点(Subsample)<ul>
<li>采样点的数量可以是任意的，更多的采样点能带来更精确的遮盖率</li>
</ul>
</li>
<li>这也意味着颜色缓冲的大小会随着子采样点的增加而增加</li>
</ul>
<p><img src="/2024/04/14/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%85%AD%EF%BC%89/image-20240414024753943.png" alt="image-20240414024753943"></p>
<ul>
<li>我们知道三角形只遮盖了2个子采样点，所以下一步是决定这个像素的颜色。<ul>
<li>MSAA真正的工作方式是：无论三角形遮盖了多少个子采样点（至少1个），（每个图元中）每个像素只运行<strong>一次</strong>片段着色器。</li>
<li>片段着色器所使用的顶点数据会插值到每个像素的<strong>中心</strong>，所得到的结果颜色会被储存在每个被遮盖住的子采样点中。</li>
<li>当颜色缓冲的子样本被图元的所有颜色填满时，所有的这些颜色将会在每个像素内部平均化。<ul>
<li>因为上图的4个采样点中只有2个被遮盖住了，这个像素的颜色将会是三角形颜色与其他两个采样点的颜色（在这里是无色）的平均值，最终形成一种淡蓝色。</li>
</ul>
</li>
<li>对于每个像素来说，越少的子采样点被三角形所覆盖，那么它受到三角形的影响就越小。</li>
</ul>
</li>
</ul>
<p><img src="/2024/04/14/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%85%AD%EF%BC%89/image-20240414025133098.png" alt="image-20240414025133098"></p>
<p><img src="/2024/04/14/LearnOpenGL%E6%91%98%E8%A6%81%EF%BC%88%E5%85%AD%EF%BC%89/image-20240414025304477.png" alt="image-20240414025304477"></p>
<ul>
<li>三角形的不平滑边缘被稍浅的颜色所包围后，从远处观察时就会显得更加平滑了。</li>
</ul>
<p>不仅仅是颜色值会受到多重采样的影响，深度和模板测试也能够使用多个采样点。</p>
<ul>
<li>对深度测试来说，每个顶点的深度值会在运行深度测试之前被插值到各个子样本中。</li>
<li>对模板测试来说，我们对每个子样本，而不是每个像素，存储一个模板值。</li>
</ul>
<p>当然，这也意味着深度和模板缓冲的大小会乘以子采样点的个数。</p>
<h3 id="OpenGL中的MSAA"><a href="#OpenGL中的MSAA" class="headerlink" title="OpenGL中的MSAA"></a>OpenGL中的MSAA</h3><p>如果我们想要在OpenGL中使用MSAA，我们必须要使用一个能在每个像素中存储大于1个颜色值的颜色缓冲（因为多重采样需要我们为每个采样点都储存一个颜色）。</p>
<p><code>多重采样缓冲(Multisample Buffer)</code>，存储特定数量的多重采样样本</p>
<ul>
<li><p>大多数的窗口系统都应该提供了一个多重采样缓冲，用以代替默认的颜色缓冲</p>
</li>
<li><p>在创建窗口之前调用<code>glfwWindowHint</code><strong>提示</strong>(Hint) GLFW，我们希望使用一个包含N个样本的多重采样缓冲</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_SAMPLES, <span class="number">4</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>调用glEnable启用GL_MULTISAMPLE，来启用多重采样</p>
<ul>
<li><p>在大多数OpenGL的驱动上，多重采样都是默认启用的</p>
</li>
<li><p>只要默认的帧缓冲有了多重采样缓冲的附件，我们所要做的只是调用glEnable来启用多重采样。</p>
<ul>
<li>多重采样的算法都在OpenGL驱动的光栅器中实现了，我们不需要再多做什么。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glEnable</span>(GL_MULTISAMPLE);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="离屏MSAA"><a href="#离屏MSAA" class="headerlink" title="离屏MSAA"></a>离屏MSAA</h3><p>如果我们想要使用我们自己的帧缓冲来进行离屏渲染，那么我们就必须要自己动手生成多重采样缓冲了。</p>
<p>有两种方式可以创建多重采样缓冲，将其作为帧缓冲的附件：</p>
<ul>
<li>纹理附件</li>
<li>渲染缓冲对象</li>
</ul>
<h4 id="多重采样纹理附件"><a href="#多重采样纹理附件" class="headerlink" title="多重采样纹理附件"></a>多重采样纹理附件</h4><p>创建一个支持储存多个采样点的纹理</p>
<ul>
<li>它的第二个参数设置的是纹理所拥有的样本个数</li>
<li>最后一个参数为GL_TRUE，图像将会对每个纹素使用相同的样本位置以及相同数量的子采样点个数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D_MULTISAMPLE, tex);</span><br><span class="line"><span class="built_in">glTexImage2DMultisample</span>(GL_TEXTURE_2D_MULTISAMPLE, samples, GL_RGB, width, height, GL_TRUE);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D_MULTISAMPLE, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>使用glFramebufferTexture2D将多重采样纹理附加到帧缓冲上</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glFramebufferTexture2D</span>(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D_MULTISAMPLE, tex, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>



<h4 id="多重采样渲染缓冲对象"><a href="#多重采样渲染缓冲对象" class="headerlink" title="多重采样渲染缓冲对象"></a>多重采样渲染缓冲对象</h4><p>在指定（当前绑定的）渲染缓冲的内存存储时，将<code>glRenderbufferStorage</code>的调用改为<code>glRenderbufferStorageMultisample</code>就可以了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glRenderbufferStorageMultisample</span>(GL_RENDERBUFFER, <span class="number">4</span>, GL_DEPTH24_STENCIL8, width, height);</span><br></pre></td></tr></table></figure>



<h4 id="渲染到多重采样帧缓冲"><a href="#渲染到多重采样帧缓冲" class="headerlink" title="渲染到多重采样帧缓冲"></a>渲染到多重采样帧缓冲</h4><p>一个多重采样的图像包含比普通图像更多的信息，我们所要做的是缩小或者还原(Resolve)图像。</p>
<p>多重采样帧缓冲的还原通常是通过<code>glBlitFramebuffer</code>来完成：</p>
<ul>
<li>将一个帧缓冲中的某个区域复制到另一个帧缓冲中，并且将多重采样缓冲还原。</li>
<li>将一个用4个屏幕空间坐标所定义的源区域复制到一个同样用4个屏幕空间坐标所定义的目标区域中</li>
<li>根据当前绑定的<code>GL_READ_FRAMEBUFFER</code>与<code>GL_DRAW_FRAMEBUFFER</code>来确定 源 和 目标</li>
</ul>
<p>将图像位块传送(Blit)到默认的帧缓冲中，即把多重采样的帧缓冲传送到屏幕上。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 源：多重采样帧缓冲 目标：屏幕帧缓冲</span></span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_READ_FRAMEBUFFER, multisampledFBO);</span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_DRAW_FRAMEBUFFER, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBlitFramebuffer</span>(<span class="number">0</span>, <span class="number">0</span>, width, height, <span class="number">0</span>, <span class="number">0</span>, width, height, GL_COLOR_BUFFER_BIT, GL_NEAREST);</span><br></pre></td></tr></table></figure>



<h4 id="使用多重采样帧缓冲做后期处理"><a href="#使用多重采样帧缓冲做后期处理" class="headerlink" title="使用多重采样帧缓冲做后期处理"></a>使用多重采样帧缓冲做后期处理</h4><p>使用多重采样帧缓冲的纹理输出来做像是后期处理这样的事情</p>
<ul>
<li>我们不能直接在片段着色器中使用多重采样的纹理</li>
<li>我们能做的是将多重采样缓冲位块传送到一个没有使用多重采样纹理附件的FBO中，然后用这个普通的颜色附件来做后期处理</li>
</ul>
<p>这也意味着我们需要生成一个新的FBO，作为中介帧缓冲对象，将多重采样缓冲还原为一个能在着色器中使用的普通2D纹理。这个过程的伪代码是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> msFBO = <span class="built_in">CreateFBOWithMultiSampledAttachments</span>();</span><br><span class="line"><span class="comment">// 使用普通的纹理颜色附件创建一个新的FBO</span></span><br><span class="line">...</span><br><span class="line"><span class="built_in">glFramebufferTexture2D</span>(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, screenTexture, <span class="number">0</span>);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glBindFramebuffer</span>(msFBO);</span><br><span class="line">    <span class="built_in">ClearFrameBuffer</span>();</span><br><span class="line">    <span class="built_in">DrawScene</span>();</span><br><span class="line">    <span class="comment">// 将多重采样缓冲还原到中介FBO上</span></span><br><span class="line">    <span class="built_in">glBindFramebuffer</span>(GL_READ_FRAMEBUFFER, msFBO);</span><br><span class="line">    <span class="built_in">glBindFramebuffer</span>(GL_DRAW_FRAMEBUFFER, intermediateFBO);</span><br><span class="line">    <span class="built_in">glBlitFramebuffer</span>(<span class="number">0</span>, <span class="number">0</span>, width, height, <span class="number">0</span>, <span class="number">0</span>, width, height, GL_COLOR_BUFFER_BIT, GL_NEAREST);</span><br><span class="line">    <span class="comment">// 现在场景是一个2D纹理缓冲，可以将这个图像用来后期处理</span></span><br><span class="line">    <span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">ClearFramebuffer</span>();</span><br><span class="line">    <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, screenTexture);</span><br><span class="line">    <span class="built_in">DrawPostProcessingQuad</span>();  </span><br><span class="line"></span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>因为屏幕纹理又变回了一个只有单一采样点的普通纹理，像是<strong>边缘检测</strong>这样的后期处理滤镜会重新导致锯齿。为了补偿这一问题，你可以之后对纹理进行模糊处理，或者想出你自己的抗锯齿算法。</p>
</blockquote>
<blockquote>
<p>如果将多重采样与离屏渲染结合起来，我们需要自己负责一些额外的细节。</p>
</blockquote>
<h3 id="自定义抗锯齿算法"><a href="#自定义抗锯齿算法" class="headerlink" title="自定义抗锯齿算法"></a>自定义抗锯齿算法</h3><p>将一个多重采样的纹理图像不进行还原直接传入着色器也是可行的</p>
<p>GLSL提供了这样的选项，让我们能够对纹理图像的每个子样本进行采样，所以我们可以创建我们自己的抗锯齿算法</p>
<ul>
<li>将纹理uniform采样器设置为<code>sampler2DMS</code>，而不是平常使用的sampler2D</li>
<li>使用<code>texelFetch</code>函数获取每个子样本的颜色值</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2DMS</span> screenTextureMS;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec4</span> colorSample = <span class="built_in">texelFetch</span>(screenTextureMS, TexCoords, <span class="number">3</span>);  <span class="comment">// 第4个子样本</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
</search>
